var Gge=Object.defineProperty;var Hge=(n,e,t)=>e in n?Gge(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var Mt=(n,e,t)=>(Hge(n,typeof e!="symbol"?e+"":e,t),t);function jge(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(n,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qge=1e-7,Xge=1e-4;class wM{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let jS=class{refCount(e){return La("refCount")}incRef(e){return La("incRef")}timerAvailable(){return!0}time(e){return La("time")}read(e){return La("read")}readSync(e){return La("readSync")}readToGPU(e,t){return La("readToGPU")}numDataIds(){return La("numDataIds")}disposeData(e,t){return La("disposeData")}write(e,t,r){return La("write")}move(e,t,r,s,i){return La("move")}createTensorFromGPUData(e,t,r){return La("createTensorFromGPUData")}memory(){return La("memory")}floatPrecision(){return La("floatPrecision")}epsilon(){return this.floatPrecision()===32?qge:Xge}dispose(){return La("dispose")}};function La(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AL(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Tf(n,e,t)}function Kge(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Tf(n,t,r),Tf(e,t,r)}function ip(n,e,t){return Math.max(n,Math.min(e,t))}function xM(n){return n%2===0?n:n+1}function Tf(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function ML(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function Yge(n,e){const t=Math.random();return e*t+(1-t)*n}function Zge(n,e){let t=0;for(let r=0;r<n.length;r++){const s=Number(n[r])-Number(e[r]);t+=s*s}return t}function U(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function qi(n,e,t=""){U(Rn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function zg(n){U(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Te(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function hD(n){return n.length===0}function cX(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Rn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function og(n){return n%1===0}function Jge(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function _I(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Qge(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return AL(e),e}function Ym(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function fD(n,e=s=>0,t,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n()){s();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function _M(n,e){let t=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function An(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),U(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),U(n.every(r=>og(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Wf(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:An(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function ci(n,e){return Ss(n,e)}function Ss(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function uX(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function hX(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function SM(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function g_(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function fX(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function uu(n){return typeof n=="string"||n instanceof String}function dX(n){return typeof n=="boolean"}function SI(n){return typeof n=="number"}function Ap(n){return Array.isArray(n)?Ap(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":SI(n)?"float32":uu(n)?"string":dX(n)?"bool":"float32"}function op(n){return!!(n&&n.constructor&&n.call&&n.apply)}function CI(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Jt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function pX(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=pX(n+l*a,o,t,r)}return s}function Tl(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return pX(0,n,e,t)}function J1(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function CM(n,e){const t=ji(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function ji(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function NL(n,e){const t=n.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return Tl(n,new Float32Array(t));if(e==="int32")return Tl(n,new Int32Array(t));if(e==="bool")return Tl(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function el(n){n.forEach(e=>{U(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function gu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function Bg(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function ap(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nG="tfjsflags";let mX=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=eye,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ap(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);nG in e&&e[nG].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=nye(s,i)})}};function eye(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(tye(e,r[0],r[1]),r.join("="))),e}function tye(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function nye(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ee(){return $L}let $L=null;function rye(n){$L=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let i3;function gX(){if(i3==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");i3=n}return i3}function sye(){const n=gX();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function RL(n,e){const t=sye();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Mv="Abs",Vg="Acos",Ug="Acosh",Mp="Add",Nv="AddN",qS="All",XS="Any",$v="ArgMax",Rv="ArgMin",Wg="Asin",Gg="Asinh",Hg="Atan",jg="Atanh",qg="Atan2",Pv="AvgPool",KS="AvgPoolGrad",Dv="AvgPool3D",YS="AvgPool3DGrad",Ov="BatchMatMul",Fv="BatchToSpaceND",ZS="Bincount",JS="BitwiseAnd",yX="BroadcastTo",QS="BroadcastArgs",Xg="Cast",Kg="Ceil",Yg="ClipByValue",e2="Complex",Lv="ComplexAbs",zv="Concat",Bv="Conv2D",t2="Conv2DBackpropFilter",Vv="Conv2DBackpropInput",Uv="Conv3D",n2="Conv3DBackpropFilterV2",r2="Conv3DBackpropInputV2",Zg="Cos",Jg="Cosh",s2="Cumprod",Wv="Cumsum",i2="CropAndResize",o2="DenseBincount",a2="DepthToSpace",Gv="DepthwiseConv2dNative",l2="DepthwiseConv2dNativeBackpropFilter",c2="DepthwiseConv2dNativeBackpropInput",u2="Diag",Hv="Dilation2D",y_="Dilation2DBackpropInput",b_="Dilation2DBackpropFilter",h2="Draw",Qg="RealDiv",f2="Einsum",ey="Elu",d2="EluGrad",ty="Erf",jv="Equal",ny="Exp",qv="ExpandDims",ry="Expm1",p2="FFT",m2="Fill",g2="FlipLeftRight",sy="Floor",iy="FloorDiv",Xv="FusedBatchNorm",Kv="GatherV2",y2="GatherNd",Yv="Greater",oy="GreaterEqual",ay="Identity",b2="IFFT",v2="Imag",ly="IsFinite",cy="IsInf",uy="IsNan",Zv="LeakyRelu",Jv="Less",Qv="LessEqual",w2="LinSpace",hy="Log",fy="Log1p",ew="LogicalAnd",tw="LogicalNot",nw="LogicalOr",iye="LogicalXor",bX="LogSoftmax",oye="LowerBound",rw="LRN",x2="LRNGrad",aye="MatrixBandPart",sw="Max",dy="Maximum",iw="MaxPool",_2="MaxPoolGrad",ow="MaxPool3D",S2="MaxPool3DGrad",C2="MaxPoolWithArgmax",aw="Mean",lw="Min",py="Minimum",cw="MirrorPad",my="Mod",k2="Multinomial",gy="Multiply",uw="Neg",hw="NotEqual",T2="NonMaxSuppressionV3",kM="NonMaxSuppressionV4",E2="NonMaxSuppressionV5",fw="OnesLike",dw="OneHot",pw="Pack",mw="PadV2",lye="Pool",yy="Pow",gw="Prelu",yw="Prod",TM="RaggedGather",EM="RaggedRange",IM="RaggedTensorToTensor",I2="Range",A2="Real",by="Reciprocal",vy="Relu",bw="Reshape",vw="ResizeNearestNeighbor",M2="ResizeNearestNeighborGrad",ww="ResizeBilinear",N2="ResizeBilinearGrad",wy="Relu6",xw="Reverse",xy="Round",_y="Rsqrt",$2="ScatterNd",R2="TensorScatterUpdate",P2="SearchSorted",_w="Select",Sy="Selu",Sw="Slice",Cy="Sin",ky="Sinh",Ty="Sign",Ey="Sigmoid",Iy="Softplus",Ay="Sqrt",Cw="Sum",kw="SpaceToBatchND",Tw="SplitV",Ew="Softmax",AM="SparseFillEmptyRows",MM="SparseReshape",D2="SparseSegmentMean",O2="SparseSegmentSum",F2="SparseToDense",My="SquaredDifference",L2="Square",z2="StaticRegexReplace",B2="StridedSlice",V2="StringNGrams",NM="StringSplit",$M="StringToHashBucketFast",Ny="Sub",$y="Tan",Ry="Tanh",Py="Tile",U2="TopK",W2="Transform",jd="Transpose",RM="Unique",Iw="Unpack",Aw="UnsortedSegmentSum",cye="UpperBound",Mw="ZerosLike",Dy="Step",v_="FromPixels",G2="RotateWithOffset",Hb="_FusedMatMul",jb="FusedConv2D",qb="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(...n)}function uye(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xb=RL("kernelRegistry",()=>new Map),w_=RL("gradRegistry",()=>new Map);function x_(n,e){const t=PL(n,e);return Xb.get(t)}function dD(n){return w_.get(n)}function kI(n){const e=Xb.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function H2(n){const{kernelName:e,backendName:t}=n,r=PL(e,t);Xb.has(r)&&wl(`The kernel '${e}' for backend '${t}' is already registered`),Xb.set(r,n)}function vX(n){const{kernelName:e}=n;w_.has(e)&&Ee().getBool("DEBUG")&&wl(`Overriding the gradient for '${e}'`),w_.set(e,n)}function hye(n,e){const t=PL(n,e);if(!Xb.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Xb.delete(t)}function fye(n){if(!w_.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);w_.delete(n)}function dye(n,e){kI(n).forEach(r=>{const s=Object.assign({},r,{backendName:e});H2(s)})}function PL(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var pt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Np(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Gf(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var xX=as,hc=null;try{hc=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function as(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}as.prototype.__isLong__;Object.defineProperty(as.prototype,"__isLong__",{value:!0});function tl(n){return(n&&n.__isLong__)===!0}as.isLong=tl;var rG={},sG={};function Oy(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=sG[n],r)?r:(t=ls(n,(n|0)<0?-1:0,!0),s&&(sG[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=rG[n],r)?r:(t=ls(n,n<0?-1:0,!1),s&&(rG[n]=t),t))}as.fromInt=Oy;function fc(n,e){if(isNaN(n))return e?Um:dc;if(e){if(n<0)return Um;if(n>=_X)return kX}else{if(n<=-oG)return Ha;if(n+1>=oG)return CX}return n<0?fc(-n,e).neg():ls(n%Kb|0,n/Kb|0,e)}as.fromNumber=fc;function ls(n,e,t){return new as(n,e,t)}as.fromBits=ls;var TI=Math.pow;function DL(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return dc;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return DL(n.substring(1),e,t).neg();for(var s=fc(TI(t,8)),i=dc,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=fc(TI(t,a));i=i.mul(c).add(fc(l))}else i=i.mul(s),i=i.add(fc(l))}return i.unsigned=e,i}as.fromString=DL;function Ou(n,e){return typeof n=="number"?fc(n,e):typeof n=="string"?DL(n,e):ls(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}as.fromValue=Ou;var iG=65536,pye=1<<24,Kb=iG*iG,_X=Kb*Kb,oG=_X/2,aG=Oy(pye),dc=Oy(0);as.ZERO=dc;var Um=Oy(0,!0);as.UZERO=Um;var Cb=Oy(1);as.ONE=Cb;var SX=Oy(1,!0);as.UONE=SX;var pD=Oy(-1);as.NEG_ONE=pD;var CX=ls(-1,2147483647,!1);as.MAX_VALUE=CX;var kX=ls(-1,-1,!0);as.MAX_UNSIGNED_VALUE=kX;var Ha=ls(0,-2147483648,!1);as.MIN_VALUE=Ha;var Nt=as.prototype;Nt.toInt=function(){return this.unsigned?this.low>>>0:this.low};Nt.toNumber=function(){return this.unsigned?(this.high>>>0)*Kb+(this.low>>>0):this.high*Kb+(this.low>>>0)};Nt.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ha)){var t=fc(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=fc(TI(e,6),this.unsigned),o=this,a="";;){var l=o.div(i),c=o.sub(l.mul(i)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Nt.getHighBits=function(){return this.high};Nt.getHighBitsUnsigned=function(){return this.high>>>0};Nt.getLowBits=function(){return this.low};Nt.getLowBitsUnsigned=function(){return this.low>>>0};Nt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ha)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Nt.isZero=function(){return this.high===0&&this.low===0};Nt.eqz=Nt.isZero;Nt.isNegative=function(){return!this.unsigned&&this.high<0};Nt.isPositive=function(){return this.unsigned||this.high>=0};Nt.isOdd=function(){return(this.low&1)===1};Nt.isEven=function(){return(this.low&1)===0};Nt.equals=function(e){return tl(e)||(e=Ou(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Nt.eq=Nt.equals;Nt.notEquals=function(e){return!this.eq(e)};Nt.neq=Nt.notEquals;Nt.ne=Nt.notEquals;Nt.lessThan=function(e){return this.comp(e)<0};Nt.lt=Nt.lessThan;Nt.lessThanOrEqual=function(e){return this.comp(e)<=0};Nt.lte=Nt.lessThanOrEqual;Nt.le=Nt.lessThanOrEqual;Nt.greaterThan=function(e){return this.comp(e)>0};Nt.gt=Nt.greaterThan;Nt.greaterThanOrEqual=function(e){return this.comp(e)>=0};Nt.gte=Nt.greaterThanOrEqual;Nt.ge=Nt.greaterThanOrEqual;Nt.compare=function(e){if(tl(e)||(e=Ou(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Nt.comp=Nt.compare;Nt.negate=function(){return!this.unsigned&&this.eq(Ha)?Ha:this.not().add(Cb)};Nt.neg=Nt.negate;Nt.add=function(e){tl(e)||(e=Ou(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,f=0,d=0;return d+=i+c,f+=d>>>16,d&=65535,f+=s+l,h+=f>>>16,f&=65535,h+=r+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,ls(f<<16|d,u<<16|h,this.unsigned)};Nt.subtract=function(e){return tl(e)||(e=Ou(e)),this.add(e.neg())};Nt.sub=Nt.subtract;Nt.multiply=function(e){if(this.isZero())return dc;if(tl(e)||(e=Ou(e)),hc){var t=hc.mul(this.low,this.high,e.low,e.high);return ls(t,hc.get_high(),this.unsigned)}if(e.isZero())return dc;if(this.eq(Ha))return e.isOdd()?Ha:dc;if(e.eq(Ha))return this.isOdd()?Ha:dc;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(aG)&&e.lt(aG))return fc(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,f=0,d=0,p=0;return p+=o*u,d+=p>>>16,p&=65535,d+=i*u,f+=d>>>16,d&=65535,d+=o*c,f+=d>>>16,d&=65535,f+=s*u,h+=f>>>16,f&=65535,f+=i*c,h+=f>>>16,f&=65535,f+=o*l,h+=f>>>16,f&=65535,h+=r*u+s*c+i*l+o*a,h&=65535,ls(d<<16|p,h<<16|f,this.unsigned)};Nt.mul=Nt.multiply;Nt.divide=function(e){if(tl(e)||(e=Ou(e)),e.isZero())throw Error("division by zero");if(hc){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?hc.div_u:hc.div_s)(this.low,this.high,e.low,e.high);return ls(t,hc.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Um:dc;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Um;if(e.gt(this.shru(1)))return SX;i=Um}else{if(this.eq(Ha)){if(e.eq(Cb)||e.eq(pD))return Ha;if(e.eq(Ha))return Cb;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(dc)?e.isNegative()?Cb:pD:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}else if(e.eq(Ha))return this.unsigned?Um:dc;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=dc}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:TI(2,a-48),c=fc(r),u=c.mul(e);u.isNegative()||u.gt(s);)r-=l,c=fc(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=Cb),i=i.add(c),s=s.sub(u)}return i};Nt.div=Nt.divide;Nt.modulo=function(e){if(tl(e)||(e=Ou(e)),hc){var t=(this.unsigned?hc.rem_u:hc.rem_s)(this.low,this.high,e.low,e.high);return ls(t,hc.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Nt.mod=Nt.modulo;Nt.rem=Nt.modulo;Nt.not=function(){return ls(~this.low,~this.high,this.unsigned)};Nt.and=function(e){return tl(e)||(e=Ou(e)),ls(this.low&e.low,this.high&e.high,this.unsigned)};Nt.or=function(e){return tl(e)||(e=Ou(e)),ls(this.low|e.low,this.high|e.high,this.unsigned)};Nt.xor=function(e){return tl(e)||(e=Ou(e)),ls(this.low^e.low,this.high^e.high,this.unsigned)};Nt.shiftLeft=function(e){return tl(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ls(0,this.low<<e-32,this.unsigned)};Nt.shl=Nt.shiftLeft;Nt.shiftRight=function(e){return tl(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ls(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Nt.shr=Nt.shiftRight;Nt.shiftRightUnsigned=function(e){if(tl(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return ls(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ls(t,0,this.unsigned):ls(t>>>e-32,0,this.unsigned)};Nt.shru=Nt.shiftRightUnsigned;Nt.shr_u=Nt.shiftRightUnsigned;Nt.toSigned=function(){return this.unsigned?ls(this.low,this.high,!1):this};Nt.toUnsigned=function(){return this.unsigned?this:ls(this.low,this.high,!0)};Nt.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Nt.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Nt.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};as.fromBytes=function(e,t,r){return r?as.fromBytesLE(e,t):as.fromBytesBE(e,t)};as.fromBytesLE=function(e,t){return new as(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};as.fromBytesBE=function(e,t){return new as(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const TX=Np(xX),mye=jge({__proto__:null,default:TX},[xX]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dm=TX||mye;function j2(n){return Dm.fromString(n,!0,16)}const EX=j2("c3a5c85c97cb3127"),km=j2("b492b66fbe98f273"),Vo=j2("9ae16a3b2f90404f");function mD(n){return n.xor(n.shru(47))}function IX(n,e,t){const r=n.slice(e,e+t);return Dm.fromBytes(Array.from(r),!0,!0)}function Qr(n,e){return IX(n,e,8)}function lG(n,e){return IX(n,e,4)}function Vi(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function qd(n,e,t=j2("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function gye(n,e,t,r,s,i){s=s.add(n),i=Vi(i.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(t),i=i.add(Vi(s,44)),[s.add(r),i.add(o)]}function jk(n,e,t,r){return gye(Qr(n,e),Qr(n,e+8),Qr(n,e+16),Qr(n,e+24),t,r)}function yye(n,e=n.length){if(e>=8){const t=Vo.add(e*2),r=Qr(n,0).add(Vo),s=Qr(n,e-8),i=Vi(s,37).mul(t).add(r),o=Vi(r,25).add(s).mul(t);return qd(i,o,t)}if(e>=4){const t=Vo.add(e*2),r=lG(n,0);return qd(r.shl(3).add(e),lG(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],i=t+(r<<8),o=e+(s<<2);return mD(Vo.mul(i).xor(EX.mul(o))).mul(Vo)}return Vo}function bye(n,e=n.length){const t=Vo.add(e*2),r=Qr(n,0).mul(km),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Vo);return qd(Vi(r.add(s),43).add(Vi(i,30)).add(o),r.add(Vi(s.add(Vo),18)).add(i),t)}function vye(n,e=n.length){const t=Vo.add(e*2),r=Qr(n,0).mul(Vo),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Vo),a=Vi(r.add(s),43).add(Vi(i,30)).add(o),l=qd(a,r.add(Vi(s.add(Vo),18)).add(i),t),c=Qr(n,16).mul(t),u=Qr(n,24),h=a.add(Qr(n,e-32)).mul(t),f=l.add(Qr(n,e-24)).mul(t);return qd(Vi(c.add(u),43).add(Vi(h,30)).add(f),c.add(Vi(u.add(r),18)).add(h),t)}function AX(n,e=n.length){const t=Dm.fromNumber(81,!0);if(e<=32)return e<=16?yye(n,e):bye(n,e);if(e<=64)return vye(n,e);let r=t,s=t.mul(km).add(113),i=mD(s.mul(Vo).add(113)).mul(Vo),o=[Dm.UZERO,Dm.UZERO],a=[Dm.UZERO,Dm.UZERO];r=r.mul(Vo).add(Qr(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=Vi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(km),s=Vi(s.add(o[1]).add(Qr(n,l+48)),42).mul(km),r=r.xor(a[1]),s=s.add(o[0]).add(Qr(n,l+40)),i=Vi(i.add(a[0]),33).mul(km),o=jk(n,l,o[1].mul(km),r.add(a[0])),a=jk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],l+=64;while(l!==c);const h=km.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Vi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(h),s=Vi(s.add(o[1]).add(Qr(n,l+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(Qr(n,l+40))),i=Vi(i.add(a[0]),33).mul(h),o=jk(n,l,o[1].mul(h),r.add(a[0])),a=jk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],qd(qd(o[0],a[0],h).add(mD(s).mul(EX)).add(i),qd(o[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hf(n,e){return e==="string"?yu(n):$p([n],e)}function wye(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function $p(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=kc(n)),Ee().getBool("DEBUG")&&uX(n,e),wye(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function so(){return Ee().platform.now()}function xye(n,e){return Ee().platform.fetch(n,e)}function yu(n,e="utf-8"){return e=e||"utf-8",Ee().platform.encode(n,e)}function Cc(n,e="utf-8"){return e=e||"utf-8",Ee().platform.decode(n,e)}function _i(n){return Ee().platform.isTypedArray!=null?Ee().platform.isTypedArray(n):wX(n)}function kc(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||ap(n)||n==null||_i(n)&&t)e.push(n);else if(Array.isArray(n)||_i(n))for(let r=0;r<n.length;++r)kc(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)kc(n[s],e,t)}return e}const _ye=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Rn,arraysEqualWithNull:cX,assert:U,assertNonNegativeIntegerDimensions:el,assertNonNull:zg,assertShapesMatch:qi,bytesFromStringArray:fX,bytesPerElement:g_,checkConversionForErrors:uX,clamp:ip,computeStrides:Jt,convertBackendValuesAndArrayBuffer:J1,createScalarValue:Hf,createShuffledIndices:Qge,decodeString:Cc,distSquared:Zge,encodeString:yu,fetch:xye,fingerPrint64:AX,flatten:kc,getArrayFromDType:Ss,getTypedArrayFromDType:ci,hasEncodingLoss:SM,hexToLong:j2,indexToLoc:Bg,inferDtype:Ap,inferFromImplicitShape:_M,isBoolean:dX,isFunction:op,isInt:og,isNumber:SI,isPromise:ap,isScalarShape:hD,isString:uu,isTypedArray:_i,isValidDtype:hX,locToIndex:gu,makeOnesTypedArray:CM,makeZerosNestedTypedArray:NL,makeZerosTypedArray:ji,nearestDivisor:CI,nearestLargerEven:xM,now:so,parseAxisParam:An,randUniform:Yge,repeatedTry:fD,rightPad:Ym,shuffle:AL,shuffleCombo:Kge,sizeFromShape:Te,sizeToSquarishShape:_I,squeezeShape:Wf,sum:ML,swap:Tf,tanh:Jge,toNestedArray:Tl,toTypedArray:$p},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sye=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new kye)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=so();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:so()-a})}if(Ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{Cye(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}};function Cye(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}let kye=class{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?Ym(`${s}ms`,9):s.error,l=Ym(e,25),c=t.rank,u=t.size,h=Ym(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tye(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function Eye(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Rn(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cG=20,Hx=3,o3=7;function Iye(n,e,t,r){const s=Jt(e),i=Aye(n,e,t,s),o=e.length,a=DE(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function Aye(n,e,t,r){const s=Te(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?k1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],C1(l[u+h],0,t).length)}return o}function C1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(o3))} + ${parseFloat(n[1].toFixed(o3))}j`:uu(n)?r=`'${n}'`:t==="bool"?r=MX(n):r=parseFloat(n.toFixed(o3)).toString(),Ym(r,e)}function MX(n){return n===0?"false":"true"}function DE(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=k1(n);return[C1(m[0],0,t)]}return t==="bool"?[MX(n[0])]:[n[0].toString()]}if(l===1){if(a>cG){const g=Hx*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-Hx)*o,a*o));return t==="complex64"&&(y=k1(y),b=k1(b)),["["+y.map((x,w)=>C1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>C1(x,s[a-Hx+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?k1(n):Array.from(n)).map((g,y)=>C1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>cG){for(let m=0;m<Hx;m++){const g=m*h,y=g+h;f.push(...DE(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-Hx;m<a;m++){const g=m*h,y=g+h;f.push(...DE(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...DE(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function k1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class li{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Te(e),r!=null){const s=r.length;U(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Ss(t,this.size),this.strides=Jt(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ru().makeTensor(this.values,this.shape,this.dtype)}}let ru=null,mb=null;function Mye(n){ru=n}function Nye(n){mb=n}let jn=class{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Te(e),this.strides=Jt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return mb.buffer(this.shape,this.dtype,e)}bufferSync(){return mb.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Tl(this.shape,e,this.dtype==="complex64")}arraySync(){return Tl(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ru().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Cc(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ru().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ru().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Cc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ru().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ru().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return mb.print(this,e)}clone(){return this.throwIfDisposed(),mb.clone(this)}toString(e=!1){const t=this.dataSync();return Iye(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),mb.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),ru().makeVariable(this,e,t,r)}};Object.defineProperty(jn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function $ye(){return RL("Tensor",()=>jn)}$ye();let __=class extends jn{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Rn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ru().disposeTensor(this),this.dataId=e.dataId,ru().incRef(this,null)}dispose(){ru().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(__,Symbol.hasInstance,{value:n=>n instanceof jn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gD;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(gD||(gD={}));var yD;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(yD||(yD={}));var bD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(bD||(bD={}));var vD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(vD||(vD={}));var wD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(wD||(wD={}));const Rye={float32:vD,int32:yD,bool:bD,complex64:wD};function Mi(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Rye[n][e]}function q2(n){return Mi(n,"int32")}function NX(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function $X(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(n,e){if(n.dtype===e.dtype)return[n,e];const t=Mi(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function RX(n,e){U(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function PM(n,e){return e.some(t=>t.id===n.id)}function Df(n){const e=[];return PX(n,e,new Set),e}function PX(n,e,t){if(n==null)return;if(n instanceof jn){e.push(n);return}if(!Pye(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),PX(i,e,t))}}function Pye(n){return Array.isArray(n)||typeof n=="object"}const Dye=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:RX,getTensorsInContainer:Df,isTensorInList:PM,makeTypesMatch:ks},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3(n){return n.kernelName!=null}let uG=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},OL=class xD{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new uG}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(wl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Sye(this.backendInstance),!0}setupRegisteredKernels(){kI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){kI(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof jS)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,wl(`Initialization of backend ${e} failed`),wl(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return wl(`Initialization of backend ${e} failed`),wl(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return xD.nextTensorId++}nextVariableId(){return xD.nextVariableId++}clone(e){const t=ue.runKernel(ay,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ue.runKernel(Xg,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(x_(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=a3(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(a3(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=x_(p,this.backendName);U(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=a3(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=dD(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(U(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&uu(e[0])&&(i=e.map(l=>yu(l)));const o=s.write(i,t,r),a=new jn(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=fX(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new jn(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new __(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*g_(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof __||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*g_(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=dD(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=ji(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Df(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(U(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));U(i instanceof jn,()=>"The result y returned by f() must be a tensor.");const o=Tye(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??Oye(i.shape),Eye(a,o,c=>this.tidy(c),Fye);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return U(op(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{U(t.every(a=>a instanceof jn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),U(r.value instanceof jn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(op(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];U(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(u.every(f=>f instanceof jn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=so(),r=await this.backend.time(e);return r.wallMs=so()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new uG;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};OL.nextTensorId=0;OL.nextVariableId=0;function Oye(n){const e=CM(Te(n),"float32");return ue.makeTensor(e,n,"float32")}function DX(){const n=gX();if(n._tfengine==null){const e=new mX(n);n._tfengine=new OL(e)}return rye(n._tfengine.ENV),Mye(()=>n._tfengine),n._tfengine}const ue=DX();function Fye(n,e){const t={a:n,b:e};return ue.runKernel(Mp,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lye(){return typeof navigator<"u"&&navigator!=null}let _D;function zye(n){_D=n}function FL(n){if(_D!==void 0)return _D;if(n||Lye()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function LL(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Bye=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:LL,isMobile:FL,mockIsMobile:zye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wa=Ee();wa.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});wa.registerFlag("IS_BROWSER",()=>LL());wa.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");wa.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));wa.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));wa.registerFlag("PROD",()=>!1);wa.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wa.getBool("DEBUG"));wa.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);wa.registerFlag("IS_TEST",()=>!1);wa.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>wa.getBool("DEBUG"));wa.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);wa.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);wa.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wh(n,e){let t=n;if(_i(n))return e==="string"?[]:[n.length];if(NX(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if($X(n))return[n.buffer.size/(e==null?4:g_(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||_i(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&OX(n,r,[]),r}function OX(n,e,t){if(t=t||[],!Array.isArray(n)&&!_i(n)){U(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}U(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),U(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)OX(n[s],r,t.concat(s))}function hG(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function j(n,e,t,r="numeric"){if(n instanceof jn)return hG(r,n.dtype,e,t),n;let s=Ap(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),hG(r,s,e,t),n==null||!_i(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=wh(n,s);!_i(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?$p(n,s):kc(n,[],!0);return ue.makeTensor(a,i,s)}function S_(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>j(i,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zL="__op";function he(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+zL;const s=(...i)=>{ue.startScope(t);try{const o=r(...i);return ap(o)&&console.error("Cannot return a Promise inside of tidy."),ue.endScope(o),o}catch(o){throw ue.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vye(n,e){const t=j(n,"real","complex"),r=j(e,"imag","complex");qi(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return ue.runKernel(e2,s)}const Of=he({complex_:Vye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(n,e,t,r){if(r==null)r=Ap(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if($X(n)||NX(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ue.backend.createTensorFromGPUData(n,e||t,r)}if(!_i(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){el(e);const s=Te(e),i=Te(t);U(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Te(e.slice(o)):!0;U(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!_i(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?$p(n,r):kc(n,[],!0),ue.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n,e,t){const r=wh(n,t);return Rp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Fu{static join(e){return new Fu(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>_i(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+s.byteLength;this.shards.push({buffer:s,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],h=e+a-c.start,f=a,p=Math.min(t,c.end)-c.start,m=new Uint8Array(c.buffer,h,p-h);if(o.set(m,f),a+=m.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Uye(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Uye(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,i=e(n[s]);if(i===0)return s;i<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EI=4;async function CD(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const f=await l.bytes(),d=f.reduce((g,y)=>g+y.length,0)+EI*f.length,p=new Uint8Array(d);let m=0;for(let g=0;g<f.length;g++){const y=f[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(b,m),m+=EI,p.set(y,m),m+=y.length}h(p)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(r);return{data:Wye(i),specs:t}}function BL(n,e){const t=new Fu(n),r={};let s,i=0;for(const o of e){const a=o.name,l=o.dtype,c=o.shape,u=Te(c);let h;if("quantization"in o){const f=o.quantization;if(f.dtype==="uint8"||f.dtype==="uint16"){if(!("min"in f&&"scale"in f))throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}else if(f.dtype==="float16"){if(l!=="float32")throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${l}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=SD[f.dtype],p=t.slice(i,i+u*d),m=f.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(l==="float32")if(f.dtype==="uint8"||f.dtype==="uint16"){h=new Float32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=y*f.scale+f.min}}else if(f.dtype==="float16")s===void 0&&(s=Kye()),h=s(m);else throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);else if(l==="int32"){if(f.dtype!=="uint8"&&f.dtype!=="uint16")throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);h=new Int32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=Math.round(y*f.scale+f.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*d}else if(l==="string"){const f=Te(o.shape);h=[];for(let d=0;d<f;d++){const p=new Uint32Array(t.slice(i,i+EI))[0];i+=EI;const m=new Uint8Array(t.slice(i,i+p));h.push(m),i+=p}}else{const f=SD[l],d=t.slice(i,i+u*f);if(l==="float32")h=new Float32Array(d);else if(l==="int32")h=new Int32Array(d);else if(l==="bool")h=new Uint8Array(d);else if(l==="complex64"){h=new Float32Array(d);const p=new Float32Array(h.length/2),m=new Float32Array(h.length/2);for(let b=0;b<p.length;b++)p[b]=h[b*2],m[b]=h[b*2+1];const g=Ei(p,c,"float32"),y=Ei(m,c,"float32");r[a]=Of(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*f}l!=="complex64"&&(r[a]=Ei(h,c,l))}return r}function Wye(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const VL=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function fG(n){return VL?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Gye(n){if(VL)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function Hye(n){if(VL){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function FX(n){return Fu.join(n)}function dG(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function LX(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function UL(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function WL(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),UL(n,t,r)}function X2(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:fG(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:fG(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Fu(n.weightData).byteLength}}function GL(n){const e=[];for(const t of n)e.push(...t.weights);return e}function jye(){const n=t=>{let r=t<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function qye(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Xye(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Kye(){const n=jye(),e=qye(),t=Xye();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _s{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _s.instance==null&&(_s.instance=new _s),_s.instance}static registerSaveRouter(e){_s.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_s.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _s.getHandlers(e,"save")}static getLoadHandlers(e,t){return _s.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?_s.getInstance().loadRouters:_s.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}}const Yye=n=>_s.registerSaveRouter(n),Zye=n=>_s.registerLoadRouter(n),zX=n=>_s.getSaveHandlers(n),BX=(n,e)=>_s.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kD="tensorflowjs",TD=1,Wm="models_store",Pd="model_info_store";function VX(){if(!Ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ED(n){const e=n.result;e.createObjectStore(Wm,{keyPath:"modelPath"}),e.createObjectStore(Pd,{keyPath:"modelPath"})}class ag{constructor(e){if(this.indexedDB=VX(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const i=this.indexedDB.open(kD,TD);i.onupgradeneeded=()=>ED(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Wm,"readonly"),c=a.objectStore(Wm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(o.close(),s(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Fu.join(t.weightData);const a=X2(t),l=o.transaction(Pd,"readwrite");let c=l.objectStore(Pd),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return s(f)}let h;u.onsuccess=()=>{h=o.transaction(Wm,"readwrite");const f=h.objectStore(Wm);let d;try{d=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(p){return s(p)}d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=p=>{c=l.objectStore(Pd);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),s(d.error)),m.onerror=g=>(o.close(),s(d.error))}},u.onerror=f=>(o.close(),s(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}}ag.URL_SCHEME="indexeddb://";const UX=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ag.URL_SCHEME)?Jye(n.slice(ag.URL_SCHEME.length)):null;_s.registerSaveRouter(UX);_s.registerLoadRouter(UX);function Jye(n){return new ag(n)}function Qye(n){return n.startsWith(ag.URL_SCHEME)?n.slice(ag.URL_SCHEME.length):n}class e0e{constructor(){this.indexedDB=VX()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(kD,TD);r.onupgradeneeded=()=>ED(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(Pd,"readonly"),a=i.objectStore(Pd).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=Qye(e),new Promise((t,r)=>{const s=this.indexedDB.open(kD,TD);s.onupgradeneeded=()=>ED(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(Pd,"readwrite"),a=o.objectStore(Pd),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=i.transaction(Wm,"readwrite");const d=c.objectStore(Wm).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};u.onsuccess=h,u.onerror=f=>(h(),i.close(),r(l.error))}},l.onerror=u=>(i.close(),r(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ef="/",gb="tensorflowjs_models",WX="info",t0e="model_topology",n0e="weight_specs",r0e="weight_data",s0e="model_metadata";function GX(n){return{info:[gb,n,WX].join(Ef),topology:[gb,n,t0e].join(Ef),weightSpecs:[gb,n,n0e].join(Ef),weightData:[gb,n,r0e].join(Ef),modelMetadata:[gb,n,s0e].join(Ef)}}function HX(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function i0e(n){const e=n.split(Ef);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Ef)}function o0e(n){return n.startsWith(lg.URL_SCHEME)?n.slice(lg.URL_SCHEME.length):n}class lg{constructor(e){if(!Ee().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=GX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=X2(e),i=Fu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Gye(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw HX(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Hye(o),t}}lg.URL_SCHEME="localstorage://";const jX=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lg.URL_SCHEME)?a0e(n.slice(lg.URL_SCHEME.length)):null;_s.registerSaveRouter(jX);_s.registerLoadRouter(jX);function a0e(n){return new lg(n)}class l0e{constructor(){U(Ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=gb+Ef,r=Ef+WX;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(r)){const o=i0e(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=o0e(e);const t=GX(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return HX(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mb="://";class zo{constructor(){this.managers={}}static getInstance(){return zo.instance==null&&(zo.instance=new zo),zo.instance}static registerManager(e,t){U(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Mb)&&(e=e.slice(0,e.indexOf(Mb))),U(e.length>0,()=>"scheme must not be an empty string.");const r=zo.getInstance();U(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=zo.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(zo.getInstance().managers)}}function OE(n){if(n.indexOf(Mb)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${zo.getSchemes().join(",")}`);return{scheme:n.split(Mb)[0],path:n.split(Mb)[1]}}async function qX(n,e,t=!1){U(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=_s.getLoadHandlers(n);U(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),U(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=_s.getSaveHandlers(e);U(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),U(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=OE(n).scheme,l=OE(n).path,c=a===OE(n).scheme,u=await s.load();t&&c&&await zo.getManager(a).removeModel(l);const h=await o.save(u);return t&&!c&&await zo.getManager(a).removeModel(l),h.modelArtifactsInfo}async function HL(){const n=zo.getSchemes(),e={};for(const t of n){const r=await zo.getManager(t).listModels();for(const s in r){const i=t+Mb+s;e[i]=r[s]}}return e}async function jL(n){const e=OE(n);return zo.getManager(e.scheme).removeModel(e.path)}async function c0e(n,e){return qX(n,e,!1)}async function u0e(n,e){return qX(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h0e{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ee().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return wX(e)}}if(Ee().get("IS_BROWSER")){Ee().setPlatform("browser",new h0e);try{zo.registerManager(lg.URL_SCHEME,new l0e)}catch{}try{zo.registerManager(ag.URL_SCHEME,new e0e)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e={importFetch:()=>require("node-fetch")};let l3;class d0e{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ee().global.fetch!=null?Ee().global.fetch(e,t):(l3==null&&(l3=f0e.importFetch()),l3(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ee().get("IS_NODE")&&!Ee().get("IS_BROWSER")&&Ee().setPlatform("node",new d0e);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(n,e="float32",t){return e=e||"float32",el(n),new li(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(n,e){const t=j(n,"x","cast");if(!hX(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return ue.runKernel(Xg,r,s)}const wt=he({cast_:p0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0e(n){const t={x:j(n,"x","clone","string_or_numeric")};return ue.runKernel(ay,t)}const mh=he({clone_:m0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */DX();const g0e={buffer:Sn,cast:wt,clone:mh,print:qL};Nye(g0e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0e(){Ee().set("PROD",!0)}function b0e(){Ee().set("DEBUG",!0)}function v0e(){Ee().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function w0e(n){Ee().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function x0e(){ue.disposeVariables()}function xo(){return ue}function II(){return ue.memory()}function _0e(n){return ue.profile(n)}function Se(n,e){return ue.tidy(n,e)}function nn(n){Df(n).forEach(t=>t.dispose())}function Xs(n){return ue.keep(n)}function S0e(n){return ue.time(n)}function C0e(n){return ue.setBackend(n)}function K2(){return ue.ready()}function C_(){return ue.backendName}function k0e(n){ue.removeBackend(n)}function T0e(n){return ue.findBackend(n)}function E0e(n){return ue.findBackendFactory(n)}function DM(n,e,t=1){return ue.registerBackend(n,e,t)}function cg(){return ue.backend}function I0e(n,e){Ee().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(n,e){let t=j(n,"a","add"),r=j(e,"b","add");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(Mp,s)}const qe=he({add_:A0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0e(n,e){let t=j(n,"a","floorDiv"),r=j(e,"b","floorDiv");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(iy,s)}const XL=he({floorDiv_:M0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(n,e){let t=j(n,"a","div"),r=j(e,"b","div");if([t,r]=ks(t,r),t.dtype==="int32"&&r.dtype==="int32")return XL(t,r);const s={a:t,b:r},i={};return ue.runKernel(Qg,s,i)}const Lt=he({div_:N0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(n,e){let t=j(n,"a","mul"),r=j(e,"b","mul");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(gy,s)}const fe=he({mul_:$0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(n){const e=j(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ue.runKernel(Lv,t)}else{const t={x:e};return ue.runKernel(Mv,t)}}const wi=he({abs_:R0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(n){const t={x:j(n,"x","acos")};return ue.runKernel(Vg,t)}const XX=he({acos_:P0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(n){const t={x:j(n,"x","acosh")};return ue.runKernel(Ug,t)}const KX=he({acosh_:D0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e(n){U(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),U(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,i)=>j(s,`tensors${i}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Rn(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return ue.runKernel(Nv,r)}const YX=he({addN_:O0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0e(n,e=null,t=!1){const s={x:j(n,"x","all","bool")},i={axis:e,keepDims:t};return ue.runKernel(qS,s,i)}const KL=he({all_:F0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(n,e=null,t=!1){const s={x:j(n,"x","any","bool")},i={axis:e,keepDims:t};return ue.runKernel(XS,s,i)}const AI=he({any_:L0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e(n,e=0){const r={x:j(n,"x","argMax")},s={axis:e};return ue.runKernel($v,r,s)}const ug=he({argMax_:z0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0e(n,e=0){const r={x:j(n,"x","argMin")},s={axis:e};return ue.runKernel(Rv,r,s)}const ZX=he({argMin_:B0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0e(n){const t={x:j(n,"x","asin")};return ue.runKernel(Wg,t)}const JX=he({asin_:V0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0e(n){const t={x:j(n,"x","asinh")};return ue.runKernel(Gg,t)}const QX=he({asinh_:U0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n){const t={x:j(n,"x","atan")};return ue.runKernel(Hg,t)}const eK=he({atan_:W0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(n,e){let t=j(n,"a","atan2"),r=j(e,"b","atan2");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(qg,s)}const tK=he({atan2_:G0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(n){const t={x:j(n,"x","atanh")};return ue.runKernel(jg,t)}const nK=he({atanh_:H0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pp(n,e,t,r,s="NHWC",i){const o=n[3],a=[...e,o],l=nl(s);return ts(n,a,t,i,r,null,null,l)}function ko(n,e,t,r,s,i,o="channelsLast"){const[a,l]=k_(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ts(n,c,t,r,s,i,!1,o)}function Ll(n,e,t,r,s,i,o="NDHWC"){const[a,l,c]=ID(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Lu(n,u,t,r,s,!1,h,i)}function ts(n,e,t,r,s,i,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,p]=e,[m,g]=k_(t),[y,b]=k_(r),x=Nb(f,y),w=Nb(d,b),{padInfo:S,outHeight:C,outWidth:k}=X0e(s,c,u,m,g,x,w,i,a),A=o?p*h:p;let M;return a==="channelsFirst"?M=[l,A,C,k]:a==="channelsLast"&&(M=[l,C,k,A]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:C,outWidth:k,outChannels:A,padInfo:S,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:n,outShape:M,filterShape:e}}function Lu(n,e,t,r,s,i=!1,o="channelsLast",a){let[l,c,u,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,f]=n;else if(o==="channelsFirst")[l,f,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,m,,g]=e,[y,b,x]=ID(t),[w,S,C]=ID(r),k=Nb(d,w),A=Nb(p,S),M=Nb(m,C),{padInfo:E,outDepth:N,outHeight:O,outWidth:R}=K0e(s,c,u,h,y,b,x,k,A,M,a),D=i?g*f:g;let z;return o==="channelsFirst"?z=[l,D,N,O,R]:o==="channelsLast"&&(z=[l,N,O,R,D]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:f,outDepth:N,outHeight:O,outWidth:R,outChannels:D,padInfo:E,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:A,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:S,dilationWidth:C,inShape:n,outShape:z,filterShape:e}}function j0e(n,e,t,r,s){r==null&&(r=YL(n,e,t));const i=n[0],o=n[1],a=T_((i-e+2*r)/t+1,s),l=T_((o-e+2*r)/t+1,s);return[a,l]}function q0e(n,e,t,r,s,i){s==null&&(s=YL(n,e[0],r[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*s>=e[a]&&(o[a]=T_((n[a]-e[a]+2*s)/r[a]+1,i));return o}function YL(n,e,t,r=1){const s=Nb(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function k_(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function ID(n){return typeof n=="number"?[n,n,n]:n}function Nb(n,e){return e<=1?n:n+(n-1)*(e-1)}function X0e(n,e,t,r,s,i,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=j0e([e,t],i,r,n,a);u=d[0],h=d[1]}else if(n==="same"){u=Math.ceil(e/r),h=Math.ceil(t/s);const f=Math.max(0,(u-1)*r+i-e),d=Math.max(0,(h-1)*s+o-t),p=Math.floor(f/2),m=f-p,g=Math.floor(d/2),y=d-g;c={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-i+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const f=l==="channelsLast"?n[1][0]:n[2][0],d=l==="channelsLast"?n[1][1]:n[2][1],p=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:f,bottom:d,left:p,right:m,type:f===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT"},u=T_((e-i+f+d)/r+1,a),h=T_((t-o+p+m)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function K0e(n,e,t,r,s,i,o,a,l,c,u){let h,f,d,p;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=q0e([e,t,r,1],[a,l,c],1,[s,i,o],n,u);f=g[0],d=g[1],p=g[2]}else if(n==="same"){f=Math.ceil(e/s),d=Math.ceil(t/i),p=Math.ceil(r/o);const m=(f-1)*s+a-e,g=(d-1)*i+l-t,y=(p-1)*o+c-r,b=Math.floor(m/2),x=m-b,w=Math.floor(g/2),S=g-w,C=Math.floor(y/2),k=y-C;h={top:w,bottom:S,left:C,right:k,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}function T_(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function lp(n){const[e,t,r]=k_(n);return e===1&&t===1&&r===1}function Ri(n,e){return lp(n)||lp(e)}function hg(n){return k_(n).every(e=>e>0)}function nl(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function na(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")U(og(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{U(og(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n,e){const r={x:j(n,"x","reshape","string_or_numeric")},s={shape:e};return ue.runKernel(bw,r,s)}const ve=he({reshape_:Y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(n,e,t,r,s){const i=j(n,"x","avgPool","float32"),o=1;U(Ri(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),na("avgPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=ue.runKernel(Pv,c,u);return h=wt(h,i.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const OM=he({avgPool_:Z0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(n,e,t,r,s,i="NDHWC"){const o=j(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),U(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),na("avgPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i};let h=ue.runKernel(Dv,c,u);return h=wt(h,a.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const ZL=he({avgPool3d_:J0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0e(n,e=0){U(n.length>=1,()=>"Pass at least one tensor to concat");const t=S_(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return mh(t[0]);const r=t,s={axis:e};return ue.runKernel(zv,r,s)}const cs=he({concat_:Q0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(n,e,t=!1,r=!1){let s=j(n,"a","matMul"),i=j(e,"b","matMul");[s,i]=ks(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return ue.runKernel(Ov,o,a)}const Hn=he({matMul_:ebe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tbe(n){const t={x:j(n,"x","sigmoid","float32")};return ue.runKernel(Ey,t)}const El=he({sigmoid_:tbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(n,e,t){const r=j(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:t};return ue.runKernel(Sw,s,i)}const dn=he({slice_:nbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(n){const t={x:j(n,"x","tanh","float32")};return ue.runKernel(Ry,t)}const Yb=he({tanh_:rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbe(n,e,t,r,s,i){const o=j(n,"forgetBias","basicLSTMCell"),a=j(e,"lstmKernel","basicLSTMCell"),l=j(t,"lstmBias","basicLSTMCell"),c=j(r,"data","basicLSTMCell"),u=j(s,"c","basicLSTMCell"),h=j(i,"h","basicLSTMCell"),f=cs([c,h],1),d=Hn(f,a),p=qe(d,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],b=dn(p,[0,0],y),x=dn(p,[0,g],y),w=dn(p,[0,g*2],y),S=dn(p,[0,g*3],y),C=qe(fe(El(b),Yb(x)),fe(u,El(qe(o,w)))),k=fe(Yb(C),El(S));return[C,k]}const rK=he({basicLSTMCell_:sbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(n,e,t){const r=j(n,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);U(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),U(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),U(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:t};return ue.runKernel(Fv,i,o)}const FM=he({batchToSpaceND_:ibe});function obe(n){let e;return n.rank===0||n.rank===1?e=ve(n,[1,1,1,n.size]):n.rank===2?e=ve(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(n,e,t,r,s,i){i==null&&(i=.001);const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;r!=null&&(u=j(r,"offset","batchNorm")),U(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:obe(o),scale:c,offset:u,mean:a,variance:l},d={varianceEpsilon:i},p=ue.runKernel(Xv,f,d);return ve(p,o.shape)}const Y2=he({batchNorm_:abe});function lbe(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),U(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Y2(o,a,l,u,c,i)}const JL=he({batchNorm2d_:lbe});function cbe(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),U(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Y2(o,a,l,u,c,i)}const QL=he({batchNorm3d_:cbe});function ube(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),U(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Y2(o,a,l,u,c,i)}const ez=he({batchNorm4d_:ube});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(n,e,t){const r=j(n,"x","bincount"),s=j(e,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:t};return ue.runKernel(ZS,i,o)}const tz=he({bincount_:hbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fbe(n,e){const t=j(n,"x","bitwiseAnd"),r=j(e,"y","bitwiseAnd");if(!Rn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return ue.runKernel(JS,s)}const sK=he({bitwiseAnd_:fbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(n,e){const t=j(n,"s0","broadcastArgs","int32"),r=j(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return ue.runKernel(QS,s)}const iK=he({broadcastArgs_:dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n,e){let t=j(n,"broadcastTo","x");const r=t.shape;if(el(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ve(t,c)}const s=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return mh(t);const a={x:t},l={reps:i};return ue.runKernel(Py,a,l)}const $b=he({broadcastTo_:pbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(n){const t={x:j(n,"x","ceil","float32")};return ue.runKernel(Kg,t)}const oK=he({ceil_:mbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fy(n,e,t){el(n),t=t||Ap(e);const r={shape:n,value:e,dtype:t};return ue.runKernel(m2,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(n,e,t){const r=j(n,"x","clipByValue");if(U(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Fy(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:t};return ue.runKernel(Yg,s,i)}const xa=he({clipByValue_:gbe});function ybe(n){return cs(n,0)}const nz=he({concat1d_:ybe});function bbe(n,e){return cs(n,e)}const rz=he({concat2d_:bbe});function vbe(n,e){return cs(n,e)}const sz=he({concat3d_:vbe});function wbe(n,e){return cs(n,e)}const iz=he({concat4d_:wbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","conv2d","float32"),l=j(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),na("conv2d",r,o);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),U(Ri(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(hg(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(hg(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ue.runKernel(Bv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const cp=he({conv2d_:xbe});function _be(n,e,t,r,s="NWC",i=1,o){const a=j(n,"x","conv1d"),l=j(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1]])),U(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),U(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),na("conv1d",r,o),U(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),U(Ri(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),U(hg(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(hg(t),()=>"Error in conv1D: Stride should be larger than 0."),U(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=ve(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=cp(f,h,[1,t],r,"NHWC",[1,i],o);return u?ve(g,[g.shape[2],g.shape[3]]):ve(g,[g.shape[0],g.shape[2],g.shape[3]])}const oz=he({conv1d_:_be});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n,e,t,r,s,i="NHWC",o){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),U(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),U(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),U(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];U(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),U(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),na("conv2dDerInput",s,o);const f={dy:l,filter:t},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},p=ue.runKernel(Vv,f,d);return c?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const az=he({conv2DBackpropInput_:Sbe});function Cbe(n,e,t,r,s,i){const o=j(n,"x","conv2dTranspose"),a=j(e,"filter","conv2dTranspose");return az(t,o,a,r,s,"NHWC",i)}const lz=he({conv2dTranspose_:Cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n,e,t,r,s="NDHWC",i=[1,1,1]){const o=j(n,"x","conv3d"),a=j(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),U(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),U(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),U(Ri(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),U(hg(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(hg(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:i},f=ue.runKernel(Uv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const cz=he({conv3d_:kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(n,e,t,r,s){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];U(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),U(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),U(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),U(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),U(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:s,strides:r,inputShape:i},f=ue.runKernel(r2,u,h);return a?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const aK=he({conv3DBackpropInput_:Tbe});function Ebe(n,e,t,r,s){const i=j(n,"x","conv3dTranspose"),o=j(e,"filter","conv3dTranspose");return aK(t,i,o,r,s)}const uz=he({conv3dTranspose_:Ebe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const t={x:j(n,"x","cos","float32")};return ue.runKernel(Zg,t)}const LM=he({cos_:Ibe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n){const t={x:j(n,"x","cosh","float32")};return ue.runKernel(Jg,t)}const hz=he({cosh_:Abe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(s2,i,o)}const MI=he({cumprod_:Mbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(Wv,i,o)}const fz=he({cumsum_:Nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(n,e,t,r=!1){const s=j(n,"x","denseBincount"),i=j(e,"weights","denseBincount");U(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),U(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:t,binaryOutput:r};return ue.runKernel(o2,o,a)}const NI=he({denseBincount_:$be});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(n,e,t="NHWC"){const r=j(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],i=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];U(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),U(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),U(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),U(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return ue.runKernel(a2,a,l)}const lK=he({depthToSpace_:Rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pbe(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","depthwiseConv2d","float32"),l=j(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),na("depthwiseConv2d",r,o);const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ue.runKernel(Gv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Z2=he({depthwiseConv2d_:Pbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n){const t={x:j(n,"x","diag")};return ue.runKernel(u2,t)}const cK=he({diag_:Dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(n,e,t,r,s=[1,1],i="NHWC"){const o=j(n,"x","dilation2d"),a=j(e,"filter","dilation2d");U(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),U(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),U(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),U(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:r,dilations:s},f=ue.runKernel(Hv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const uK=he({dilation2d_:Obe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const i=t-1-s,o=n[i]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(i)}return r}function ui(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&t.unshift(i)}return t}function ln(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let i=n[n.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=i}return r}const Fbe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:ln,getBroadcastDims:Ff,getReductionAxes:ui},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(n,e){let t=j(n,"a","equal","string_or_numeric"),r=j(e,"b","equal","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(jv,s)}const vu=he({equal_:Lbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zbe(n,e,t){const r=j(e,"a","where"),s=j(t,"b","where"),i=j(n,"condition","where","bool"),o=ln(ln(i.shape,r.shape),s.shape),a=$b(i,o),l=$b(r,o),c=$b(s,o),u={condition:a,t:l,e:c};return ue.runKernel(_w,u)}const _o=he({where_:zbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bbe(n){const t={x:j(n,"x","zerosLike")};return ue.runKernel(Mw,t)}const lr=he({zerosLike_:Bbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(n,e){let t=j(n,"a","div"),r=j(e,"b","div");[t,r]=ks(t,r);const s=Lt(t,r),i=lr(s),o=vu(r,i);return _o(o,i,s)}const hK=he({divNoNan_:Vbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(n,e){const t=j(n,"t1","dot"),r=j(e,"t2","dot");U((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],i=r.rank===1?r.size:r.shape[0];if(U(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),t.rank===1&&r.rank===1){const o=ve(t,[1,-1]),a=ve(r,[-1,1]),l=Hn(o,a);return ve(l,[])}else if(t.rank===1&&r.rank===2){const o=ve(t,[1,-1]),a=ve(r,[r.shape[0],r.shape[1]]),l=Hn(o,a);return ve(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=ve(r,[-1,1]),a=Hn(t,o);return ve(a,[a.size])}else{const o=ve(r,[r.shape[0],r.shape[1]]);return Hn(t,o)}}const fK=he({dot_:Ube});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wbe(n,...e){const t=e.map((s,i)=>j(s,`tensors${i}`,"einsum")),r={equation:n};return ue.runKernel(f2,t,r)}const Om=he({einsum_:Wbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gbe(n){const t={x:j(n,"x","elu","float32")};return ue.runKernel(ey,t)}const J2=he({elu_:Gbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(n,e){const t=j(n,"x","ensureShape","string_or_numeric");if(!cX(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const dK=he({ensureShape_:Hbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(n){let e=j(n,"x","erf");U(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=wt(e,"float32"));const t={x:e};return ue.runKernel(ty,t)}const pK=he({erf_:jbe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function mK(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function Qs(n,e){const t=[],r=n.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&t.push(n[i]);const s=e.map(i=>n[i]);return[t,s]}function Ls(n,e){const t=e.map(r=>1);return mK(n,t,e)}function fi(n,e,t){U(dz(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Lr(n,e){if(dz(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Oh(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ns(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(n,e=null,t=!1){const s={x:j(n,"x","max")},i={reductionIndices:e,keepDims:t};return ue.runKernel(sw,s,i)}const wc=he({max_:qbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(n,e=null,t=!1){const s={x:j(n,"x","min")},i={axis:e,keepDims:t};return ue.runKernel(lw,s,i)}const E_=he({min_:Xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n,e){let t=j(n,"base","pow"),r=j(e,"exp","pow");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(yy,s)}const up=he({pow_:Kbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n,e){if((_i(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&_i(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Rp(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(n){const t={x:j(n,"x","sqrt","float32")};return ue.runKernel(Ay,t)}const So=he({sqrt_:Ybe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(n){const e=j(n,"x","square"),t={};return ue.runKernel("Square",{x:e},t)}const Or=he({square_:Zbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n,e=null,t=!1){let r=j(n,"x","sum");r.dtype==="bool"&&(r=wt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ue.runKernel(Cw,s,i)}const Yt=he({sum_:Jbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(n,e="euclidean",t=null,r=!1){n=j(n,"x","norm");const s=gK(n,e,t);let i=s.shape;if(r){const o=An(t,n.shape);i=Ls(s.shape,o)}return ve(s,i)}function gK(n,e,t=null){if(n.rank===0)return wi(n);if(n.rank!==1&&t===null)return gK(ve(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Yt(wi(n),t);if(e===1/0)return wc(wi(n),t);if(e===-1/0)return E_(wi(n),t);if(e==="euclidean"||e===2)return So(Yt(up(wi(n),en(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return wc(Yt(wi(n),t[0]),t[1]-1);if(e===1/0)return wc(Yt(wi(n),t[1]),t[0]);if(e===-1/0)return E_(Yt(wi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return So(Yt(Or(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Nw=he({norm_:Qbe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(n,e=null,t=!1){return Nw(n,"euclidean",e,t)}const yK=he({euclideanNorm_:eve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tve(n){const t={x:j(n,"x","exp")};return ue.runKernel(ny,t)}const Yo=he({exp_:tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(n,e=0){const t=j(n,"x","expandDims","string_or_numeric");U(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return ue.runKernel(qv,r,s)}const oi=he({expandDims_:nve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(n){const t={x:j(n,"x","expm1")};return ue.runKernel(ry,t)}const bK=he({expm1_:rve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(n,e){const t=j(n,"x","tile","string_or_numeric");U(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return ue.runKernel(Py,r,s)}const pc=he({tile_:sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(n,e,t,r="float32"){e==null&&(e=n);const s=Sn([n,e],r),i=n<=e?n:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=ve(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return pc(oi(o,0),[t[0],1,1]);if(t.length===2)return pc(oi(oi(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return pc(oi(oi(oi(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const zM=he({eye_:ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(n){const t={x:j(n,"x","floor","float32")};return ue.runKernel(sy,t)}const Q2=he({floor_:ove});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(n,e,t=0,r=0){const s=j(n,"x","gather"),i=j(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return ue.runKernel(Kv,o,a)}const eC=he({gather_:ave});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lve(n,e){let t=j(n,"a","greater","string_or_numeric"),r=j(e,"b","greater","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Yv,s)}const rl=he({greater_:lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(n,e){let t=j(n,"a","greaterEqual","string_or_numeric"),r=j(e,"b","greaterEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(oy,s)}const Dp=he({greaterEqual_:cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(n){const t={input:j(n,"input","imag")};return ue.runKernel(v2,t)}const tC=he({imag_:uve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(n){const t={x:j(n,"x","isFinite")};return ue.runKernel(ly,t)}const vK=he({isFinite_:hve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fve(n){const t={x:j(n,"x","isInf")};return ue.runKernel(cy,t)}const wK=he({isInf_:fve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(n){const t={x:j(n,"x","isNaN")};return ue.runKernel(uy,t)}const xK=he({isNaN_:dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pve(n,e=.2){const r={x:j(n,"x","leakyRelu")},s={alpha:e};return ue.runKernel(Zv,r,s)}const BM=he({leakyRelu_:pve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mve(n,e){let t=j(n,"a","less","string_or_numeric"),r=j(e,"b","less","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Jv,s)}const I_=he({less_:mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gve(n,e){let t=j(n,"a","lessEqual","string_or_numeric"),r=j(e,"b","lessEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Qv,s)}const Ly=he({lessEqual_:gve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return ue.runKernel(w2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yve(n,e=5,t=1,r=1,s=.5){const i=j(n,"x","localResponseNormalization");U(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),U(og(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:r,beta:s},u=ue.runKernel(rw,l,c);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const SK=he({localResponseNormalization_:yve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(n){const t={x:j(n,"x","log","float32")};return ue.runKernel(hy,t)}const Nl=he({log_:bve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vve(n){const t={x:j(n,"x","log1p")};return ue.runKernel(fy,t)}const VM=he({log1p_:vve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wve(n){return U(op(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const r=j(e,"x","tf.grad","string_or_numeric"),s=t!=null?j(t,"dy","tf.grad"):null;return ue.tidy(()=>{const{value:i,grads:o}=ue.gradients(()=>n(r),[r],s);return s!=null&&qi(i.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),UM(o),o[0]})}}function xve(n){return U(op(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{U(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=S_(e,"args","tf.grads","string_or_numeric"),s=t!=null?j(t,"dy","tf.grads"):null;return ue.tidy(()=>{const{value:i,grads:o}=ue.gradients(()=>n(...r),r,s);return s!=null&&qi(i.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),UM(o),o})}}function _ve(n){return U(op(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{U(e instanceof jn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=ue.gradients(()=>n(e),[e],t);return UM(r),{grad:r[0],value:s}}}function Sve(n){return U(op(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{U(Array.isArray(e)&&e.every(s=>s instanceof jn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=ue.gradients(()=>n(...e),e,t);return t!=null&&qi(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),UM(r.grads),r}}function CK(n,e){U(op(n),()=>"The f passed in variableGrads(f) must be a function"),U(e==null||Array.isArray(e)&&e.every(c=>c instanceof __),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ue.registeredVariables)e.push(ue.registeredVariables[c])}const r=t?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),U(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=ue.gradients(n,e,null,i);U(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:o,grads:l}}function xh(n){return ue.customGrad(n)}function UM(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n){const t={x:j(n,"x","neg")};return ue.runKernel(uw,t)}const us=he({neg_:Cve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(n){const t={x:j(n,"x","softplus")};return ue.runKernel(Iy,t)}const $w=he({softplus_:kve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(n){const e=j(n,"x","logSigmoid");return xh(r=>({value:us($w(us(r))),gradFunc:o=>fe(o,El(us(r)))}))(e)}const kK=he({logSigmoid_:Tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eve(n,e){let t=j(n,"a","sub"),r=j(e,"b","sub");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(Ny,s)}const Dt=he({sub_:Eve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(n,e=-1){const t=j(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return xh((s,i)=>{const a=wc(s,e,!0),l=Dt(s,a),c=Dt(wt(l,"float32"),Nl(Yt(Yo(l),e,!0)));return i([c]),{value:c,gradFunc:(h,f)=>{const[d]=f,p=!0,m=Yo(d);return Dt(h,fe(Yt(h,e,p),m))}}})(t)}const pz=he({logSoftmax_:Ive});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(n,e=null,t=!1){const r=j(n,"x","logSumExp"),s=An(e,r.shape),i=wc(r,s,!0),o=Dt(r,i),a=Yo(o),l=Yt(a,s),c=Nl(l),u=qe(ve(i,c.shape),c);if(t){const h=Ls(u.shape,s);return ve(u,h)}return u}const WM=he({logSumExp_:Ave});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(n,e){const t=j(n,"a","logicalAnd","bool"),r=j(e,"b","logicalAnd","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(ew,s)}const _h=he({logicalAnd_:Mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(n){const t={x:j(n,"x","logicalNot","bool")};return ue.runKernel(tw,t)}const GM=he({logicalNot_:Nve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ve(n,e){const t=j(n,"a","logicalOr","bool"),r=j(e,"b","logicalOr","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(nw,s)}const mz=he({logicalOr_:$ve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(n,e){const t=j(n,"a","logicalXor","bool"),r=j(e,"b","logicalXor","bool");return ln(t.shape,r.shape),_h(mz(n,e),GM(_h(n,e)))}const TK=he({logicalXor_:Rve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qk=2147483648;function Pve(n,e,t="left"){const r=j(n,"sortedSequence","searchSorted"),s=j(e,"values","searchSorted"),i=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],a=ve(r,[-1,i]),l=ve(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Te(l.shape)>=qk)throw new Error(`values tensor size must less than ${qk}`);if(a.shape[1]>=qk)throw new Error(`trailing dim_size must less than ${qk} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return ue.runKernel(P2,c,u)}const HM=he({searchSorted_:Pve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EK(n,e){return HM(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(n,e,t,r,s){const i=j(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),U(Ri(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),na("maxPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=ue.runKernel(iw,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const jM=he({maxPool_:Dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ove(n,e=[1,1,1],t,r,s,i="NDHWC"){const o=j(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),na("maxPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i},h=ue.runKernel(ow,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const gz=he({maxPool3d_:Ove});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(n,e,t,r,s=!1){const o={x:j(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},l=ue.runKernel(C2,o,a);return{result:l[0],indexes:l[1]}}const IK=he({maxPoolWithArgmax_:Fve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(n,e){let t=j(n,"a","maximum"),r=j(e,"b","maximum");[t,r]=ks(t,r),t.dtype==="bool"&&(t=wt(t,"int32"),r=wt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(dy,s)}const jf=he({maximum_:Lve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zve(n,e=null,t=!1){const s={x:j(n,"x","mean")},i={axis:e,keepDims:t};return ue.runKernel(aw,s,i)}const Ds=he({mean_:zve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e="float32"){if(el(n),e==="complex64"){const r=ms(n,"float32"),s=ms(n,"float32");return Of(r,s)}const t=ji(Te(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(n,e="float32"){if(el(n),e==="complex64"){const r=ma(n,"float32"),s=ms(n,"float32");return Of(r,s)}const t=CM(Te(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AK(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=j(n,"x","meshgrid",n instanceof jn?n.dtype:"float32");if(e===void 0)return[r];let s=j(e,"y","meshgrid",e instanceof jn?e.dtype:"float32");const i=Te(r.shape),o=Te(s.shape);return t==="xy"?(r=ve(r,[1,-1]),s=ve(s,[-1,1]),[Hn(ma([o,1],r.dtype),r),Hn(s,ma([1,i],s.dtype))]):(r=ve(r,[-1,1]),s=ve(s,[1,-1]),[Hn(r,ma([1,o],r.dtype)),Hn(ma([i,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(n,e){let t=j(n,"a","minimum"),r=j(e,"b","minimum");[t,r]=ks(t,r),t.dtype==="bool"&&(t=wt(t,"int32"),r=wt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(py,s)}const hp=he({minimum_:Bve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(n,e,t){U(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=j(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)U(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:t},o={x:r};return ue.runKernel(cw,o,i)}const yz=he({mirrorPad_:Vve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uve(n,e){let t=j(n,"a","mod"),r=j(e,"b","mod");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(my,s)}const MK=he({mod_:Uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wve(n,e=null,t=!1){n=j(n,"x","moments");const r=An(e,n.shape),s=Ds(n,r,t);let i=s.shape;t||(i=Ls(s.shape,r));const o=Or(Dt(wt(n,"float32"),ve(s,i))),a=Ds(o,r,t);return{mean:s,variance:a}}const nC=he({moments_:Wve});function Gve(n,e,t,r){const s=j(e,"data","multiRNNCell"),i=S_(t,"c","multiRNNCell"),o=S_(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<n.length;h++){const f=n[h](a,i[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const NK=he({multiRNNCell_:Gve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hve(n,e,t,r=!1){const s=j(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ve(s,[1,-1]):s},c={numSamples:e,seed:t,normalized:r},u=ue.runKernel(k2,l,c);return o===1?ve(u,[u.size]):u}const $K=he({multinomial_:Hve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(n,e){let t=j(n,"a","notEqual","string_or_numeric"),r=j(e,"b","notEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(hw,s)}const Zb=he({notEqual_:jve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qve(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:j(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return ue.runKernel(dw,o,a)}const Jb=he({oneHot_:qve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xve(n){const t={x:j(n,"x","onesLike")};return ue.runKernel(fw,t)}const $l=he({onesLike_:Xve});function Kve(n,e){const t=j(n,"v1","outerProduct"),r=j(e,"v2","outerProduct");U(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=ve(t,[-1,1]),i=ve(r,[1,-1]);return Hn(s,i)}const RK=he({outerProduct_:Kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yve(n,e,t=0){const r=j(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:r};return ue.runKernel(mw,i,s)}const wu=he({pad_:Yve});function Zve(n,e,t=0){return U(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),wu(n,[e],t)}const PK=he({pad1d_:Zve});function Jve(n,e,t=0){return U(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const DK=he({pad2d_:Jve});function Qve(n,e,t=0){return U(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const OK=he({pad3d_:Qve});function ewe(n,e,t=0){return U(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const FK=he({pad4d_:ewe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function twe(n,e,t){const r=j(n,"x","spaceToBatchND");U(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),U(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),U(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:t};return ue.runKernel(kw,s,i)}const qM=he({spaceToBatchND_:twe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(n,e,t,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=j(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(Ri(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=ko(l.shape,e,i,s,r),h=[u.dilationHeight,u.dilationWidth];let f;r==="same"?f=swe([u.filterHeight,u.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[p,m]=rwe([u.inHeight,u.inWidth],h,f),g=d?r:"valid",y=d?l:qM(l,h,p),x=(t==="avg"?()=>OM(y,e,i,g,o):()=>jM(y,e,i,g,o))(),w=d?x:FM(x,h,m);return c?ve(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function rwe(n,e,t){const r=t.map(u=>u[0]),s=t.map(u=>u[1]),i=n.concat(r,s),o=e.map((u,h)=>(u-i[h]%u)%u),a=s.map((u,h)=>u+o[h]),l=e.map((u,h)=>[r[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function swe(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const LK=he({pool_:nwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iwe(n,e){const t=j(n,"x","prelu"),r=j(e,"alpha","prelu"),s={x:t,alpha:r};return ue.runKernel(gw,s)}const XM=he({prelu_:iwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function owe(n,e=null,t=!1){let r=j(n,"x","prod");r.dtype==="bool"&&(r=wt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ue.runKernel(yw,s,i)}const zK=he({prod_:owe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(n,e,t,r){const s=n.map((u,h)=>j(u,`tensors${h}`,"raggedGather","int32")),i=j(e,"paramsDenseValues","raggedGather"),o=j(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:i,indices:o},l={outputRaggedRank:r},c=ue.runKernel(TM,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const BK=he({raggedGather_:awe});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lwe(n,e,t){const r=j(n,"starts","raggedRange"),s=j(e,"limits","raggedRange",r.dtype),i=j(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:i},a=ue.runKernel(EM,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const VK=he({raggedRange_:lwe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwe(n,e,t,r,s){const i=j(n,"shape","raggedTensorToTensor","int32"),o=j(e,"values","raggedTensorToTensor"),a=j(t,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((h,f)=>j(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:s};return ue.runKernel(IM,c,u)}const UK=he({raggedTensorToTensor_:cwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uwe(n,e,t){el(n);const r=Te(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<r;i++)s[i]=e();return ue.makeTensor(s,n,t)}const WK=he({rand_:uwe});var bz={exports:{}};bz.exports;(function(n){(function(e,t,r){function s(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new s(l),h=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&i(h,u),f.state=function(){return i(u,{})}),f}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(pt,n,!1)})(bz);var hwe=bz.exports,vz={exports:{}};vz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(pt,n,!1)})(vz);var fwe=vz.exports,wz={exports:{}};wz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(pt,n,!1)})(wz);var dwe=wz.exports,xz={exports:{}};xz.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.x,h=l.i,f,d;return f=u[h],f^=f>>>7,d=f^f<<24,f=u[h+1&7],d^=f^f>>>10,f=u[h+3&7],d^=f^f>>>3,f=u[h+4&7],d^=f^f<<7,f=u[h+7&7],f=f^f<<13,d^=f^f<<9,u[h]=d,l.i=h+1&7,d};function c(u,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],u.x=d,u.i=0,f=256;f>0;--f)u.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.x&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(pt,n,!1)})(xz);var pwe=xz.exports,_z={exports:{}};_z.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.w,h=l.X,f=l.i,d,p;return l.w=u=u+1640531527|0,p=h[f+34&127],d=h[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,p=h[f]=p^d,l.i=f,p+(u^u>>>16)|0};function c(u,h){var f,d,p,m,g,y=[],b=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,b=Math.max(b,h.length)),p=0,m=-32;m<b;++m)h&&(d^=h.charCodeAt((m+32)%h.length)),m===0&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(g=g+1640531527|0,f=y[m&127]^=d+g,p=f==0?p+1:0);for(p>=128&&(y[(h&&h.length||0)&127]=-1),p=127,m=4*128;m>0;--m)d=y[p+34&127],f=y[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,y[p]=d^f;u.w=g,u.X=y,u.i=p}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.X&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(pt,n,!1)})(_z);var mwe=_z.exports,Sz={exports:{}};Sz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.b,f=l.c,d=l.d,p=l.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-d|0,l.d=d<<16^f>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(pt,n,!1)})(Sz);var gwe=Sz.exports,GK={exports:{}};const ywe={},bwe=Object.freeze(Object.defineProperty({__proto__:null,default:ywe},Symbol.toStringTag,{value:"Module"})),HK=Gf(bwe);(function(n){(function(e,t,r){var s=256,i=6,o=52,a="random",l=r.pow(s,i),c=r.pow(2,o),u=c*2,h=s-1,f;function d(w,S,C){var k=[];S=S==!0?{entropy:!0}:S||{};var A=y(g(S.entropy?[w,x(t)]:w??b(),3),k),M=new p(k),E=function(){for(var N=M.g(i),O=l,R=0;N<c;)N=(N+R)*s,O*=s,R=M.g(1);for(;N>=u;)N/=2,O/=2,R>>>=1;return(N+R)/O};return E.int32=function(){return M.g(4)|0},E.quick=function(){return M.g(4)/4294967296},E.double=E,y(x(M.S),t),(S.pass||C||function(N,O,R,D){return D&&(D.S&&m(D,M),N.state=function(){return m(M,{})}),R?(r[a]=N,O):N})(E,A,"global"in S?S.global:this==r,S.state)}function p(w){var S,C=w.length,k=this,A=0,M=k.i=k.j=0,E=k.S=[];for(C||(w=[C++]);A<s;)E[A]=A++;for(A=0;A<s;A++)E[A]=E[M=h&M+w[A%C]+(S=E[A])],E[M]=S;(k.g=function(N){for(var O,R=0,D=k.i,z=k.j,B=k.S;N--;)O=B[D=h&D+1],R=R*s+B[h&(B[D]=B[z=h&z+O])+(B[z]=O)];return k.i=D,k.j=z,R})(s)}function m(w,S){return S.i=w.i,S.j=w.j,S.S=w.S.slice(),S}function g(w,S){var C=[],k=typeof w,A;if(S&&k=="object")for(A in w)try{C.push(g(w[A],S-1))}catch{}return C.length?C:k=="string"?w:w+"\0"}function y(w,S){for(var C=w+"",k,A=0;A<C.length;)S[h&A]=h&(k^=S[h&A]*19)+C.charCodeAt(A++);return x(S)}function b(){try{var w;return f&&(w=f.randomBytes)?w=w(s):(w=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(w)),x(w)}catch{var S=e.navigator,C=S&&S.plugins;return[+new Date,e,C,e.screen,x(t)]}}function x(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),t),n.exports){n.exports=d;try{f=HK}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:pt,[],Math)})(GK);var vwe=GK.exports,wwe=hwe,xwe=fwe,_we=dwe,Swe=pwe,Cwe=mwe,kwe=gwe,zy=vwe;zy.alea=wwe;zy.xor128=xwe;zy.xorwow=_we;zy.xorshift7=Swe;zy.xor4096=Cwe;zy.tychei=kwe;var Rw=zy;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Twe=.001,jK=.1;function Ewe(n,e,t){return t==null&&(t=Cz()),AD(n,e,(r,s)=>kz(r,s,t))}function Cz(){return ue.backend.floatPrecision()===32?Twe:jK}function AD(n,e,t){let r=!0;if((_i(n)||_i(e))&&(r=!1),_i(n)&&_i(e)&&(r=!0),r){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=wh(n),a=wh(e);if(!Rn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const s=_i(n)?n:kc(n),i=_i(e)?e:kc(e);if(s.length!==i.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${i.length}.
Actual:   ${s}.
Expected: ${i}.`);for(let o=0;o<i.length;++o){const a=s[o],l=i[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${s}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function Iwe(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function Awe(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return uu(n)||uu(n[0])||uu(e)||uu(e[0])?AD(n,t,(r,s)=>r==s):AD(n,e,(r,s)=>kz(r,s,0))}function Mwe(n,e,t){if(t==null&&(t=Cz()),!kz(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function kz(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function Nwe(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function $we(n,e){const t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let s=0;s<r.length;s++)if(t[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${t[s]} instead`)}function qK(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?qK(t):n[e]=yu(t)}return n}function Rwe(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function Pwe(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const Dwe=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:jK,createVideoElement:Rwe,encodeStrings:qK,expectArrayBuffersEqual:$we,expectArraysClose:Ewe,expectArraysEqual:Awe,expectNumbersClose:Mwe,expectPromiseToFail:Iwe,expectValuesInRange:Nwe,play:Pwe,testEpsilon:Cz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tz{constructor(e,t,r,s,i){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Rw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Owe{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const i=s||Math.random();this.randu=Rw.alea(i.toString()),this.randn=new Tz(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,i,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class Fwe{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Rw.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(n,e,t=1,r="float32",s){if(el(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const i=new Owe(e,t,r,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const XK=he({randomGamma_:Lwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n,e=0,t=1,r,s){if(el(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new Tz(e,t,r,!1,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const KM=he({randomNormal_:zwe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bwe(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return KM(n,0,1,e,t)}const KK=he({randomStandardNormal_:Bwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(n,e=0,t=1,r="float32",s){el(n);const i=Sn(n,r),o=new Fwe(e,t,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Op=he({randomUniform_:Vwe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(n,e,t,r){return Op(n,e,t,"int32",r)}const YK=he({randomUniformInt_:Uwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fg(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return ue.runKernel(I2,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wwe(n){const t={input:j(n,"input","real")};return ue.runKernel(A2,t)}const Qb=he({real_:Wwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(n){const t={x:j(n,"x","reciprocal")};return ue.runKernel(by,t)}const ZK=he({reciprocal_:Gwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hwe(n){const t={x:j(n,"x","relu")};return ue.runKernel(vy,t)}const Fh=he({relu_:Hwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(n){const t={x:j(n,"x","relu6")};return ue.runKernel(wy,t)}const Ez=he({relu6_:jwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qwe(n,e){const r={x:j(n,"x","reverse")},s={dims:e};return ue.runKernel(xw,r,s)}const Tc=he({reverse_:qwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xwe(n){const e=j(n,"x","reverse");return U(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Tc(e,0)}const JK=he({reverse1d_:Xwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kwe(n,e){const t=j(n,"x","reverse");return U(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Tc(t,e)}const QK=he({reverse2d_:Kwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywe(n,e){const t=j(n,"x","reverse");return U(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Tc(t,e)}const eY=he({reverse3d_:Ywe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zwe(n,e){const t=j(n,"x","reverse");return U(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Tc(t,e)}const tY=he({reverse4d_:Zwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jwe(n){const t={x:j(n,"x","round")};return ue.runKernel(xy,t)}const Iz=he({round_:Jwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qwe(n){const t={x:j(n,"x","rsqrt","float32")};return ue.runKernel(_y,t)}const Az=he({rsqrt_:Qwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(n){const t={x:j(n,"x","selu")};return ue.runKernel(Sy,t)}const Mz=he({selu_:exe});function txe(n,e,t,r,s,i=[1,1],o="NHWC"){const a=j(n,"x","separableConv2d"),l=j(e,"depthwiseFilter","separableConv2d"),c=j(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),U(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),U(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],d=l.shape[3];U(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);const p=Z2(u,l,r,s,o,i),g=cp(p,c,1,"valid",o);return h?ve(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Nz=he({separableConv2d_:txe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nxe(n,e){const t=j(n,"x","setdiff1d"),r=j(e,"y","setdiff1d");U(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),U(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),U(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),i=await r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new li([a],t.dtype),c=new li([a],"int32");for(let u=0,h=0;u<s.length;u++)o.has(s[u])||(l.values[h]=s[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const nY=nxe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(n){const t={x:j(n,"x","sign")};return ue.runKernel(Ty,t)}const rY=he({sign_:rxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(n){const t={x:j(n,"x","sin","float32")};return ue.runKernel(Cy,t)}const $z=he({sin_:sxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe(n){const t={x:j(n,"x","sinh")};return ue.runKernel(ky,t)}const Rz=he({sinh_:ixe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n,e,t){const r=j(n,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),dn(r,[e],[t])}const rC=he({slice1d_:oxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axe(n,e,t){const r=j(n,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const YM=he({slice2d_:axe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe(n,e,t){const r=j(n,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const sC=he({slice3d_:lxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cxe(n,e,t){const r=j(n,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const ev=he({slice4d_:cxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(n,e=-1){const t=j(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return ue.runKernel(Ew,r,s)}const iC=he({softmax_:uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hxe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(p2,e)}const ZM=he({fft_:hxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(b2,e)}const A_=he({ifft_:fxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=ve(n,[t,e]);r=A_(s)}else{const s=[t,2*(e-1)],i=ve(Qb(n),[t,e]),o=ve(tC(n),[t,e]),a=Tc(dn(i,[0,1],[t,e-2]),1),l=fe(Tc(dn(o,[0,1],[t,e-2]),1),en(-1)),c=cs([i,a],1),u=cs([o,l],1),h=ve(Of(c,u),[s[0],s[1]]);r=A_(h)}if(r=Qb(r),n.rank===3&&n.shape[0]!==0){const s=r,i=n.shape[0];r=ve(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const Pz=he({irfft_:dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(n,e,t=0){const s={x:j(n,"x","split")},i={numOrSizeSplits:e,axis:t};return ue.runKernel(Tw,s,i)}const qa=he({split_:pxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mxe(n,e){U(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,s=dn(n,p,m),t=e}else if(e!=null&&e>t){const p=n.shape.map(m=>m);p[n.shape.length-1]=e-t,s=cs([n,ms(p)],n.shape.length-1),t=e}else s=n;const i=lr(s),o=ve(Of(s,i),[r,t]),a=ZM(o),l=Math.floor(t/2)+1,c=Qb(a),u=tC(a),h=qa(c,[l,t-l],c.shape.length-1),f=qa(u,[l,t-l],u.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=l,ve(Of(h[0],f[0]),d)}const JM=he({rfft_:mxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gxe(n,e){let t=j(n,"a","squaredDifference"),r=j(e,"b","squaredDifference");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r},i={};return ue.runKernel(My,s,i)}const Dz=he({squaredDifference_:gxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxe(n,e){const t=j(n,"x","squeeze","string_or_numeric");return ve(t,Wf(t.shape,e).newShape)}const vr=he({squeeze_:yxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(n,e=0){const t=S_(n,"tensors","stack","string_or_numeric");U(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&U(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return ue.runKernel(pw,r,s)}const _a=he({stack_:bxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(n,e=0){const r={x:j(n,"x","step")},s={alpha:e};return ue.runKernel(Dy,r,s)}const Pw=he({step_:vxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wxe(n,e,t,r,s=0,i=0,o=0,a=0,l=0){const u={x:j(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ue.runKernel(B2,u,h)}const sY=he({stridedSlice_:wxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(n){const t={x:j(n,"x","tan","float32")};return ue.runKernel($y,t)}const iY=he({tan_:xxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n,e){zg(n);const t=wh(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Rp(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n,e,t){if(zg(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=wh(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Rp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oz(n,e,t){if(zg(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=wh(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Rp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(n,e,t){if(zg(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=wh(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Rp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(n,e,t){if(zg(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=wh(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Rp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(n,e,t){if(zg(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=wh(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Rp(n,e,r,t)}function Fz(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(i+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(i+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function QM(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Fz(t,e,n)}function zu(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=t.length;let o=1;for(let h=s;h<i;++h)o*=t[h];const a=s<1?1:s,l=Te(e.shape)/a,c=[...Jt(t.slice(0,s)),1],u=Te(t);return{sliceRank:s,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const _xe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:zu,validateInput:QM,validateUpdateShape:Fz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sxe(n,e,t){const r=j(n,"tensor","tensorScatterupdate"),s=j(e,"indices","tensorScatterupdate","int32"),i=j(t,"updates","tensorScatterupdate");if(QM(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);const o={tensor:r,indices:s,updates:i},a={};return ue.runKernel(R2,o,a)}const cY=he({tensorScatterUpdate_:Sxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxe(n,e=1,t=!0){const r=j(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:t},[a,l]=ue.runKernel(U2,i,o);return{values:a,indices:l}}const uY=he({topk_:Cxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kxe(n,e=0,t=1,r,s){if(el(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new Tz(e,t,r,!0,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const eN=he({truncatedNormal_:kxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(n,e=0){const t=j(n,"x","unique","string_or_numeric");U(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[i,o]=ue.runKernel(RM,r,s);return{values:i,indices:o}}const hY=he({unique_:Txe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Exe(n,e,t){const r=j(n,"x","unsortedSegmentSum"),s=j(e,"segmentIds","unsortedSegmentSum","int32");U(og(t),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:t};return ue.runKernel(Aw,i,o)}const Lz=he({unsortedSegmentSum_:Exe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixe(n,e=0){const t=j(n,"x","unstack","string_or_numeric");U(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return ue.runKernel(Iw,r,s)}const Ec=he({unstack_:Ixe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fY(n,e){return HM(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(n,e=!0,t,r){return ue.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const r=Sn(n,"int32"),s=Sn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=r.indexToLoc(t[i]),a=i*n.length;s.values.set(o,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Axe(n){const e=j(n,"condition","whereAsync","bool"),t=await e.data(),r=tN(e.shape,t);return n!==e&&e.dispose(),r}const Bz=Axe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Mxe(n,e,t){const r=j(n,"tensor","boolMask"),s=j(e,"mask","boolMask","bool"),i=t??0,o=s.rank,a=r.shape;U(o>0,()=>"mask cannot be scalar"),qi(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=ve(r,c),h=ve(s,[-1]),f=await Bz(h),d=vr(f,[1]),p=eC(u,d,i);return n!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),u.dispose(),h.dispose(),f.dispose(),p}const dY=Mxe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n,e,t){const r=j(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),U(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{U(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?Se(()=>{let o=Qb(r),a=tC(r);return o=ue.runKernel(jd,{x:o},i),a=ue.runKernel(jd,{x:a},i),t&&(a=us(a)),Of(o,a)}):ue.runKernel(jd,s,i)}const rr=he({transpose_:Nxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(n,e,t,r,s=!0){const i=j(n,"v","movingAverage"),o=j(e,"x","movingAverage"),a=j(t,"decay","movingAverage");RX(i,o),U(Rn(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=en(1),c=Dt(l,a);let u=fe(Dt(o,i),c);if(s){U(r!=null,()=>"When using zeroDebias: true, step is required.");const h=j(r,"step","movingAverage");u=Lt(u,Dt(l,up(a,h)))}return qe(i,u)}const pY=he({movingAverage_:$xe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(n,e,t){el(t);const r=j(n,"indices","scatterND","int32"),s=j(e,"updates","scatterND");QM(s,r,t);const i={indices:r,updates:s},o={shape:t};return ue.runKernel($2,i,o)}const mY=he({scatterND_:Rxe});function Pxe(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(n,e,t,r=0){el(t);const s=j(n,"sparseIndices","sparseToDense","int32"),i=j(e,"sparseValues","sparseToDense","string_or_numeric"),o=j(r,"defaultValue","sparseToDense",i.dtype);Pxe(s,i,t,o);const a={sparseIndices:s,sparseValues:i,defaultValue:o},l={outputShape:t};return ue.runKernel(F2,a,l)}const gY=he({sparseToDense_:Dxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(n,e){const t=j(e,"indices","gatherND","int32"),s={params:j(n,"x","gatherND","string_or_numeric"),indices:t};return ue.runKernel(y2,s)}const yY=he({gatherND_:Oxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fxe(n,e){if(e==null)return n.shape.slice();if(Rn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lxe(n,e,t,r){const s=j(n,"x","dropout");if(U(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),U(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof jn?s.clone():s;const i=Fxe(s,t),o=1-e,a=Lt(Q2(qe(Op(i,0,1,"float32",r),o)),o);return fe(s,a)}const Vz=he({dropout_:Lxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function nN(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=e-t*Math.cos(o)}return Ks(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function zxe(n,e,t=1){const r=j(n,"predictions","inTopK"),s=j(e,"targets","inTopK");U(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),U(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),qi(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];U(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await r.data(),a=await s.data(),[l,c]=[o.length/i,i],u=ci("bool",l);for(let h=0;h<l;h++){const f=h*c,d=o.subarray(f,f+c),p=[];for(let m=0;m<d.length;m++)p.push({value:d[m],index:m});p.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<t;m++)if(p[m].index===a[h]){u[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),Ei(u,s.shape,"bool")}const bY=zxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(n,e,t,r,s,i="NHWC",o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]])),U(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),U(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),U(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],u=i==="NHWC"?l.shape[3]:l.shape[1];U(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),U(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),na("conv2dDerFilter",s,o);const h={x:a,dy:l},f={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:t};return ue.runKernel(t2,h,f)}const Wz=he({conv2DBackpropFilter_:Bxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return fe(n,Pw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function sN(n,e){let t=e;const r=ui(n.shape,e.shape);return r.length>0&&(t=Yt(t,r)),ve(t,n.shape)}function iN(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Fh(n);if(e==="elu")return J2(n);if(e==="relu6")return Ez(n);if(e==="prelu")return XM(n,t);if(e==="leakyrelu")return BM(n,r);if(e==="sigmoid")return El(n);throw new Error(`Unknown fused activation ${e}.`)}const oN=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",oN(ue.state.gradientDepth,l)===!1){U(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=cp(n,e,t,r,s,i,o);return a!=null&&(C=qe(C,a)),iN(C,l,c,u)}const h=j(n,"x","conv2d","float32"),f=j(e,"filter","conv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),na("fused conv2d",r,o);const m=s==="NHWC"?d.shape[3]:d.shape[1];U(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),U(Ri(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const g=ts(d.shape,f.shape,t,i,r,o);let y;a!=null&&(y=j(a,"bias","fused conv2d"),[y]=ks(y,h),s==="NHWC"?ln(g.outShape,y.shape):(U(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),U(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(c!=null){const C=c.shape;if(U(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)U(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{ln(C,g.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(A)}b=j(c,"prelu weights","fused conv2d")}const x=(C,k)=>{U(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[A,M,E,N]=k,O=rN(C,E,l);U(lp(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const R=az(M.shape,O,A,t,r),D=Wz(M,O,A.shape,t,r),z=[R,D];if(N!=null){const B=sN(N,O);z.push(B)}return z},w={x:d,filter:f,bias:y,preluActivationWeights:b},S={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((k,A,M)=>{let E=ue.runKernel(jb,w,S);return M([A,k,E]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(d,f):xh((k,A,M,E)=>{let N=ue.runKernel(jb,w,S);return E([A,k,N,M]),p&&(N=ve(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:x}})(d,f,y)}const vY=he({fusedConv2d_:Vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uxe(n,e,t,r,s,i=[1,1],o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:t};return ue.runKernel(l2,c,u)}const wY=he({depthwiseConv2dNativeBackpropFilter_:Uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wxe(n,e,t,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n},h=ue.runKernel(c2,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const xY=he({depthwiseConv2dNativeBackpropInput_:Wxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(oN(ue.state.gradientDepth,l)===!1){let S=Z2(n,e,t,r,s,i,o);return a!=null&&(S=qe(S,a)),iN(S,l,c,u)}const h=j(n,"x","depthwiseConv2d","float32"),f=j(e,"filter","depthwiseConv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),U(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),i==null&&(i=[1,1]),U(Ri(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),na("fused depthwiseConv2d",r,o);const m=ts(d.shape,f.shape,t,i,r,o,!0);let g;a!=null&&(g=j(a,"bias","fused conv2d"),[g]=ks(g,h),ln(m.outShape,g.shape));let y;c!=null&&(y=j(c,"prelu weights","fused depthwiseConv2d"));const b=(S,C)=>{U(lp(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[k,A,M,E]=C,N=rN(S,M,l),O=xY(A.shape,N,k,t,r,i,o),R=wY(A,N,k.shape,t,r,i,o);if(E!=null){const D=sN(g,N);return[O,R,D]}return[O,R]},x={x:d,filter:f,bias:g,preluActivationWeights:y},w={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((C,k,A)=>{let M=ue.runKernel(qb,x,w);return A([k,C,M]),p&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(d,f):xh((C,k,A,M)=>{let E=ue.runKernel(qb,x,w);return M([k,C,E,A]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(d,f,g)}const Hxe=he({fusedDepthwiseConv2d_:Gxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jxe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(oN(ue.state.gradientDepth,i)===!1){let N=Hn(n,e,t,r);return s!=null&&(N=qe(N,s)),iN(N,i,o,a)}let l=j(n,"a","fused matMul"),c=j(e,"b","fused matMul");[l,c]=ks(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=Te(p),y=Te(m);U(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${r} must match.`);const x=ln(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),w=t?ve(l,[g,u,f]):ve(l,[g,f,u]),S=r?ve(c,[y,d,h]):ve(c,[y,h,d]);let C;s!=null&&(C=j(s,"bias","fused matMul"),[C]=ks(C,l),ln(x,C.shape));let k;o!=null&&(k=j(o,"prelu weights","fused matMul"));const A=(N,O)=>{const[R,D,z,B]=O,X=rN(ve(N,z.shape),z,i);let G,te;if(!t&&!r?(G=Hn(X,D,!1,!0),te=Hn(R,X,!0,!1)):!t&&r?(G=Hn(X,D,!1,!1),te=Hn(X,R,!0,!1)):t&&!r?(G=Hn(D,X,!1,!0),te=Hn(R,X,!1,!1)):(G=Hn(D,X,!0,!0),te=Hn(X,R,!0,!0)),s!=null){const ge=sN(B,X);return[G,te,ge]}else return[G,te]},M={a:w,b:S,bias:C,preluActivationWeights:k},E={transposeA:t,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?xh((O,R,D)=>{const z=ue.runKernel(Hb,M,E);return D([O,R,z]),{value:ve(z,x),gradFunc:A}})(w,S):xh((O,R,D,z)=>{const B=ue.runKernel(Hb,M,E);return z([O,R,B,D]),{value:ve(B,x),gradFunc:A}})(w,S,C)}const MD=he({fusedMatMul_:jxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Y=Object.freeze(Object.defineProperty({__proto__:null,conv2d:vY,depthwiseConv2d:Hxe,matMul:MD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qxe(n){return nN(n,.54,.46)}const Xxe=he({hammingWindow_:qxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(n){return nN(n,.5,.5)}const SY=he({hannWindow_:Kxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yxe(n,e,t,r=!1,s=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(dn(n,i,e)),i+=t;if(r)for(;i<n.size;){const a=i+e-n.size,l=cs([dn(n,i,e-a),Fy([a],s)]);o.push(l),i+=t}return o.length===0?Xa([],[0,e]):ve(cs(o),[o.length,e])}const CY=he({frame_:Yxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zxe(n,e,t,r,s=SY){r==null&&(r=Uz(e));const i=CY(n,e,t),o=fe(i,s(e));return JM(o,r)}const Jxe=he({stft_:Zxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxe(n,e,t,r,s="bilinear",i=0){const o=j(n,"image","cropAndResize"),a=j(e,"boxes","cropAndResize","float32"),l=j(t,"boxInd","cropAndResize","int32"),c=a.shape[0];U(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),U(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const u={image:o,boxes:a,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return ue.runKernel(i2,u,h)}const e1e=he({cropAndResize_:Qxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1e(n){const e=j(n,"image","flipLeftRight","float32");U(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ue.runKernel(g2,t,{})}const n1e=he({flipLeftRight_:t1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r1e(n){const e=j(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,pc(e,s)}const s1e=he({grayscaleToRGB_:r1e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1e(n){const e=j(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),U(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=wt(e,"float32"),o=Ks([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Om("ij,j->i",i,o);break;case 3:a=Om("ijk,k->ij",i,o);break;case 4:a=Om("ijkl,l->ijk",i,o);break;case 5:a=Om("ijklm,m->ijkl",i,o);break;case 6:a=Om("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=oi(a,-1),wt(a,s)}const o1e=he({rgbToGrayscale_:i1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1e(n,e,t=0,r=.5){const s=j(n,"image","rotateWithOffset","float32");U(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:t,center:r};return ue.runKernel(G2,i,o)}const l1e=he({rotateWithOffset_:a1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n,e,t,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),U(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),U(e.rank===1,()=>"scores must be a 1D tensor"),U(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),U(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppression","float32"),o=j(e,"scores","nonMaxSuppression","float32"),a=Dw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return ue.runKernel(T2,{boxes:i,scores:o},l)}const u1e=he({nonMaxSuppression_:c1e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1e(n,e,t){const r=f1e(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function f1e(n,e,t){return p1e(n,e,t||d1e)}function d1e(n,e){return n>e?1:n<e?-1:0}function p1e(n,e,t){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=t(e,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oC(n,e,t,r,s){return Gz(n,e,t,r,s,0)}function aN(n,e,t,r,s,i){return Gz(n,e,t,r,s,0,!1,i,!0)}function aC(n,e,t,r,s,i){return Gz(n,e,t,r,s,i,!0)}function Gz(n,e,t,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>s&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(pG);const u=i>0?-.5/i:0,h=[],f=[];for(;h.length<t&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let w=!1;for(let S=h.length-1;S>=x;--S){const C=m1e(n,b,h[S]);if(C>=r){w=!0;break}if(g.score=g.score*g1e(r,u,C),g.score<=s)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(b),f.push(g.score)):g.score>s&&h1e(c,g,pG))}const d=h.length,p=t-d;a&&p>0&&(h.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=f),l&&(m.validOutputs=d),m}function m1e(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),d=(a-i)*(l-o),p=(h-c)*(f-u);if(d<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,f),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(d+p-x)}function g1e(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function pG(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function y1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppressionAsync"),o=j(e,"scores","nonMaxSuppressionAsync"),a=Dw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=oC(c,u,t,r,s);return i!==n&&i.dispose(),o!==e&&o.dispose(),Ks(h,"int32")}const b1e=y1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Dw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},h=ue.runKernel(E2,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const w1e=he({nonMaxSuppressionWithScore_:v1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function x1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Dw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:f,selectedScores:d}=aC(u,h,t,r,s,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Ks(f,"int32"),selectedScores:Ks(d)}}const _1e=x1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Dw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},d={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},p=ue.runKernel(kM,f,d);return{selectedIndices:p[0],validOutputs:p[1]}}const C1e=he({nonMaxSuppressionPadded_:S1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function k1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Dw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[f,d]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=aN(f,d,c,u,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Ks(p,"int32"),validOutputs:en(m,"int32")}}const T1e=k1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(n,e,t=!1,r=!1){const s=j(n,"images","resizeBilinear");U(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),U(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(ww,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const I1e=he({resizeBilinear_:E1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(n,e,t=!1,r=!1){const s=j(n,"images","resizeNearestNeighbor");U(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),U(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(vw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const M1e=he({resizeNearestNeighbor_:A1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(n,e="binary",t=!1,r=.5){const s=j(n,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let c=fe(Ks([r]),255),u,h,f,d;if(U(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),U(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),U(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),U(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[u,h,f]=qa(s,[1,1,1],-1);const g=fe(u,i),y=fe(h,o),b=fe(f,a);d=qe(qe(g,y),b)}else d=n;if(e==="otsu"){const g=tz(wt(Iz(d),"int32"),Ei([]),256);c=$1e(g,l)}const p=t?Ly(d,c):rl(d,c);return wt(fe(p,255),"int32")}function $1e(n,e){let t=Ks([-1]),r=Ks([0]),s=Ks([0]),i,o,a,l,c,u;for(let h=0;h<n.size-1;h++){i=dn(n,0,h+1),o=dn(n,h+1),c=Lt(Yt(i),e),u=Lt(Yt(o),e);const f=Yt(fe(i,fg(0,i.size)));a=Lt(f,Yt(i));const d=Fy(o.shape,i.size),p=qe(fg(0,o.size),d),m=fe(o,p);l=Lt(Yt(m),Yt(o));const g=Dt(a,l),y=Dt(a,l),b=fe(c,u);s=fe(fe(b,g),y);const x=rl(s,r);r=_o(x,s,r),t=_o(x,Ks([h]),t)}return t}const R1e=he({threshold_:N1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1e(n,e,t="nearest",r="constant",s=0,i){const o=j(n,"image","transform","float32"),a=j(e,"transforms","transform","float32");U(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:r,fillValue:s,outputShape:i};return ue.runKernel(W2,l,c)}const D1e=he({transform_:P1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1e(n,e,t){const r=j(n,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(U(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),U(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=j(e<0?i:e,"numLower","bandPart")):(U(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=_o(I_(e,0),i,hp(e,i))),typeof t=="number"?(U(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),U(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=j(t<0?o:t,"numUpper","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=_o(I_(t,0),o,hp(t,o)));const c=ve(fg(0,i,1,"int32"),[-1,1]),u=fg(0,o,1,"int32"),h=Dt(c,u),f=_h(Ly(h,a),Dp(h,us(l))),d=ms([i,o],r.dtype);return ve(_a(Ec(ve(r,[-1,i,o])).map(p=>_o(f,p,d))),s)}const F1e=he({bandPart_:O1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1e(n){let e;if(Array.isArray(n)){e=!1,U(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)U(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else e=!0,n=qa(n,n.shape[0],0).map(s=>vr(s,[0]));U(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(ue.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=fe(Yt(fe(t[o],i)),t[o]);i=Dt(i,a)}return Lt(i,Nw(i,"euclidean"))}));return e?_a(t,0):t}const z1e=he({gramSchmidt_:L1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1e(n,e=!1){if(U(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return mG(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Ec(ve(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[c,u]=mG(l,e);s.push(c),i.push(u)});const o=ve(_a(s,0),n.shape),a=ve(_a(i,0),n.shape);return[o,a]}}function mG(n,e=!1){return ue.tidy(()=>{U(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=zM(t),i=mh(n);const o=Xa([[1]],[1,1]);let a=mh(o);const l=t>=r?r:t;for(let c=0;c<l;++c){const u=i,h=a,f=s;[a,i,s]=ue.tidy(()=>{const d=dn(i,[c,c],[t-c,1]),p=Nw(d),m=dn(i,[c,c],[1,1]),g=_o(rl(m,0),Xa([[-1]]),Xa([[1]])),y=Dt(m,fe(g,p)),b=Lt(d,y);b.shape[0]===1?a=mh(o):a=cs([o,dn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=us(Lt(Hn(g,y),p)),w=dn(i,[c,0],[t-c,r]),S=fe(x,a),C=rr(a);if(c===0)i=Dt(w,Hn(S,Hn(C,w)));else{const M=Dt(w,Hn(S,Hn(C,w)));i=cs([dn(i,[0,0],[c,r]),M],0)}const k=rr(S),A=dn(s,[0,c],[t,s.shape[1]-c]);if(c===0)s=Dt(A,Hn(Hn(A,a),k));else{const M=Dt(A,Hn(Hn(A,a),k));s=cs([dn(s,[0,0],[t,c]),M],1)}return[a,i,s]}),nn([u,h,f])}return!e&&t>r&&(s=dn(s,[0,0],[t,r]),i=dn(i,[0,0],[r,r])),[s,i]})}const V1e=he({qr_:B1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Uo;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Uo||(Uo={}));function U1e(n,e,t=Uo.SUM_BY_NONZERO_WEIGHTS){const r=j(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=j(e,"weights","computeWeightedLoss"));const i=s==null?r:fe(r,s);if(t===Uo.NONE)return i;if(t===Uo.SUM)return Yt(i);if(t===Uo.MEAN){if(s==null)return Ds(i);{const o=r.size/s.size,a=Lt(Yt(i),Yt(s));return o>1?Lt(a,en(o)):a}}if(t===Uo.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Lt(Yt(i),en(r.size));{const o=fe(s,ma(r.shape)),a=wt(Yt(Zb(o,en(0))),"float32");return Lt(Yt(i),a)}}throw Error(`Unknown reduction: ${t}`)}const qf=he({computeWeightedLoss_:U1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","absoluteDifference"),i=j(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=j(t,"weights","absoluteDifference")),qi(s.shape,i.shape,"Error in absoluteDifference: ");const a=wi(Dt(s,i));return qf(a,o,r)}const G1e=he({absoluteDifference_:W1e});function H1e(n,e,t,r,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","cosineDistance"),o=j(e,"predictions","cosineDistance");let a=null;r!=null&&(a=j(r,"weights","cosineDistance")),qi(i.shape,o.shape,"Error in cosineDistance: ");const l=en(1),c=Dt(l,Yt(fe(i,o),t,!0));return qf(c,a,s)}const j1e=he({cosineDistance_:H1e});function q1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){let s=j(n,"labels","hingeLoss");const i=j(e,"predictions","hingeLoss");let o=null;t!=null&&(o=j(t,"weights","hingeLoss")),qi(s.shape,i.shape,"Error in hingeLoss: ");const a=en(1);s=Dt(fe(en(2),s),a);const l=Fh(Dt(a,fe(s,i)));return qf(l,o,r)}const X1e=he({hingeLoss_:q1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1e(n,e,t,r=1,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","huberLoss"),o=j(e,"predictions","huberLoss");let a=null;t!=null&&(a=j(t,"weights","huberLoss")),qi(i.shape,o.shape,"Error in huberLoss: ");const l=en(r),c=wi(Dt(o,i)),u=hp(c,l),h=Dt(c,u),f=qe(fe(en(.5),Or(u)),fe(l,h));return qf(f,a,s)}const Y1e=he({huberLoss_:K1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1e(n,e,t,r=1e-7,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","logLoss"),o=j(e,"predictions","logLoss");let a=null;t!=null&&(a=j(t,"weights","logLoss")),qi(i.shape,o.shape,"Error in logLoss: ");const l=en(1),c=en(r),u=us(fe(i,Nl(qe(o,c)))),h=fe(Dt(l,i),Nl(qe(Dt(l,o),c))),f=Dt(u,h);return qf(f,a,s)}const J1e=he({logLoss_:Z1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","meanSquaredError"),i=j(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=j(t,"weights","meanSquaredError")),qi(s.shape,i.shape,"Error in meanSquaredError: ");const a=Dz(s,i);return qf(a,o,r)}const e_e=he({meanSquaredError_:Q1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_e(n,e){const t=j(n,"labels","sigmoidCrossEntropyWithLogits"),r=j(e,"logits","sigmoidCrossEntropyWithLogits");qi(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Fh(r),i=fe(r,t),o=VM(Yo(us(wi(r))));return qe(Dt(s,i),o)}function n_e(n,e,t,r=0,s=Uo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"multiClassLabels","sigmoidCrossEntropy");const o=j(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","sigmoidCrossEntropy")),qi(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(.5);i=qe(fe(i,Dt(u,c)),fe(h,c))}const l=t_e(i,o);return qf(l,a,s)}const r_e=he({sigmoidCrossEntropy_:n_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_e(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return xh((s,i,o)=>{const l=WM(i,[t],!0),c=Dt(wt(i,"float32"),l);o([s,c]);const u=us(fe(c,s));return{value:Yt(u,[t]),gradFunc:(d,p)=>{const[m,g]=p,y=Ls(d.shape,[t]);return[fe(ve(d,y),Dt(wt(m,"float32"),Yo(g))),fe(ve(d,y),Dt(Yo(g),wt(m,"float32")))]}}})(n,e)}function i_e(n,e,t,r=0,s=Uo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"onehotLabels","softmaxCrossEntropy");const o=j(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","softmaxCrossEntropy")),qi(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(i.shape[1]);i=qe(fe(i,Dt(u,c)),Lt(c,h))}const l=s_e(i,o);return qf(l,a,s)}const o_e=he({softmaxCrossEntropy_:i_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_e(n,e,t,r){const s=j(n,"indices","sparseFillEmptyRows","int32"),i=j(e,"values","sparseFillEmptyRows"),o=j(t,"denseShape","sparseFillEmptyRows","int32"),a=j(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:i,denseShape:o,defaultValue:a},c=ue.runKernel(AM,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const l_e=he({sparseFillEmptyRows_:a_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_e(n,e,t){const r=j(n,"inputIndices","sparseReshape","int32"),s=j(e,"inputShape","sparseReshape","int32"),i=j(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:r,inputShape:s,newShape:i},a=ue.runKernel(MM,o);return{outputIndices:a[0],outputShape:a[1]}}const u_e=he({sparseReshape_:c_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_e(n,e,t){const r=j(n,"data","sparseSegmentMean"),s=j(e,"indices","sparseSegmentMean","int32"),i=j(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ue.runKernel(D2,o)}const f_e=he({sparseSegmentMean_:h_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_e(n,e,t){const r=j(n,"data","sparseSegmentSum"),s=j(e,"indices","sparseSegmentSum","int32"),i=j(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ue.runKernel(O2,o)}const p_e=he({sparseSegmentSum_:d_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_e(n,e,t,r,s,i,o,a){const l=j(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=j(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},f=ue.runKernel(V2,h,u);return{nGrams:f[0],nGramsSplits:f[1]}}const g_e=he({stringNGrams_:m_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_e(n,e,t=!0){const r=j(n,"input","stringSplit","string"),s=j(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:t},o={input:r,delimiter:s},a=ue.runKernel(NM,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const b_e=he({stringSplit_:y_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_e(n,e){const t=j(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return ue.runKernel($M,s,r)}const w_e=he({stringToHashBucketFast_:v_e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_e(n,e,t,r=!0){const s=j(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:r};return ue.runKernel(z2,{x:s},i)}const __e=he({staticRegexReplace_:x_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kY={fft:ZM,ifft:A_,rfft:JM,irfft:Pz},TY={hammingWindow:Xxe,hannWindow:SY,frame:CY,stft:Jxe},Ci={flipLeftRight:n1e,grayscaleToRGB:s1e,resizeNearestNeighbor:M1e,resizeBilinear:I1e,rgbToGrayscale:o1e,rotateWithOffset:l1e,cropAndResize:e1e,nonMaxSuppression:u1e,nonMaxSuppressionAsync:b1e,nonMaxSuppressionWithScore:w1e,nonMaxSuppressionWithScoreAsync:_1e,nonMaxSuppressionPadded:C1e,nonMaxSuppressionPaddedAsync:T1e,threshold:R1e,transform:D1e},Hz={bandPart:F1e,gramSchmidt:z1e,qr:V1e},EY={absoluteDifference:G1e,computeWeightedLoss:qf,cosineDistance:j1e,hingeLoss:X1e,huberLoss:Y1e,logLoss:J1e,meanSquaredError:e_e,sigmoidCrossEntropy:r_e,softmaxCrossEntropy:o_e},IY={sparseFillEmptyRows:l_e,sparseReshape:u_e,sparseSegmentMean:f_e,sparseSegmentSum:p_e},AY={stringNGrams:g_e,stringSplit:b_e,stringToHashBucketFast:w_e,staticRegexReplace:__e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S_e=new Map,ND=new Map;class By{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class xl{constructor(){this.classNameMap={}}static getMap(){return xl.instance==null&&(xl.instance=new xl),xl.instance}static register(e){xl.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ot(n,e,t){U(n.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),U(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return xl.register(n),S_e.set(s,n),ND.set(n,s),n}function C_e(n){return ND.has(n)?ND.get(n):n.className}const k_e=Object.freeze(Object.defineProperty({__proto__:null,Serializable:By,SerializationMap:xl,getRegisteredName:C_e,registerClass:ot},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xf extends By{minimize(e,t=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return nn(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return CK(e,t)}dispose(){this.iterations_!=null&&nn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:en(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Xf,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jz extends Xf{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Se(()=>lr(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;Se(()=>{const u=qe(fe(l,this.rho),fe(Or(a),1-this.rho)),h=fe(Lt(So(qe(c,this.epsilon)),So(qe(l,this.epsilon))),a),f=qe(fe(c,this.rho),fe(Or(h),1-this.rho));l.assign(u),c.assign(f);const d=qe(fe(h,-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nn(this.accumulatedGrads.map(e=>e.variable)),nn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz extends Xf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Se(()=>Fy(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;Se(()=>{const l=qe(a,Or(o));a.assign(l);const c=qe(fe(Lt(o,So(qe(l,ue.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xz extends Xf{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=en(t).variable(),this.accBeta2=en(r).variable()}),s==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),s=Dt(1,this.accBeta2);t.forEach((i,o)=>{const a=ue.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Se(()=>lr(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:Se(()=>lr(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=qe(fe(h,this.beta2),fe(Or(c),1-this.beta2)),p=Lt(f,r),m=Lt(d,s);u.assign(f),h.assign(d);const g=qe(fe(Lt(p,qe(So(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Se(()=>{this.accBeta1.assign(up(this.beta1,this.iterations_+1)),this.accBeta2.assign(up(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kz extends Xf{static get className(){return"Adamax"}constructor(e,t,r,s=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=en(0).variable(),this.accBeta1=en(t).variable()}),s==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),s=Lt(-this.learningRate,qe(fe(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=ue.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:lr(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:lr(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=fe(h,this.beta2),p=wi(c),m=jf(d,p);u.assign(f),h.assign(m);const g=qe(fe(Lt(s,r),Lt(f,qe(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(qe(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lN extends Xf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=ue.registeredVariables[r];Se(()=>{const a=qe(fe(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Xs(en(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yz extends lN{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=en(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Se(()=>lr(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&Se(()=>{let l;const c=qe(fe(this.m,o),a);this.useNesterov?l=qe(fe(this.c,qe(a,fe(c,this.m))),i):l=qe(fe(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zz extends Xf{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=ue.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Se(()=>lr(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;Se(()=>{const u=qe(fe(l,this.decay),fe(Or(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,f=qe(fe(h,this.decay),fe(a,1-this.decay)),d=Lt(fe(a,this.learningRate),So(Dt(u,qe(Or(f),this.epsilon)))),p=qe(fe(c,this.momentum),d);l.assign(u),h.assign(f),c.assign(p);const m=Dt(i,p);i.assign(m)}else{const h=qe(fe(l,this.decay),fe(Or(a),1-this.decay)),f=qe(fe(c,this.momentum),Lt(fe(a,this.learningRate),So(qe(h,this.epsilon))));l.assign(h),c.assign(f);const d=Dt(i,f);i.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T_e=[jz,qz,Xz,Kz,Yz,Zz,lN];function E_e(){for(const n of T_e)ot(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_e="model",A_e=".json",M_e=".weights.bin";function gG(n){return new Promise(e=>setTimeout(e)).then(n)}class dg{constructor(e){if(!Ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(dg.URL_SCHEME)&&(e=e.slice(dg.URL_SCHEME.length)),(e==null||e.length===0)&&(e=I_e),this.modelJsonFileName=e+A_e,this.weightDataFileName=e+M_e}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Fu.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=LX(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await gG(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await gG(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:X2(e)}}}}dg.URL_SCHEME="downloads://";class N_e{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=WL(i,c=>this.loadWeights(c));e(l)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;r(a)},i.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(i=>dG(i.name)),s={};for(const i of e)i.paths.forEach(o=>{const a=dG(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const $_e=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(dg.URL_SCHEME)?R_e(n.slice(dg.URL_SCHEME.length)):null;_s.registerSaveRouter($_e);function R_e(n="model"){return new dg(n)}function MY(n){return new N_e(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(n,e,t,r){o(n),t=t??0,r=r??1,a(t,r);let s=0;const i=l=>(l.then(c=>{const u=t+ ++s/n.length*(r-t);return e(u),c}),l);function o(l){U(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){U(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),U(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),U(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function NY(n,e){e==null&&(e={});const t=e.fetchFunc==null?Ee().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,i=.5,a=(e.onProgress==null?await Promise.all(r):await yG(r,e.onProgress,s,i)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await yG(a,e.onProgress,l,c)}async function P_e(n,e="",t,r){return $Y(o=>NY(o,{requestInit:r}))(n,e,t)}function $Y(n){return async(e,t="",r)=>{const s=e.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,p)=>{let m=0;d.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=SD[y]*Te(g.shape),x=()=>{s[p]=!0,i[p]==null&&(i[p]=[]),i[p].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,S)=>{w===g.name&&(x(),o[S]=!0)}):x(),a.push(g.name),m+=b})}),!o.every(d=>d)){const d=r.filter((p,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((d,p,m)=>(p&&d.push(m),d),[]),c=[];l.forEach(d=>{e[d].paths.forEach(p=>{const m=t+(t.endsWith("/")?"":"/")+p;c.push(m)})});const u=await n(c),h={};let f=0;return l.forEach(d=>{const p=e[d].paths.length,m=new Fu(u.slice(f,f+p));i[d].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),x=BL(b,[y.manifestEntry]);for(const w in x)h[w]=x[w]}),f+=p}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D_e="application/octet-stream",O_e="application/json";class Jz{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ee().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=LX(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:O_e}),"model.json"),e.weightData!=null){const o=Fu.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:D_e}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:X2(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return WL(t,i=>this.loadWeights(i))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=F_e(t),i=this.weightPathPrefix||r,o=GL(e),a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(i+h+s);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await NY(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,c]}}Jz.URL_SCHEME_REGEX=/^https?:\/\//;function F_e(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function $D(n){return n.match(Jz.URL_SCHEME_REGEX)!=null}const RY=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>$D(r)):t=$D(n),t)return cN(n,e)}return null};_s.registerSaveRouter(RY);_s.registerLoadRouter(RY);function cN(n,e){return new Jz(n,e)}function PY(n,e){return cN(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c3{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class DY{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class L_e{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function z_e(n,e,t,r){const s=arguments;return new L_e($I(...s))}function $I(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new c3(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new c3({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new c3({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function OY(n){return new DY(n)}function B_e(n){return new DY(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Fu,browserFiles:MY,browserHTTPRequest:PY,concatenateArrayBuffers:FX,copyModel:c0e,decodeWeights:BL,encodeWeights:CD,fromMemory:z_e,fromMemorySync:$I,getLoadHandlers:BX,getModelArtifactsForJSON:WL,getModelArtifactsForJSONSync:UL,getModelArtifactsInfoForJSON:X2,getSaveHandlers:zX,getWeightSpecs:GL,http:cN,isHTTPScheme:$D,listModels:HL,loadWeights:P_e,moveModel:u0e,registerLoadRouter:Zye,registerSaveRouter:Yye,removeModel:jL,weightsLoaderFactory:$Y,withSaveHandler:OY,withSaveHandlerSync:B_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_e(n,e,t){const r=j(n,"labels","confusionMatrix"),s=j(e,"predictions","confusionMatrix");U(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),U(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),U(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),U(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),U(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=Jb(wt(r,"int32"),t),o=Jb(wt(s,"int32"),t),a=rr(i),l=Hn(a,o);return wt(l,"int32")}const U_e=he({confusionMatrix_:V_e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_e=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:U_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let am,bG=!1;function FY(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(x_(v_,ue.backendName)!=null){const p={pixels:n},m={numChannels:e};return ue.runKernel(v_,p,m)}const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||t)h=n.data;else if(i||s||a){if(am==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")am=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else am=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});am.canvas.width=c,am.canvas.height=u,am.drawImage(n,0,0,c,u),h=am.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(h);else{const p=c*u;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=h[m*4+g]}return Oz(f,[u,c,e],"int32")}function G_e(n){return n!=null&&n.data instanceof Uint8Array}function H_e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function j_e(n){return n!=null&&n.width!==0&&n.height!==0}function q_e(n){return H_e()&&!(n instanceof ImageBitmap)&&j_e(n)&&!G_e(n)}async function X_e(n,e=3){let t=null;if(Ee().getBool("WRAP_TO_IMAGEBITMAP")&&q_e(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return FY(t,e)}function LY(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function K_e(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function lC(n,e){let t=j(n,"img","toPixels");if(!(n instanceof jn)){const c=t;t=wt(c,"int32"),c.dispose()}LY(t);const[r,s]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const u=[0,0,0,255];for(let f=0;f<i;f++){const d=o[c*i+f];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);i===1?(u[0]=d*a,u[1]=d*a,u[2]=d*a):u[f]=d*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){bG||x_(h2,ue.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),bG=!0),e.width=s,e.height=r;const c=e.getContext("2d"),u=new ImageData(l,s,r);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function Y_e(n,e,t){let r=j(n,"img","draw");if(!(n instanceof jn)){const o=r;r=wt(o,"int32"),o.dispose()}LY(r),K_e(t==null?void 0:t.imageOptions);const s={image:r},i={canvas:e,options:t};ue.runKernel(h2,s,i)}const cC=he({fromPixels_:FY}),Z_e=Object.freeze(Object.defineProperty({__proto__:null,draw:Y_e,fromPixels:cC,fromPixelsAsync:X_e,toPixels:lC},Symbol.toStringTag,{value:"Module"}));function uC(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Te(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,i=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const a=n.shape,l=s.slice();l.pop();let c=1;for(let h=i;h<t;++h)c*=a[h],l.push(a[h]);const u=[...Jt(n.shape).map(h=>h/c),1].slice(0,i);return[l,o,c,u]}const J_e=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:uC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RD=-2,Q_e=-1;function uN(n,e,t){const r=n.shape.length;U(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),U(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)U(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function eSe(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function hN(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function zY(n,e,t,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<t;i++)i===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function BY(n,e,t){return t<=n?t:t-(e-1)}function VY(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function tSe(n,e,t,r,s,i,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),f=new Array(c);if(e.length&&t>0){const d=e[0],p=t+1;u=UY(o,d,p,r,n),h=WY(a,d,p,s,n),f=zY(i,d,p,n)}else for(let d=0;d<c;d++)u[d]=HY(o,r,i,n,d,l),h[d]=jY(a,s,i,n,d,l),f[d]=GY(i,d,l);return{begin:u,end:h,strides:f}}function UY(n,e,t,r,s){const i=[...s],o=VY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=BY(e,t,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function WY(n,e,t,r,s){const i=[...s],o=VY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=BY(e,t,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=ip(0,i[a],s[a])}return i}function GY(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function HY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=ip(0,o,l-1),o}function jY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),a>0?o=ip(0,o,l):o=ip(-1,o,l-1),o}function eB(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function tB(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function hC(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{U(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(s).fill(-1):typeof t=="number"?i=[t,...new Array(s-1).fill(-1)]:t.length<s?i=t.concat(new Array(s-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(U(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function fN(n,e,t,r,s,i,o,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let x=0;x<h.dims;x++)u&&1<<x&a&&h.numAddAxisAfterEllipsis++,1<<x&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};nSe(h,f);let d=!0,p=!0,m=!0;const g=[],y=[];for(let x=0;x<n.length;++x){if(f.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(f.shrinkAxisMask&1<<x),S=n[x];if(S===-1){g.push(w?1:-1);continue}const C=[f.beginMask&1<<x,f.endMask&1<<x],k=[f.strides[x]>0?0:-1,f.strides[x]>0?S:S-1];if(w&&f.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[x]===1;const A=!!(f.beginMask&1<<x&&f.endMask&1<<x);if(f.beginValid&&f.endValid){if(w){const O=f.begin[x]<0?S+f.begin[x]:f.begin[x];if(f.begin[x]=O,f.end[x]=f.begin[x]+1,O<0||O>=S)throw Error(`slice index ${f.begin[x]} of dimension ${x} out of bounds.`)}else f.begin[x]=vG(f.begin[x],0,f.strides[x],S,C,k),f.end[x]=vG(f.end[x],1,f.strides[x],S,C,k);const N=f.strides[x]===1&&f.begin[x]===0&&f.end[x]===S;d=d&&N,p=p&&(x===0&&f.strides[x]===1||N)}else d=d&&f.strides[x]===1&&A,p=p&&(x===0&&f.strides[x]===1||A);let M,E=!1;if(f.beginValid&&f.endValid?(M=f.end[x]-f.begin[x],E=!0):w?(M=1,E=!0):A&&S>=0&&(f.strides[x]<0?M=-S:M=S,E=!0),E){let N;M===0||M<0!=f.strides[x]<0?N=0:N=Math.trunc(M/f.strides[x])+(M%f.strides[x]!==0?1:0),g.push(N)}else g.push(-1)}for(let x=0;x<f.finalShapeGatherIndices.length;++x){const w=f.finalShapeGatherIndices[x];w>=0?y.push(g[w]):w===RD&&y.push(1)}return{finalShapeSparse:y.filter((x,w)=>f.finalShapeGatherIndices[w]!==RD),finalShape:y,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function nSe(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(RD),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(Q_e),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function vG(n,e,t,r,s,i){if(s[e])return t>0?i[e]:i[e+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const qY=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:uN,computeFlatOffset:tB,computeOutShape:hN,getNormalizedAxes:tSe,isSliceContinous:eB,maskToAxes:eSe,parseSliceParams:hC,sliceInfo:fN,startForAxis:HY,startIndicesWithElidedDims:UY,stopForAxis:jY,stopIndicesWithElidedDims:WY,stridesForAxis:GY,stridesWithElidedDims:zY},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const rSe="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XY{static sgd(e){return new lN(e)}static momentum(e,t,r=!1){return new Yz(e,t,r)}static rmsprop(e,t=.9,r=0,s=null,i=!1){return new Zz(e,t,r,s,i)}static adam(e=.001,t=.9,r=.999,s=null){return new Xz(e,t,r,s)}static adadelta(e=.001,t=.95,r=null){return new jz(e,t,r)}static adamax(e=.002,t=.9,r=.999,s=null,i=0){return new Kz(e,t,r,s,i)}static adagrad(e,t=.1){return new qz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Id=XY;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sSe=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function nB(){return new Promise(n=>sSe(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n,e){const t=n[0].length;n.forEach((s,i)=>{U(s.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),U(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<t;o++)U(o===e||s[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function ba(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var su;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(su||(su={}));function KY(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const i=t[s],o=r[r.length-t.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function YY(n){const e={FIRST_DIM_SIZE:su.FIRST_DIM_SIZE,VALUE_ROWIDS:su.VALUE_ROWIDS,ROW_LENGTHS:su.ROW_LENGTHS,ROW_SPLITS:su.ROW_SPLITS,ROW_LIMITS:su.ROW_LIMITS,ROW_STARTS:su.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function ZY(n){return n.length===0?0:n[0]===su.FIRST_DIM_SIZE?n.length-1:n.length}function JY(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const i=n[s],o=e[s+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rB=30;function pN(n){return n<=rB?n:CI(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mN(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/e[o],e[o]]);s=s.concat(n.slice(i+1))}return s}function Uy(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Wy(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?r?s.push(e[i-1]*n[i]):s.push(n[i]/e[i-1]):s.push(n[i]);return s}function gN(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function yN(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fC=1.7580993408473768,dC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bN=.3275911,vN=.254829592,wN=-.284496736,xN=1.421413741,_N=-1.453152027,SN=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xu(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function QY(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function eZ(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function tZ(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function sB(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function nZ(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function rZ(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:t,imag:r}}function sZ(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),i=Math.sin(r);return{real:s,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3="->",iSe=/->/g,wG=",",xG="...";function CN(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(iSe,"").length)/u3.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${u3}").`);const[r,s]=n.split(u3);U(r.indexOf(xG)===-1,()=>`The ellipsis notation ("${xG}") is not supported yet.`);const i=r.split(wG),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<s.length;++f){const d=s[f];if(!i.some(p=>p.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){const d=r[f];a.indexOf(d)===-1&&d!==wG&&a.push(d)}const l=new Array(i.length);for(let f=0;f<o;++f){if(new Set(i[f].split("")).size!==i[f].length)throw new Error(`Found duplicate axes in input component ${i[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<i[f].length;++d)l[f].push(a.indexOf(i[f][d]))}const c=a.length,u=s.length,h=[];for(let f=u;f<c;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function kN(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function TN(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const i=t[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=i[o]:U(r[e[s][o]]===i[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function EN(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=oSe(e,a);for(const c of l)i.indexOf(c)===-1&&(r[o].push(c),i.push(c))}return{path:t,steps:r}}function IN(n){return n.every((e,t)=>e===t)}function oSe(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function AN(n,e,t=0){let r=[];if(typeof e=="number")U(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);U(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}U(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function oZ(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function aZ(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function cZ(n,e){return`size ${n} must be non-negative, not ${e}`}function uZ(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function hZ(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function fZ(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(){return"segment ids must be >= 0"}function dZ(){return"segment ids are not increasing"}function pZ(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function mZ(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(n,e){let t=!1,r;for(n<=rB?(r=n,t=!0):r=CI(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=CI(n,r+1);return r}function iB(n,e,t){const r=[],s=n.length;for(let i=0;i<s;i++)i!==e?r.push(n[i]):r.push(t);return r}function MN(n,e,t,r){const s=e.shape.length,i=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const aSe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:MN,computeOutShape:iB,segOpComputeOptimalWindowSize:gZ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _u(n){try{return n.map(e=>Cc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function yZ(n){return n.map(e=>yu(e))}const bZ=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:vN,ERF_A2:wN,ERF_A3:xN,ERF_A4:_N,ERF_A5:SN,ERF_P:bN,PARALLELIZE_THRESHOLD:rB,get RowPartitionType(){return su},SELU_SCALE:dC,SELU_SCALEALPHA:fC,applyActivation:iN,assertAndGetBroadcastShape:ln,assertAxesAreInnerMostDims:fi,assertParamsConsistent:dN,assignToTypedArray:nZ,axesAreInnerMostDims:dz,calculateShapes:zu,checkEinsumDimSizes:TN,checkPadOnDimRoundingMode:na,combineLocations:mK,combineRaggedTensorToTensorShapes:KY,complexWithEvenIndex:eZ,complexWithOddIndex:tZ,computeConv2DInfo:ts,computeConv3DInfo:Lu,computeDefaultPad:YL,computeDilation2DInfo:Pp,computeOptimalWindowSize:pN,computeOutAndReduceShapes:Qs,computeOutShape:ba,computePool2DInfo:ko,computePool3DInfo:Ll,convertConv2DDataFormat:nl,decodeEinsumEquation:CN,eitherStridesOrDilationsAreOne:Ri,expandShapeToKeepDim:Ls,exponent:sZ,exponents:rZ,fromStringArrayToUint8:yZ,fromUint8ToStringArray:_u,getAxesPermutation:Lr,getBroadcastDims:Ff,getComplexWithIndex:sB,getEinsumComputePath:EN,getEinsumPermutation:kN,getFusedBiasGradient:sN,getFusedDyActivation:rN,getImageCenter:mN,getInnerMostAxes:ns,getPermuted:Uy,getRaggedRank:ZY,getReductionAxes:ui,getReshaped:Vy,getReshapedPermuted:Wy,getRowPartitionTypesHelper:YY,getSliceBeginCoords:gN,getSliceSize:yN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:iZ,getSparseFillEmptyRowsNegativeIndexErrorMessage:oZ,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:aZ,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:uZ,getSparseReshapeInputOutputMismatchErrorMessage:fZ,getSparseReshapeInputOutputMultipleErrorMessage:hZ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:lZ,getSparseReshapeNegativeOutputDimErrorMessage:cZ,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:mZ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:PD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:dZ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:pZ,getUndoAxesPermutation:Oh,isIdentityPermutation:IN,log:uye,mergeRealAndImagArrays:xu,prepareAndValidate:uC,prepareSplitSize:AN,segment_util:aSe,shouldFuse:oN,slice_util:qY,splitRealAndImagArrays:QY,stridesOrDilationsArePositive:hg,tupleValuesAreOne:lp,upcastType:Mi,validateDefaultValueShape:JY,validateInput:QM,validateUpdateShape:Fz,warn:wl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lSe=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:oC,nonMaxSuppressionV4Impl:aN,nonMaxSuppressionV5Impl:aC,whereImpl:tN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */E_e();const vZ=Object.freeze(Object.defineProperty({__proto__:null,Abs:Mv,Acos:Vg,Acosh:Ug,AdadeltaOptimizer:jz,AdagradOptimizer:qz,AdamOptimizer:Xz,AdamaxOptimizer:Kz,Add:Mp,AddN:Nv,All:qS,Any:XS,ArgMax:$v,ArgMin:Rv,Asin:Wg,Asinh:Gg,Atan:Hg,Atan2:qg,Atanh:jg,AvgPool:Pv,AvgPool3D:Dv,AvgPool3DGrad:YS,AvgPoolGrad:KS,BatchMatMul:Ov,BatchToSpaceND:Fv,Bincount:ZS,BitwiseAnd:JS,BroadcastArgs:QS,BroadcastTo:yX,Cast:Xg,Ceil:Kg,ClipByValue:Yg,Complex:e2,ComplexAbs:Lv,Concat:zv,Conv2D:Bv,Conv2DBackpropFilter:t2,Conv2DBackpropInput:Vv,Conv3D:Uv,Conv3DBackpropFilterV2:n2,Conv3DBackpropInputV2:r2,Cos:Zg,Cosh:Jg,CropAndResize:i2,Cumprod:s2,Cumsum:Wv,DataStorage:wM,DenseBincount:o2,DepthToSpace:a2,DepthwiseConv2dNative:Gv,DepthwiseConv2dNativeBackpropFilter:l2,DepthwiseConv2dNativeBackpropInput:c2,Diag:u2,Dilation2D:Hv,Dilation2DBackpropFilter:b_,Dilation2DBackpropInput:y_,Draw:h2,get ENV(){return $L},Einsum:f2,Elu:ey,EluGrad:d2,Environment:mX,Equal:jv,Erf:ty,Exp:ny,ExpandDims:qv,Expm1:ry,FFT:p2,Fill:m2,FlipLeftRight:g2,Floor:sy,FloorDiv:iy,FromPixels:v_,FusedBatchNorm:Xv,FusedConv2D:jb,FusedDepthwiseConv2D:qb,GatherNd:y2,GatherV2:Kv,Greater:Yv,GreaterEqual:oy,IFFT:b2,Identity:ay,Imag:v2,IsFinite:ly,IsInf:cy,IsNan:uy,KernelBackend:jS,LRN:rw,LRNGrad:x2,LeakyRelu:Zv,Less:Jv,LessEqual:Qv,LinSpace:w2,Log:hy,Log1p:fy,LogSoftmax:bX,LogicalAnd:ew,LogicalNot:tw,LogicalOr:nw,LogicalXor:iye,LowerBound:oye,MatrixBandPart:aye,Max:sw,MaxPool:iw,MaxPool3D:ow,MaxPool3DGrad:S2,MaxPoolGrad:_2,MaxPoolWithArgmax:C2,Maximum:dy,Mean:aw,Min:lw,Minimum:py,MirrorPad:cw,Mod:my,MomentumOptimizer:Yz,Multinomial:k2,Multiply:gy,Neg:uw,NonMaxSuppressionV3:T2,NonMaxSuppressionV4:kM,NonMaxSuppressionV5:E2,NotEqual:hw,OP_SCOPE_SUFFIX:zL,OneHot:dw,OnesLike:fw,Optimizer:Xf,OptimizerConstructors:XY,Pack:pw,PadV2:mw,Pool:lye,Pow:yy,Prelu:gw,Prod:yw,RMSPropOptimizer:Zz,RaggedGather:TM,RaggedRange:EM,RaggedTensorToTensor:IM,Range:I2,get Rank(){return gD},Real:A2,RealDiv:Qg,Reciprocal:by,get Reduction(){return Uo},Relu:vy,Relu6:wy,Reshape:bw,ResizeBilinear:ww,ResizeBilinearGrad:N2,ResizeNearestNeighbor:vw,ResizeNearestNeighborGrad:M2,Reverse:xw,RotateWithOffset:G2,Round:xy,Rsqrt:_y,SGDOptimizer:lN,ScatterNd:$2,SearchSorted:P2,Select:_w,Selu:Sy,Sigmoid:Ey,Sign:Ty,Sin:Cy,Sinh:ky,Slice:Sw,Softmax:Ew,Softplus:Iy,SpaceToBatchND:kw,SparseFillEmptyRows:AM,SparseReshape:MM,SparseSegmentMean:D2,SparseSegmentSum:O2,SparseToDense:F2,SplitV:Tw,Sqrt:Ay,Square:L2,SquaredDifference:My,StaticRegexReplace:z2,Step:Dy,StridedSlice:B2,StringNGrams:V2,StringSplit:NM,StringToHashBucketFast:$M,Sub:Ny,Sum:Cw,Tan:$y,Tanh:Ry,Tensor:jn,TensorBuffer:li,TensorScatterUpdate:R2,Tile:Py,TopK:U2,Transform:W2,Transpose:jd,Unique:RM,Unpack:Iw,UnsortedSegmentSum:Aw,UpperBound:cye,Variable:__,ZerosLike:Mw,_FusedMatMul:Hb,abs:wi,acos:XX,acosh:KX,add:qe,addN:YX,all:KL,any:AI,argMax:ug,argMin:ZX,asin:JX,asinh:QX,atan:eK,atan2:tK,atanh:nK,avgPool:OM,avgPool3d:ZL,backend:cg,backend_util:bZ,basicLSTMCell:rK,batchNorm:Y2,batchNorm2d:JL,batchNorm3d:QL,batchNorm4d:ez,batchToSpaceND:FM,bincount:tz,bitwiseAnd:sK,booleanMaskAsync:dY,broadcastArgs:iK,broadcastTo:$b,broadcast_util:Fbe,browser:Z_e,buffer:Sn,cast:wt,ceil:oK,clipByValue:xa,clone:mh,complex:Of,concat:cs,concat1d:nz,concat2d:rz,concat3d:sz,concat4d:iz,conv1d:oz,conv2d:cp,conv2dTranspose:lz,conv3d:cz,conv3dTranspose:uz,copyRegisteredKernels:dye,cos:LM,cosh:hz,cosineWindow:nN,cumprod:MI,cumsum:fz,customGrad:xh,denseBincount:NI,deprecationWarn:w0e,depthToSpace:lK,depthwiseConv2d:Z2,device_util:Bye,diag:cK,dilation2d:uK,disableDeprecationWarnings:v0e,dispose:nn,disposeVariables:x0e,div:Lt,divNoNan:hK,dot:fK,dropout:Vz,einsum:Om,elu:J2,enableDebugMode:b0e,enableProdMode:y0e,enclosingPowerOfTwo:Uz,engine:xo,ensureShape:dK,env:Ee,equal:vu,erf:pK,euclideanNorm:yK,exp:Yo,expandDims:oi,expm1:bK,eye:zM,fft:ZM,fill:Fy,findBackend:T0e,findBackendFactory:E0e,floor:Q2,floorDiv:XL,fused:_Y,gather:eC,gatherND:yY,gather_util:J_e,getBackend:C_,getGradient:dD,getKernel:x_,getKernelsForBackend:kI,grad:wve,grads:xve,greater:rl,greaterEqual:Dp,ifft:A_,imag:tC,image:Ci,inTopKAsync:bY,io:Qz,irfft:Pz,isFinite:vK,isInf:wK,isNaN:xK,keep:Xs,kernel_impls:lSe,leakyRelu:BM,less:I_,lessEqual:Ly,linalg:Hz,linspace:_K,localResponseNormalization:SK,log:Nl,log1p:VM,logSigmoid:kK,logSoftmax:pz,logSumExp:WM,logicalAnd:_h,logicalNot:GM,logicalOr:mz,logicalXor:TK,losses:EY,lowerBound:EK,matMul:Hn,math:W_e,max:wc,maxPool:jM,maxPool3d:gz,maxPoolWithArgmax:IK,maximum:jf,mean:Ds,memory:II,meshgrid:AK,min:E_,minimum:hp,mirrorPad:yz,mod:MK,moments:nC,movingAverage:pY,mul:fe,multiRNNCell:NK,multinomial:$K,neg:us,nextFrame:nB,norm:Nw,notEqual:Zb,oneHot:Jb,ones:ma,onesLike:$l,op:he,outerProduct:RK,pad:wu,pad1d:PK,pad2d:DK,pad3d:OK,pad4d:FK,pool:LK,pow:up,prelu:XM,print:qL,prod:zK,profile:_0e,raggedGather:BK,raggedRange:VK,raggedTensorToTensor:UK,rand:WK,randomGamma:XK,randomNormal:KM,randomStandardNormal:KK,randomUniform:Op,randomUniformInt:YK,range:fg,ready:K2,real:Qb,reciprocal:ZK,registerBackend:DM,registerGradient:vX,registerKernel:H2,relu:Fh,relu6:Ez,removeBackend:k0e,reshape:ve,reverse:Tc,reverse1d:JK,reverse2d:QK,reverse3d:eY,reverse4d:tY,rfft:JM,round:Iz,rsqrt:Az,scalar:en,scatterND:mY,scatter_util:_xe,searchSorted:HM,selu:Mz,separableConv2d:Nz,serialization:k_e,setBackend:C0e,setPlatform:I0e,setdiff1dAsync:nY,sigmoid:El,sign:rY,signal:TY,sin:$z,sinh:Rz,slice:dn,slice1d:rC,slice2d:YM,slice3d:sC,slice4d:ev,slice_util:qY,softmax:iC,softplus:$w,spaceToBatchND:qM,sparse:IY,sparseToDense:gY,spectral:kY,split:qa,sqrt:So,square:Or,squaredDifference:Dz,squeeze:vr,stack:_a,step:Pw,stridedSlice:sY,string:AY,sub:Dt,sum:Yt,sumOutType:q2,tan:iY,tanh:Yb,tensor:Ei,tensor1d:Ks,tensor2d:Xa,tensor3d:Oz,tensor4d:oY,tensor5d:aY,tensor6d:lY,tensorScatterUpdate:cY,tensor_util:Dye,test_util:Dwe,tidy:Se,tile:pc,time:S0e,topk:uY,train:Id,transpose:rr,truncatedNormal:eN,unique:hY,unregisterGradient:fye,unregisterKernel:hye,unsortedSegmentSum:Lz,unstack:Ec,upcastType:Mi,upperBound:fY,util:_ye,valueAndGrad:_ve,valueAndGrads:Sve,variable:zz,variableGrads:CK,version_core:rSe,where:_o,whereAsync:Bz,zeros:ms,zerosLike:lr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cSe=tN;class NN extends jS{nextDataId(){return NN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new wM(this,xo())}write(e,t,r){this.firstUse&&(this.firstUse=!1,Ee().get("IS_NODE")&&wl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&uu(r[0])){const i=r.map(o=>yu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,s,i){this.data.set(e,{values:t,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const s=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return xu(s,i)}return J1(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Cc(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}makeOutput(e,t,r){return xo().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=so();return e(),{kernelMs:so()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Zt([e],"where");const t=this.readSync(e.dataId);return cSe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}NN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const uSe=n=>{const{x:e}=n.inputs,t=n.backend;Zt(e,"abs");let r=new Float32Array(Te(e.shape));const s=t.data.get(e.dataId).values;return r=wZ(s),t.makeOutput(r,e.shape,e.dtype)},hSe={kernelName:Mv,backendName:"cpu",kernelFunc:uSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(n){return(e,t,r,s,i)=>{const o=ln(e,t),a=o.length,l=Jt(o),c=Te(o),u=ci(i,c),h=e.length,f=t.length,d=Jt(e),p=Jt(t),m=Ff(e,o),g=Ff(t,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=Bg(y,a,l),x=b.slice(-h);m.forEach(k=>x[k]=0);const w=gu(x,h,d),S=b.slice(-f);g.forEach(k=>S[k]=0);const C=gu(S,f,p);u[y]=n(r[w],s[C])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",i),imag:t.makeTensorInfo(s.shape,"float32",o)},a}const fSe={kernelName:e2,backendName:"cpu",kernelFunc:Wa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n,e,t="float32"){if(t==="complex64"){const s=RI(n,e,"float32"),i=RI(n,e,"float32");return Wa({inputs:{real:s,imag:i},backend:n})}const r=ji(Te(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const dSe={kernelName:ay,backendName:"cpu",kernelFunc:Sh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pg(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.real,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const pSe={kernelName:A2,backendName:"cpu",kernelFunc:pg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=$p([0],t),[i,o]=ei((a,l)=>a!==l?1:0)(e,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function fp(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Sh({inputs:{x:s},backend:t});const u=RI(t,s.shape,s.dtype),h=fp({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),f=Wa({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),f}if(s.dtype==="complex64"){const u=pg({inputs:{input:s},backend:t}),h=fp({inputs:{x:u},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(u),h}if(!SM(s.dtype,i)){const u=Sh({inputs:{x:s},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=t.data.get(s.dataId).values,[a,l,c]=xZ(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}const mSe={kernelName:Xg,backendName:"cpu",kernelFunc:fp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n,e,t,r){return t==null?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Zt([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?_u(c):c,f=o.dtype==="string"?_u(u):u,d=r||o.dtype,[p,m]=e(o.shape,a.shape,h,f,d);return l.makeTensorInfo(m,d,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=fp({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,d=l.data.get(h.dataId).values,p=l.data.get(f.dataId).values,m=fp({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[S,C,k]=t(o.shape,a.shape,d,p,x,w),A=l.makeTensorInfo(k,"float32",S),M=l.makeTensorInfo(k,"float32",C),E=Wa({inputs:{real:A,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(M),E}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=r||o.dtype,[f,d]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(d,h,f)}}}function oB(n){return(e,t,r,s,i,o)=>{const a=ln(e,t),l=Te(a),c=a.length,u=Jt(a),h=ci("float32",l),f=ci("float32",l),d=Ff(e,a),p=Ff(t,a),m=xu(r,s),g=xu(i,o),y=e.length,b=Jt(e),x=t.length,w=Jt(t);if(d.length+p.length===0)for(let S=0;S<h.length;S++){const C=S%m.length,k=S%g.length,A=n(m[C*2],m[C*2+1],g[k*2],g[k*2+1]);h[S]=A.real,f[S]=A.imag}else for(let S=0;S<h.length;S++){const C=Bg(S,c,u),k=C.slice(-y);d.forEach(O=>k[O]=0);const A=gu(k,y,b),M=C.slice(-x);p.forEach(O=>M[O]=0);const E=gu(M,x,w),N=n(m[A*2],m[A*2+1],g[E*2],g[E*2+1]);h[S]=N.real,f[S]=N.imag}return[h,f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Z=ei((n,e)=>n+e),gSe=oB((n,e,t,r)=>({real:n+t,imag:e+r})),tv=Pi(Mp,_Z,gSe),ySe={kernelName:Mp,backendName:"cpu",kernelFunc:tv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n,e,t,r,s){const i=Te(r),o=ji(s,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function SZ(n,e,t,r=!1){const s=n.shape[0],i=n.shape[1],o=Sn([s,t],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(r?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CZ=ei((n,e)=>n&e),bSe=Pi(JS,CZ),vSe={kernelName:JS,backendName:"cpu",kernelFunc:bSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(n){return(e,t,r)=>{const s=Ss(t,e.length);for(let i=0;i<e.length;++i)s[i]=n(e[i],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n,e,t){const r=Lh(e);return Fp(n,r,t)}function Fp(n,e,t){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;Zt(o,n);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=_u(l)}else c=l;const u=t||o.dtype,h=e(c,u,s);return a.makeTensorInfo(o.shape,u,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kZ=Lh(n=>Math.ceil(n)),wSe=Fp(Kg,kZ),xSe={kernelName:Kg,backendName:"cpu",kernelFunc:wSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(n,e,t,r){const s=Ss(t,Te(e));if(r&&t!=="string"){let i=0;n.forEach(o=>{const a=Te(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?_u(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+i;for(let h=0;h<o.shape[1];++h)s[u+h]=a[l++]}i+=o.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EZ=ei((n,e)=>n===e?1:0),IZ=Pi(jv,EZ,null,"bool"),_Se={kernelName:jv,backendName:"cpu",kernelFunc:IZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ=Lh(n=>Math.exp(n)),MZ=Fp(ny,AZ,"float32"),SSe={kernelName:ny,backendName:"cpu",kernelFunc:MZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ=Lh(n=>Math.expm1(n)),CSe=Fp(ry,NZ),kSe={kernelName:ry,backendName:"cpu",kernelFunc:CSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Z=Lh(n=>Math.floor(n)),TSe=Fp(sy,$Z),ESe={kernelName:sy,backendName:"cpu",kernelFunc:TSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ=ei((n,e)=>Math.floor(n/e)),ISe=Pi(iy,RZ,null,"int32"),ASe={kernelName:iy,backendName:"cpu",kernelFunc:ISe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PZ(n,e,t,r,s,i,o,a,l){const c=Sn([r,i],t);for(let u=0;u<r;u++){const h=[];let f=0;for(let d=0;d<s;d++){const p=n[u*s+d];f+=p*o[d],h.push(p)}if(f<0||f>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<i;d++)c.values[u*i+d]=e.get(...e.indexToLoc(f*i+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(n,e,t){const r=Sn(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZ=ei((n,e)=>n>e?1:0),MSe=Pi(Yv,OZ,null,"bool"),NSe={kernelName:Yv,backendName:"cpu",kernelFunc:MSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZ=ei((n,e)=>n>=e?1:0),$Se=Pi(oy,FZ,null,"bool"),RSe={kernelName:oy,backendName:"cpu",kernelFunc:$Se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZ=ei((n,e)=>n<e?1:0),PSe=Pi(Jv,LZ,null,"bool"),DSe={kernelName:Jv,backendName:"cpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZ=ei((n,e)=>n<=e?1:0),OSe=Pi(Qv,zZ,null,"bool"),FSe={kernelName:Qv,backendName:"cpu",kernelFunc:OSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(n,e,t){const r=(e-n)/(t-1),s=ji(t,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZ=Lh(n=>Math.log(n)),LSe=Fp(hy,VZ),zSe={kernelName:hy,backendName:"cpu",kernelFunc:LSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UZ(n,e,t,r){const s=ci(r,Te(t));for(let i=0;i<s.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WZ=ei((n,e)=>Math.max(n,e)),BSe=Pi(dy,WZ),VSe={kernelName:dy,backendName:"cpu",kernelFunc:BSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ=ei((n,e)=>Math.min(n,e)),USe=Pi(py,GZ),WSe={kernelName:py,backendName:"cpu",kernelFunc:USe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lB=ei((n,e)=>n*e),GSe=oB((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),$N=Pi(gy,lB,GSe),HSe={kernelName:gy,backendName:"cpu",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZ(n,e,t){const r=Hf(-1,t);return lB([],e,r,n,t)}function jSe(n){const{inputs:e,backend:t}=n,{x:r}=e;Zt(r,"neg");const s=t.data.get(r.dataId).values,[i,o]=HZ(s,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,i)}const qSe={kernelName:uw,backendName:"cpu",kernelFunc:jSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZ=ei((n,e)=>n!==e?1:0),XSe=Pi(hw,jZ,null,"bool"),KSe={kernelName:hw,backendName:"cpu",kernelFunc:XSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cB(n,e,t,r,s){const i=e.length,o=Te(e),a=Jt(e),l=Jt(s),c=ci(t,Te(s));for(let u=0;u<o;++u){const h=Bg(u,i,a),f=new Array(h.length);for(let p=0;p<f.length;p++)f[p]=h[r[p]];const d=gu(f,i,l);c[d]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sa(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{perm:i}=t;Zt(s,"transpose");const o=s.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=s.shape[i[h]];const l=r.data.get(s.dataId).values,c=cB(l,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const YSe={kernelName:jd,backendName:"cpu",kernelFunc:Sa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZ(n,e,t,r){const[s,i]=Qs(n,r),o=Mi(e,"int32"),a=ji(Te(s),o),l=Te(i);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let f=0;f<l;++f)h*=t[u+f];a[c]=h}return{outVals:a,outShape:s,outDtype:o}}function ZSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"prod");const a=s.shape.length,l=An(i,s.shape),c=Lr(l,a);let u=l,h=s;const f=[];c!=null&&(h=Sa({inputs:{x:s},backend:t,attrs:{perm:c}}),f.push(h),u=ns(u.length,a));const d=t.data.get(h.dataId).values,{outVals:p,outShape:m,outDtype:g}=qZ(h.shape,h.dtype,d,u);let y=m;return o&&(y=Ls(m,l)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,p)}const JSe={kernelName:yw,backendName:"cpu",kernelFunc:ZSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSe(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const i=Bg(s,e.length,Jt(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${t})`)}})}function e2e(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function t2e(n,e,t,r){const s=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);e2e(t,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let f=0;f<t.length;++f){const d=t[f],p=f+e.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-d[u];for(let y=u;y<h;++y)a[p].push(d[y+1]+g)}u=d[u],h=d[h]}h!==u&&(s.push([u,h]),i+=h-u)}return{outSplits:a,valueSlices:s,numValues:i}}function n2e(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=Ss("int32",r);e.push(s),n[t].forEach((i,o)=>s[o]=i)}return e}function _G(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function r2e(n,e,t,r,s,i){const o=_G(e,2)[1],a=_G(i,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<r;++h)s[l*a+h]=n[u*o+h];++l}}function s2e(n,e,t,r,s){const i=e.slice();i[0]=s;const o=Ss(t,Te(i)),a=n.length,l=a===0?0:a/e[0];return r2e(n,e,r,l,o,i),[o,i]}function XZ(n,e,t,r,s,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(QSe(i,o,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:h,numValues:f}=t2e(i,o,n,c),d=n2e(u),p=s2e(t,r,s,h,f);return[d,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=2147483647;function KZ(n,e,t,r,s,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],f=Ss("int32",h+1);f[0]=0;for(let g=0;g<h;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],x=c?i[0]:i[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&b<y||x<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/x)),w>SG)throw new Error(`Requires ((limit - start) / delta) <= ${SG}`);f[g+1]=f[g]+w}const d=f[h],p=Ss(t,d);let m=0;for(let g=0;g<h;++g){const y=f[g+1]-f[g];let b=a?n[0]:n[g];const x=c?i[0]:i[g];for(let w=0;w<y;++w)p[m++]=b,b+=x}return[f,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jl=su;class PI{constructor(e,t,r,s,i,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=YY(u),this.raggedRank=ZY(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Jl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Jl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Jl.VALUE_ROWIDS:return PI.getMaxWidthValueRowID(t);case Jl.ROW_SPLITS:return PI.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Jl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const i=e[s+1]-e[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(t-r,i)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return kG(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;JY(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=KY(this.raggedRank,s,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),i=[];let o=0;for(let a=0;a<s;++a,o+=t)i.push(o);for(let a=s;a<e;++a)i.push(-1);return U(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,r,s){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=r;for(let h=0;h<l-c;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,s){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<i;++u){const h=e[u];if(h===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,s){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Jl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,r,s);case Jl.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,r,s);default:throw new Error(`Unsupported partition type: ${Jl[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Jl.FIRST_DIM_SIZE:return e[0];case Jl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Jl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Jl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=kG(r,!1),o=Ss(this.valuesDType,Te(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,r,s){if(r.length===0)return;const i=this.values,o=r;let a=s.slice();a=a.slice(e+1);const l=Te(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const p=this.defaultValueShape;Se(()=>{const m=ve(u,p);u=$b(m,a).dataSync()})}let h=0,f=0,d=0;for(let p=0;p<=c;++p){let m=p<c?t[p]:-1;if(m===d){++d;continue}if(f<d){const g=i.subarray(h*l),y=o.subarray(f*l),b=(d-f)*l;CG(y,g,b)}if(p>=c){const g=r.length;m=Math.floor(g/l)}if(m>d)if(this.defaultValue.length===1)o.subarray(d*l,m*l).fill(this.defaultValue[0]),d=m;else for(;m>d;){const g=o.slice(d*l);CG(g,u,l),++d}m<0?(h=p+1,f=d):(h=p,f=d,d=f+1)}}}function CG(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function kG(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function YZ(n,e,t,r,s,i,o,a,l,c){return new PI(n,e,t,r,s,i,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZ(n,e,t,r){const s=n===e,i=n<e&&t<0,o=e<n&&t>1;if(s||i||o)return ji(0,r);const a=Math.abs(Math.ceil((e-n)/t)),l=ji(a,r);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZ=Lh(n=>1/Math.sqrt(n)),i2e=Fp(_y,JZ),o2e={kernelName:_y,backendName:"cpu",kernelFunc:i2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gm(n,e,t,r,s,i,o,a,l,c){const u=[r/s,s],h=n.values,f=e.values;if(r===0)return Sn(t,e.dtype);const d=l instanceof li?l:Sn(u,e.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=h[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<s;y++)c?d.values[g*s+y]+=f[p*s+y]:d.values[g*s+y]=e.rank===0?f[0]:f[p*s+y]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2e=Lh(n=>1/(1+Math.exp(-n))),QZ=$r(Ey,n=>1/(1+Math.exp(-n))),l2e={kernelName:Ey,backendName:"cpu",kernelFunc:QZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n,e,t,r,s){const i=eB(r,e,t),o=Te(t),a=Jt(r);if(i){const h=tB(e,a);return s==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=s==="string"?_u(n):n,c=Sn(r,s,l),u=Sn(t,s);for(let h=0;h<u.size;++h){const f=u.indexToLoc(h),d=f.map((p,m)=>p+e[m]);u.set(c.get(...d),...f)}return s==="string"?yZ(u.values):u.values}function mg(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r;Zt(s,"slice");const[a,l]=hC(s,i,o);uN(s,a,l);const c=t.data.get(s.dataId).values,u=eJ(c,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,u)}const c2e={kernelName:Sw,backendName:"cpu",kernelFunc:mg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(n,e,t,r,s,i,o){const a=e[0],l=i[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(iZ(a));const g=Ss(t,0),y=Ss(s,0);return[g,[0,h],y,c,u]}let f=!0,d=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*h];if(y<0)throw new Error(oZ(g,y));if(y>=l)throw new Error(aZ(g,y,l));++p[y],f=f&&y>=d,d=y}let m=!0;for(let g=0;g<l;++g){const y=p[g]===0;c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&f){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,h],y,c,u]}else{const g=p[l-1],y=Ss(t,g*h),b=Ss(s,g),x=new Array(l).fill(0);for(let w=0;w<a;++w){const S=n[w*h],C=x[S],k=(S===0?0:p[S-1])+C;x[S]++;for(let A=0;A<h;++A)y[k*h+A]=n[w*h+A];b[k]=r[w],u[w]=k}for(let w=0;w<l;++w)if(x[w]===0){const C=w===0?0:p[w-1];y[C*h+0]=w;for(let k=1;k<h;++k)y[C*h+k]=0;b[C]=o}return[y,[g,h],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n,e,t,r,s){const i=Te(r),o=e[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(y===-1){if(u!==-1)throw new Error(lZ(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(cZ(g,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(uZ());const g=Math.trunc(i/c);if(c*g!==i)throw new Error(hZ(r,l));l[u]=g}if(Te(l)!==i)throw new Error(fZ(r,l));const f=r.length,d=[];if(f>0){d[f-1]=1;for(let g=f-2;g>=0;--g)d[g]=d[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Ss(t,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<f;++b)y+=n[g*f+b]*d[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(n,e,t,r,s,i=!1,o=0){const a=r.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(PD());const f=e.slice();f[0]=h;const d=f.reduce((x,w)=>x*w,1),p=Ss(t,d);if(a===0)return h>0&&p.fill(o),[p,f];if(h<=0)throw new Error(PD());let m=0,g=1,y=0,b=s[m];for(;;){let x=0;if(g<a){if(x=s[g],b===x){++g;continue}if(b>=x)throw new Error(dZ())}if(b<0||b>=h)throw new Error(pZ(b,h));b>y&&p.fill(o,y*c,b*c);for(let w=m;w<g;++w){const S=r[w];if(S<0||S>=l[0])throw new Error(mZ(w,r[w],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[S*c+C]}if(i)for(let w=0;w<c;w++)p[b*c+w]/=g-m;if(m=g,++g,y=b+1,b=x,g>a)break}return y<h&&p.fill(o,y*c,h*c),[p,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u2e=Lh(n=>Math.sqrt(n)),h2e=$r(Ay,n=>Math.sqrt(n)),f2e={kernelName:Ay,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rJ=ei((n,e)=>{const t=n-e;return t*t}),d2e=Pi(My,rJ),p2e={kernelName:My,backendName:"cpu",kernelFunc:d2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJ=Lh((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=e;return n.replace(new RegExp(t,r?"g":""),s)}),m2e=Fp(z2,sJ),g2e={kernelName:z2,backendName:"cpu",kernelFunc:m2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n,e,t,r){const s=Sn(n,e.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+r[l];s.set(e.get(...a),...o)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y2e{constructor(e,t,r,s,i,o){this.separator=yu(e),this.nGramWidths=t,this.leftPad=yu(r),this.rightPad=yu(s),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),h=o-(c+u),f=t+(c>0?0:a-l);let d=0;d+=c*this.leftPad.length;for(let b=0;b<h;++b)d+=e[f+b].length;d+=u*this.rightPad.length;const p=c+u+h-1;d+=p*this.separator.length,r[s+a]=new Uint8Array(d);const m=r[s+a];let g=0;const y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(e[f+b]),y(this.separator);if(h>0){y(e[f+h-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=t[c]>=l;if(u=u&&t[c]<=r,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${r}]`);l=t[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Ss("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],d=this.getNumNGrams(f,h);this.createNGrams(e,c,a,u,d,h),u+=d}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth,d=1;this.createNGrams(e,c,a,u,d,f)}}return[a,o]}}function oJ(n,e,t,r,s,i,o,a){return new y2e(t,r,s,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b2e(n,e,t,r){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&r.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(s,i);(!t||o.length!==0)&&r.push(o),s=i+1}}function aJ(n,e,t){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const d=s.length;b2e(n[f],e,t,s);const p=s.length-d;a[f]=p,i+=p,o=Math.max(o,p)}const l=Ss("int32",i*2),c=new Array(i),u=[r,o];let h=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[h*2]=f,l[h*2+1]=d,c[h]=s[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(n,e){const t=Ss("int32",n.length);for(let r=0;r<n.length;++r)t[r]=AX(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJ=ei((n,e)=>n-e),v2e=oB((n,e,t,r)=>({real:n-t,imag:e-r})),hB=Pi(Ny,cJ,v2e),w2e={kernelName:Ny,backendName:"cpu",kernelFunc:hB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uJ(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Sn(t,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T1=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function hJ(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(t,Math.floor(e-l*u/a+h)),d=Math.min(r,Math.floor(e+(a-l)*u/a+h));hJ(n,e,f,d)}const s=n[e];let i=t,o=r;for(Tf(n,t,e),T1(n[r],s)>0&&Tf(n,t,r);i<o;){for(Tf(n,i,o),i++,o--;T1(n[i],s)<0;)i=i+1;for(;T1(n[o],s)>0;)o=o-1}T1(n[t],s)===0?Tf(n,t,o):(o=o+1,Tf(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function fJ(n,e,t,r,s){const i=e[e.length-1],[o,a]=[n.length/i,i],l=ci(t,o*r),c=ci("int32",o*r);for(let h=0;h<o;h++){const f=h*a,d=n.subarray(f,f+a);let p=new Array(d.length);d.forEach((b,x)=>p[x]={value:b,index:x}),r<p.length&&(hJ(p,r),p=p.slice(0,r)),s&&p.sort(T1);const m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=e.slice();return u[u.length-1]=r,[Sn(u,t,l),Sn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(n,e,t,r){const s=An(e,t)[0],i=[1,t[0],1];for(let p=0;p<s;p++)i[0]*=t[p];i[1]=t[s];for(let p=s+1;p<t.length;p++)i[2]*=t[p];const o=new Map,a=new Int32Array(t[s]),l=new li(i,r,n),c=[],u=i[0]===1&&i[2]===1;for(let p=0;p<t[s];p++){let m;if(u)m=n[p].toString();else{const y=[];for(let b=0;b<i[0];b++)for(let x=0;x<i[2];x++)y.push(l.get(b,p,x));m=y.join(",")}const g=o.get(m);if(g!=null)a[p]=g;else{const y=o.size;o.set(m,y),a[p]=y,c.push(p)}}const h=i.slice();h[1]=o.size;const f=new li(h,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)f.set(l.get(g,p,y),g,m,y)});const d=t.slice();return d[s]=h[1],{outputValues:f.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pJ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:_Z,bincountImpl:aB,bincountReduceImpl:SZ,bitwiseAndImpl:CZ,castImpl:xZ,ceilImpl:kZ,concatImpl:TZ,equalImpl:EZ,expImpl:AZ,expm1Impl:NZ,floorDivImpl:RZ,floorImpl:$Z,gatherNdImpl:PZ,gatherV2Impl:DZ,greaterEqualImpl:FZ,greaterImpl:OZ,lessEqualImpl:zZ,lessImpl:LZ,linSpaceImpl:BZ,logImpl:VZ,maxImpl:UZ,maximumImpl:WZ,minimumImpl:GZ,multiplyImpl:lB,negImpl:HZ,notEqualImpl:jZ,prodImpl:qZ,raggedGatherImpl:XZ,raggedRangeImpl:KZ,raggedTensorToTensorImpl:YZ,rangeImpl:ZZ,rsqrtImpl:JZ,scatterImpl:Gm,sigmoidImpl:a2e,simpleAbsImpl:wZ,sliceImpl:eJ,sparseFillEmptyRowsImpl:tJ,sparseReshapeImpl:nJ,sparseSegmentReductionImpl:uB,sqrtImpl:u2e,squaredDifferenceImpl:rJ,staticRegexReplaceImpl:sJ,stridedSliceImpl:iJ,stringNGramsImpl:oJ,stringSplitImpl:aJ,stringToHashBucketFastImpl:lJ,subImpl:cJ,tileImpl:uJ,topKImpl:fJ,transposeImpl:cB,uniqueImpl:dJ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */DM("cpu",()=>new NN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJ=$r(ey,n=>n>=0?n:Math.exp(n)-1),x2e={kernelName:ey,backendName:"cpu",kernelFunc:mJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r;Zt([s],"leakyRelu");const o=Te(s.shape),a=t.data.get(s.dataId).values,l=ci("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return t.makeTensorInfo(s.shape,"float32",l)}const _2e={kernelName:Zv,backendName:"cpu",kernelFunc:gJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2e=ei((n,e)=>n<0?e*n:n);function yJ(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e;Zt([r,s],"prelu");const i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,[a,l]=S2e(r.shape,s.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const C2e={kernelName:gw,backendName:"cpu",kernelFunc:yJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJ=$r(vy,n=>Math.max(0,n)),k2e={kernelName:vy,backendName:"cpu",kernelFunc:bJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vJ=$r(wy,n=>Math.min(Math.max(0,n),6)),T2e={kernelName:wy,backendName:"cpu",kernelFunc:vJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e,t,r,s){if(t==="linear")return Sh({inputs:{x:e},backend:n});if(t==="relu")return bJ({inputs:{x:e},backend:n});if(t==="elu")return mJ({inputs:{x:e},backend:n});if(t==="relu6")return vJ({inputs:{x:e},backend:n});if(t==="prelu")return yJ({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return gJ({inputs:{x:e},backend:n,attrs:{alpha:s}});if(t==="sigmoid")return QZ({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function es(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=Te(s.shape),a=_M(i,o),l=Te(a);U(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const c=t.data.get(s.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const E2e={kernelName:bw,backendName:"cpu",kernelFunc:es};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wJ(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;Zt([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],h=a?i.shape[c-1]:i.shape[c-2],f=o?s.shape[l-1]:s.shape[l-2],d=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=Te(p),y=Te(m),x=ln(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([f,d]);U(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[g,u,f]:[g,f,u],S=a?[y,d,h]:[y,h,d],C=es({inputs:{x:s},backend:t,attrs:{shape:w}}),k=es({inputs:{x:i},backend:t,attrs:{shape:S}}),A=o?C.shape[1]:C.shape[2],M=o?C.shape[2]:C.shape[1],E=a?k.shape[1]:k.shape[2],N=Math.max(g,y),O=t.data.get(C.dataId).values,R=t.data.get(k.dataId).values,D=Jt(C.shape),z=Jt(k.shape),[B,X,G]=o?[D[0],1,D[1]]:[D[0],D[1],1],[te,ge,ae]=a?[1,z[1],z[0]]:[z[1],1,z[0]],Ne=M*E,ke=Sn([N,M,E],C.dtype),De=ke.values,be=t.blockSize;for(let Xe=0;Xe<N;Xe++){const Oe=Xe%g,it=Xe%y;for(let We=0;We<M;We+=be){const dt=Math.min(We+be,M);for(let ct=0;ct<E;ct+=be){const Ve=Math.min(ct+be,E);for(let ze=0;ze<A;ze+=be){const Be=Math.min(ze+be,A);for(let ut=We;ut<dt;ut++)for(let Ke=ct;Ke<Ve;Ke++){let ee=0;for(let J=ze;J<Be;J++){const rt=O[Oe*B+ut*X+J*G],Ge=R[J*te+Ke*ge+it*ae];ee+=rt*Ge}De[Xe*Ne+(ut*E+Ke)]+=ee}}}}}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(k),t.makeTensorInfo(x,ke.dtype,ke.values)}const I2e={kernelName:Ov,backendName:"cpu",kernelFunc:wJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let f,d,p;const m=[];f=wJ({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(d=tv({inputs:{a:f,b:o},backend:t}),m.push(f),f=d),u&&(p=DI(t,f,u,a,h),m.push(f),f=p);for(const y of m)t.disposeIntermediateTensorInfo(y);return f}const M2e={kernelName:Hb,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2e=$r(Vg,n=>Math.acos(n)),$2e={kernelName:Vg,backendName:"cpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R2e=$r(Ug,n=>Math.acosh(n)),P2e={kernelName:Ug,backendName:"cpu",kernelFunc:R2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D2e(n){const{inputs:e,backend:t}=n,r=e;Zt(e,"addN");const s=r.map(a=>t.data.get(a.dataId).values),i=Sn(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const O2e={kernelName:Nv,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"all");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=Sa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("all",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];x=x&&S}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const L2e={kernelName:qS,backendName:"cpu",kernelFunc:F2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"any");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=Sa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("any",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];x=x||S}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const B2e={kernelName:XS,backendName:"cpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMax");let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Sa({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),o=[o[0]],fi("argMax",o,l.shape.length);const[u,h]=Qs(l.shape,o),f=Te(u),d=ji(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const S=m[y+w];S>b&&(b=S,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const U2e={kernelName:$v,backendName:"cpu",kernelFunc:V2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMin");let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Sa({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),o=[o[0]],fi("argMin",o,l.shape.length);const[u,h]=Qs(l.shape,o),f=Te(u),d=ji(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const S=m[y+w];S<b&&(b=S,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const G2e={kernelName:Rv,backendName:"cpu",kernelFunc:W2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H2e=$r(Wg,n=>Math.asin(n)),j2e={kernelName:Wg,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q2e=$r(Gg,n=>Math.asinh(n)),X2e={kernelName:Gg,backendName:"cpu",kernelFunc:q2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K2e=$r(Hg,n=>Math.atan(n)),Y2e={kernelName:Hg,backendName:"cpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z2e=ei((n,e)=>Math.atan2(n,e)),J2e=Pi(qg,Z2e),Q2e={kernelName:qg,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eCe=$r(jg,n=>Math.atanh(n)),tCe={kernelName:jg,backendName:"cpu",kernelFunc:eCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n,e,t,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,d=s.padInfo.left,p=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Sn(s.outShape,t),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const S=w*y,C=w*r[0];for(let k=0;k<s.inChannels;++k)for(let A=0;A<s.outHeight;++A){const M=A*o-f,E=Math.max(0,M),N=Math.min(s.inHeight,u+M),O=S+A*b;for(let R=0;R<s.outWidth;++R){const D=R*a-d,z=Math.max(0,D),B=Math.min(s.inWidth,h+D);let X=p,G=0,te=0;for(let ae=E;ae<N;ae+=l){const Ne=C+ae*r[1];for(let ke=z;ke<B;ke+=c){const De=Ne+ke*r[2],be=n[De+k];i==="max"&&be>X?X=be:i==="avg"&&(G+=be,te++)}if(isNaN(X))break}const ge=O+R*x+k;g[ge]=i==="avg"?G/te:X}}}return m}function xJ(n,e,t,r,s=!1,i=!1){const o=Sn(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,m=Sn(e,t,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const x=b*a-d;let w=x;for(;w<0;)w+=c;const S=Math.min(r.inHeight,h+x);for(let C=0;C<r.outWidth;++C){const k=C*l-p;let A=k;for(;A<0;)A+=u;const M=Math.min(r.inWidth,f+k);let E=Number.NEGATIVE_INFINITY,N=-1;for(let O=w;O<S;O+=c){const R=O-x;for(let D=A;D<M;D+=u){const z=D-k,B=m.get(g,O,D,y);B>E&&(E=B,s?N=i?((g*r.inHeight+O)*r.inWidth+D)*r.inChannels+y:(O*r.inWidth+D)*r.inChannels+y:N=R*f+z)}}o.set(N,g,b,C,y)}}return o}function _J(n,e,t,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterDepth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Sn(s.outShape,t),w=x.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let M=0;M<s.batchSize;++M){const E=M*S,N=M*r[0];for(let O=0;O<s.inChannels;++O)for(let R=0;R<s.outDepth;++R){const D=R*o-m;let z=D;for(;z<0;)z+=c;const B=Math.min(s.inDepth,f+D),X=E+R*C;for(let G=0;G<s.outHeight;++G){const te=G*a-g;let ge=te;for(;ge<0;)ge+=u;const ae=Math.min(s.inHeight,d+te),Ne=X+G*k;for(let ke=0;ke<s.outWidth;++ke){const De=ke*l-y;let be=De;for(;be<0;)be+=h;const Xe=Math.min(s.inWidth,p+De),Oe=Ne+ke*A;let it=b,We=0,dt=0;for(let Ve=z;Ve<B;Ve+=c){const ze=N+Ve*r[1];for(let Be=ge;Be<ae;Be+=u){const ut=ze+Be*r[2];for(let Ke=be;Ke<Xe;Ke+=h){const ee=ut+Ke*r[3],J=n[ee+O];if(i==="max"&&J>it?it=J:i==="avg"&&(We+=J,dt++),isNaN(it))break}if(isNaN(it))break}if(isNaN(it))break}const ct=Oe+O;w[ct]=i==="avg"?We/Math.max(dt,1):it}}}}return x}function nCe(n,e){const t=Sn(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*r-f;let x=b;for(;x<0;)x+=o;const w=Math.min(e.inDepth,c+b);for(let S=0;S<e.outHeight;++S){const C=S*s-d;let k=C;for(;k<0;)k+=a;const A=Math.min(e.inHeight,u+C);for(let M=0;M<e.outWidth;++M){const E=M*i-p;let N=E;for(;N<0;)N+=l;const O=Math.min(e.inWidth,h+E);let R=Number.NEGATIVE_INFINITY,D=-1;for(let z=x;z<w;z+=o){const B=z-b;for(let X=k;X<A;X+=a){const G=X-C;for(let te=N;te<O;te+=l){const ge=te-E,ae=n.get(m,z,X,te,g);ae>=R&&(R=ae,D=B*u*h+G*u+ge)}}}t.set(D,m,y,S,M,g)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=Sh({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=fB(f,s.shape,s.dtype,d,u,"avg");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const sCe={kernelName:Pv,backendName:"cpu",kernelFunc:rCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"avgPool3d");const u=Ll(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=_J(h,s.shape,s.dtype,Jt(s.shape),u,"avg");return t.makeTensorInfo(f.shape,"float32",f.values)}const oCe={kernelName:Dv,backendName:"cpu",kernelFunc:iCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"avgPool3DGrad");const u=Ll(i.shape,o,a,1,l,c),h=u.strideDepth,f=u.strideHeight,d=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,w=u.effectiveFilterDepth,S=u.effectiveFilterHeight,C=u.effectiveFilterWidth,k=w-1-u.padInfo.front,A=C-1-u.padInfo.left,M=S-1-u.padInfo.top,E=Sn(i.shape,"float32"),N=1/(p*m*g),O=t.bufferSync(s);for(let R=0;R<u.batchSize;++R)for(let D=0;D<u.inChannels;++D)for(let z=0;z<u.inDepth;++z)for(let B=0;B<u.inHeight;++B)for(let X=0;X<u.inWidth;++X){const G=z-k,te=B-M,ge=X-A;let ae=0;for(let Ne=0;Ne<w;Ne+=y){const ke=(G+Ne)/h;if(!(ke<0||ke>=u.outDepth||Math.floor(ke)!==ke))for(let De=0;De<S;De+=b){const be=(te+De)/f;if(!(be<0||be>=u.outHeight||Math.floor(be)!==be))for(let Xe=0;Xe<C;Xe+=x){const Oe=(ge+Xe)/d;if(Oe<0||Oe>=u.outWidth||Math.floor(Oe)!==Oe)continue;const it=O.get(R,ke,be,Oe,D);ae+=it}}}E.set(ae*N,R,z,B,X,D)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const lCe={kernelName:YS,backendName:"cpu",kernelFunc:aCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;Zt([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=u.strideHeight,f=u.strideWidth,d=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,w=y-1-u.padInfo.top,S=Sn(o.shape,"float32"),C=1/(d*p),k=t.data.get(s.dataId).values,A=Sn(s.shape,"float32",k);for(let M=0;M<u.batchSize;++M)for(let E=0;E<u.inChannels;++E)for(let N=0;N<u.inHeight;++N)for(let O=0;O<u.inWidth;++O){const R=N-w,D=O-x;let z=0;for(let B=0;B<y;B+=m){const X=(R+B)/h;if(!(X<0||X>=u.outHeight||Math.floor(X)!==X))for(let G=0;G<b;G+=g){const te=(D+G)/f;if(te<0||te>=u.outWidth||Math.floor(te)!==te)continue;const ge=A.get(M,X,te,E);z+=ge}}S.set(z*C,M,N,O,E)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const uCe={kernelName:KS,backendName:"cpu",kernelFunc:cCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=e;U(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Zt([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const u=t.data.get(s.dataId).values,h=t.data.get(a.dataId).values,f=t.data.get(l.dataId).values,d=i?t.data.get(i.dataId).values:new Float32Array([1]),p=o?t.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=d.length,b=f.length,x=h.length;let w=0,S=0,C=0,k=0;for(let A=0;A<u.length;++A)m[A]=p[w++]+(u[A]-h[S++])*d[C++]/Math.sqrt(f[k++]+c),w>=g&&(w=0),S>=x&&(S=0),C>=y&&(C=0),k>=b&&(k=0);return t.makeTensorInfo(s.shape,s.dtype,m)}const fCe={kernelName:Xv,backendName:"cpu",kernelFunc:hCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;Zt([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Vy(s.shape,i,a),c=Uy(l.length,i.length),u=Wy(s.shape,i,a),h=gN(o,i.length),f=yN(u,o,i.length),d=es({inputs:{x:s},backend:t,attrs:{shape:l}}),p=Sa({inputs:{x:d},backend:t,attrs:{perm:c}}),m=es({inputs:{x:p},backend:t,attrs:{shape:u}}),g=mg({inputs:{x:m},backend:t,attrs:{begin:h,size:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const pCe={kernelName:Fv,backendName:"cpu",kernelFunc:dCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=aB(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const gCe={kernelName:ZS,backendName:"cpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yCe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const bCe={kernelName:QS,backendName:"cpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCe=$r(Yg,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),wCe={kernelName:Yg,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xCe=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Te(e.shape)),s=t.data.get(e.dataId),i=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];r[c]=Math.hypot(u,h)}return t.makeOutput(r,e.shape,"float32")},_Ce={kernelName:Lv,backendName:"cpu",kernelFunc:xCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.imag,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const SCe={kernelName:v2,backendName:"cpu",kernelFunc:nv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(m=>m.shape);dN(o,i);let a=ba(e.map(m=>m.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(m=>Te(m.shape)>0);if(l.length===1)return Sh({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(w=>pg({inputs:{input:w},backend:t})),g=l.map(w=>nv({inputs:{input:w},backend:t})),y=rv({inputs:m,backend:t,attrs:{axis:i}}),b=rv({inputs:g,backend:t,attrs:{axis:i}}),x=Wa({inputs:{real:y,imag:b},backend:t});return m.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}const c=l.map(m=>{const y=[-1,Te(m.shape.slice(i))];return es({inputs:{x:m},backend:t,attrs:{shape:y}})}),u=c.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=ba(c.map(m=>m.shape),1);const h=c[0].shape[0]===1,f=TZ(u,a,e[0].dtype,h),d=ba(l.map(m=>m.shape),i),p=t.makeTensorInfo(d,e[0].dtype,f);return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const CCe={kernelName:zv,backendName:"cpu",kernelFunc:rv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Zt([s,i],"conv2d");const h=nl(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h),d=f.filterHeight,p=f.filterWidth,m=f.dilationHeight,g=f.dilationWidth,y=f.padInfo.left,b=f.padInfo.top,x=f.dataFormat==="channelsLast",w=new li(f.outShape,s.dtype),S=Jt(s.shape),C=Jt(i.shape),k=S[0],A=x?S[1]:S[2],M=x?S[2]:1,E=x?1:S[1],N=w.strides[0],O=x?w.strides[1]:w.strides[2],R=x?w.strides[2]:1,D=x?1:w.strides[1],z=t.data.get(s.dataId).values,B=t.data.get(i.dataId).values,X=w.values;for(let G=0;G<f.batchSize;++G){const te=G*k,ge=G*N;for(let ae=0;ae<f.outHeight;++ae){const Ne=ge+ae*O,ke=ae*f.strideHeight-b;for(let De=0;De<d;++De){const be=ke+De*m;if(be<0||be>=f.inHeight)continue;const Xe=De*C[0],Oe=te+be*A;for(let it=0;it<f.outWidth;++it){const We=Ne+it*R,dt=it*f.strideWidth-y;for(let ct=0;ct<p;++ct){const Ve=dt+ct*g;if(Ve<0||Ve>=f.inWidth)continue;const ze=Xe+ct*C[1],Be=Oe+Ve*M;let ut=ze;for(let Ke=0;Ke<f.inChannels;++Ke){const ee=z[Be+Ke*E];for(let J=0;J<f.outChannels;++J)X[We+J*D]+=ee*B[ut+J];ut+=f.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,X)}const kCe={kernelName:Bv,backendName:"cpu",kernelFunc:SJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"conv2dBackpropFilter");const h=nl(l),f=ts(s.shape,u,o,1,a,c,!1,h),{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:g}=f,y=f.dataFormat==="channelsLast",b=new li(f.filterShape,"float32"),x=f.padInfo.left,w=f.padInfo.top,S=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=new li(s.shape,s.dtype,S),A=new li(i.shape,i.dtype,C);for(let M=0;M<m;++M){const E=Math.max(0,Math.ceil((w-M)/d)),N=Math.min(f.outHeight,(f.inHeight+w-M)/d);for(let O=0;O<g;++O){const R=Math.max(0,Math.ceil((x-O)/p)),D=Math.min(f.outWidth,(f.inWidth+x-O)/p);for(let z=0;z<f.inChannels;++z)for(let B=0;B<f.outChannels;++B){let X=0;for(let G=0;G<f.batchSize;++G)for(let te=E;te<N;++te){const ge=M+te*d-w;for(let ae=R;ae<D;++ae){const Ne=O+ae*p-x;y?X+=k.get(G,ge,Ne,z)*A.get(G,te,ae,B):X+=k.get(G,z,ge,Ne)*A.get(G,B,te,ae)}}b.set(X,M,O,z,B)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const ECe={kernelName:t2,backendName:"cpu",kernelFunc:TCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ICe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Zt([s,i],"conv2dBackpropInput");const h=Jt(i.shape),f=Jt(s.shape);let d=nl(c);const p=ts(o,i.shape,a,1,l,u,!1,d),m=new li(p.inShape,"float32"),g=m.values,y=t.data.get(s.dataId).values,b=t.data.get(i.dataId).values,[x,w,S]=h,{batchSize:C,filterHeight:k,filterWidth:A,inChannels:M,inHeight:E,inWidth:N,outChannels:O,outHeight:R,outWidth:D,strideHeight:z,strideWidth:B}=p;d=p.dataFormat;const X=k-1-p.padInfo.top,G=A-1-p.padInfo.left,te=d==="channelsLast",ge=m.strides[0],ae=te?m.strides[1]:m.strides[2],Ne=te?m.strides[2]:1,ke=te?1:m.strides[1],De=f[0],be=te?f[1]:f[2],Xe=te?f[2]:1,Oe=te?1:f[1];for(let it=0;it<C;++it)for(let We=0;We<M;++We)for(let dt=0;dt<E;++dt){const ct=dt-X,Ve=Math.max(0,Math.ceil(ct/z)),ze=Math.min(R,(k+ct)/z);for(let Be=0;Be<N;++Be){const ut=Be-G,Ke=Math.max(0,Math.ceil(ut/B)),ee=Math.min(D,(A+ut)/B);let J=0;for(let Ge=Ve;Ge<ze;++Ge){const ye=Ge*z-ct;for(let Ze=Ke;Ze<ee;++Ze){const yt=Ze*B-ut,Ct=De*it+be*Ge+Xe*Ze,ft=x*(k-1-ye)+w*(A-1-yt)+S*We;for(let ce=0;ce<O;++ce){const nt=y[Ct+Oe*ce],St=b[ft+ce];J+=nt*St}}}const rt=ge*it+ae*dt+Ne*Be+ke*We;g[rt]=J}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const ACe={kernelName:Vv,backendName:"cpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r;Zt([s,i],"conv3d");const c=Lu(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:f,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,x=g.top,w=new li(c.outShape,s.dtype),S=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=w.values,A=Jt(s.shape),M=Jt(i.shape);for(let E=0;E<c.batchSize;++E){const N=E*A[0],O=E*w.strides[0];for(let R=0;R<c.outDepth;++R){const D=O+R*w.strides[1],z=R*c.strideDepth-y;for(let B=0;B<u;++B){const X=z+B*d;if(X<0||X>=c.inDepth)continue;const G=B*M[0],te=N+X*A[1];for(let ge=0;ge<c.outHeight;++ge){const ae=D+ge*w.strides[2],Ne=ge*c.strideHeight-x;for(let ke=0;ke<h;++ke){const De=Ne+ke*p;if(De<0||De>=c.inHeight)continue;const be=G+ke*M[1],Xe=te+De*A[2];for(let Oe=0;Oe<c.outWidth;++Oe){const it=ae+Oe*c.outChannels,We=Oe*c.strideWidth-b;for(let dt=0;dt<f;++dt){const ct=We+dt*m;if(ct<0||ct>=c.inWidth)continue;const Ve=be+dt*M[2],ze=Xe+ct*c.inChannels;let Be=Ve;for(let ut=0;ut<c.inChannels;++ut){const Ke=S[ze+ut];for(let ee=0;ee<c.outChannels;++ee)k[it+ee]+=Ke*C[Be+ee];Be+=c.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const NCe={kernelName:Uv,backendName:"cpu",kernelFunc:MCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ce(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r;Zt([s,i],"conv3dBackpropFilterV2");const c=Jt(s.shape),u=Jt(i.shape),h=Lu(s.shape,l,o,1,a),f=h.strideDepth,d=h.strideHeight,p=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new li(h.filterShape,"float32"),x=b.values,[w,S,C,k]=b.strides,A=t.data.get(i.dataId).values,[M,E,N,O]=u,R=t.data.get(s.dataId).values,[D,z,B,X]=c,G=h.padInfo.front,te=h.padInfo.left,ge=h.padInfo.top;for(let ae=0;ae<m;++ae){const Ne=Math.max(0,Math.ceil((G-ae)/f)),ke=Math.min(h.outDepth,(h.inDepth+G-ae)/f),De=ae*w;for(let be=0;be<g;++be){const Xe=Math.max(0,Math.ceil((ge-be)/d)),Oe=Math.min(h.outHeight,(h.inHeight+ge-be)/d),it=be*S+De;for(let We=0;We<y;++We){const dt=Math.max(0,Math.ceil((te-We)/p)),ct=Math.min(h.outWidth,(h.inWidth+te-We)/p),Ve=We*C+it;for(let ze=0;ze<h.inChannels;++ze){const Be=ze*k+Ve;for(let ut=0;ut<h.outChannels;++ut){let Ke=0;for(let ee=0;ee<h.batchSize;++ee){const J=ee*D,rt=ee*M;for(let Ge=Ne;Ge<ke;++Ge){const Ze=(ae+Ge*f-G)*z+J,yt=Ge*E+rt;for(let Ct=Xe;Ct<Oe;++Ct){const ce=(be+Ct*d-ge)*B+Ze,nt=Ct*N+yt;for(let St=dt;St<ct;++St){const Gt=(We+St*p-te)*X+ce,Mn=St*O+nt;Ke+=R[Gt+ze]*A[Mn+ut]}}}}x[Be+ut]=Ke}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const RCe={kernelName:n2,backendName:"cpu",kernelFunc:$Ce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r;Zt([s],"conv3dBackpropInputV2");const c=Jt(s.shape),u=Jt(i.shape),h=Lu(l,i.shape,a,1,o),f=new li(h.inShape,"float32"),d=f.values,[p,m,g,y]=f.strides,b=t.data.get(s.dataId).values,[x,w,S,C]=c,k=t.data.get(i.dataId).values,[A,M,E,N]=u,{batchSize:O,filterDepth:R,filterHeight:D,filterWidth:z,inChannels:B,inDepth:X,inHeight:G,inWidth:te,outChannels:ge,outDepth:ae,outHeight:Ne,outWidth:ke,strideDepth:De,strideHeight:be,strideWidth:Xe}=h,Oe=R-1-h.padInfo.front,it=D-1-h.padInfo.top,We=z-1-h.padInfo.left;for(let dt=0;dt<O;++dt)for(let ct=0;ct<B;++ct)for(let Ve=0;Ve<X;++Ve){const ze=Ve-Oe,Be=Math.max(0,Math.ceil(ze/De)),ut=Math.min(ae,(R+ze)/De);for(let Ke=0;Ke<G;++Ke){const ee=Ke-it,J=Math.max(0,Math.ceil(ee/be)),rt=Math.min(Ne,(D+ee)/be);for(let Ge=0;Ge<te;++Ge){const ye=Ge-We,Ze=Math.max(0,Math.ceil(ye/Xe)),yt=Math.min(ke,(z+ye)/Xe);let Ct=0;for(let ft=Be;ft<ut;++ft){const ce=ft*De-ze;for(let nt=J;nt<rt;++nt){const St=nt*be-ee;for(let gt=Ze;gt<yt;++gt){const Gt=gt*Xe-ye,Mn=x*dt+w*ft+S*nt+C*gt,Cr=A*(R-1-ce)+M*(D-1-St)+E*(z-1-Gt)+N*ct;for(let Bs=0;Bs<ge;++Bs){const As=b[Mn+Bs],Ms=k[Cr+Bs];Ct+=As*Ms}}}}d[p*dt+m*Ve+g*Ke+y*Ge+ct]=Ct}}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const DCe={kernelName:r2,backendName:"cpu",kernelFunc:PCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OCe=$r(Zg,n=>Math.cos(n)),FCe={kernelName:Zg,backendName:"cpu",kernelFunc:OCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LCe=$r(Jg,n=>Math.cosh(n)),zCe={kernelName:Jg,backendName:"cpu",kernelFunc:LCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,[u,h,f,d]=s.shape,p=i.shape[0],[m,g]=a,y=Sn([p,m,g,d],"float32"),b=t.data.get(i.dataId).values,x=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,S=Jt(s.shape),C=Jt(y.shape);for(let k=0;k<p;k++){const A=k*4,M=b[A],E=b[A+1],N=b[A+2],O=b[A+3],R=x[k];if(R>=u)continue;const D=m>1?(N-M)*(h-1)/(m-1):0,z=g>1?(O-E)*(f-1)/(g-1):0;for(let B=0;B<m;B++){const X=m>1?M*(h-1)+B*D:.5*(M+N)*(h-1);if(X<0||X>h-1){for(let G=0;G<g;G++)for(let te=0;te<d;te++){const ge=te+G*C[2]+B*C[1]+k*C[0];y.values[ge]=c}continue}if(l==="bilinear"){const G=Math.floor(X),te=Math.ceil(X),ge=X-G;for(let ae=0;ae<g;ae++){const Ne=g>1?E*(f-1)+ae*z:.5*(E+O)*(f-1);if(Ne<0||Ne>f-1){for(let Xe=0;Xe<d;Xe++){const Oe=Xe+ae*C[2]+B*C[1]+k*C[0];y.values[Oe]=c}continue}const ke=Math.floor(Ne),De=Math.ceil(Ne),be=Ne-ke;for(let Xe=0;Xe<d;Xe++){let Oe=Xe+ke*S[2]+G*S[1]+R*S[0];const it=w[Oe];Oe=Xe+De*S[2]+G*S[1]+R*S[0];const We=w[Oe];Oe=Xe+ke*S[2]+te*S[1]+R*S[0];const dt=w[Oe];Oe=Xe+De*S[2]+te*S[1]+R*S[0];const ct=w[Oe],Ve=it+(We-it)*be,ze=dt+(ct-dt)*be;Oe=Xe+ae*C[2]+B*C[1]+k*C[0],y.values[Oe]=Ve+(ze-Ve)*ge}}}else for(let G=0;G<g;++G){const te=g>1?E*(f-1)+G*z:.5*(E+O)*(f-1);if(te<0||te>f-1){for(let Ne=0;Ne<d;Ne++){const ke=Ne+G*C[2]+B*C[1]+k*C[0];y.values[ke]=c}continue}const ge=Math.round(te),ae=Math.round(X);for(let Ne=0;Ne<d;Ne++){const ke=Ne+ge*S[2]+ae*S[1]+R*S[0],De=Ne+G*C[2]+B*C[1]+k*C[0];y.values[De]=w[ke]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const VCe={kernelName:i2,backendName:"cpu",kernelFunc:BCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumprod");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=Sa({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=ns(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Mi(c.dtype,"int32"),f=CM(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?1:d[x];else{const w=m(y,b-1);f[x]=o?d[w]*f[w]:d[x]*f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Oh(l),b=Sa({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const WCe={kernelName:s2,backendName:"cpu",kernelFunc:UCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumsum");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=Sa({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=ns(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Mi(c.dtype,"int32"),f=ji(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?0:d[x];else{const w=m(y,b-1);f[x]=o?d[w]+f[w]:d[x]+f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Oh(l),b=Sa({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const HCe={kernelName:Wv,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=aB(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=SZ(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const qCe={kernelName:o2,backendName:"cpu",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r;U(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],h=l*i,f=c*i,d=u/(i*i),p=t.data.get(s.dataId).values,m=new Float32Array(a*h*f*d);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const x=Math.floor(b/i),w=b%i;for(let S=0;S<f;++S){const C=Math.floor(S/i),k=S%i,A=(w*i+k)*d;for(let M=0;M<d;++M){const N=M+A+u*(C+c*(x+l*y));m[g++]=p[N]}}}return t.makeTensorInfo([a,h,f,d],s.dtype,m)}const KCe={kernelName:a2,backendName:"cpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Zt([s,i],"depthwiseConv2DNative");const u=Jt(s.shape),h=Jt(i.shape);let f=l;f==null&&(f=[1,1]),U(Ri(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const d=ts(s.shape,i.shape,o,f,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,x=b.left,w=b.top,S=d.outChannels/d.inChannels,C=new li(d.outShape,s.dtype),k=t.data.get(s.dataId).values,A=t.data.get(i.dataId).values,M=C.values;for(let E=0;E<d.batchSize;++E){const N=E*u[0],O=E*C.strides[0];for(let R=0;R<d.outHeight;++R){const D=O+R*C.strides[1],z=R*d.strideHeight-w;for(let B=0;B<p;++B){const X=z+B*g;if(X<0||X>=d.inHeight)continue;const G=B*h[0],te=N+X*u[1];for(let ge=0;ge<d.outWidth;++ge){const ae=D+ge*C.strides[2],Ne=ge*d.strideWidth-x;for(let ke=0;ke<m;++ke){const De=Ne+ke*y;if(De<0||De>=d.inWidth)continue;const be=G+ke*h[1],Xe=te+De*d.inChannels;let Oe=ae,it=be;for(let We=0;We<d.inChannels;++We){const dt=k[Xe+We];for(let ct=0;ct<S;++ct)M[Oe+ct]+=dt*A[it+ct];Oe+=S,it+=S}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const YCe={kernelName:Gv,backendName:"cpu",kernelFunc:CJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"depthwiseConv2dNativeBackpropFilter");const h=ts(s.shape,u,o,a,l,c,!0),{strideHeight:f,strideWidth:d,filterHeight:p,filterWidth:m}=h,g=new li(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,w=t.data.get(s.dataId).values,S=new li(s.shape,s.dtype,w),C=t.data.get(i.dataId).values,k=new li(i.shape,i.dtype,C);for(let A=0;A<p;++A){const M=Math.max(0,Math.ceil((b-A)/f)),E=Math.min(h.outHeight,(h.inHeight+b-A)/f);for(let N=0;N<m;++N){const O=Math.max(0,Math.ceil((y-N)/d)),R=Math.min(h.outWidth,(h.inWidth+y-N)/d);for(let D=0;D<h.outChannels;++D){const z=Math.trunc(D/x),B=D%x;let X=0;for(let G=0;G<h.batchSize;++G)for(let te=M;te<E;++te){const ge=A+te*f-b;for(let ae=O;ae<R;++ae){const Ne=N+ae*d-y;X+=S.get(G,ge,Ne,z)*k.get(G,te,ae,D)}}g.set(X,A,N,z,B)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const JCe={kernelName:l2,backendName:"cpu",kernelFunc:ZCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Zt([s,i],"depthwiseConv2DNativeBackpropInput");const h=Jt(s.shape),f=Jt(i.shape),d=ts(u,i.shape,o,a,l,c,!0),p=new li(d.inShape,"float32"),m=p.values,[g,y,b]=p.strides,x=t.data.get(s.dataId).values,[w,S,C]=h,k=t.data.get(i.dataId).values,[A,M,E]=f,{batchSize:N,filterHeight:O,filterWidth:R,inChannels:D,inHeight:z,inWidth:B,outChannels:X,outHeight:G,outWidth:te,strideHeight:ge,strideWidth:ae}=d,Ne=O-1-d.padInfo.top,ke=R-1-d.padInfo.left,De=X/D;for(let be=0;be<N;++be)for(let Xe=0;Xe<D;++Xe)for(let Oe=0;Oe<z;++Oe){const it=Oe-Ne,We=Math.max(0,Math.ceil(it/ge)),dt=Math.min(G,(O+it)/ge);for(let ct=0;ct<B;++ct){const Ve=ct-ke,ze=Math.max(0,Math.ceil(Ve/ae)),Be=Math.min(te,(R+Ve)/ae);let ut=0;for(let Ke=We;Ke<dt;++Ke){const ee=Ke*ge-it;for(let J=ze;J<Be;++J){const rt=J*ae-Ve,Ge=w*be+S*Ke+C*J,ye=A*(O-1-ee)+M*(R-1-rt)+E*Xe;for(let Ze=0;Ze<De;++Ze){const yt=Xe*De+Ze,Ct=x[Ge+yt],ft=k[ye+Ze];ut+=Ct*ft}}}m[g*be+y*Oe+b*ct+Xe]=ut}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const eke={kernelName:c2,backendName:"cpu",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tke(n){const{inputs:e,backend:t}=n,{x:r}=e,s=Te(r.shape),i=t.data.get(r.dataId).values,o=Sn([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const nke={kernelName:u2,backendName:"cpu",kernelFunc:tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rke={kernelName:Hv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=t,l=e,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(s.dataId).values,f=s.shape.length,{batchSize:d,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:S,filterHeight:C,filterWidth:k,dilationHeight:A,dilationWidth:M,outShape:E}=Pp(r.shape,s.shape,i,o,"NHWC",a),N=Te(E),O=E.length,R=Ss(r.dtype,N);for(let z=0;z<d;++z)for(let B=0;B<y;++B){const X=B*w-x.top;for(let G=0;G<b;++G){const te=G*S-x.left;for(let ge=0;ge<g;++ge){let ae=Number.MIN_SAFE_INTEGER;for(let ke=0;ke<C;++ke){const De=X+ke*A;if(De>=0&&De<p)for(let be=0;be<k;++be){const Xe=te+be*M;if(Xe>=0&&Xe<m){const Oe=gu([z,De,Xe,ge],u,Jt(r.shape)),it=gu([ke,be,ge],f,Jt(s.shape)),We=c[Oe]+h[it];We>ae&&(ae=We)}}}const Ne=gu([z,B,G,ge],O,Jt(E));R[Ne]=ae}}}return{dataId:l.write($p(R,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ske={kernelName:b_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Tl(r.shape,c.data.get(r.dataId).values),h=Tl(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=Pp(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${b_}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const E=Tl(M,c.data.get(i.dataId).values),N=NL(s.shape,s.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let te=Number.MIN_SAFE_INTEGER,ge=0,ae=0;for(let Ne=0;Ne<S;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Xe=u[R][ke][be][G]+h[Ne][De][G];Xe>te&&(te=Xe,ge=Ne,ae=De)}}}N[ge][ae][G]+=E[R][D][B][G]}}}return{dataId:c.write($p(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ike={kernelName:y_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Tl(r.shape,c.data.get(r.dataId).values),h=Tl(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=Pp(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${y_}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const E=Tl(M,c.data.get(i.dataId).values),N=NL(r.shape,r.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let te=Number.MIN_SAFE_INTEGER,ge=z<0?0:z,ae=X<0?0:X;for(let Ne=0;Ne<S;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Xe=u[R][ke][be][G]+h[Ne][De][G];Xe>te&&(te=Xe,ge=ke,ae=be)}}}N[R][ge][ae][G]+=E[R][D][B][G]}}}return{dataId:c.write($p(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oke(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,u=(a==null?void 0:a.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(u,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[f,d]=s.shape.slice(0,2),p=s.shape.length===2?1:s.shape[2],m=t.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let x=0;x<f*d;++x){const w=[0,0,0,255*c];for(let C=0;C<p;C++){const k=m[x*p+C];if(s.dtype==="float32"){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if(s.dtype==="int32"&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);p===1?(w[0]=k*g,w[1]=k*g,w[2]=k*g):w[C]=k*g}const S=x*4;y[S+0]=Math.round(w[0]),y[S+1]=Math.round(w[1]),y[S+2]=Math.round(w[2]),y[S+3]=Math.round(w[3])}i.width=d,i.height=f;const b=new ImageData(y,d,f);return h.putImageData(b,0,0),s}const ake={kernelName:h2,backendName:"cpu",kernelFunc:oke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"sum");let a;s.dtype==="bool"?a=fp({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):a=Sh({inputs:{x:s},backend:t});const l=a.shape.length,c=An(i,a.shape),u=Lr(c,l);let h=c,f=a;u!=null&&(f=Sa({inputs:{x:a},backend:t,attrs:{perm:u}}),h=ns(h.length,l)),fi("sum",h,f.shape.length);const[d,p]=Qs(f.shape,h),m=Mi(f.dtype,"int32");let g=RI(t,d,m);const y=Te(p),b=t.data.get(g.dataId).values,x=t.data.get(f.dataId).values;for(let w=0;w<b.length;++w){const S=w*y;let C=0;for(let k=0;k<y;++k)C+=x[S+k];b[w]=C}if(o){const w=Ls(g.shape,c),S=g;g=es({inputs:{x:g},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(f),g}const lke={kernelName:Cw,backendName:"cpu",kernelFunc:pC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cke(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=CN(s,i.length);TN(o.length,l,i);const{path:c,steps:u}=EN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=kN(d,l[g]);let x;IN(y)?x=i[g]:(x=Sa({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=es({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=$N({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=pC({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const uke={kernelName:f2,backendName:"cpu",kernelFunc:cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(n){const{inputs:e,backend:t}=n,{dy:r,y:s}=e;Zt([r,s],"eluGrad");const i=new Float32Array(Te(s.shape)),o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return t.makeTensorInfo(s.shape,"float32",i)}const fke={kernelName:d2,backendName:"cpu",kernelFunc:hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dke=bN,pke=vN,mke=wN,gke=xN,yke=_N,bke=SN,vke=$r(ty,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+dke*t);return e*(1-((((bke*r+yke)*r+gke)*r+mke)*r+pke)*r*Math.exp(-t*t))}),wke={kernelName:ty,backendName:"cpu",kernelFunc:vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){const{inputs:e,backend:t,attrs:r}=n,{input:s}=e,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(U(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),es({inputs:{x:s},backend:t,attrs:{shape:a}})}const xke={kernelName:qv,backendName:"cpu",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ke=ei((n,e)=>n/e),dB=Pi(Qg,_ke),DD={kernelName:Qg,backendName:"cpu",kernelFunc:dB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(n,e,t){const r=n.shape,s=r[0],i=r[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=Te(c),h=ci("float32",u),f=ci("float32",u);for(let g=0;g<s;g++){const y=mg({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,i]}}),b=mg({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,i]}}),x=Wa({inputs:{real:y,imag:b},backend:t}),{real:w,imag:S}=Ske(x,e,t),C=xu(w,S);for(let k=0;k<i;k++){const A=sB(C,k);h[g*i+k]=A.real,f[g*i+k]=A.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x)}const d=t.makeTensorInfo(c,"float32",h),p=t.makeTensorInfo(c,"float32",f),m=Wa({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}function Ske(n,e,t){const r=Te(n.shape),s=t.data.get(n.dataId),i=t.data.get(s.complexTensorInfos.real.dataId).values,o=t.data.get(s.complexTensorInfos.imag.dataId).values;if(Cke(r)){const a=OD(i,o,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Hf(r,"float32")),f=Sh({inputs:{x:h},backend:t}),d=DD.kernelFunc({inputs:{a:c,b:h},backend:t}),p=DD.kernelFunc({inputs:{a:u,b:f},backend:t}),m=t.data.get(d.dataId).values,g=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}else{const a=xu(i,o),l=kke(a,r,e);return QY(l)}}function Cke(n){return(n&n-1)===0}function OD(n,e,t,r,s){if(t===1)return{real:n,imag:e};const i=xu(n,e),o=t/2,a=eZ(i),l=a.real,c=a.imag,u=[l.length],h=s.makeTensorInfo(u,"float32",l),f=s.makeTensorInfo(u,"float32",c),d=Wa({inputs:{real:h,imag:f},backend:s}),p=tZ(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=Wa({inputs:{real:b,imag:x},backend:s}),S=OD(l,c,o,r,s),C=S.real,k=S.imag,A=[C.length],M=s.makeTensorInfo(A,"float32",C),E=s.makeTensorInfo(A,"float32",k),N=Wa({inputs:{real:M,imag:E},backend:s}),O=OD(m,g,o,r,s),R=O.real,D=O.imag,z=[R.length],B=s.makeTensorInfo(z,"float32",R),X=s.makeTensorInfo(z,"float32",D),G=Wa({inputs:{real:B,imag:X},backend:s}),te=rZ(t,r),ge=[te.real.length],ae=s.makeTensorInfo(ge,"float32",te.real),Ne=s.makeTensorInfo(ge,"float32",te.imag),ke=Wa({inputs:{real:ae,imag:Ne},backend:s}),De=$N({inputs:{a:ke,b:G},backend:s}),be=tv({inputs:{a:N,b:De},backend:s}),Xe=hB({inputs:{a:N,b:De},backend:s}),Oe=pg({inputs:{input:be},backend:s}),it=pg({inputs:{input:Xe},backend:s}),We=nv({inputs:{input:be},backend:s}),dt=nv({inputs:{input:Xe},backend:s}),ct=rv({inputs:[Oe,it],backend:s,attrs:{axis:0}}),Ve=rv({inputs:[We,dt],backend:s,attrs:{axis:0}}),ze=s.data.get(ct.dataId).values,Be=s.data.get(Ve.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Xe),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(We),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(dt),s.disposeIntermediateTensorInfo(ct),s.disposeIntermediateTensorInfo(Ve),{real:ze,imag:Be}}function kke(n,e,t){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let i=0,o=0;for(let a=0;a<e;a++){const l=sZ(s*a,e,t),c=sB(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(i/=e,o/=e),nZ(r,i,o,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tke(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=es({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=kJ(a,!1,t),c=es({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Eke={kernelName:p2,backendName:"cpu",kernelFunc:Tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n){const{backend:e,attrs:t}=n,{shape:r,value:s,dtype:i}=t,o=i||Ap(s),a=Ss(o,Te(r));return Ake(a,s,o),e.makeTensorInfo(r,o,a)}const Ike={kernelName:m2,backendName:"cpu",kernelFunc:pB};function Ake(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mke={kernelName:g2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,s=t,i=ci(r.dtype,Te(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let f=0;f<o;f++){const d=f*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const x=Math.round(l-g-1),w=d+m+y+b;let S=u[w];if(x>=0&&x<l){const C=x*c,k=d+m+C+b;S=u[k]}i[w]=S}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=SJ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=es({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});m=tv({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=tv({inputs:{a:m,b:o},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){const g=m;if(u==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=es({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=DI(t,m,d,y,p),t.disposeIntermediateTensorInfo(y)}else m=DI(t,m,d,a,p);t.disposeIntermediateTensorInfo(g)}return m}const $ke={kernelName:jb,backendName:"cpu",kernelFunc:Nke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=CJ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;m=tv({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){const g=m;m=DI(t,m,d,a,p),t.disposeIntermediateTensorInfo(g)}return m}const Pke={kernelName:qb,backendName:"cpu",kernelFunc:Rke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dke(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=Te(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,h]=uC(r,s);if(c===0)return t.makeTensorInfo(l,r.dtype,[]);const f=t.data.get(s.dataId).values,d=t.bufferSync(r),p=PZ(f,d,r.dtype,c,a,u,h,r.shape,i);return t.makeTensorInfo(l,r.dtype,p.values)}const Oke={kernelName:y2,backendName:"cpu",kernelFunc:Dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r;Zt([s,i],"gatherV2");const l=An(o,s.shape)[0],c=t.data.get(i.dataId).values,u=s.shape[l];for(let w=0;w<c.length;++w){const S=c[w];U(S<=u-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const f=Te(i.shape),d=MN(s,i,l,h),p=es({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=es({inputs:{x:i},backend:t,attrs:{shape:[d.batchSize,f/d.batchSize]}}),g=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=t.bufferSync(m),b=t.bufferSync(p),x=DZ(b,y,g);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(d.outputShape,x.dtype,x.values)}const Lke={kernelName:Kv,backendName:"cpu",kernelFunc:Fke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zke(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=es({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=kJ(a,!0,t),c=es({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Bke={kernelName:b2,backendName:"cpu",kernelFunc:zke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke=$r(ly,n=>Number.isFinite(n)?1:0,"bool"),Uke={kernelName:ly,backendName:"cpu",kernelFunc:Vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wke=$r(cy,n=>Math.abs(n)===1/0?1:0,"bool"),Gke={kernelName:cy,backendName:"cpu",kernelFunc:Wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hke=$r(uy,n=>Number.isNaN(n)?1:0,"bool"),jke={kernelName:uy,backendName:"cpu",kernelFunc:Hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qke(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=BZ(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const Xke={kernelName:w2,backendName:"cpu",kernelFunc:qke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kke=$r(fy,n=>Math.log1p(n)),Yke={kernelName:fy,backendName:"cpu",kernelFunc:Kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zke=ei((n,e)=>n&&e),Jke=Pi(ew,Zke,null,"bool"),Qke={kernelName:ew,backendName:"cpu",kernelFunc:Jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eTe=$r(tw,n=>n?0:1,"bool"),tTe={kernelName:tw,backendName:"cpu",kernelFunc:eTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nTe=ei((n,e)=>n||e),rTe=Pi(nw,nTe,null,"bool"),sTe={kernelName:nw,backendName:"cpu",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Zt(s,"LRN");const c=s.shape[3],u=c-1,h=t.data.get(s.dataId).values,f=Te(s.shape),d=new Float32Array(f);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let x=0;for(;y<=b;y++){const w=h[y];x+=w*w}return x}for(let m=0;m<f;m++){const g=p(m),y=h[m]*Math.pow(o+a*g,-l);d[m]=y}return t.makeTensorInfo(s.shape,s.dtype,d)}const oTe={kernelName:rw,backendName:"cpu",kernelFunc:iTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Zt(o,"LRNGrad");const h=Te(o.shape),f=o.shape[3],d=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const x=b%f,w=b-x+Math.max(0,x-a),S=b-x+Math.min(f,x+a+1);let C=0;for(let k=w;k<S;k++)C+=Math.pow(p[k],2);C=c*C+l;for(let k=w;k<S;k++){let A=-2*c*u*p[k]*m[b]/C;b===k&&(A+=Math.pow(C,-u)),A*=d[b],g[k]+=A}}return t.makeTensorInfo(o.shape,s.dtype,g)}const lTe={kernelName:x2,backendName:"cpu",kernelFunc:aTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=t;let l=s.shape;const c=l.length,u=An(i,l);let h=u;const f=Lr(h,c);let d=a.data.get(s.dataId).values;if(f!=null){const w=new Array(c);for(let S=0;S<w.length;S++)w[S]=l[f[S]];d=cB(d,l,s.dtype,f,w),h=ns(h.length,c),l=w}Zt(s,"max"),fi("max",h,c);const[p,m]=Qs(l,h),g=Te(m),y=UZ(d,g,p,s.dtype),b=a.write(y,p,s.dtype);let x=p;return o&&(x=Ls(p,u)),{dataId:b,shape:x,dtype:s.dtype}}const cTe={kernelName:sw,backendName:"cpu",kernelFunc:TJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=Sh({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=fB(f,s.shape,s.dtype,d,u,"max");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const hTe={kernelName:iw,backendName:"cpu",kernelFunc:uTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"maxPool3d");const u=Ll(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=_J(h,s.shape,s.dtype,Jt(s.shape),u,"max");return t.makeTensorInfo(f.shape,"float32",f.values)}const dTe={kernelName:ow,backendName:"cpu",kernelFunc:fTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"maxPool3DGrad");const u=Ll(i.shape,o,a,1,l,c),h=t.bufferSync(i),f=nCe(h,u),d=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,S=u.effectiveFilterWidth,C=x-1-u.padInfo.front,k=S-1-u.padInfo.left,A=w-1-u.padInfo.top,M=Sn(i.shape,"float32"),E=t.bufferSync(s);for(let N=0;N<u.batchSize;++N)for(let O=0;O<u.inChannels;++O)for(let R=0;R<u.inDepth;++R)for(let D=0;D<u.inHeight;++D)for(let z=0;z<u.inWidth;++z){const B=R-C,X=D-A,G=z-k;let te=0;for(let ge=0;ge<x;ge+=g){const ae=(B+ge)/d;if(!(ae<0||ae>=u.outDepth||Math.floor(ae)!==ae))for(let Ne=0;Ne<w;Ne+=y){const ke=(X+Ne)/p;if(!(ke<0||ke>=u.outHeight||Math.floor(ke)!==ke))for(let De=0;De<S;De+=b){const be=(G+De)/m;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;const Xe=x*w*S-1-f.get(N,ae,ke,be,O),Oe=ge*w*S+Ne*S+De,it=Xe===Oe?1:0;if(it===0)continue;const We=E.get(N,ae,ke,be,O);te+=We*it}}}M.set(te,N,R,D,z,O)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const mTe={kernelName:S2,backendName:"cpu",kernelFunc:pTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;Zt([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=t.data.get(a.dataId).values,p=Sn(f.outShape,a.dtype,xJ(d,a.shape,a.dtype,f).values),m=f.strideHeight,g=f.strideWidth,y=f.dilationHeight,b=f.dilationWidth,x=f.effectiveFilterHeight,w=f.effectiveFilterWidth,S=w-1-f.padInfo.left,C=x-1-f.padInfo.top,k=Sn(a.shape,"float32"),A=t.data.get(s.dataId).values,M=Sn(s.shape,"float32",A);for(let E=0;E<f.batchSize;++E)for(let N=0;N<f.inChannels;++N)for(let O=0;O<f.inHeight;++O)for(let R=0;R<f.inWidth;++R){const D=O-C,z=R-S;let B=0;for(let X=0;X<x;X+=y){const G=(D+X)/m;if(!(G<0||G>=f.outHeight||Math.floor(G)!==G))for(let te=0;te<w;te+=b){const ge=(z+te)/g;if(ge<0||ge>=f.outWidth||Math.floor(ge)!==ge)continue;const ae=x*w-1-p.get(E,G,ge,N),Ne=X*w+te,ke=ae===Ne?1:0;if(ke===0)continue;const De=M.get(E,G,ge,N);B+=De*ke}}k.set(B,E,O,R,N)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const yTe={kernelName:_2,backendName:"cpu",kernelFunc:gTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(n,e,t,r,s){const i=Jt(e),o=fB(n,e,t,i,s,"max"),a=xJ(n,e,t,s,!0,r);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vTe={kernelName:C2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;Zt(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=ko(r.shape,s,i,[1,1],o),[h,f]=bTe(c,r.shape,r.dtype,a,u),d=l.write(h,u.outShape,r.dtype),p=l.write(f,u.outShape,r.dtype);return[{dataId:d,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=An(i,s.shape),c=Qs(s.shape,a)[1],u=Te(c),h=[],f=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(f);const d=fp({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});h.push(d);const p=dB({inputs:{a:d,b:f},backend:t});h.push(p);const m=pC({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:o}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const xTe={kernelName:aw,backendName:"cpu",kernelFunc:wTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Te(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"min");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=Sa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("min",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];(Number.isNaN(S)||S<x)&&(x=S)}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const STe={kernelName:lw,backendName:"cpu",kernelFunc:_Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,mode:o}=r;Zt(s,"mirrorPad");const a=i.map((x,w)=>x[0]+s.shape[w]+x[1]),l=i.map(x=>x[0]),c=i.map((x,w)=>x[0]+s.shape[w]),u=o==="reflect"?0:1,h=t.data.get(s.dataId).values,f=s.shape.length,d=Jt(s.shape),p=Te(a),m=a.length,g=Jt(a),y=ci(s.dtype,p);for(let x=0;x<p;x++){let w=Bg(x,m,g);for(let C=0;C<m;C++)w[C]<l[C]?w[C]=l[C]*2-w[C]-u:w[C]>=c[C]&&(w[C]=(c[C]-1)*2-w[C]+u);w=w.map((C,k)=>C-l[k]);const S=gu(w,f,d);y[x]=h[S]}return{dataId:t.write(y,a,s.dtype),shape:a,dtype:s.dtype}}const kTe={kernelName:cw,backendName:"cpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TTe=ei((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),ETe=Pi(my,TTe),ITe={kernelName:my,backendName:"cpu",kernelFunc:ETe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=s.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=An([a],s.shape),c=TJ({inputs:{x:s},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=Ls(c.shape,l),h=es({inputs:{x:c},backend:t,attrs:{shape:u}}),f=hB({inputs:{a:s,b:h},backend:t}),d=MZ({inputs:{x:f},backend:t}),p=pC({inputs:{x:d},backend:t,attrs:{axis:l,keepDims:!1}}),m=es({inputs:{x:p},backend:t,attrs:{shape:u}}),g=dB({inputs:{a:d,b:m},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const ATe={kernelName:Ew,backendName:"cpu",kernelFunc:EJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r;Zt(s,"multinomial");const l=a?s:EJ({inputs:{logits:s},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,f=[c,i],d=ji(Te(f),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=h[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[m+x];const y=Rw.alea(o.toString()),b=p*i;for(let x=0;x<i;++x){const w=y();d[b+x]=g.length;for(let S=0;S<g.length;S++)if(w<g[S]){d[b+x]=S;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(f,"int32",d)}const NTe={kernelName:k2,backendName:"cpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Te=oC;function RTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Zt(s,"NonMaxSuppression");const c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,{selectedIndices:h}=$Te(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const PTe={kernelName:T2,backendName:"cpu",kernelFunc:RTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DTe=aN;function OTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Zt(s,"NonMaxSuppressionPadded");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:f,validOutputs:d}=DTe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const FTe={kernelName:kM,backendName:"cpu",kernelFunc:OTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LTe=aC;function zTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Zt(s,"NonMaxSuppressionWithScore");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=LTe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const BTe={kernelName:E2,backendName:"cpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r;Zt(s,"oneHot");const c=Te(s.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(s.dataId).values;for(let f=0;f<c;++f)h[f]>=0&&h[f]<o&&(u[f*o+h[f]]=a);return t.makeTensorInfo([...s.shape,o],i,u)}const UTe={kernelName:dw,backendName:"cpu",kernelFunc:VTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=pg({inputs:{input:r},backend:t}),i=FI({inputs:{x:s},backend:t}),o=nv({inputs:{input:r},backend:t}),a=FI({inputs:{x:o},backend:t}),l=Wa({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pB({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const WTe={kernelName:Mw,backendName:"cpu",kernelFunc:FI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=pg({inputs:{input:r},backend:t}),i=IJ({inputs:{x:s},backend:t}),o=nv({inputs:{input:r},backend:t}),a=FI({inputs:{x:o},backend:t}),l=Wa({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pB({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const GTe={kernelName:fw,backendName:"cpu",kernelFunc:IJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return OI({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=OI({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=rv({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const HTe={kernelName:pw,backendName:"cpu",kernelFunc:AJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;Zt(s,"pad");const a=i.map((b,x)=>b[0]+s.shape[x]+b[1]),l=i.map(b=>b[0]),c=t.data.get(s.dataId).values,u=Te(s.shape),h=s.shape.length,f=Jt(s.shape),d=Te(a),p=a.length,m=Jt(a),g=ci(s.dtype,d);o!==0&&g.fill(o);for(let b=0;b<u;b++){const w=Bg(b,h,f).map((C,k)=>C+l[k]),S=gu(w,p,m);g[S]=c[b]}return{dataId:t.write(g,a,s.dtype),shape:a,dtype:s.dtype}}const MJ={kernelName:mw,backendName:"cpu",kernelFunc:jTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qTe=ei((n,e)=>Math.pow(n,e)),XTe=Pi(yy,qTe),KTe={kernelName:yy,backendName:"cpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YTe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,a=s.map(g=>t.data.get(g.dataId).values),l=s.map(g=>g.shape),c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values,[h,f,d]=XZ(a,l,c,i.shape,i.dtype,u,o.shape),p=h.map(g=>t.makeTensorInfo([g.length],"int32",g)),m=t.makeTensorInfo(d,i.dtype,f);return p.concat([m])}const ZTe={kernelName:TM,backendName:"cpu",kernelFunc:YTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JTe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=KZ(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const QTe={kernelName:EM,backendName:"cpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eEe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,f=a.map(g=>t.data.get(g.dataId).values),d=a.map(g=>g.shape),[p,m]=YZ(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const tEe={kernelName:IM,backendName:"cpu",kernelFunc:eEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nEe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,dtype:i,step:o}=t,a=ZZ(r,s,o,i);return e.makeTensorInfo([a.length],i,a)}const rEe={kernelName:I2,backendName:"cpu",kernelFunc:nEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sEe=$r(by,n=>1/n),iEe={kernelName:by,backendName:"cpu",kernelFunc:sEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeBilinear");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(Te([h,c,u,p])),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let x=0;const w=y[0]/b[0],S=y[1]/b[1];for(let C=0;C<h;C++)for(let k=0;k<c;k++){let A;o?A=w*(k+.5)-.5:A=w*k;const M=Math.max(0,Math.floor(A)),E=A-M,N=Math.min(f-1,Math.ceil(A)),O=C*l[0]+M*l[1],R=C*l[0]+N*l[1];for(let D=0;D<u;D++){let z;o?z=S*(D+.5)-.5:z=S*D;const B=Math.max(0,Math.floor(z)),X=z-B,G=Math.min(d-1,Math.ceil(z)),te=O+B*l[2],ge=R+B*l[2],ae=O+G*l[2],Ne=R+G*l[2];for(let ke=0;ke<p;ke++){const De=m[te+ke],be=m[ge+ke],Xe=m[ae+ke],Oe=m[Ne+ke],it=De+(Xe-De)*X,We=be+(Oe-be)*X,dt=it+(We-it)*E;g[x++]=dt}}}return t.makeTensorInfo([h,c,u,p],"float32",g)}const aEe={kernelName:ww,backendName:"cpu",kernelFunc:oEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeBilinearGrad");const a=Jt(s.shape),[l,c,u,h]=s.shape,[,f,d]=i.shape,p=new Float32Array(l*c*u*h),m=[o&&f>1?c-1:c,o&&d>1?u-1:u],g=[o&&f>1?f-1:f,o&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],x=t.data.get(i.dataId).values;let w=0;for(let S=0;S<l;S++){const C=S*a[0];for(let k=0;k<f;k++){const A=k*y,M=Math.floor(A),E=Math.min(Math.ceil(A),c-1),N=C+M*a[1],O=C+E*a[1],R=A-M,D=1-R;for(let z=0;z<d;z++){const B=z*b,X=Math.floor(B),G=Math.min(Math.ceil(B),u-1),te=B-X,ge=1-te,ae=N+X*a[2],Ne=N+G*a[2],ke=O+X*a[2],De=O+G*a[2],be=D*ge,Xe=D*te,Oe=R*ge,it=R*te;for(let We=0;We<h;We++){const dt=x[w++];p[ae+We]+=dt*be,p[Ne+We]+=dt*Xe,p[ke+We]+=dt*Oe,p[De+We]+=dt*it}}}}return t.makeTensorInfo([l,u,c,h],"float32",p)}const cEe={kernelName:N2,backendName:"cpu",kernelFunc:lEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeNearestNeighbor");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(h*c*u*p),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],x=y[0]/b[0],w=y[1]/b[1];let S=0;for(let C=0;C<h;C++){const k=C*l[0];for(let A=0;A<c;A++){const M=o?x*(A+.5):x*A;let E=Math.min(f-1,i?Math.round(M):Math.floor(M));o&&(E=Math.max(0,E));const N=k+E*l[1];for(let O=0;O<u;O++){const R=o?w*(O+.5):w*O;let D=Math.min(d-1,i?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const z=N+D*l[2];for(let B=0;B<p;B++){const X=m[z+B];g[S++]=X}}}}return t.makeTensorInfo([h,c,u,p],s.dtype,g)}const hEe={kernelName:vw,backendName:"cpu",kernelFunc:uEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeNearestNeighborGrad");const a=Jt(s.shape),l=Jt(i.shape),[c,u,h,f]=s.shape,[,d,p]=i.shape,m=new Float32Array(c*u*h*f),g=t.data.get(i.dataId).values,y=[o&&d>1?u-1:u,o&&p>1?h-1:h],b=[o&&d>1?d-1:d,o&&p>1?p-1:p],x=y[0]/b[0],w=y[1]/b[1],S=1/x,C=1/w,k=Math.ceil(S)*2+2,A=Math.ceil(C)*2+2;for(let M=0;M<c;M++){const E=M*a[0];for(let N=0;N<u;N++){const O=E+N*a[1],R=Math.floor(N*S),D=Math.floor(R-k/2);for(let z=0;z<h;z++){const B=O+z*a[2],X=Math.floor(z*C),G=Math.floor(X-A/2);for(let te=0;te<f;te++){let ge=0;for(let ae=0;ae<k;ae++){const Ne=ae+D;if(Ne<0||Ne>=d)continue;const ke=E+Ne*l[1],De=Ne*x,be=Math.min(u-1,o?Math.round(De):Math.floor(De));if(N===be)for(let Xe=0;Xe<A;Xe++){const Oe=Xe+G;if(Oe<0||Oe>=p)continue;const it=ke+Oe*l[2],We=Oe*w,dt=Math.min(h-1,o?Math.round(We):Math.floor(We));z===dt&&(ge+=g[it+te])}}m[B+te]=ge}}}}return t.makeTensorInfo(s.shape,s.dtype,m)}const dEe={kernelName:M2,backendName:"cpu",kernelFunc:fEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r;Zt(s,"reverse");const o=s.shape.length,a=An(i,s.shape);if(o===0)return Sh({inputs:{x:s},backend:t});const l=new li(s.shape,s.dtype),c=t.bufferSync(s);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),f=h.slice();a.forEach(d=>f[d]=s.shape[d]-1-f[d]),l.set(c.get(...f),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const mEe={kernelName:xw,backendName:"cpu",kernelFunc:pEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gEe={kernelName:G2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=ci(r.dtype,Te(r.shape)),[c,u,h,f]=r.shape,[d,p]=mN(o,u,h),m=255,g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let w=0;w<c;w++){const S=w*h*u*f;for(let C=0;C<u;C++){const k=C*(h*f);for(let A=0;A<h;A++){const M=A*f;for(let E=0;E<f;E++){const N=[c,C,A,E],O=N[2],R=N[1];let D=(O-d)*y-(R-p)*g,z=(O-d)*g+(R-p)*y;D=Math.round(D+d),z=Math.round(z+p);let B=i;if(typeof i!="number"&&(E===3?B=m:B=i[E]),D>=0&&D<h&&z>=0&&z<u){const G=z*(h*f),te=D*f,ge=S+G+te+E;B=b[ge]}const X=S+k+M+E;l[X]=B}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yEe=$r(xy,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),bEe={kernelName:xy,backendName:"cpu",kernelFunc:yEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vEe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=zu(i,s,o),f=!0,d=t.bufferSync(s),p=t.bufferSync(i),m=Gm(d,p,o,h,c,l,a,u,0,f);return t.makeTensorInfo(o,m.dtype,m.values)}const wEe={kernelName:$2,backendName:"cpu",kernelFunc:vEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xEe(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<e?t=s+1:r=s;return r}function _Ee(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<=e?t=s+1:r=s;return r}function SEe(n,e,t,r,s,i){const o=Ss("int32",t*s);for(let a=0;a<t;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]=i==="left"?xEe(l,e[u+c]):_Ee(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CEe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=SEe(a,l,s.shape[0],s.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",c)}const kEe={kernelName:P2,backendName:"cpu",kernelFunc:CEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TEe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e;Zt([r,s,i],"select");const o=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=Mi(s.dtype,i.dtype),h=ji(Te(s.shape),u);let f=0;const d=o===0||o>1||s.shape.length===1?1:Te(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<d;m++)a[p]===1?h[f++]=l[p]:h[f++]=c[p];return t.makeTensorInfo(s.shape,u,h)}const EEe={kernelName:_w,backendName:"cpu",kernelFunc:TEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IEe=fC,AEe=dC,MEe=$r(Sy,n=>n>=0?AEe*n:IEe*(Math.exp(n)-1)),NEe={kernelName:Sy,backendName:"cpu",kernelFunc:MEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ee=$r(Ty,n=>n<0?-1:n>0?1:0),REe={kernelName:Ty,backendName:"cpu",kernelFunc:$Ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PEe=$r(Cy,n=>Math.sin(n)),DEe={kernelName:Cy,backendName:"cpu",kernelFunc:PEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OEe=$r(ky,n=>Math.sinh(n)),FEe={kernelName:ky,backendName:"cpu",kernelFunc:OEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LEe=11920928955078125e-23,TG=Math.log(LEe)+2,zEe=$r(Iy,n=>{const e=n>-TG,t=n<TG,r=Math.exp(n);let s;return t?s=r:e?s=n:s=Math.log(1+r),s}),BEe={kernelName:Iy,backendName:"cpu",kernelFunc:zEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;Zt([s],"spaceToBatchND");const a=Te(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=MJ.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),u=Vy(c.shape,i,a,!1),h=Uy(u.length,i.length,!1),f=Wy(c.shape,i,a,!1),m=es({inputs:{x:c},backend:t,attrs:{shape:u}}),b=Sa({inputs:{x:m},backend:t,attrs:{perm:h}}),S=es({inputs:{x:b},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),S}const UEe={kernelName:kw,backendName:"cpu",kernelFunc:VEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WEe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values[0],[h,f,d,p,m]=tJ(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const GEe={kernelName:AM,backendName:"cpu",kernelFunc:WEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HEe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(s.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(i.dataId).values),[c,u,h]=nJ(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const jEe={kernelName:MM,backendName:"cpu",kernelFunc:HEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=uB(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const XEe={kernelName:D2,backendName:"cpu",kernelFunc:qEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=uB(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const YEe={kernelName:O2,backendName:"cpu",kernelFunc:KEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZEe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=zu(i,s,a),d=!1,p=t.bufferSync(s);let m;switch(i.dtype){case"bool":{const g=t.bufferSync(i),y=!!t.data.get(o.dataId).values[0];m=Gm(p,g,a,f,u,c,l,h,y,d);break}case"float32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=Gm(p,g,a,f,u,c,l,h,y,d);break}case"int32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=Gm(p,g,a,f,u,c,l,h,y,d);break}case"string":{const g=t.bufferSync(i),y=Cc(t.data.get(o.dataId).values[0]);m=Gm(p,g,a,f,u,c,l,h,y,d);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}const JEe={kernelName:F2,backendName:"cpu",kernelFunc:ZEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=AN(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(h=>{const f=[...u];f[a]=h;const d=mg({inputs:{x:s},backend:t,attrs:{begin:c,size:f}});return c[a]+=h,d})}const eIe={kernelName:Tw,backendName:"cpu",kernelFunc:QEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tIe={kernelName:L2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Zt(t,"square");const s=r.data.get(t.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nIe=$r(Dy,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),rIe={kernelName:Dy,backendName:"cpu",kernelFunc:nIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r;Zt(s,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=fN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=es({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=hN(b,x,w),k=mg({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});S=es({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(k)}else{const C=t.bufferSync(s),k=iJ(d,C,w,b);S=t.makeTensorInfo(p,k.dtype,k.values)}return S}const iIe={kernelName:B2,backendName:"cpu",kernelFunc:sIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oIe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.data.get(u.dataId).values,d=t.data.get(h.dataId).values,[p,m]=oJ(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const aIe={kernelName:V2,backendName:"cpu",kernelFunc:oIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lIe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=aJ(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const cIe={kernelName:NM,backendName:"cpu",kernelFunc:lIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=lJ(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const hIe={kernelName:$M,backendName:"cpu",kernelFunc:uIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fIe=$r($y,n=>Math.tan(n)),dIe={kernelName:$y,backendName:"cpu",kernelFunc:fIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pIe=$r(Ry,n=>Math.tanh(n)),mIe={kernelName:Ry,backendName:"cpu",kernelFunc:pIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gIe(n){const{inputs:e,backend:t}=n,{tensor:r,indices:s,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=zu(i,s,r.shape),h=!1,f=t.bufferSync(s),d=t.bufferSync(i),p=t.bufferSync(r),m=Gm(f,d,r.shape,u,l,a,o,c,p,h);return t.makeTensorInfo(r.shape,m.dtype,m.values)}const yIe={kernelName:R2,backendName:"cpu",kernelFunc:gIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;Zt(s,"tile");const o=uJ(t.bufferSync(s),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const vIe={kernelName:Py,backendName:"cpu",kernelFunc:bIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r;Zt(s,"topk");const a=t.data.get(s.dataId).values,[l,c]=fJ(a,s.shape,s.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const xIe={kernelName:U2,backendName:"cpu",kernelFunc:wIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ie(n){const{inputs:e,attrs:t,backend:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=Jt(s.shape),b=y[0],x=y[1],w=y[2],S=Jt(g),C=S[0],k=S[1],A=S[2],M=ci(s.dtype,Te(g));M.fill(l);const E=r.data.get(s.dataId).values,N=r.data.get(i.dataId).values;for(let R=0;R<u;++R){const D=i.shape[0]===1?N:N.subarray(R*8,R*8+8);for(let z=0;z<p;++z)for(let B=0;B<m;++B)for(let X=0;X<d;++X){let G;const te=D[6]*B+D[7]*z+1;if(te===0)continue;const ge=(D[0]*B+D[1]*z+D[2])/te,ae=(D[3]*B+D[4]*z+D[5])/te,Ne=EG(ge,f,a),ke=EG(ae,h,a);switch(o){case"nearest":G=IIe(E,h,f,b,x,w,R,ke,Ne,X,l);break;case"bilinear":G=AIe(E,h,f,b,x,w,R,ke,Ne,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const De=R*C+z*k+B*A+X;M[De]=G}return r.makeTensorInfo(g,s.dtype,M)}return{dataId:r.write(M,g,s.dtype),shape:s.shape,dtype:s.dtype}}const SIe={kernelName:W2,backendName:"cpu",kernelFunc:_Ie};function EG(n,e,t){switch(t){case"reflect":return CIe(n,e);case"wrap":return kIe(n,e);case"nearest":return EIe(n,e);case"constant":default:return TIe(n)}}function CIe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return ip(0,t,e-1)}function kIe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return ip(0,t,e-1)}function TIe(n,e){return n}function EIe(n,e){return ip(0,n,e-1)}function E1(n,e,t,r,s,i,o,a,l,c,u){const h=o*r+a*s+l*i+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function IIe(n,e,t,r,s,i,o,a,l,c,u){const h=Math.round(a),f=Math.round(l);return E1(n,e,t,r,s,i,o,h,f,c,u)}function AIe(n,e,t,r,s,i,o,a,l,c,u){const h=Math.floor(a),f=Math.floor(l),d=h+1,p=f+1,m=(p-l)*E1(n,e,t,r,s,i,o,h,f,c,u)+(l-f)*E1(n,e,t,r,s,i,o,h,p,c,u),g=(p-l)*E1(n,e,t,r,s,i,o,d,f,c,u)+(l-f)*E1(n,e,t,r,s,i,o,d,p,c,u);return(d-a)*m+(a-h)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MIe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;Zt(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=dJ(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const NIe={kernelName:RM,backendName:"cpu",kernelFunc:MIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ie(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let d=0;d<o;d++)d!==i&&(l[c++]=s.shape[d]);const u=new Array(o).fill(0),h=s.shape.slice();h[i]=1;const f=new Array(a);for(let d=0;d<f.length;d++){u[i]=d;const p=mg({inputs:{x:s},backend:t,attrs:{begin:u,size:h}});f[d]=es({inputs:{x:p},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(p)}return f}const RIe={kernelName:Iw,backendName:"cpu",kernelFunc:$Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r;Zt(s,"unsortedSegmentSum");const a=s.shape.length,l=i.shape.length,c=[],u=[],h=a-l;let f=i;for(let p=0;p<h;++p){const m=OI({inputs:{input:f},backend:t,attrs:{dim:p+1}});f=m,u.push(m)}for(let p=0;p<o;++p){const m=Hf(p,"int32"),g=t.makeTensorInfo([],"int32",m),y=IZ({inputs:{a:g,b:f},backend:t}),b=fp({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),x=$N({inputs:{a:b,b:s},backend:t}),w=pC({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(b),u.push(x),u.push(w)}const d=AJ({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const DIe={kernelName:Aw,backendName:"cpu",kernelFunc:PIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OIe=[M2e,hSe,$2e,P2e,ySe,O2e,L2e,B2e,U2e,G2e,j2e,X2e,Y2e,Q2e,tCe,sCe,oCe,lCe,uCe,I2e,fCe,pCe,gCe,vSe,bCe,mSe,xSe,wCe,fSe,_Ce,CCe,kCe,ECe,ACe,NCe,RCe,DCe,FCe,zCe,VCe,WCe,HCe,qCe,KCe,YCe,JCe,eke,nke,rke,ske,ike,ake,uke,x2e,fke,_Se,wke,SSe,xke,kSe,Eke,Ike,Mke,ESe,ASe,$ke,Pke,Oke,Lke,NSe,RSe,dSe,Bke,SCe,Uke,Gke,jke,_2e,DSe,FSe,Xke,zSe,Yke,Qke,tTe,sTe,oTe,lTe,cTe,VSe,hTe,dTe,mTe,yTe,vTe,xTe,STe,WSe,kTe,ITe,NTe,HSe,qSe,PTe,FTe,BTe,KSe,UTe,GTe,HTe,MJ,KTe,C2e,JSe,ZTe,QTe,tEe,rEe,pSe,DD,iEe,k2e,T2e,E2e,aEe,cEe,hEe,dEe,mEe,gEe,bEe,o2e,wEe,kEe,EEe,NEe,l2e,REe,DEe,FEe,c2e,ATe,BEe,UEe,GEe,jEe,XEe,YEe,JEe,eIe,f2e,tIe,p2e,g2e,rIe,iIe,aIe,cIe,hIe,w2e,lke,dIe,mIe,yIe,vIe,xIe,SIe,YSe,NIe,RIe,DIe,WTe];for(const n of OIe)H2(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fm={},Xk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function FIe(n,e){Fm[n]=e}function Su(n,e){if(!(n in Fm)||e!=null){const r=zIe(n,e);if(r!==null)Fm[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Fm[n];return t==null||t.isContextLost()?(delete Fm[n],Su(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Fm[n])}function LIe(n){if(!Ee().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function zIe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??LIe(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Fm[n]},!1),Ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(Xk.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Xk)||t.getContext("experimental-webgl",Xk):t.getContext("webgl2",Xk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M_;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(M_||(M_={}));var Sl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Sl||(Sl={}));var oo;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(oo||(oo={}));function mC(n,e){return[e,n]}function BIe(n,e){return n*e}function Kk(n){const e=Te(n),t=Math.ceil(e/4);return _I(t)}function Ow(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function VIe(n,e){const[t,r]=Ow(n,e);return t*r*4}function mB(n,e){const t=n;let r,s,i,o,a,l,c,u,h,f;return Ee().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,f=t.FLOAT,l=t.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n,e){const t=e();return Ee().getBool("DEBUG")&&UIe(n),t}function UIe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+jIe(n,e))}const WIe=596e-10,GIe=65504;function HIe(n){return!!(Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||WIe<Math.abs(n)&&Math.abs(n)<GIe)}function jIe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Yk(n,e){return Kf(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function qIe(n,e){const t=Kf(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function XIe(n,e){const t=Kf(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),Ee().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw NJ(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const KIe=/ERROR: [0-9]+:([0-9]+):/g;function NJ(n,e){const t=KIe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),i=s.length.toString().length+2,o=s.map((h,f)=>Ym((f+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Ym(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function YIe(n){return Kf(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function ZIe(n,e){if(Bt(n,()=>n.linkProgram(e)),!Ee().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function h3(n,e){if(Bt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function JIe(n,e){const t=Kf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function QIe(n,e){const t=Kf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function eAe(n){return Kf(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function tAe(n,e){const t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function nAe(n){return Kf(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function IG(n,e,t,r,s,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Bt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),Bt(n,()=>n.enableVertexAttribArray(a)),!0)}function rAe(n,e,t){lAe(n,t),Bt(n,()=>n.activeTexture(n.TEXTURE0+t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function sAe(n,e,t){return Kf(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function iAe(n,e,t){return n.getUniformLocation(e,t)}function oAe(n,e,t,r){Bt(n,()=>rAe(n,e,r)),Bt(n,()=>n.uniform1i(t,r))}function f3(n,e,t){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function AG(n,e){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Zk(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+aAe(n,e))}function aAe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Kf(n,e,t){const r=Bt(n,()=>e());if(r==null)throw new Error(t);return r}function lAe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function sv(n,e=2){return Te(n.slice(0,n.length-e))}function iv(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Jk(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[sv(n),...iv(n)]),e}function cAe(n,e=!1){let t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?xM(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Wf(n).newShape);let s=Te(n),i=null;n.length<=1&&s<=t?i=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=sv(n);let l=2,c=2;n.length&&([l,c]=iv(n)),s=a*(l/2)*(c/2),i=_I(s).map(u=>u*2)}else i=_I(s);return i}function Qk(n){return n%2===0}function LI(n,e){if(n=n.slice(-2),e=e.slice(-2),Rn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||Qk(t)&&Qk(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Qk(n[0])&&Qk(e[0])}let d3,p3;function uAe(n){if(d3==null){const e=Su(n);d3=e.getParameter(e.MAX_TEXTURE_SIZE)}return d3}function hAe(n){if(p3==null){const e=Su(n);p3=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,p3)}function fAe(n){if(n===0)return 0;let e;const t=Su(n);return mc(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:mc(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function mc(n,e){return n.getExtension(e)!=null}function MG(n){try{if(Su(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function dAe(n){if(n===0)return!1;const e=Su(n);if(n===1){if(!mc(e,"OES_texture_float"))return!1}else if(!mc(e,"EXT_color_buffer_float"))return!1;return FD(e)}function pAe(n){if(n===0)return!1;const e=Su(n);if(n===1){if(!mc(e,"OES_texture_float")||!mc(e,"WEBGL_color_buffer_float"))return!1}else{if(mc(e,"EXT_color_buffer_float"))return FD(e);const r="EXT_color_buffer_half_float";if(mc(e,r)){const s=e.getExtension(r);return mAe(e,s)}return!1}return FD(e)}function FD(n){const e=mB(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function mAe(n,e){const t=mB(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,i=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,i,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}function gAe(n){return n!==2?!1:Su(n).fenceSync!=null}function gC(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qt=Ee();Qt.registerFlag("HAS_WEBGL",()=>Qt.getNumber("WEBGL_VERSION")>0);Qt.registerFlag("WEBGL_VERSION",()=>MG(2)?2:MG(1)?1:0);Qt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qt.get("WEBGL_VERSION")===2);Qt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qt.registerFlag("WEBGL_PACK",()=>Qt.getBool("HAS_WEBGL"));Qt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CLIP",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_REDUCE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_CONV_IM2COL",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>uAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>hAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qt.getNumber("WEBGL_VERSION");return n===0?0:fAe(n)});Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!FL());Qt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>dAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>pAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>gAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Qt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>FL()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Qt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_EXP_CONV",()=>!1);Qt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qt.getBool("IS_TEST"));Qt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(){let n,e,t,r,s,i,o,a,l,c;return Ee().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=Ee().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gy(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / ${s}`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`;return`${o}; ${a};`}).join("")}function RN(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function yAe(n,e){const t=n.length,r=n.map(i=>`${e}[${i}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let i=t-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}function bAe(n,e,t="index"){const r=n.map((i,o)=>o),s=yAe(r,e);return s.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${s[o]}`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`;return`${a}; ${l};`}).join("")}function gB(n){const e=Jt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function yB(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const $J=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:RJ}=bZ;function vAe(n,e,t){const r=[];if(n.forEach(d=>{const p=Te(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:m}=bB(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),i=n.map(d=>wAe(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=ra(),l=SAe(a);let c,u,h=TAe(a);return e.isPacked?(c=xAe(e.logicalShape,o,t.enableShapeUniforms),u=kAe(a)):(c=_Ae(e.logicalShape,o,t.enableShapeUniforms),u=CAe(a)),t.packedInputs&&(h+=MAe),[h,l,u,s,c,i,t.userCode].join(`
`)}function Fw(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return UAe(n,e);case 1:return GAe(n,e);case 2:return jAe(n,e);case 3:return XAe(n,e);case 4:return YAe(n,e);case 5:return ZAe(n);case 6:return JAe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function PJ(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return VAe(n);case 1:return WAe(n,e);case 2:return HAe(n,e);case 3:return qAe(n,e);default:return KAe(n,e)}}function wAe(n,e,t=!1,r){let s="";t?s+=PJ(n,r):s+=Fw(n,r);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?s+=QAe(n,e):s+=eMe(n,e)),s}function xAe(n,e,t){switch(n.length){case 0:return DJ();case 1:return NAe(n,e,t);case 2:return zAe(n,e,t);case 3:return RAe(n,e,t);default:return DAe(n,e,t)}}function _Ae(n,e,t){switch(n.length){case 0:return DJ();case 1:return $Ae(n,e,t);case 2:return BAe(n,e,t);case 3:return PAe(n,e,t);case 4:return OAe(n,e,t);case 5:return FAe(n,e);case 6:return LAe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function SAe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function CAe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function kAe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function TAe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${EAe}
    ${IAe}
    ${AAe}
  `}const EAe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,IAe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,AAe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,MAe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function DJ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function NAe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function $Ae(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function RAe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function PAe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${RN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=Gy(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function DAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${l});
    }
  `}function OAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${RN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Gy(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function FAe(n,e){const t=Gy(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function LAe(n,e){const t=Gy(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function zAe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Rn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function BAe(n,e,t){return Rn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Hy(n){return`offset${n}`}function VAe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ra();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function UAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,i]=n.shapeInfo.texShape;if(s===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Hy(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function WAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,i=ra();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function GAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Lw(n)}
      }
    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(o===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Hy(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function HAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=ra();if(i!=null&&Rn(t,i))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function jAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Rn(t,i)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=i[0],d=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Wf(t),l=o;if(l.length<t.length){const f=zw(n,l),d=["row","col"];return`
      ${Fw(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${Bw(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Lw(n)}
      }
    `;const c=i[0],u=i[1],h=Hy(r);return u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function qAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const f=t.slice(1),d=[1,2],p=zw(n,f),m=["b","row","col"];return`
        ${PJ(p,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Bw(m,d)});
        }
      `}const a=ra();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function XAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Wf(t),c=a;if(c.length<t.length){const m=zw(n,c),g=["row","col","depth"];return`
        ${Fw(m,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Bw(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Lw(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],f=u[1],d=n.shapeInfo.flatOffset;if(f===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=Hy(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function KAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ra();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(i[o-1]/2);let f=h*Math.ceil(i[o-2]/2),d="int b, int row, int col",p=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)d=`int b${m}, `+d,f*=i[o-m-1],p=`b${m} * ${f} + `+p;return`
    vec4 ${r}(${d}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${s.texture2D}(${t}, uv);
    }
  `}function YAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Wf(t);if(l.length<t.length){const b=zw(n,l),x=["row","col","depth","depth2"];return`
      ${Fw(b,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Bw(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Lw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===i&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=Hy(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function ZAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],i=e[3]*s,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Wf(e);if(l.length<e.length){const m=zw(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${Fw(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Bw(g,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${s})) +
          depth3;
        ${Lw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1];if(d===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=Hy(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function JAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:i}=Wf(e);if(s.length<e.length){const g=zw(n,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Fw(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Bw(y,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Lw(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],p=f[1];if(p===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=Hy(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Lw(n){const e=n.name,t=Te(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function QAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=RJ(n.shapeInfo.logicalShape,e.logicalShape),l=Fr(o),c=o-i;let u;const h=["x","y","z","w","u","v"];i===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let f="";o<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((b,x)=>`coords.${h[x+c]}`).join(", ");let d="return outputValue;";const m=Te(n.shapeInfo.logicalShape)===1,y=Te(e.logicalShape)===1;if(i===1&&!m&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=i-2,x=i-1;a.indexOf(b)>-1&&a.indexOf(x)>-1?d="return vec4(outputValue.x);":a.indexOf(b)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function eMe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Rn(o,i))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Fr(l),u=RJ(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let f;const d=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(m=>`coords.${d[m+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((m,g)=>`coords.${d[g+h]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `}function Fr(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function bB(n,e,t){const{newShape:r,keptDims:s}=Wf(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):r,l=!n&&i>1&&!Rn(e,t)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function zw(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Bw(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tMe(n,e,t,r){const s=t.map((u,h)=>{const f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=vAe(s,o,e),l=XIe(n.gl,a),c=n.createProgram(l);return Ee().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},OJ(n,e,c)))}function OJ(n,e,t){const r=[],s=[];let i,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),Ee().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const f={name:h,uniform:n.getUniformLocation(t,h,u),offset:n.getUniformLocation(t,`offset${h}`,u)};e.enableShapeUniforms&&(f.shape=n.getUniformLocation(t,`${h}Shape`,u),f.texShape=n.getUniformLocation(t,`${h}TexShape`,u)),r.push(f)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)s.push(n.getUniformLocation(t,h.name,u));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function NG(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,i=e[r],o=i.shape;if(!Rn(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!Rn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function nMe(n,e,t,r,s){e.program.enableShapeUniforms||(NG(e.inShapeInfos,t),NG([e.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Ee().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:h,shape:f,texShape:d}=e.variablesLocations[l];if(f){const{uniformShape:p}=bB(e.program.packedInputs,c.shape,c.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(f,new Int32Array(p));break;case 2:n.gl.uniform2iv(f,new Int32Array(p));break;case 3:n.gl.uniform3iv(f,new Int32Array(p));break;case 4:n.gl.uniform4iv(f,new Int32Array(p));break}}if(d&&n.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(Te(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let p=c.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(u,p)}continue}c.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Jt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],h=s[l];if(c.type==="float")n.gl.uniform1fv(u,h);else if(c.type==="vec2")n.gl.uniform2fv(u,h);else if(c.type==="vec3")n.gl.uniform3fv(u,h);else if(c.type==="vec4")n.gl.uniform4fv(u,h);else if(c.type==="int")n.gl.uniform1iv(u,h);else if(c.type==="ivec2")n.gl.uniform2iv(u,h);else if(c.type==="ivec3")n.gl.uniform3iv(u,h);else if(c.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function rMe(n,e,t){let r="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=bB(n.packedInputs,o.shape,l);let f="",d="",p="";if(u.length===1&&n.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${S[0]>1}_${S[1]>1}`}else if(u.length===2&&!n.packedInputs)d=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const S=Jt(u);p=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const m=o.shape.length,g=u.length===2&&Rn(o.shape,l),y=Te(o.shape)===1,b=Ff(o.shape,t.shape),x=!n.packedInputs&&m===t.shape.length&&Rn(l,t.texData.texShape),w=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${c?h:""}_${u.length}_${y}_${b}_${g}_${f}_${d}_${p}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const s=n.userCode;let i=n.constructor.name;return i+="_"+r+"_"+s+`${Ee().getNumber("WEBGL_VERSION")}`,i}function To(n){return Ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sMe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=M_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?RN(["r","c","d"],e):Gy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=M_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?RN(["r","c","d"],e):Gy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oMe{constructor(e){this.variableNames=["A"],this.outTexUsage=Sl.DOWNLOAD;const t=ra();this.outputShape=e,this.userCode=`
      ${$J}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Sl.DOWNLOAD;const t=ra();this.outputShape=e,this.userCode=`
      ${$J}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lMe={R:0,G:1,B:2,A:3};class $G{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${lMe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?yB():gB(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${o}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cMe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let s="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?yB():gB(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uMe(n){const e=ra(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return qIe(n,t)}function hMe(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return JIe(n,e)}function fMe(n){const e=new Uint16Array([0,1,2,2,1,3]);return QIe(n,e)}function yC(n,e,t,r,s,i){tAe(e,t);const o=eAe(n),a=n.TEXTURE_2D;return Bt(n,()=>n.bindTexture(a,o)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),Ee().getNumber("WEBGL_VERSION")===1?Bt(n,()=>n.texImage2D(a,0,r,e,t,0,s,i,null)):Bt(n,()=>n.texStorage2D(a,1,r,e,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function FJ(n){return n.internalFormatFloat}function dMe(n,e,t,r){const[s,i]=mC(e,t);return yC(n,s,i,FJ(r),r.textureFormatFloat,n.FLOAT)}function LJ(n){return n.internalFormatHalfFloat}function pMe(n,e,t,r){const[s,i]=mC(e,t);return yC(n,s,i,LJ(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function zJ(n){return n.downloadTextureFormat}function mMe(n,e,t,r){const[s,i]=mC(e,t);return yC(n,s,i,zJ(r),n.RGBA,n.UNSIGNED_BYTE)}function BJ(n){return n.internalFormatPackedFloat}function gMe(n,e,t,r){const[s,i]=Ow(e,t);return yC(n,s,i,BJ(r),n.RGBA,n.FLOAT)}function VJ(n){return n.internalFormatPackedHalfFloat}function yMe(n,e,t,r){const[s,i]=Ow(e,t);return yC(n,s,i,VJ(r),n.RGBA,r.textureTypeHalfFloat)}function bMe(n,e,t){return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),IG(n,e,"clipSpacePos",t,3,20,0)&&IG(n,e,"uv",t,2,20,12)}function vMe(n,e,t,r,s,i){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;s instanceof Uint8Array?(o=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,o)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,r,0,n.RGBA,a,o)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function wMe(n,e,t){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function xMe(n,e,t,r){const s=n.createBuffer();Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Bt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function _Me(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function SMe(n,e,t,r){const[s,i]=mC(e,t),o=4,a=new Uint8Array(BIe(e*t,o));return Bt(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function CMe(n,e,t,r,s,i,o,a){const l=n,c=new Float32Array(VIe(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function kMe(n,e,t){const r=new Float32Array(e*t*4);return Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m3{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Ee().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,FIe(t,e)):this.gl=Su(t),e=this.gl,Ee().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Bt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Bt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Bt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Bt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bt(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Bt(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bt(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bt(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ee().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Yk(this.gl,i),mc(this.gl,o))this.textureHalfFloatExtension=Yk(this.gl,o);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),mc(this.gl,s))this.colorBufferHalfFloatExtension=Yk(this.gl,s);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",mc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(mc(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=hMe(this.gl),this.indexBuffer=fMe(this.gl),this.framebuffer=nAe(this.gl),this.textureConfig=mB(this.gl,this.textureHalfFloatExtension)}get debug(){return Ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Bt(e,()=>e.finish()),Bt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Bt(e,()=>e.deleteFramebuffer(this.framebuffer)),Bt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Bt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Bt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),dMe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),pMe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),mMe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),wMe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),vMe(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),yMe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),gMe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(AG(this.gl,this.framebuffer),this.outputTexture=null),Bt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>SMe(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,i,o){return CMe(this.gl,e,t,r,s,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return _Me(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=xMe(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(Ee().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},t=i}else Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>kMe(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=uMe(t));const r=YIe(t);Bt(t,()=>t.attachShader(r,this.vertexShader)),Bt(t,()=>t.attachShader(r,e)),ZIe(t,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&h3(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Bt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),bMe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Bt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&h3(this.gl,this.program),Bt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?sAe(this.gl,e,t):iAe(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Bt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),oAe(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,i]=Ow(t,r);this.setOutputMatrixTextureDriver(e,s,i)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&h3(this.gl,this.program),Zk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Yk(this.gl,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await fD(()=>this.disposed||this.isQueryAvailable(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=TMe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ee().platform&&(r=Ee().platform.setTimeoutCustom.bind(Ee().platform)),fD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),f3(this.gl,e,this.framebuffer),this.debug&&Zk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(f3(this.gl,this.outputTexture,this.framebuffer),this.debug&&Zk(this.gl)):AG(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;f3(s,e,this.framebuffer),this.debug&&Zk(s),this.outputTexture=e,Bt(s,()=>s.viewport(0,0,t,r)),Bt(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function TMe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:EMe,bincountImpl:UJ,bincountReduceImpl:IMe,bitwiseAndImpl:AMe,castImpl:MMe,ceilImpl:NMe,concatImpl:$Me,equalImpl:RMe,expImpl:PMe,expm1Impl:DMe,floorImpl:OMe,gatherNdImpl:FMe,gatherV2Impl:LMe,greaterImpl:zMe,greaterEqualImpl:BMe,lessImpl:VMe,lessEqualImpl:UMe,linSpaceImpl:WMe,logImpl:GMe,maxImpl:HMe,maximumImpl:jMe,minimumImpl:qMe,multiplyImpl:XMe,negImpl:KMe,notEqualImpl:YMe,prodImpl:ZMe,raggedGatherImpl:JMe,raggedRangeImpl:QMe,raggedTensorToTensorImpl:eNe,rangeImpl:tNe,rsqrtImpl:nNe,scatterImpl:rNe,sigmoidImpl:sNe,simpleAbsImpl:WJ,sliceImpl:iNe,sparseFillEmptyRowsImpl:oNe,sparseReshapeImpl:aNe,sparseSegmentReductionImpl:GJ,sqrtImpl:lNe,staticRegexReplaceImpl:cNe,stridedSliceImpl:uNe,stringNGramsImpl:hNe,stringSplitImpl:fNe,stringToHashBucketFastImpl:dNe,subImpl:pNe,tileImpl:mNe,topKImpl:gNe,transposeImpl:vB,uniqueImpl:yNe}=pJ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Wo(n,e){return e===1?[n]:HJ(n,e)}function bNe(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vNe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=To(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Wo("rc",this.rank),r=Fr(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${wNe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?yB():gB(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function wNe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?bAe(["r","c","d"],"inputShape"):Gy(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xNe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const s=PG(t,r),i=DG(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=RG(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return s===oo.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===oo.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===oo.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===oo.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===oo.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const i=PG(r,s),o=DG(t,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=RG(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=Ee().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function _Ne(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function RG(n,e,t,r,s){const i=SNe(e,r);let o;if(s){const[l,c]=Ow(n[0],n[1]);o=l*c}else{const[l,c]=mC(n[0],n[1]);o=l*c}const a=_Ne(t,i);return o*a}function SNe(n,e){switch(n){case oo.PACKED_2X2_FLOAT32:return BJ(e);case oo.PACKED_2X2_FLOAT16:return VJ(e);case oo.UNPACKED_FLOAT32:return FJ(e);case oo.UNPACKED_FLOAT16:return LJ(e);case oo.PACKED_4X1_UNSIGNED_BYTE:return zJ(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function CNe(n){return Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?oo.PACKED_2X2_FLOAT32:oo.UNPACKED_FLOAT32:n?oo.PACKED_2X2_FLOAT16:oo.UNPACKED_FLOAT16}function PG(n,e){if(n===Sl.UPLOAD)return oo.PACKED_2X2_FLOAT32;if(n===Sl.RENDER||n==null)return CNe(e);if(n===Sl.DOWNLOAD||n===Sl.PIXELS)return oo.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function DG(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fh=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Pc="if (isnan(x)) return x;",kNe="return x;",OG="return abs(x);",TNe="return (x >= 0.0) ? x : (exp(x) - 1.0);",ENe=Pc+`
  return (x < 0.0) ? 0.0 : x;
`,INe=Pc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ad="return x;",ANe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MNe="return x;",NNe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$Ne=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,RNe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,PNe="return 1.0 / (1.0 + exp(-1.0 * x));";class Dd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DNe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const t=e.length,r=Wo("rc",t),s=Fr(t),i=bNe(t,r),o=r.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ONe=tN,FNe=1e-7,LNe=1e-4,eT={};function zNe(n){return n in eT||(eT[n]={}),eT[n]}const BNe=Ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),VNe=600;function UNe(){return Ee().global.screen==null?1024:Ee().global.screen.height*Ee().global.screen.width*window.devicePixelRatio*VNe/1024/1024}class PN extends jS{nextDataId(){return PN.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof m3)t=e;else{const r=Su(Ee().getNumber("WEBGL_VERSION"),e);t=new m3(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Su(Ee().getNumber("WEBGL_VERSION"));t=new m3(r),this.binaryCache=zNe(Ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xNe(this.gpgpu),this.numMBBeforeWarning=UNe(),this.texData=new wM(this,xo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,s,i,o){const a=this.makeTensorInfo(t,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];const c=Jk(t),u=new $G(c,!1,o),h=this.runWebGLProgram(u,[a],r,[[s,i]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,r){if((Ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:Sl.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,i){if(Ee().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:Sl.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let f;l?f=new Dd(a,Ad):f=new fh(a,Ad);const d=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:s}],s),p=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=so());let h;if(s==="complex64"){const f=this.readSync(i.real.dataId),d=this.readSync(i.imag.dataId);h=xu(f,d)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=so()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const t=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let p;l?p=new Dd(s,Ad):p=new fh(s,Ad);const m=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(Ee().getBool("DEBUG")&&!Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&Ee().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...Kk(s))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=p[0],g=p[1];h=xu(m,g)}else if(c==null)h=this.getValuesFromTexture(e);else{const p=Te(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;Bt(p,()=>p.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&xo().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let d;l?d=new Dd(i,Ad):d=new fh(i,Ad);const p=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:a}],a),m=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=xo().makeTensorFromTensorInfo(u),f=this.texData.get(u.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Cc(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!HIe(r))throw Ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),i=Te(t);if(Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),d=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Kk(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),p}const o=Ee().getBool("WEBGL_PACK")&&s===!0,a=o?Jk(t):t,l=o?new aMe(a):new oMe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=kc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=kc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=ML(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:so(),endMs:null}}endTimer(e){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=so(),e)}async getQueryTime(e){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,i,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=BNe){return Ee().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Te(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){wl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return ONe(e.shape,t)}packedUnaryOp(e,t,r){const s=new Dd(e.shape,t),i=this.compileAndRun(s,[e],r);return xo().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=WJ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,OG,e.dtype);const t=new fh(e.shape,OG),r=this.compileAndRun(t,[e]);return xo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&uu(r[0])){const i=r.map(o=>yu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return xo().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new DNe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new vNe(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[sv(e.shape),...iv(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[sv(t),...iv(t)],o=new jJ(i,r),a=!0,l=[r],c=this.runWebGLProgram(o,[s],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:i,dtype:o}=r;if(t!=null){const f=Te(i),d=t[0]*t[1]*4;U(f<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Jk(i);let l;s?l=new iMe(a):l=new sMe(a);const c=!0,u=[t??Kk(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,r,s,i=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===M_.DENSE){const y=o??Kk(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Te(a.shape)===0)return l.values=ci(a.dtype,0),a;const c=[],u=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&Te(y.shape)<=Ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!LI(b.shape,y.shape)){const x=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),c.push(y),b=this.texData.get(y.dataId),x.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},f=rMe(e,u,h),d=this.getAndSaveBinary(f,()=>tMe(this.gpgpu,e,u,h)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),Ee().get("ENGINE_COMPILE_ONLY")||nMe(this.gpgpu,d,u,h,s),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Ee().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=so();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Ee().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,t,r,s,i=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!Ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ee().getBool("DEBUG");Ee().set("DEBUG",!1);const t=this.abs(en(1e-8)).dataSync()[0];if(Ee().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?FNe:LNe}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=so());let h=t.texShape;if(h==null&&(h=cAe(r,l),t.texShape=h),i!=null){const f=Jk(r);let d,p=h[1],m=h[0];const g=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!g)&&([p,m]=Ow(h[0],h[1])),l?d=new cMe(f,g):d=new $G(f,g);const y=g?[m,p]:h,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=Sl.PIXELS:x.usage=Sl.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,m,i);const w=[[m,p]],S=!0,C=this.runWebGLProgram(d,[b],s,w,S),k=this.texData.get(C.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,Ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=so()-u)}else{const f=this.acquireTexture(h,a,s,l);t.texture=f}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return t!=null&&(r.values=WNe(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*g_(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await nB(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(NJ(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:s,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=OJ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:a}=e,l=xo().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,t,r,i,o,a);return xo().makeTensorFromDataId(c,t,r,l)}}PN.nextDataId=0;function WNe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */LL()&&DM("webgl",()=>new PN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wB=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let gg=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=ln(t,r),this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jy=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Vw{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ln(t,r);const i=this.outputShape.length;this.enableShapeUniforms=To(i);let o="";if(s)if(i===0||Te(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Fr(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Wo("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ka(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const GNe={kernelName:ay,backendName:"webgl",kernelFunc:Ka};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(i.dataId),a=Ka({inputs:{x:r},backend:t}),l=Ka({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const HNe={kernelName:e2,backendName:"webgl",kernelFunc:Lp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJ="return (a < 0.) ? b * a : a;",XJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function jNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=t.makeTensorInfo([],"float32",Hf(i,"float32")),a=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vw(XJ,s.shape,o.shape):new gg(qJ,s.shape,o.shape),l=t.runWebGLProgram(a,[s,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const qNe={kernelName:Zv,backendName:"webgl",kernelFunc:jNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ="return (a < 0.) ? b * a : a;",YJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function XNe(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vw(YJ,r.shape,s.shape):new gg(KJ,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],"float32")}const KNe={kernelName:gw,backendName:"webgl",kernelFunc:XNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uw="if (isnan(x)) return x;";function gr({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),f=t(h.values,l);return a.makeTensorInfo(o.shape,l,f)}const c=Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Dd(o.shape,e):u=new fh(o.shape,n),a.runWebGLProgram(u,[o],l)}}function uo({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[w,S]=x,C={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:S.dataId,dtype:S.dtype,shape:c.shape},A=new gg(n,l.shape,c.shape);return u.runWebGLProgram(A,[C,k],Mi(w.dtype,S.dtype))}),b=Lp({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const h=i||Mi(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&s!=null){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?_u(p):p,y=l.dtype==="string"?_u(m):m,[b,x]=s(l.shape,c.shape,g,y,h),w=u.makeTensorInfo(x,h),S=u.texData.get(w.dataId);return S.values=b,w}const f=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return f?d=new Vw(e,l.shape,c.shape,t):d=new gg(n,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function N_(n,e=!1){if(n==="linear")return e?MNe:kNe;if(n==="relu")return e?$Ne:ENe;if(n==="elu")return e?NNe:TNe;if(n==="relu6")return e?RNe:INe;if(n==="prelu")return e?YJ:KJ;if(n==="leakyrelu")return e?XJ:qJ;if(n==="sigmoid")return e?PNe:ANe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZJ=class{constructor(e,t,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=To(this.outputShape.length);const u=s?e[1]:e[2],h=Math.ceil(u/2),f=s?"i * 2, rc.y":"rc.y, i * 2",d=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let LG=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ln(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG="return a * b;";function xB(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Mi(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),c=new LG(FG.REAL,r.shape,s.shape),u=new LG(FG.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Lp({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),[c,u]=XMe(r.shape,s.shape,a.values,l.values,i),h=t.makeTensorInfo(u,i),f=t.texData.get(h.dataId);return f.values=c,h}let o;return Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Vw(zG,r.shape,s.shape):o=new gg(zG,r.shape,s.shape),t.runWebGLProgram(o,[r,s],i)}const YNe={kernelName:gy,backendName:"webgl",kernelFunc:xB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZNe(n,e,t){const r=[sv(n.shape),...iv(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[sv(e),...iv(e)],o=new jJ(i,r),a=!0,l=[r],c=t.runWebGLProgram(o,[s],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=t,a=Te(s.shape),l=_M(i,a),c=Te(l);U(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return u.isPacked&&!LI(s.shape,l)&&!(u.texture!==null&&LI(u.shape,l))?ZNe(s,l,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const JNe={kernelName:bw,backendName:"webgl",kernelFunc:At};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BG{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${og(h)?h.toPrecision(2):h}, ones);`}let u="";i%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QNe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,h=r%4;let f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$e(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=pN(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function qy(n,e,t,r){const s=e$e(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,h;t==="mean"?u=o===0?new BG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new BG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new QNe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=i,i=r.runWebGLProgram(u,[i],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t$e=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=n$e(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function n$e(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r$e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Fr(this.rank),i=HJ("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(n,e,t){const r=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new r$e(n.shape,e):new t$e(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$e(n,e,t,r){const s=e,i=n.shape.length,o=An(s,n.shape);let a=o;const l=Lr(a,i),c=l!=null;let u=n;c&&(u=DN(n,l,r),a=ns(a.length,i)),fi("sum",a,i);const[h,f]=Qs(u.shape,a);let d=h;t&&(d=Ls(h,o));const p=Te(f),g=Te(n.shape)/p,y=At({inputs:{x:u},attrs:{shape:[g,p]},backend:r}),b=q2(n.dtype),x=qy(y,b,"sum",r),w=At({inputs:{x},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return s$e(s,i,o,t)}const i$e={kernelName:Cw,backendName:"webgl",kernelFunc:ON};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zo(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const h=o.texData.get(s.dataId).values,f=vB(h,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype);const d=o.texData.get(c.dataId);d.values=f}else c=DN(s,i,o);return c}const o$e={kernelName:jd,backendName:"webgl",kernelFunc:Zo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJ=1e3;function zI({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=At({inputs:{x:n},backend:s,attrs:{shape:S}}),A=At({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=t?k.shape[1]:k.shape[2],O=i!=null,R=o!=null,D=l==="leakyrelu",z=l!=null?N_(l,!0):null,B=O||R||D||z!=null;let X;if((d===1||p===1)&&N>JJ&&B===!1){let te=k,ge=A;t&&(te=Zo({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),M.push(te)),r&&(ge=Zo({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),M.push(ge));const ae=p!==1,Ne=p===1;let ke=te;ae&&(ke=At({inputs:{x:te},backend:s,attrs:{shape:[E,N,1]}}),M.push(ke));const De=p===1?2:1;let be=ge;Ne&&(be=At({inputs:{x:ge},backend:s,attrs:{shape:[E,1,N]}}),M.push(be));const Xe=xB({inputs:{a:ke,b:be},backend:s});X=ON({inputs:{x:Xe},backend:s,attrs:{axis:De,keepDims:!0}}),M.push(Xe)}else{const te=Mi(n.dtype,e.dtype),ge=new ZJ(S,C,[E,d,p],t,r,O,z,R,D),ae=[k,A];if(i!=null&&ae.push(i),R&&ae.push(o),D){const Ne=s.makeTensorInfo([],"float32",Hf(a,"float32"));ae.push(Ne),M.push(Ne)}X=s.runWebGLProgram(ge,ae,te)}const G=At({inputs:{x:X},backend:s,attrs:{shape:w}});M.push(X);for(const te of M)s.disposeIntermediateTensorInfo(te);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return zI({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const l$e={kernelName:Hb,backendName:"webgl",kernelFunc:a$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG="return abs(x);";function c$e(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=t.texData.get(r.dataId),o=WJ(i.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Dd(r.shape,VG):s=new fh(r.shape,VG),t.runWebGLProgram(s,[r],r.dtype)}const u$e={kernelName:Mv,backendName:"webgl",kernelFunc:c$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$e=Pc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,f$e=gr({opSnippet:h$e}),d$e={kernelName:Vg,backendName:"webgl",kernelFunc:f$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$e=Pc+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,m$e=gr({opSnippet:p$e}),g$e={kernelName:Ug,backendName:"webgl",kernelFunc:m$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG="return a + b;",y$e=uo({opSnippet:UG,packedOpSnippet:UG,supportsComplex:!0,cpuKernelImpl:EMe}),b$e={kernelName:Mp,backendName:"webgl",kernelFunc:y$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v$e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let w$e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Ka({inputs:{x:r[0]},backend:t});if(r.length>Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=FE({inputs:r.slice(0,l),backend:t}),u=FE({inputs:r.slice(l),backend:t});return FE({inputs:[c,u],backend:t})}const s=r.map(l=>l.dtype).reduce((l,c)=>Mi(l,c)),i=r.map(l=>l.shape),a=Ee().getBool("WEBGL_PACK")?new w$e(r[0].shape,i):new v$e(r[0].shape,i);return t.runWebGLProgram(a,r,s)}const x$e={kernelName:Nv,backendName:"webgl",kernelFunc:FE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,a)),fi("all",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=qy(m,m.dtype,"all",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const S$e={kernelName:qS,backendName:"webgl",kernelFunc:_$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,a)),fi("any",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=qy(m,m.dtype,"any",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const k$e={kernelName:XS,backendName:"webgl",kernelFunc:C$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T$e=class{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E$e{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Fr(l),u=Wo("coords",l);let h,f;if(o===1){f=l+1;const A=Fr(f);h=`
        ${A} sourceLocR = ${A}(${u.join()}, 0);
        ++${u[l-1]};
        ${A} sourceLocG = ${A}(${u.join()}, 0);
        ++${u[l-2]};
        ${A} sourceLocA = ${A}(${u.join()}, 0);
        --${u[l-1]};
        ${A} sourceLocB = ${A}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const d=["x","y","z","w","u","v"].slice(0,f),p="."+d[f-1],m=d.map(A=>"int "+A),g=Wo("sourceLocR",f-1).concat("inIdx.r"),y=Wo("sourceLocG",f-1).concat("inIdx.g"),b=Wo("sourceLocB",f-1).concat("inIdx.b"),x=Wo("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",S=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJ(n,e,t,r=null){let s=e.shape[0],i=e.shape[1];r!=null&&(s=r.shape[0],i=r.shape[1]);const o=pN(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new T$e(a,t,r==null),c=[e];r!=null&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=QJ(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function eQ(n,e,t,r=null){const s=r!=null?r.shape:e.shape,i=s[s.length-1],o=pN(i),a=new E$e(s,o,t,r==null),l=r==null?[e]:[e,r],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=eQ(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function tQ(n,e,t,r){const s=[t];if(fi("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!Ee().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[c,u]=Qs(l.shape,s),h=Te(u),f=At({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(f);const d=QJ(n,f,r);i.push(d);const p=At({inputs:{x:d},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return eQ(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Zo({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMax",[o[0]],l.shape.length);const u=tQ(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const A$e={kernelName:$v,backendName:"webgl",kernelFunc:I$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Zo({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMin",[o[0]],l.shape.length);const u=tQ(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const N$e={kernelName:Rv,backendName:"webgl",kernelFunc:M$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$e=Pc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,R$e=gr({opSnippet:$$e}),P$e={kernelName:Wg,backendName:"webgl",kernelFunc:R$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$e=Pc+"return log(x + sqrt(x * x + 1.0));",O$e=gr({opSnippet:D$e}),F$e={kernelName:Gg,backendName:"webgl",kernelFunc:O$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L$e=Pc+`
  return atan(x);
`,z$e=gr({opSnippet:L$e}),B$e={kernelName:Hg,backendName:"webgl",kernelFunc:z$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$e=wB+`
  return atan(a, b);
`,U$e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+jy+`
  return result;
`,W$e=uo({opSnippet:V$e,packedOpSnippet:U$e}),G$e={kernelName:qg,backendName:"webgl",kernelFunc:W$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$e=Pc+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,j$e=gr({opSnippet:H$e}),q$e={kernelName:jg,backendName:"webgl",kernelFunc:j$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $_=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const S=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${S};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${w});
      }
    `}},_B=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg";let w="0.0";if(x||(w="-1.0 / 1e-20"),r){const E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,A=o%4,M=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${k};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${C});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;gC(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return Ka({inputs:{x:s},backend:t});const h=new $_(u,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const K$e={kernelName:Pv,backendName:"webgl",kernelFunc:X$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],h=Ll(s.shape,i,o,u,a,l,c),f=new _B(h,"avg",!1);return t.runWebGLProgram(f,[s],"float32")}const Z$e={kernelName:Dv,backendName:"webgl",kernelFunc:Y$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let J$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,f=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Q$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=h-1-e.padInfo.front,m=f-1-e.padInfo.top,g=d-1-e.padInfo.left,y=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new Q$e(f);return t.runWebGLProgram(d,[s],o.dtype)}const tRe={kernelName:YS,backendName:"webgl",kernelFunc:eRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;gC([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new J$e(u);return t.runWebGLProgram(h,[s],o.dtype)}const rRe={kernelName:KS,backendName:"webgl",kernelFunc:nRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sRe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return zI({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const iRe={kernelName:Ov,backendName:"webgl",kernelFunc:sRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oRe=class{constructor(e,t,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="0.0";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aRe{constructor(e,t,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="vec4(0.0)";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lRe=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;U(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[r,s,i];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const f=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new aRe(r.shape,s.shape,i.shape,u,h,l):new oRe(r.shape,s.shape,i.shape,u,h,l);return e.runWebGLProgram(f,c,c[0].dtype)},cRe={kernelName:Xv,backendName:"webgl",kernelFunc:lRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uRe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Fr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=hRe(this.rank);let s;const i=e.map((o,a)=>`sourceLoc.${LD[a]} = start[${a}] + coords.${LD[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const LD=["x","y","z","w","u","v"];function hRe(n){if(n===1)return"sourceLoc";if(n<=6)return LD.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fRe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Fr(this.rank),r=Wo("coords",this.rank),s=Wo("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dRe(n,e,t,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(t,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=tB(e,Jt(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}function Ww(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=hC(s,i,o);if(uN(s,a,l),Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),f=iNe(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}const{isPacked:c}=t.texData.get(s.dataId),u=eB(s.shape,a,l);if(c||!u){const h=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fRe(l):new uRe(l),f=[a];return t.runWebGLProgram(h,[s],s.dtype,f)}return t.uploadToGPU(s.dataId),dRe(s,a,l,t)}const pRe={kernelName:Sw,backendName:"webgl",kernelFunc:Ww};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mRe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Vy(s.shape,i,a),c=Uy(l.length,i.length),u=Wy(s.shape,i,a),h=gN(o,i.length),f=yN(u,o,i.length),d=[],p=At({inputs:{x:s},backend:t,attrs:{shape:l}}),m=Zo({inputs:{x:p},backend:t,attrs:{perm:c}}),g=At({inputs:{x:m},backend:t,attrs:{shape:u}}),y=Ww({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},gRe={kernelName:Fv,backendName:"webgl",kernelFunc:mRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=UJ(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const bRe={kernelName:ZS,backendName:"webgl",kernelFunc:yRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vRe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,wRe=`
  return float(int(a.r) & int(b.r));
`;function xRe(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ee().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,s])||o===1){const l=t.texData.get(r.dataId).values,c=t.texData.get(s.dataId).values,[u,h]=AMe(r.shape,s.shape,l,c,r.dtype),f=t.makeTensorInfo(h,r.dtype),d=t.texData.get(f.dataId);return d.values=u,f}let a;return i?a=new Vw(vRe,r.shape,s.shape,!1):a=new gg(wRe,r.shape,s.shape),t.runWebGLProgram(a,[r,s],r.dtype)}const _Re={kernelName:JS,backendName:"webgl",kernelFunc:xRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SRe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.readSync(r.dataId),o=t.readSync(s.dataId),a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const CRe={kernelName:QS,backendName:"webgl",kernelFunc:SRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kRe="return float(a != b);",nQ=uo({opSnippet:kRe,cpuKernelImpl:YMe,dtype:"bool"}),TRe={kernelName:hw,backendName:"webgl",kernelFunc:nQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ka({inputs:{x:s.complexTensorInfos.real},backend:t})}const ERe={kernelName:A2,backendName:"webgl",kernelFunc:bC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IRe="return float(int(x));";function ARe(n,e){const t=new fh(n.shape,IRe),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Ka({inputs:{x:s},backend:t});const o=ms(s.shape),a=zD({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Lp({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const o=bC({inputs:{input:s},backend:t}),a=zD({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!SM(s.dtype,i)){const o=Ka({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId).values,[a,l,c]=MMe(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return ARe(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",ci("bool",1)),l=nQ({inputs:{a:s,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const MRe={kernelName:Xg,backendName:"webgl",kernelFunc:zD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WG="return ceil(x);",NRe=gr({opSnippet:WG,packedOpSnippet:WG,cpuKernelImpl:NMe}),$Re={kernelName:Kg,backendName:"webgl",kernelFunc:NRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RRe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PRe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;Ee().getBool("WEBGL_PACK_CLIP")?a=new PRe(s.shape):a=new RRe(s.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[s],s.dtype,l)}const ORe={kernelName:Yg,backendName:"webgl",kernelFunc:DRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FRe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GG(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function LRe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),i=new FRe(r.shape),o=[GG(r,s.complexTensorInfos.real),GG(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const zRe={kernelName:Lv,backendName:"webgl",kernelFunc:LRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BRe=class{constructor(e){this.outputShape=[],this.outputShape=ba(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const s=t.length,i=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VRe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ba(e,t);const r=this.outputShape,s=r.length,i=Fr(s),o=Wo("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];f+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${tT(a,c,g)}),
            vec2(${tT(u,c,g)}));
        }`}const d=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${tT(a,c,p)}),
          vec2(${tT(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${f}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function tT(n,e,t){const r=n.indexOf(e);return n.map((i,o)=>o===r?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ka({inputs:{x:s.complexTensorInfos.imag},backend:t})}const URe={kernelName:v2,backendName:"webgl",kernelFunc:FN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const d=n.map(b=>bC({inputs:{input:b},backend:t})),p=n.map(b=>FN({inputs:{input:b},backend:t})),m=I1(d,e,t),g=I1(p,e,t),y=Lp({inputs:{real:m,imag:g},backend:t});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const d=n.map(w=>{const C=[-1,Te(w.shape.slice(e))];return At({inputs:{x:w},backend:t,attrs:{shape:C}})}),p=d.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),m=ba(d.map(w=>w.shape),1),g=d[0].shape[0]===1,y=$Me(p,m,r,g),b=ba(n.map(w=>w.shape),e),x=t.makeTensorInfo(b,r,y);return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const i=n.filter(d=>Te(d.shape)>0),o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const d=o?new fh(n[0].shape,Ad):new Dd(n[0].shape,Ad);return t.runWebGLProgram(d,n,r)}const a=Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const d=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);d.push(I1(g,e,t))}const p=I1(d,e,t);for(const m of d)t.disposeIntermediateTensorInfo(m);return p}if(o){const d=new VRe(i.map(p=>p.shape),e);return t.runWebGLProgram(d,i,r)}const{tensors2D:l,outShape:c}=WRe(i,e,t),u=new BRe(l.map(d=>d.shape)),h=t.runWebGLProgram(u,l,r);l.forEach(d=>t.disposeIntermediateTensorInfo(d));const f=At({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),f}function WRe(n,e,t){const r=ba(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>At({inputs:{x:i},attrs:{shape:[-1,Te(i.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(c=>c.shape);dN(o,i);const a=ba(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?Ka({inputs:{x:l[0]},backend:t}):I1(l,i,t)}const GRe={kernelName:zv,backendName:"webgl",kernelFunc:rQ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sQ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1;let w="",S="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,S="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${S}
        setOutput(result);
      }
    `}}class HRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iQ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?xM(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",p="";r&&(s?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jRe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const{dataFormat:r}=t,s=ra(),i=r==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function oQ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],f=t.outChannels,d=t.dataFormat==="channelsLast",p=!1,m=!1;let g;const y=[];if(i!=null){const w=BI(i.shape,d);w!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:w}}),y.push(i))}if(s!=null){const w=BI(s.shape,d);w!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(!((h===1||f===1)&&u>JJ)&&c.isPacked&&d&&c.texture!=null&&l[2]%2!==0&&Rn(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,U(LI(c.shape,S.shape),()=>`packed reshape ${c.shape} to ${S.shape} isn't free`);const k=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const A=zI({a:S,b:k,backend:r,transposeA:p,transposeB:m,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),M=r.texData.get(A.dataId);U(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,M.shape=t.outShape,g=Ka({inputs:{x:A},backend:r}),g.shape=t.outShape,y.push(A)}else{const w=t.outHeight*t.outWidth,S=At({inputs:{x:n},backend:r,attrs:{shape:d?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),C=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=zI({a:d?S:C,b:d?C:S,transposeA:!d,transposeB:m,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=At({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),y.push(S),y.push(C),y.push(k)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function aQ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:f,dataFormat:d}=t,p=d==="channelsLast",m=l*c*u,g=f*h,y=[t.batchSize,m,g],b=!0,x=!1,w=[];if(i!=null){const G=BI(i.shape,p);G!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:G}}),w.push(i))}if(s!=null){const G=BI(s.shape,p);G!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:G}}),w.push(s))}const S=At({inputs:{x:e},backend:r,attrs:{shape:[1,m,Te(e.shape)/m]}});w.push(S);const C=new jRe(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=r.runWebGLProgram(C,[n],"float32",k),M=At({inputs:{x:A},backend:r,attrs:{shape:y}});w.push(A),w.push(M);const E=s!=null,N=i!=null,O=a==="leakyrelu",R=a?N_(a,!0):null,D=new ZJ(p?M.shape:S.shape,p?S.shape:M.shape,p?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,x,E,R,N,O),z=p?[M,S]:[S,M];if(s&&z.push(s),N&&z.push(i),O){const G=r.makeTensorInfo([],"float32",Hf(o,"float32"));z.push(G),w.push(G)}const B=r.runWebGLProgram(D,z,"float32"),X=At({inputs:{x:B},backend:r,attrs:{shape:t.outShape}});w.push(B);for(const G of w)r.disposeIntermediateTensorInfo(G);return X}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=nl(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h);let d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=oQ({x:s,filter:i,convInfo:f,backend:t});else if(f.strideWidth<=2&&h==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const m=new iQ(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=t.runWebGLProgram(m,[s,i],"float32",g)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))d=aQ({x:s,filter:i,convInfo:f,backend:t});else{const m=new sQ(f);d=t.runWebGLProgram(m,[s,i],"float32")}const p=At({inputs:{x:d},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(d),p}const XRe={kernelName:Bv,backendName:"webgl",kernelFunc:qRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},YRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=r-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},ZRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},JRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=r-1-e.padInfo.top,u=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=nl(l),f=ts(s.shape,u,o,1,a,c,!1,h),d=new KRe(f);return t.runWebGLProgram(d,[s,i],"float32")}const e3e={kernelName:t2,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t3e{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=To(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,s=t-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=nl(c),f=ts(o,i.shape,a,1,l,u,!1,h);if(Ee().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const d=[[f.strideHeight,f.strideWidth]],p=new t3e(f);return t.runWebGLProgram(p,[s,i],"float32",d)}else{const d=new YRe(f);return t.runWebGLProgram(d,[s,i],"float32")}}const r3e={kernelName:Vv,backendName:"webgl",kernelFunc:n3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Lu(s.shape,i.shape,o,l,a),u=new HRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const i3e={kernelName:Uv,backendName:"webgl",kernelFunc:s3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Lu(s.shape,l,o,1,a),u=new ZRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const a3e={kernelName:n2,backendName:"webgl",kernelFunc:o3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r,c=Lu(l,i.shape,a,1,o),u=new JRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const c3e={kernelName:r2,backendName:"webgl",kernelFunc:l3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3e=Uw+`
  return cos(x);
`,h3e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${jy}
  return result;
`,f3e=gr({opSnippet:u3e,packedOpSnippet:h3e}),d3e={kernelName:Zg,backendName:"webgl",kernelFunc:f3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p3e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,m3e=gr({opSnippet:p3e}),g3e={kernelName:Jg,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let y3e=class{constructor(e,t,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,f]=r;this.outputShape=[u,h,f,c];const d=s==="bilinear"?1:0,[p,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,w,S]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3e=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new y3e(s.shape,i.shape,a,l,c);return t.runWebGLProgram(u,[s,i,o],"float32")},v3e={kernelName:i2,backendName:"webgl",kernelFunc:b3e};var R_;(function(n){n.Prod="*",n.Sum="+"})(R_||(R_={}));let HG=class{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===R_.Prod?"1.0":"0.0",a=r?o:`getX(${jG(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?`end != ${l-1}`:"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fr(i)} coords = getOutputCoords();
        int end = ${qG(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${qG(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${jG(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function jG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function qG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Zo({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ns(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Ka({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new HG(n,l.shape,!1,i),p=[[f]],m=h;h=t.runWebGLProgram(d,[h],h.dtype,p),t.disposeIntermediateTensorInfo(m)}if(s){const f=new HG(n,l.shape,s,i),d=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const f=Oh(a),d=Zo({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return lQ(R_.Prod,s,t,i,o,a)}const x3e={kernelName:s2,backendName:"webgl",kernelFunc:w3e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return lQ(R_.Sum,s,t,i,o,a)}const S3e={kernelName:Wv,backendName:"webgl",kernelFunc:_3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=UJ(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=IMe(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const k3e={kernelName:o2,backendName:"webgl",kernelFunc:C3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T3e=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=new T3e(p,i,o);return t.runWebGLProgram(m,[s],s.dtype)}const I3e={kernelName:a2,backendName:"webgl",kernelFunc:E3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cQ=class{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uQ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,f=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<h;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const b=y*2;if(d+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?d+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const x=a%2===0?xM(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:d+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?d+=`
                    xC${b+1} = xTexelC${b};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(d+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(d+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(d+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",m="";r&&(s?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),U(Ri(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=ts(s.shape,i.shape,o,u,a,c,!0);let f;Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new uQ(h):f=new cQ(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(f,[s,i],"float32",d)}const M3e={kernelName:Gv,backendName:"webgl",kernelFunc:A3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let N3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},$3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ts(s.shape,u,o,a,l,c,!0),f=new N3e(h);return t.runWebGLProgram(f,[s,i],"float32")}const P3e={kernelName:l2,backendName:"webgl",kernelFunc:R3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ts(u,i.shape,o,a,l,c,!0),f=new $3e(h);return t.runWebGLProgram(f,[s,i],"float32")}const O3e={kernelName:c2,backendName:"webgl",kernelFunc:D3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F3e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3e(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=At({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new F3e(i),l=t.runWebGLProgram(a,[o],o.dtype),c=At({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const z3e={kernelName:u2,backendName:"webgl",kernelFunc:L3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let B3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Pp(s.shape,i.shape,o,a,"NHWC",l);let u;const h=new B3e(c);u=t.runWebGLProgram(h,[s,i],"float32");const f=At({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),f}const U3e={kernelName:Hv,backendName:"webgl",kernelFunc:V3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3e(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=CN(s,i.length);TN(o.length,l,i);const{path:c,steps:u}=EN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=kN(d,l[g]);let x;IN(y)?x=i[g]:(x=Zo({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=At({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=xB({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=ON({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const G3e={kernelName:f2,backendName:"webgl",kernelFunc:W3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3e="return (x >= 0.0) ? x : (exp(x) - 1.0);",j3e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,q3e=gr({opSnippet:H3e,packedOpSnippet:j3e}),X3e={kernelName:ey,backendName:"webgl",kernelFunc:q3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K3e="return (b >= 0.0) ? a : a * (b + 1.0);",Y3e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Z3e=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vw(Y3e,r.shape,s.shape):new gg(K3e,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],r.dtype)},J3e={kernelName:d2,backendName:"webgl",kernelFunc:Z3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3e=`
  return vec4(equal(a, b));
`,ePe="return float(a == b);",tPe=uo({opSnippet:ePe,packedOpSnippet:Q3e,dtype:"bool",cpuKernelImpl:RMe}),nPe={kernelName:jv,backendName:"webgl",kernelFunc:tPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rPe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${bN};
  float a1 = ${vN};
  float a2 = ${wN};
  float a3 = ${xN};
  float a4 = ${_N};
  float a5 = ${SN};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,sPe=gr({opSnippet:rPe}),iPe={kernelName:ty,backendName:"webgl",kernelFunc:sPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oPe=Uw+`
  return exp(x);
`,aPe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hQ=gr({opSnippet:oPe,packedOpSnippet:aPe,cpuKernelImpl:PMe,dtype:"float32"}),lPe={kernelName:ny,backendName:"webgl",kernelFunc:hQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),At({inputs:{x:i},backend:r,attrs:{shape:a}})}const cPe={kernelName:qv,backendName:"webgl",kernelFunc:BD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG="return exp(x) - 1.0;",uPe=gr({opSnippet:XG,packedOpSnippet:XG,cpuKernelImpl:DMe}),hPe={kernelName:ry,backendName:"webgl",kernelFunc:uPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KG=class{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(n,e,t){const r=t.texData.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=At({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,c=new KG("real",l,e),u=new KG("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Lp({inputs:{real:f,imag:d},backend:t});t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d);const m=At({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return fQ(r,!1,t)}const dPe={kernelName:p2,backendName:"webgl",kernelFunc:fPe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pPe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vC(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||Ap(s),i==="string"){const o=Ss(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new pPe(r,s),a=[[s]];return e.runWebGLProgram(o,[],i,a)}}const mPe={kernelName:m2,backendName:"webgl",kernelFunc:vC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gPe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yPe={kernelName:g2,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new gPe(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YG="return floor(x);",bPe=gr({opSnippet:YG,packedOpSnippet:YG,cpuKernelImpl:OMe}),vPe={kernelName:sy,backendName:"webgl",kernelFunc:bPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wPe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,xPe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,_Pe=uo({opSnippet:wPe,packedOpSnippet:xPe,dtype:"int32"}),SPe={kernelName:iy,backendName:"webgl",kernelFunc:_Pe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CPe=class{constructor(e){this.variableNames=["A"];const t=ra(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kPe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ra(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TPe={kernelName:v_,backendName:"webgl",kernelFunc:EPe};let $0,g3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function EPe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],h=[c,l,i];if(a||o){const m=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($0==null||m!==g3)&&(g3=m,$0=document.createElement("canvas").getContext("2d",{willReadFrequently:g3})),$0.canvas.width=l,$0.canvas.height=c,$0.drawImage(s,0,0,l,c),s=$0.canvas}const f=t.makeTensorInfo(u,"int32");t.texData.get(f.dataId).usage=Sl.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(f.dataId),s);const d=Ee().getBool("WEBGL_PACK")?new kPe(h):new CPe(h),p=t.runWebGLProgram(d,[f],"int32");return t.disposeData(f.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IPe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=nl(u),g=ts(s.shape,i.shape,l,h,c,f,!1,m);let y;const b=[],x=o!=null,w=a!=null,S=d==="leakyrelu",C=()=>{const A=[s,i],M=(E,N)=>{if(N==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const O=At({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return b.push(O),O}return E};if(x&&A.push(M(o,u)),w&&A.push(M(a,u)),S){const E=t.makeTensorInfo([],"float32",Hf(p,"float32"));A.push(E),b.push(E)}return A};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=oQ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else if(g.strideWidth<=2&&m==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const A=d?N_(d,!0):null,M=new iQ(g,x,A,w,S),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=C();y=t.runWebGLProgram(M,N,"float32",E)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))y=aQ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else{const A=d?N_(d,!1):null,M=new sQ(g,x,A,w,S),E=C();y=t.runWebGLProgram(M,E,"float32")}const k=At({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(A=>t.disposeIntermediateTensorInfo(A)),k}const APe={kernelName:jb,backendName:"webgl",kernelFunc:IPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MPe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r,p=[];let m=u;m==null&&(m=[1,1]),U(Ri(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=ts(s.shape,i.shape,l,m,c,h,!0),y=Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=f?N_(f,y):null,x=[s,i],w=o!=null,S=a!=null,C=f==="leakyrelu";if(w&&x.push(o),S&&x.push(a),C){const E=t.makeTensorInfo([],"float32",Hf(d,"float32"));x.push(E),p.push(E)}let k;y?k=new uQ(g,w,b,S,C):k=new cQ(g,w,b,S,C);const A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=t.runWebGLProgram(k,x,"float32",A);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),M}const NPe={kernelName:qb,backendName:"webgl",kernelFunc:MPe};let $Pe=class{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=Fr(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RPe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=uC(r,s),f=At({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=At({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=t.readSync(s.dataId),b=t.bufferSync(r),x=FMe(y,b,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,x.values)}const p=new $Pe(o,h,[c,u],r.shape),m=t.runWebGLProgram(p,[d,f],d.dtype),g=At({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),g}const PPe={kernelName:y2,backendName:"webgl",kernelFunc:RPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DPe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Fr(this.rank),s=OPe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function OPe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=An(o,s.shape)[0];if(Ee().get("DEBUG")){const b=t.readSync(i.dataId),x=s.shape[l];for(let w=0;w<b.length;++w){const S=b[w];U(S<=x-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${x-1}]`)}}const c=MN(s,i,l,a),u=Te(i.shape),h=[],f=At({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=At({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=t.bufferSync(d),x=t.bufferSync(f),w=LMe(x,b,p);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(c.outputShape,w.dtype,w.values)}const m=new DPe(f.shape,p),g=t.runWebGLProgram(m,[f,d],f.dtype);h.push(g);const y=At({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const FPe={kernelName:Kv,backendName:"webgl",kernelFunc:dQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LPe="return float(a > b);",zPe=`
  return vec4(greaterThan(a, b));
`,BPe=uo({opSnippet:LPe,packedOpSnippet:zPe,cpuKernelImpl:zMe,dtype:"bool"}),VPe={kernelName:Yv,backendName:"webgl",kernelFunc:BPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UPe="return float(a >= b);",WPe=`
  return vec4(greaterThanEqual(a, b));
`,GPe=uo({opSnippet:UPe,packedOpSnippet:WPe,dtype:"bool",cpuKernelImpl:BMe}),HPe={kernelName:oy,backendName:"webgl",kernelFunc:GPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return fQ(r,!0,t)}const qPe={kernelName:b2,backendName:"webgl",kernelFunc:jPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XPe="return float(!isnan(x) && !isinf(x));",KPe=gr({opSnippet:XPe,dtype:"bool"}),YPe={kernelName:ly,backendName:"webgl",kernelFunc:KPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZPe="return float(isinf(x));",JPe=gr({opSnippet:ZPe,dtype:"bool"}),QPe={kernelName:cy,backendName:"webgl",kernelFunc:JPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eDe="return float(isnan(x));",tDe=gr({opSnippet:eDe,dtype:"bool"}),nDe={kernelName:uy,backendName:"webgl",kernelFunc:tDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rDe="return float(a < b);",sDe=`
  return vec4(lessThan(a, b));
`,iDe=uo({opSnippet:rDe,packedOpSnippet:sDe,cpuKernelImpl:VMe,dtype:"bool"}),oDe={kernelName:Jv,backendName:"webgl",kernelFunc:iDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aDe="return float(a <= b);",lDe=`
  return vec4(lessThanEqual(a, b));
`,cDe=uo({opSnippet:aDe,packedOpSnippet:lDe,cpuKernelImpl:UMe,dtype:"bool"}),uDe={kernelName:Qv,backendName:"webgl",kernelFunc:cDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hDe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=WMe(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const fDe={kernelName:w2,backendName:"webgl",kernelFunc:hDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dDe=Uw+`
  return x < 0.0 ? 0./0. : log(x);
`,pDe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,mDe=gr({opSnippet:dDe,packedOpSnippet:pDe,cpuKernelImpl:GMe}),gDe={kernelName:hy,backendName:"webgl",kernelFunc:mDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yDe=Uw+`
  return log(1.0 + x);
`,bDe=gr({opSnippet:yDe}),vDe={kernelName:fy,backendName:"webgl",kernelFunc:bDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wDe="return float(a >= 1.0 && b >= 1.0);",xDe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,_De=uo({opSnippet:wDe,packedOpSnippet:xDe,dtype:"bool"}),SDe={kernelName:ew,backendName:"webgl",kernelFunc:_De};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CDe="return float(!(x >= 1.0));",kDe=gr({opSnippet:CDe}),TDe={kernelName:tw,backendName:"webgl",kernelFunc:kDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EDe="return float(a >= 1.0 || b >= 1.0);",IDe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ADe=uo({opSnippet:EDe,packedOpSnippet:IDe,dtype:"bool"}),MDe={kernelName:nw,backendName:"webgl",kernelFunc:ADe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let NDe=class{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $De{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RDe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new $De(s.shape,i,o,a,l):new NDe(s.shape,i,o,a,l);return t.runWebGLProgram(c,[s],s.dtype)},PDe={kernelName:rw,backendName:"webgl",kernelFunc:RDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DDe=class{constructor(e,t,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ODe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new DDe(s.shape,a,l,c,u);return t.runWebGLProgram(h,[s,i,o],s.dtype)},FDe={kernelName:x2,backendName:"webgl",kernelFunc:ODe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LDe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=qy(a,n.dtype,"max",r),c=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a),h=u!=null,f=t.shouldExecuteOnCPU([s]);let d=s;if(h){if(f){const x=t.texData.get(d.dataId).values,w=new Array(a);for(let k=0;k<w.length;k++)w[k]=s.shape[u[k]];const S=vB(x,s.shape,s.dtype,u,w);d=t.makeTensorInfo(w,s.dtype);const C=t.texData.get(d.dataId);C.values=S}else d=DN(s,u,t);c=ns(c.length,a)}fi("max",c,a);const[p,m]=Qs(d.shape,c);let g=p;o&&(g=Ls(p,l));let y;if(f){const x=t.texData.get(d.dataId).values,w=HMe(x,Te(m),g,s.dtype);y=t.makeTensorInfo(g,s.dtype);const S=t.texData.get(y.dataId);S.values=w}else y=LDe(d,m,g,t);return h&&t.disposeIntermediateTensorInfo(d),y}const zDe={kernelName:sw,backendName:"webgl",kernelFunc:pQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BDe=wB+`
  return max(a, b);
`,VDe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+jy+`
  return result;
`,UDe=uo({opSnippet:BDe,packedOpSnippet:VDe,cpuKernelImpl:jMe}),WDe={kernelName:dy,backendName:"webgl",kernelFunc:UDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;gC(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return Ka({inputs:{x:s},backend:t});const h=new $_(u,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const HDe={kernelName:iw,backendName:"webgl",kernelFunc:GDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(s.shape,i,o,u,a,c,l),f=new _B(h,"max",!1);return t.runWebGLProgram(f,[s],s.dtype)}const qDe={kernelName:ow,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},KDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=c-1-e.padInfo.top,d=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new _B(f,"max",!0),p=t.runWebGLProgram(d,[o],o.dtype),m=new KDe(f),g=t.runWebGLProgram(m,[s,p],o.dtype);return t.disposeIntermediateTensorInfo(p),g}const ZDe={kernelName:S2,backendName:"webgl",kernelFunc:YDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;gC([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=!0,p=new $_(f,"max",d),m=t.runWebGLProgram(p,[a],a.dtype),g=new XDe(f),y=t.runWebGLProgram(g,[s,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}const QDe={kernelName:_2,backendName:"webgl",kernelFunc:JDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eOe(n,e,t,r){let s=new $_(t,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");s=new $_(t,"max",!0,!0,e);const o=r.runWebGLProgram(s,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tOe={kernelName:C2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];U(Ri(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ko(r.shape,s,i,c,o),[h,f]=eOe(r,a,u,l);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nOe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=qy(a,"float32","mean",r),c=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rOe={kernelName:aw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:i}=e,o=t,a=r.shape.length,l=An(i,r.shape);let c=l;const u=Lr(c,a),h=u!=null,f=o.shouldExecuteOnCPU([r]),d=[];let p=r;if(h){if(f){const w=o.texData.get(p.dataId).values,S=new Array(a);for(let A=0;A<S.length;A++)S[A]=r.shape[u[A]];const C=vB(w,r.shape,r.dtype,u,S);p=o.makeTensorInfo(S,r.dtype);const k=o.texData.get(p.dataId);k.values=C}else p=DN(r,u,o);d.push(p),c=ns(c.length,a)}fi("sum",c,a);const[m,g]=Qs(p.shape,c);let y=m;s&&(y=Ls(m,l));const b=nOe(p,g,y,o);for(const x of d)o.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,s.shape.length)),fi("min",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=qy(m,m.dtype,"min",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const iOe={kernelName:lw,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oOe=wB+`
  return min(a, b);
`,aOe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+jy+`
  return result;
`,lOe=uo({opSnippet:oOe,packedOpSnippet:aOe,cpuKernelImpl:qMe}),cOe={kernelName:py,backendName:"webgl",kernelFunc:lOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uOe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const s=e.length,i=Fr(s),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);const s=e.length,i=Fr(s),o=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+e[m]).join(","),l=Wo("rc",s),c=Wo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let d="";if(s===1){const p=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const p=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[s-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fOe=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:i}=t,o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hOe(r.shape,s,i):new uOe(r.shape,s,i);return e.runWebGLProgram(o,[r],r.dtype)},dOe={kernelName:cw,backendName:"webgl",kernelFunc:fOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pOe=`if (b == 0.0) return NAN;
  return mod(a, b);`,mOe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+jy+`
  return result;
`,gOe=uo({opSnippet:pOe,packedOpSnippet:mOe}),yOe={kernelName:my,backendName:"webgl",kernelFunc:gOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bOe=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vOe=`
if (a == b) {
  return 1.0;
};
return a / b;`,wOe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,mQ=uo({opSnippet:vOe,packedOpSnippet:wOe,checkOutOfBounds:!0}),xOe={kernelName:Qg,backendName:"webgl",kernelFunc:mQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG="return a - b;",gQ=uo({opSnippet:ZG,packedOpSnippet:ZG,supportsComplex:!0,cpuKernelImpl:pNe}),_Oe={kernelName:Ny,backendName:"webgl",kernelFunc:gQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=An([i],s.shape),a=pQ({inputs:{x:s},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Ls(a.shape,o),c=At({inputs:{x:a},backend:t,attrs:{shape:l}}),u=gQ({inputs:{a:s,b:c},backend:t}),h=hQ({inputs:{x:u},backend:t}),f=ON({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),d=At({inputs:{x:f},backend:t,attrs:{shape:l}}),p=mQ({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}const SOe={kernelName:Ew,backendName:"webgl",kernelFunc:yQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function COe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:yQ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new bOe(c,u,i),f=[[o]],d=t.runWebGLProgram(h,[l],"int32",f);return a||t.disposeIntermediateTensorInfo(l),d}const kOe={kernelName:k2,backendName:"webgl",kernelFunc:COe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TOe=Pc+`
  return -x;
`,EOe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function IOe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId),[o,a]=KMe(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Dd(r.shape,EOe):s=new fh(r.shape,TOe),t.runWebGLProgram(s,[r],r.dtype)}const AOe={kernelName:uw,backendName:"webgl",kernelFunc:IOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MOe=oC;function NOe(n){wl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=MOe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const $Oe={kernelName:T2,backendName:"webgl",kernelFunc:NOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROe=aN;function POe(n){wl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),{selectedIndices:f,validOutputs:d}=ROe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const DOe={kernelName:kM,backendName:"webgl",kernelFunc:POe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OOe=aC;function FOe(n){wl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=OOe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const LOe={kernelName:E2,backendName:"webgl",kernelFunc:FOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zOe=class{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BOe=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new zOe(c,o,a,l),h=At({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=t.runWebGLProgram(u,[h],i);t.disposeIntermediateTensorInfo(h);const d=[...s.shape,o],p=At({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(f),p},VOe={kernelName:dw,backendName:"webgl",kernelFunc:BOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=bC({inputs:{input:r},backend:t}),i=VI({inputs:{x:s},backend:t}),o=FN({inputs:{input:r},backend:t}),a=VI({inputs:{x:o},backend:t}),l=Lp({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return vC({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const UOe={kernelName:Mw,backendName:"webgl",kernelFunc:VI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=bC({inputs:{input:r},backend:t}),i=bQ({inputs:{x:s},backend:t}),o=FN({inputs:{input:r},backend:t}),a=VI({inputs:{x:o},backend:t}),l=Lp({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return vC({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const WOe={kernelName:fw,backendName:"webgl",kernelFunc:bQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GOe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return BD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=BD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=rQ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const HOe={kernelName:pw,backendName:"webgl",kernelFunc:GOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jOe=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const s=e.length,i=Fr(s),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const s=e.length,i=Fr(s),o=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),l=Wo("rc",s),c=Wo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${u}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${u}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=s===1?2:4;m<g;m++)p+=`
        ${f[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;p+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vQ=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return vC({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qOe(s.shape,i,o):new jOe(s.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[s],s.dtype,l)},XOe={kernelName:mw,backendName:"webgl",kernelFunc:vQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KOe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,YOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+jy+`
  return result;
`,ZOe=uo({opSnippet:KOe,packedOpSnippet:YOe}),JOe={kernelName:yy,backendName:"webgl",kernelFunc:ZOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=An(i,s.shape);let u=c;const h=Lr(u,a);let f=s;h!=null&&(f=Zo({inputs:{x:s},backend:t,attrs:{perm:h}}),u=ns(u.length,a),l.push(f)),fi("prod",u,a);let d;if(t.shouldExecuteOnCPU([f])){const p=t.texData.get(f.dataId).values,{outVals:m,outShape:g,outDtype:y}=ZMe(f.shape,f.dtype,p,u);d=t.makeTensorInfo(g,y,m)}else{const[p,m]=Qs(f.shape,u),g=Te(m),y=At({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}}),b=q2(s.dtype),x=qy(y,b,"prod",t);d=At({inputs:{x},backend:t,attrs:{shape:p}}),l.push(y),l.push(x)}if(o){l.push(d);const p=Ls(d.shape,c);d=At({inputs:{x:d},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const eFe={kernelName:yw,backendName:"webgl",kernelFunc:QOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tFe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(y=>t.readSync(y.dataId)),c=s.map(y=>y.shape),u=t.readSync(i.dataId),h=t.readSync(o.dataId),[f,d,p]=JMe(l,c,u,i.shape,i.dtype,h,o.shape,a),m=f.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,i.dtype,d);return m.concat([g])}const nFe={kernelName:TM,backendName:"webgl",kernelFunc:tFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=QMe(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const sFe={kernelName:EM,backendName:"webgl",kernelFunc:rFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iFe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),h=t.readSync(o.dataId),f=a.map(g=>t.readSync(g.dataId)),d=a.map(g=>g.shape),[p,m]=eNe(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const oFe={kernelName:IM,backendName:"webgl",kernelFunc:iFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wQ=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=tNe(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},aFe={kernelName:I2,backendName:"webgl",kernelFunc:wQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lFe="return 1.0 / x;",cFe=gr({opSnippet:lFe}),uFe={kernelName:by,backendName:"webgl",kernelFunc:cFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hFe=Pc+`
  return (x < 0.0) ? 0.0 : x;
`,fFe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dFe=gr({opSnippet:hFe,packedOpSnippet:fFe}),pFe={kernelName:vy,backendName:"webgl",kernelFunc:dFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mFe=Pc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,gFe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yFe=gr({opSnippet:mFe,packedOpSnippet:gFe}),bFe={kernelName:wy,backendName:"webgl",kernelFunc:yFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vFe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wFe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wFe(s.shape,l,c,i,o):new vFe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],"float32")}const _Fe={kernelName:ww,backendName:"webgl",kernelFunc:xFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SFe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new SFe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const kFe={kernelName:N2,backendName:"webgl",kernelFunc:CFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TFe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EFe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new EFe(s.shape,l,c,i,o):new TFe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],s.dtype)}const AFe={kernelName:vw,backendName:"webgl",kernelFunc:IFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MFe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new MFe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const $Fe={kernelName:M2,backendName:"webgl",kernelFunc:NFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RFe=class{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>s(l)).join(","),o=Fr(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PFe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Wo("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Fr(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${i}){
            result.g = ${c(s.slice())};
          }
          if(${o}) {
            result.b = ${u(s.slice())};
            if(${i}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function c(p){return p[r-1]="("+p[r-1]+" + 1)",f(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",f(p)}function h(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",f(p)}function f(p){const m=e.map((b,x)=>d(x,p)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function d(p,m){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DFe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length,a=An(i,s.shape);if(o===0)return Ka({inputs:{x:s},backend:t});const l=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PFe(s.shape,a):new RFe(s.shape,a);return t.runWebGLProgram(l,[s],s.dtype)}const OFe={kernelName:xw,backendName:"webgl",kernelFunc:DFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FFe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LFe={kernelName:G2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new FFe(r.shape,i),[c,u]=mN(o,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zFe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,BFe=gr({opSnippet:zFe}),VFe={kernelName:xy,backendName:"webgl",kernelFunc:BFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UFe="return inversesqrt(x);",WFe=gr({opSnippet:UFe,cpuKernelImpl:nNe}),GFe={kernelName:_y,backendName:"webgl",kernelFunc:WFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SB=class{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HFe{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=zu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=At({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=At({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;Ee().getBool("WEBGL_PACK")?g=new HFe(l,a,d.shape.length,p.shape.length,u,f):g=new SB(l,a,d.shape.length,p.shape.length,u,f);const y=t.runWebGLProgram(g,[p,d,m],p.dtype),b=At({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),b}const qFe={kernelName:$2,backendName:"webgl",kernelFunc:jFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XFe=class{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=Ee().getNumber("WEBGL_VERSION")===2?i:o,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KFe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new XFe(s.shape[0],s.shape[1],i.shape[1],o),l=[[s.shape[1]]];return t.runWebGLProgram(a,[s,i],"int32",l)}const YFe={kernelName:P2,backendName:"webgl",kernelFunc:KFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZFe=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=Fr(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JFe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new ZFe(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(o,[r,s,i],Mi(s.dtype,i.dtype))}const QFe={kernelName:_w,backendName:"webgl",kernelFunc:JFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eLe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${fC};
  float scale = ${dC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,tLe=gr({opSnippet:eLe}),nLe={kernelName:Sy,backendName:"webgl",kernelFunc:tLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rLe=Uw+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,sLe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iLe=gr({opSnippet:rLe,packedOpSnippet:sLe,cpuKernelImpl:sNe}),oLe={kernelName:Ey,backendName:"webgl",kernelFunc:iLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aLe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,lLe=gr({opSnippet:aLe}),cLe={kernelName:Ty,backendName:"webgl",kernelFunc:lLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uLe=Uw+`
  return sin(x);
`,hLe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${jy}
  return result;
`,fLe=gr({opSnippet:uLe,packedOpSnippet:hLe}),dLe={kernelName:Cy,backendName:"webgl",kernelFunc:fLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pLe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,mLe=gr({opSnippet:pLe}),gLe={kernelName:ky,backendName:"webgl",kernelFunc:mLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yLe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,bLe=gr({opSnippet:yLe}),vLe={kernelName:Iy,backendName:"webgl",kernelFunc:bLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wLe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=vQ({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),h=Vy(u.shape,i,a,!1),f=Uy(h.length,i.length,!1),d=Wy(u.shape,i,a,!1),p=At({inputs:{x:u},backend:t,attrs:{shape:h}}),m=Zo({inputs:{x:p},backend:t,attrs:{perm:f}}),g=At({inputs:{x:m},backend:t,attrs:{shape:d}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},xLe={kernelName:kw,backendName:"webgl",kernelFunc:wLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Le(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[h,f,d,p,m]=oNe(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const SLe={kernelName:AM,backendName:"webgl",kernelFunc:_Le};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CLe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(i.dataId)),[c,u,h]=aNe(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const kLe={kernelName:MM,backendName:"webgl",kernelFunc:CLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TLe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=GJ(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const ELe={kernelName:D2,backendName:"webgl",kernelFunc:TLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=GJ(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const ALe={kernelName:O2,backendName:"webgl",kernelFunc:ILe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MLe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=zu(i,s,a),d=!1;if(i.dtype==="string"){const y=t.bufferSync(s),b=t.bufferSync(i),x=Cc(t.readSync(o.dataId)[0]),w=rNe(y,b,a,f,u,c,l,h,x,d);return t.makeTensorInfo(a,w.dtype,w.values)}const p=new SB(c,l,s.shape.length,i.shape.length,h,[f,1],d),m=t.runWebGLProgram(p,[i,s,o],i.dtype),g=At({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}const NLe={kernelName:F2,backendName:"webgl",kernelFunc:MLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Le(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=AN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=Ww({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const RLe={kernelName:Tw,backendName:"webgl",kernelFunc:$Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG="return sqrt(x);",PLe=gr({opSnippet:JG,packedOpSnippet:JG,cpuKernelImpl:lNe}),DLe={kernelName:Ay,backendName:"webgl",kernelFunc:PLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OLe="return x * x;",FLe=gr({opSnippet:OLe}),LLe={kernelName:L2,backendName:"webgl",kernelFunc:FLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG="return (a - b) * (a - b);",zLe=uo({opSnippet:QG,packedOpSnippet:QG}),BLe={kernelName:My,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(s.dataId),o=_u(i),a=cNe(o,"string",r);return t.makeTensorInfo(s.shape,"string",a)}const ULe={kernelName:z2,backendName:"webgl",kernelFunc:VLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WLe({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=Pc+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new fh(r.shape,s);return t.runWebGLProgram(i,[r],r.dtype)}const GLe={kernelName:Dy,backendName:"webgl",kernelFunc:WLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HLe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Fr(r.length),o=Fr(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=fN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=At({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=hN(b,x,w),A=Ww({inputs:{x:s},backend:t,attrs:{begin:b,size:k}});S=At({inputs:{x:A},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([s])){const A=t.readSync(s.dataId),M=Sn(s.shape,s.dtype,A),E=uNe(d,M,w,b);S=t.makeTensorInfo(p,s.dtype,E.values)}else{const A=new HLe(b,w,d);S=t.runWebGLProgram(A,[s],s.dtype)}const C=At({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(S),C}const qLe={kernelName:B2,backendName:"webgl",kernelFunc:jLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XLe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=hNe(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const KLe={kernelName:V2,backendName:"webgl",kernelFunc:XLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YLe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=fNe(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const ZLe={kernelName:NM,backendName:"webgl",kernelFunc:YLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JLe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=dNe(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const QLe={kernelName:$M,backendName:"webgl",kernelFunc:JLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eze="return tan(x);",tze=gr({opSnippet:eze}),nze={kernelName:$y,backendName:"webgl",kernelFunc:tze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rze=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sze=gr({opSnippet:rze}),ize={kernelName:Ry,backendName:"webgl",kernelFunc:sze};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oze(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=zu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=At({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),p=At({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),m=At({inputs:{x:s},backend:t,attrs:{shape:f}}),g=new SB(l,a,d.shape.length,p.shape.length,u,f,!1,!0),y=t.runWebGLProgram(g,[p,d,m],m.dtype),b=At({inputs:{x:y},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const aze={kernelName:R2,backendName:"webgl",kernelFunc:oze};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lze=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=cze(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function cze(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(s.dtype==="string"||s.shape.length>5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>Cc(f)):l,u=Sn(s.shape,s.dtype,c),h=mNe(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new lze(s.shape,i);return t.runWebGLProgram(o,[s],s.dtype)}const uze={kernelName:Py,backendName:"webgl",kernelFunc:xQ};let hze=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},fze=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lm(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function eH(n){let e=1;for(;e<n;)e*=2;return e}function dze(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=Ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([s])||u<a||i>l){const E=t.readSync(s.dataId),[N,O]=gNe(E,c,s.dtype,i,o);return[t.makeTensorInfo(N.shape,N.dtype,N.values),t.makeTensorInfo(O.shape,O.dtype,O.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,s.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[s,vC({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),f=h!==null&&h.isPacked,d=f?t.unpackTensor(s):s,m=Te(c)/u,g=At({inputs:{x:d},attrs:{shape:[m,u]},backend:t});f&&lm(t,d);const y=eH(i),b=eH(u);let x=null;const w=()=>x===null?[g,g]:[g,x],S=(E,N,O)=>{const R=w(),D=new hze(O),B=[[u],[x===null?1:0],[Number.NEGATIVE_INFINITY],[E],[N]],X=x;x=t.runWebGLProgram(D,R,"int32",B),lm(t,X)};for(let E=1;E<y;E*=2){const N=E*2;for(let O=E;O>=1;O/=2)S(N,O,[m,b])}for(let E=b;E>y;E/=2){const N=w(),O=new fze([m,E/2]),D=[[u],[x===null?1:0],[y]],z=x;x=t.runWebGLProgram(O,N,"int32",D),lm(t,z);const B=y/2,X=B*2;for(let G=B;G>=1;G/=2)S(X,G,x.shape)}let C=x;x=Ww({inputs:{x},backend:t,attrs:{begin:0,size:[m,i]}}),lm(t,C);let k=dQ({inputs:{x:g,indices:x},backend:t,attrs:{axis:1,batchDims:1}});lm(t,g);const A=c.slice(0,-1);A.push(i),C=x,x=At({inputs:{x},attrs:{shape:A},backend:t}),lm(t,C);const M=k;return k=At({inputs:{x:k},attrs:{shape:A},backend:t}),lm(t,M),[k,x]}const pze={kernelName:U2,backendName:"webgl",kernelFunc:dze};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mze=class{constructor(e,t,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gze(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new mze(h,f,o,a,l,g);return t.runWebGLProgram(y,[s,i],"float32")}const yze={kernelName:W2,backendName:"webgl",kernelFunc:gze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bze(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;gC(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=yNe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const vze={kernelName:RM,backendName:"webgl",kernelFunc:bze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wze(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=Ww({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=At({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const xze={kernelName:Iw,backendName:"webgl",kernelFunc:wze};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ze{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,h=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let d="";i%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sze(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=ns(1,a)[0]);const f=iB(h.shape,c,o),d=Te([h.shape[c]]),p=At({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=q2(s.dtype),g=(w,S,C,k,A)=>{const M=w.shape[0],E=w.shape[1],N=gZ(E,A),O={windowSize:N,inSize:E,batchSize:M,numSegments:A},R=new _ze(O,S),D=t.compileAndRun(R,[w,C],k);if(l.push(D),D.shape[1]===A)return D;const z=wQ({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),B=xQ({inputs:{x:z},backend:t,attrs:{reps:[E/N]}});return l.push(z),l.push(B),g(D,S,B,k,A)},y=g(p,"unsortedSegmentSum",i,m,o),b=At({inputs:{x:y},backend:t,attrs:{shape:f}});let x=b;if(u!=null){l.push(b);const w=Oh(u);x=Zo({inputs:{x},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const Cze={kernelName:Aw,backendName:"webgl",kernelFunc:Sze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kze=[l$e,u$e,d$e,g$e,b$e,x$e,S$e,k$e,A$e,N$e,P$e,F$e,B$e,G$e,q$e,K$e,Z$e,tRe,rRe,iRe,cRe,gRe,bRe,_Re,CRe,MRe,$Re,ORe,HNe,zRe,GRe,XRe,e3e,r3e,i3e,a3e,c3e,d3e,g3e,v3e,x3e,S3e,k3e,I3e,M3e,P3e,O3e,z3e,U3e,G3e,X3e,J3e,nPe,iPe,lPe,cPe,hPe,dPe,mPe,yPe,vPe,SPe,TPe,APe,NPe,PPe,FPe,VPe,HPe,GNe,qPe,URe,YPe,QPe,nDe,qNe,oDe,uDe,fDe,gDe,vDe,SDe,TDe,MDe,PDe,FDe,zDe,WDe,HDe,qDe,ZDe,QDe,tOe,rOe,iOe,cOe,dOe,yOe,kOe,YNe,AOe,$Oe,DOe,LOe,TRe,VOe,WOe,HOe,XOe,JOe,KNe,eFe,nFe,sFe,oFe,aFe,ERe,xOe,uFe,pFe,bFe,JNe,_Fe,kFe,AFe,$Fe,OFe,LFe,VFe,GFe,qFe,YFe,QFe,nLe,oLe,cLe,dLe,gLe,pRe,SOe,vLe,xLe,SLe,kLe,ELe,ALe,NLe,RLe,DLe,LLe,BLe,ULe,GLe,qLe,KLe,ZLe,QLe,_Oe,i$e,nze,ize,aze,uze,pze,yze,o$e,vze,xze,Cze,UOe];for(const n of kze)H2(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl=Ee();zl.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);zl.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);zl.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);zl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);zl.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);zl.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);zl.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);zl.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);zl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);zl.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);zl.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);zl.registerFlag("WEBGPU_PRINT_SHADER",()=>"");zl.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tze{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eze{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,s=!0){let i;const o=tH(e,t);return s?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(i=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,i=tH(r,s),o=this.usedBuffers.get(i),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function tH(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ize{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,s){const i=rH(r),o=e*t*i,a=nH(e,t,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,r=e.height,s=e.format,i=e.usage,o=nH(t,r,s,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=rH(s),u=t*r*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function nH(n,e,t,r){return`${n}_${e}_${t}_${r}`}function rH(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aze(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,r="xyzwuv",s=n.map(o=>`${e}.${r[o]}`),i=new Array(t-1);i[t-2]=s[t-1];for(let o=t-3;o>=0;--o)i[o]=`(${i[o+1]} * ${s[o+1]})`;return i}const zp=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ov;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(ov||(ov={}));const Mze=(n,e,t,r,s)=>{const i={dtype:r.dtype,shape:r.shape},o=$ze(t,i,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=Ee().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return s?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Vn=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ys(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function $f(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function xt(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function sH(n,e){let t;return t=`
     ${Nze(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function Nze(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function $ze(n,e,t){const r=[],s=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${_Q(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const p=t.pixelsOpType===ov.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Lm(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Lm(n[0].dtype,t.outputComponent)}>;`,m=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${m},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const g=oH(t);return[iH,r.join(`
`),LE(e.shape),t.getUserCode(),sH(g,t)].join(`
`)}let i,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((p,m)=>{const g=Ys(n[m].shape.length);a+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${g}, `,i=n[m].shape.length-1,o=Ys(i),a+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${o}, `});const l=Ys(e.shape.length);a+=`outShape : ${l}, `,i=e.shape.length-1,o=Ys(i),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=Vze(a),r.push(a),t.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Lm(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((p,m)=>{r.push(`
      @group(0) @binding(${1+m}) var<storage, read> ${p}: array<${t.variableComponents?Lm(n[m].dtype,t.variableComponents[m]):Lm(n[m].dtype,t.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=Lze(e.shape,t.dispatchLayout),u=[iH,r.join(`
`)+Pze,LE(e.shape),c,zze(e.shape.length)];t.atomic||u.push(Bze(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((p,m)=>{u.push(`${LE(n[m].shape,p)}`)});const h=n.map((p,m)=>Fze(p,e.shape,t.variableComponents?t.variableComponents[m]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(h),u.push(t.getUserCode());const f=oH(t);return u.push(sH(f,t)),u.join(`
`)}function Rze(n,e,t){let r=n.shaderKey;if(n.pixelsOpType!=null)return r;const s=[],i=[];e.forEach(u=>{s.push(u.shape),i.push(u.dtype)}),s.push(t.shape),i.push(t.dtype);const o=e.map(u=>Ff(u.shape,t.shape)),a=e.map(u=>Rn(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=_Q(n)?"flatDispatch":"";return r+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+s.map(u=>u.length).join(",")+i.join(",")+n.variableNames.join(",")+l+a+c,r}const iH=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Pze=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function LE(n,e=""){const t=n.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const i=Jt(n),o=Ys(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(i.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((c,u)=>{const h=`let ${a[u]} = index2 / uniforms.${s}.${$f(u)}`,f=u===i.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${s}.${$f(u)}`:`index2 = index2 - ${a[u]} * uniforms.${s}.${$f(u)}`;return`${h}; ${f};`}).join(""),`
    fn ${r}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function Dze(n,e){const t=n.name,r=n.shape.length,s=Ys(r),i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map(u=>`${u} : i32`).join(", ");if(r<1)return`
      fn ${i}() -> ${Vn(e)} {
        return ${Vn(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${i}(${a}) -> ${Vn(e)} {
      return ${Vn(e)}(${t}[getIndexFromCoords${c}(${s}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function Oze(n,e,t,r){const s=n.name,i=s.charAt(0).toUpperCase()+s.slice(1),o="get"+i+"ByOutput",a=n.shape.length,l=e.length,c=Ys(l);if(Rn(n.shape,e)&&r)return`
    fn ${o}Index(globalIndex : i32) -> ${Vn(t)} {
      return ${Vn(t)}(${s}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${Vn(t)} {
      return ${Vn(t)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=Ff(n.shape,e),h=l-a;let f="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${Vn(t)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${c}) -> ${Vn(t)}{
      return get${i}();
    }
  `;l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${$f(g+h)} = 0;`).join(`
`);let d="";if(l<2&&a>0)d="coords";else if(l>1){const g=Ys(a),y=n.shape.map((b,x)=>`coords.${$f(x+h)}`).join(", ");d=`${g}(${y})`}else d="coords";const p=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${Vn(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${f}
    return ${Vn(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${Vn(t)} {
    var coords = coordsIn;
    ${f}
    return ${Vn(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }
`}function Fze(n,e,t,r){let s=Dze(n,t);return n.shape.length<=e.length&&(s+=Oze(n,e,t,r)),s}function Lze(n,e){const{x:t,y:r=[],z:s=[]}=e,i=n.length,o=t.length+r.length+s.length;if(o!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${Ys(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,r,s];for(let f=0;f<l.length;f++){const d=l[f];if(d.length!==0)if(d.length===1)a+=`let d${d[0]} = i32(globalId[${f}]);`;else{const p=Aze(d,"uniforms.outShape");a+=`var index${f} = i32(globalId[${f}]);`;for(let m=0;m<p.length;m++)a+=`let d${d[m]} = index${f} / ${p[m]};`,m===p.length-1?a+=`let d${d[m+1]} = index${f} - d${d[m]} * ${p[m]};`:a+=`index${f} = index${f} - d${d[m]} * ${p[m]};`}}const c=[];for(let f=0;f<o;f++)c.push(`d${f}`);const u=Ys(o);let h=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`,h}function zze(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:U(!1,()=>`Unsupported ${n}D shape`);break}return e}function _Q(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Lm(n,e=1){if(n==="float32")return Vn(e,"f32");if(n==="int32"||n==="bool")return Vn(e,"i32");throw new Error(`type ${n} is not supported.`)}function Bze(n,e,t){const r=n.length,s=Lm(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${Vn(t)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Vn(t,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=Ys(r);i+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Vn(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Vn(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function Vze(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,r=>"@align(16) "+r);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(r,s,i)=>`vec${s}, @align(16) ${i}`),n}function oH(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function _t(n,e,t=[1,1,1],r=[1,1,1]){const[s,i,o]=[Math.ceil(Zm(n.x.map(a=>e[a]))/(t[0]*r[0])),n.y?Math.ceil(Zm(n.y.map(a=>e[a]))/(t[1]*r[1])):1,n.z?Math.ceil(Zm(n.z.map(a=>e[a]))/(t[2]*r[2])):1];return[s,i,o]}function Uze(n,e,t,r=!1){const s=[8,8,1],i=[4,4,1];return r||(n<=8&&(i[1]=1),e<=16&&t<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:i}}function SQ(n,e,t=!1){if(t)return[8,8,1];const r=Zm(n.x.map(i=>e[i])),s=Zm(n.y.map(i=>e[i]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function CQ(n,e,t=!1){if(t)return[4,4,1];const r=Zm(n.x.map(i=>e[i])),s=Zm(n.y.map(i=>e[i]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Ot(n){return{x:n.map((e,t)=>t)}}function aH(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function kQ(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}function TQ(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var rh;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(rh||(rh={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wze=Ee().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Gze=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(o=>o<=t))return s;U(s[0]>t&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(s[0]));return i>t?(i=Math.ceil(Math.cbrt(s[0])),U(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class Gw extends jS{nextDataId(){return Gw.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!kQ())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new Tze(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Eze(this.device),this.textureManager=new Ize(this.device),this.tensorMap=new wM(this,xo()),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:t,values:e,refCount:1}),s}move(e,t,r,s,i){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if(Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(U(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,t){const r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){const t=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=t;if(r!=null||t.dtype==="string")return r;if(t.dtype==="complex64"){const m=this.readSync(s.real.dataId),g=this.readSync(s.imag.dataId),y=J1(xu(m,g).buffer,"float32");return this.convertAndCacheOnCPU(e,y),y}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],o=t.resource,a=o.size;U(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,h=256,f=i.map(m=>new OffscreenCanvas(u,h)),d=new OffscreenCanvas(u,h);this.endComputePassEncoder(),f.map((m,g)=>{const y=m.getContext("webgpu");return y.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[g]}),y.getCurrentTexture()}).map((m,g)=>{const y=u*4,b=(A,M,E)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:y,offset:E},{texture:m},{width:A,height:M}),this.submitQueue();const N=d.getContext("2d",{willReadFrequently:!0});N.clearRect(0,0,A,M),N.drawImage(f[g],0,0);const O=N.getImageData(0,0,A,M).data,R=i[g],D=new Uint8ClampedArray(c,E,A*M*4);for(let z=0;z<D.length;z+=4)if(R==="premultiplied")D[z+3]=O[z+3];else{const B=O[z];D[z]=O[z+2],D[z+1]=O[z+1],D[z+2]=B}},x=Math.floor(l/(u*h));let w=u,S=h,C=0;for(let A=0;A<x;A++)b(w,S,C),C+=u*h*4;const k=l%(u*h);S=Math.floor(k/u),S>0&&(b(w,S,C),C+=S*(u*4)),w=k%u,w>0&&b(w,1,C)});const p=J1(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(r!=null)return r;let s;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=i[0],a=i[1];s=xu(o,a)}else{const i=await this.getBufferData(t.resource);s=J1(i,t.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const t=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),s}createTensorFromGPUData(e,t,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(i),a=aH(o.dtype)*Te(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),o.resource=s,xo().makeTensorFromDataId(i,t,r,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:r,dtype:s,shape:i,resource:o}=t;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const h=this.makeTensorInfo(i,s),f=xo().makeTensorFromTensorInfo(h),d=this.tensorMap.get(h.dataId);return d.resource=u,{tensorRef:f,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Cc(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=kc(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=kc(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return a.kernelMs=ML(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,r){return t==="string"&&r!=null&&r.length>0&&uu(r[0])&&(r=r.map(i=>yu(i))),{dataId:this.write(r,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const r=aH(t.dtype)*Te(t.shape);let s;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(r,i,!0),s.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,s,0,r),this.stagingPendingDisposal.push(o)}else{const o=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(r,i);t.resource=s}makeUniforms(e){let t=0,r=0;const s=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:U(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>i&&(i=c),t=Math.ceil(t/c)*c,r=l.data.length,s.push(t),t+=l.data.length*4}),t=Math.ceil(t/i)*i;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=s[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,r,s,i){if(i||(i=this.makeTensorInfo(e.outputShape,r)),Te(i.shape)===0)return this.tensorMap.get(i.dataId).values=ci(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=Gze(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=Rze(e,o,i);const a=Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=Mze(this.device,e,o,i,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,i,t,s),i}recordAndSubmit(e,t,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],o=[];const a="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=r.concat(t).map(d=>d.shape);const f="int32";o.map(d=>{i.push({type:f,data:d});const p=Jt(d);i.push({type:f,data:p})})}else{const f=Jt(t.shape);i.push({type:a,data:f})}if(e.size){const f=Te(e.outputShape);i.push({type:a,data:[e.outputComponent?f/e.outputComponent:f]})}s&&(i=[...i,...s]);const l=[this.tensorToBinding(t),...r.map(f=>this.tensorToBinding(f)),this.makeUniforms(i)];r.forEach(f=>{this.commandQueueOwnedIds.add(f.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((f,d)=>({binding:d,resource:f}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||Ee().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===ov.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=Wze){return Ee().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Te(r.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Gw.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kQ()&&DM("webgpu",async()=>{const n={powerPreference:Ee().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),t.requiredFeatures=r;const s=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),o=await e.requestAdapterInfo();return new Gw(i,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yn;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(yn||(yn={}));const Hze="let resultTemp = a + b;",jze="let resultTemp = atan2(a, b);",qze="let resultTemp = areal * breal - aimag * bimag;",Xze="let resultTemp = areal * bimag + aimag * breal;",Kze="let resultTemp = a / b;",Yze="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Zze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,Jze=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,Qze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,eBe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,tBe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,nBe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,rBe="return f32(a >= 1.0 && b >= 1.0);",sBe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,iBe="return f32(a >= 1.0 || b >= 1.0);",oBe=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,aBe="let resultTemp = max(a, b);",lBe="let resultTemp = min(a, b);",cBe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,uBe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,hBe="let resultTemp = a * b;",fBe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,dBe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,pBe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,mBe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,gBe="if (a < 0.0) { return b * a; }  return a;",yBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,bBe="let resultTemp = (a - b) * (a - b);",vBe="let resultTemp = a - b;";function CB(n,e){let t;do{switch(n){case yn.ATAN2:t=jze;break;case yn.MAX:t=aBe;break;case yn.MIN:t=lBe;break;case yn.MOD:t=e?uBe:cBe;break;case yn.NOT_EQUAL:t=e?dBe:fBe;break;case yn.POW:t=e?mBe:pBe;break;default:continue}let r,s,i;return e?(r="isnanVec4",s="vec4<f32>",i="vec4<bool>"):(r="isnan",s="f32",i="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case yn.ADD:t=Hze;break;case yn.COMPLEX_MULTIPLY_IMAG:t=Xze;break;case yn.COMPLEX_MULTIPLY_REAL:t=qze;break;case yn.DIV:t=Kze;break;case yn.ELU_DER:t=Yze;break;case yn.EQUAL:t=Zze;break;case yn.FLOOR_DIV:t=Jze;break;case yn.GREATER:t=Qze;break;case yn.GREATER_EQUAL:t=eBe;break;case yn.LESS:t=tBe;break;case yn.LESS_EQUAL:t=nBe;break;case yn.LOGICAL_AND:return e?sBe:rBe;case yn.LOGICAL_OR:return e?oBe:iBe;case yn.MUL:t=hBe;break;case yn.PRELU:return e?yBe:gBe;case yn.SQUARED_DIFFERENCE:t=bBe;break;case yn.SUB:t=vBe;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bt;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(bt||(bt={}));const wBe="return abs(a);",xBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,_Be=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,SBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,CBe="return asinh(a);",kBe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,TBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,EBe="return ceil(a);",IBe="return cos(a);",ABe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,MBe="return exp(a) - 1.0;",NBe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",$Be=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,RBe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${bN};
  let a1 = ${vN};
  let a2 = ${wN};
  let a3 = ${xN};
  let a4 = ${_N};
  let a5 = ${SN};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,PBe="return exp(a);",DBe="return floor(a);",OBe="return f32(!isnan(a) && !isinf(a));",FBe="return f32(isinf(a));",LBe="return f32(isnan(a));",zBe="return a;",BBe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,VBe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,UBe="return f32(!(a >= 1.0));",WBe="return -a;",GBe="if (a < 0.0) { return uniforms.alpha * a; } return a;",HBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,jBe="return 1.0 / a;",qBe="return select(a, 0.0, a < 0.0);",XBe="return clamp(a, 0.0, 6.0);",KBe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",YBe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,ZBe="return round(a);",JBe="return inverseSqrt(a);",QBe=`
  if (a >= 0.0) {
    return ${dC} * a;
  } else {
    return ${fC} * (exp(a) - 1.0);
  }
`,e4e="return 1.0 / (1.0 + exp(-1.0 * a));",t4e="return sign(a);",n4e="return sin(a);",r4e=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,s4e=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,i4e="return sqrt(a);",o4e="return a * a;",a4e=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,l4e="return tan(a);",c4e=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,u4e="return f32(i32((a)));";function Tm(n,e){switch(n){case bt.ABS:return wBe;case bt.ACOS:return xBe;case bt.ACOSH:return _Be;case bt.ASIN:return SBe;case bt.ASINH:return CBe;case bt.ATAN:return kBe;case bt.ATANH:return TBe;case bt.COS:return IBe;case bt.COSH:return ABe;case bt.CEIL:return EBe;case bt.ELU:return e?$Be:NBe;case bt.ERF:return RBe;case bt.EXP:return PBe;case bt.EXPM1:return MBe;case bt.FLOOR:return DBe;case bt.IS_FINITE:return OBe;case bt.IS_INF:return FBe;case bt.IS_NAN:return LBe;case bt.LINEAR:return zBe;case bt.LOG:return BBe;case bt.LOG1P:return VBe;case bt.LOGICAL_NOT:return UBe;case bt.NEG:return WBe;case bt.LEAKYRELU:return e?HBe:GBe;case bt.RECIPROCAL:return jBe;case bt.RELU:return e?YBe:qBe;case bt.RELU6:return e?KBe:XBe;case bt.ROUND:return ZBe;case bt.RSQRT:return JBe;case bt.SELU:return QBe;case bt.SIGMOID:return e4e;case bt.SIGN:return t4e;case bt.SIN:return n4e;case bt.SINH:return r4e;case bt.SOFTPLUS:return s4e;case bt.SQRT:return i4e;case bt.SQUARE:return o4e;case bt.STEP:return a4e;case bt.TAN:return l4e;case bt.TANH:return c4e;case bt.TO_INT:return u4e;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yf(n,e=!1,t=!1,r=3){if(n===null)return"";let s="";if(n==="linear")s=Tm(bt.LINEAR);else if(n==="relu")s=Tm(bt.RELU,t);else if(n==="elu")s=Tm(bt.ELU,t);else if(n==="relu6")s=Tm(bt.RELU6,t);else if(n==="prelu")s=CB(yn.PRELU,t);else if(n==="sigmoid")s=Tm(bt.SIGMOID,t);else if(n==="leakyrelu")s=Tm(bt.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=Vn(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        ${s}
      }`,a}function Xy(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(n,e,t=!1,r=!1,s=!1,i=1){U(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Vn(i)} {
    var value = ${Vn(i)}(0.0);
    ${t&&s?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Vn(i)} {
    var value = ${Vn(i)}(0.0);
    ${a}
    return value;
  }
  `}function kB(n,e,t,r,s=!1,i=!1,o=!1,a=1){return`
  ${EQ(t,r,s,i,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Vn(a)}) {
    ${s&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Xy(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const h4e=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,f4e=(n,e,t,r)=>{if(n)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",i="";for(let o=0;o<e;o++)s+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,i+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function LN(n,e,t=!1,r=32,s=!1,i=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:r,u=t?r:a,h=c/e[0],f=r/e[1],d=n[1],p=n[0];return U((t&&h===4&&n[1]===4||!t&&(h===3||h===4))&&c%e[0]===0&&r%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${r}>;

  ${xt()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${f};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${h4e(t,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${f4e(t,h,d,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const lH=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,d4e=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function zN(n,e,t=!1,r=32,s=!1,i=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:r,h=t?r:l;U(h%e[1]===0&&u%e[0]===0&&r%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const f=h/e[1],d=u/e[0],p=r/e[1],m=n[1],g=n[0],y=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${lH(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${lH(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${d4e(t)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${xt()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `}const p4e=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function m4e(n,e=!1){U(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${xt()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${p4e(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class g4e{constructor(e,t,r=!1,s=!1,i=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||t[1]%4===0&&r)&&t[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const f=Uze(t[1],c,t[2],r);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=i!=null,h=a!=null;u&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const o=e%s===0,a=t%i===0,l=r%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${Yf(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${kB(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?LN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?m4e(this.workgroupSize,this.transposeA):zN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4e(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${xt()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class b4e{constructor(e,t=!1,r=!1,s=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){return`
      ${Yf(this.activation,this.hasPreluActivationWeights)}
      ${kB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${y4e(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4e(n){const e=n[1],t=n[0],r=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${xt()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class w4e{constructor(e,t,r,s=!1,i=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=i,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${i}`}getUserCode(){return`
      ${Yf(this.activation,this.hasPreluActivationWeights)}
      ${kB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${v4e(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x4e{constructor(e,t,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,U(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(r&&this.outputShape[1]%4===0||!r&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=_t(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${EQ(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Vn(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${zp("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?LN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):zN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class _4e{constructor(e,t=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Yf(this.activation,this.hasPreluActivationWeights)}
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Xy(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S4e{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function va(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||Ap(s),i==="string"){const o=Ss(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new S4e(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(o,[],i,a)}}const C4e={kernelName:m2,backendName:"webgpu",kernelFunc:va};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,i=Te(r.shape),o=_M(s,i),a=Te(o);return U(i===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const k4e={kernelName:bw,backendName:"webgpu",kernelFunc:Kt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Kt({inputs:{x:n},backend:s,attrs:{shape:S}}),A=Kt({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=[k,A],O=[{type:"int32",data:[d]},{type:"int32",data:[p]},{type:"int32",data:[h]}];let R,D;const z=[E,d,p];let B=Ee().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(B<0){const G=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),te=G>0?G:s.thresholdToIncreaseWorkgroups,ge=E*Math.ceil(d/32)*Math.ceil(p/32);ge<=te||d<=8&&ge<=te*2?E*d*p<=128?B=rh.MatMulReduceProgram:E===1&&f>=2e3?B=rh.MatMulSplitKProgram:B=rh.MatMulSmallOutputSizeProgram:B=rh.MatMulPackedProgram}switch(B){case rh.MatMulReduceProgram:R=new b4e(z,t,r,i,l,o);break;case rh.MatMulSplitKProgram:{if(D=va({backend:s,attrs:{shape:z,value:0,dtype:n.dtype}}),R=new x4e(z,f,t,r),i||l){D=s.runWebGPUProgram(R,N,n.dtype,O,D);const te=new _4e(D.shape,i,l,o);let ge=null;const ae=[D];i&&ae.push(i),o&&ae.push(o),l==="leakyrelu"&&(ge=[{type:"float32",data:[a]}],te.uniforms+=" alpha : f32,");const Ne=s.runWebGPUProgram(te,ae,D.dtype,ge);M.push(D);const ke=Kt({inputs:{x:Ne},backend:s,attrs:{shape:w}});M.push(Ne);for(const De of M)s.disposeData(De.dataId);return ke}break}case rh.MatMulSmallOutputSizeProgram:R=new w4e(S,C,z,t,r,i,l,o);break;case rh.MatMulPackedProgram:const G=s.adapterInfo.isIntel();R=new g4e(S,z,t,r,i,l,o,G);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}i&&N.push(i),o&&N.push(o),l==="leakyrelu"&&(O.push({type:"float32",data:[a]}),R.uniforms+=" alpha : f32,"),D=s.runWebGPUProgram(R,N,n.dtype,O,D);const X=Kt({inputs:{x:D},backend:s,attrs:{shape:w}});M.push(D);for(const G of M)s.disposeData(G.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return BN({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const E4e={kernelName:Hb,backendName:"webgpu",kernelFunc:T4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cH{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${CB(this.op,!1)}
      }

      ${xt("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UI{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=t.length>0&&t[t.length-1]%4===0,i=r.length>0&&r[r.length-1]%4===0;s&&i?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(hD(r)||r[r.length-1]===1)||i&&(hD(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${CB(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${xt("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${xt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const I4e={kernelName:ay,backendName:"webgpu",kernelFunc:Ya};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.tensorMap.get(i.dataId),a=Ya({inputs:{x:r},backend:t}),l=Ya({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const A4e={kernelName:e2,backendName:"webgpu",kernelFunc:Ky};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hw{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Tm(this.op,!1)}
      }
      ${xt("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:r,backend:s})=>{const{x:i}=r,o=s,a=t||i.dtype;if(o.shouldExecuteOnCPU([i])&&e!=null){const c=o.tensorMap.get(i.dataId),u=e(c.values,a);return o.makeTensorInfo(i.shape,a,u)}const l=new Hw(i.shape,n);return o.runWebGPUProgram(l,[i],a)}}function Xi({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:r}){return({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),f=l.tensorMap.get(a.dataId);let d,p;if(n!==yn.MUL)[d,p]=[[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(g=>{const[y,b]=g,x={dataId:y.dataId,dtype:y.dtype,shape:o.shape},w={dataId:b.dataId,dtype:b.dtype,shape:a.shape},S=new UI(n,o.shape,a.shape);return l.runWebGPUProgram(S,[x,w],Mi(y.dtype,b.dtype))});else{const g=new cH(yn.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),y=new cH(yn.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}];d=l.runWebGPUProgram(g,b,"float32"),p=l.runWebGPUProgram(y,b,"float32")}const m=Ky({inputs:{real:d,imag:p},backend:l});return l.disposeData(d.dataId),l.disposeData(p.dataId),m}const c=r||Mi(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,f=l.tensorMap.get(a.dataId).values,d=o.dtype==="string"?_u(h):h,p=o.dtype==="string"?_u(f):f,[m,g]=e(o.shape,a.shape,d,p,c);return l.makeTensorInfo(g,c,m)}const u=new UI(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:M4e,castImpl:N4e,ceilImpl:$4e,concatImpl:R4e,equalImpl:P4e,expImpl:D4e,expm1Impl:O4e,floorImpl:F4e,floorDivImpl:L4e,gatherNdImpl:z4e,gatherV2Impl:B4e,greaterEqualImpl:V4e,greaterImpl:U4e,lessEqualImpl:W4e,lessImpl:G4e,logImpl:H4e,maxImpl:j4e,maximumImpl:q4e,minimumImpl:X4e,multiplyImpl:K4e,negImpl:Y4e,notEqualImpl:Z4e,prodImpl:J4e,rangeImpl:Q4e,rsqrtImpl:eVe,scatterImpl:tVe,simpleAbsImpl:nVe,sliceImpl:rVe,stridedSliceImpl:sVe,stringNGramsImpl:iVe,subImpl:oVe,tileImpl:aVe,topKImpl:lVe,transposeImpl:cVe,uniqueImpl:HIt}=pJ;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uVe=yr({opType:bt.ABS,cpuKernelImpl:nVe}),hVe={kernelName:Mv,backendName:"webgpu",kernelFunc:uVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fVe=yr({opType:bt.ACOS}),dVe={kernelName:Vg,backendName:"webgpu",kernelFunc:fVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pVe=yr({opType:bt.ACOSH}),mVe={kernelName:Ug,backendName:"webgpu",kernelFunc:pVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gVe=Xi({opType:yn.ADD,cpuKernelImpl:M4e,supportsComplex:!0}),yVe={kernelName:Mp,backendName:"webgpu",kernelFunc:gVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bVe{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const t=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${xt("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vVe(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Ya({inputs:{x:r[0]},backend:t});const s=r.map(a=>a.dtype).reduce((a,l)=>Mi(a,l)),i=r.map(a=>a.shape),o=new bVe(i);return t.runWebGPUProgram(o,r,s)}const wVe={kernelName:Nv,backendName:"webgpu",kernelFunc:vVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xVe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){U(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${xt()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ve{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ys(this.outputShape.length),t=IQ(this.newDim);return`
      ${xt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function IQ(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let r=0;r<n.length;r++)t[n[r]]=`coords.${$f(r)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ch(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];if(t.shouldExecuteOnCPU([s])){const h=o.tensorMap.get(s.dataId).values,f=cVe(h,s.shape,s.dtype,i,l);return t.makeTensorInfo(l,s.dtype,f)}if(s.shape.length===2&&Rn(i,[1,0])){const u=new xVe(s.shape,i);return o.runWebGPUProgram(u,[s],s.dtype)}const c=new _Ve(s.shape,i);return o.runWebGPUProgram(c,[s],s.dtype)}const SVe={kernelName:jd,backendName:"webgpu",kernelFunc:Ch};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CVe{constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Qs(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${xt("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kVe={mean:"float32",all:"bool",any:"bool"};function Yy(n,e,t,r,s){const i=n.shape.length,o=[],a=An(e,n.shape);let l=a;const c=Lr(l,i);let u=n;c!=null&&(u=Ch({inputs:{x:n},attrs:{perm:c},backend:s}),l=ns(l.length,i),o.push(u)),fi(r,l,i);const[h,f]=Qs(u.shape,l);let d=h;t&&(d=Ls(h,a));let p;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([u])){const m=s.tensorMap.get(u.dataId).values;switch(r){case"max":const g=j4e(m,Te(f),d,n.dtype);p=s.makeTensorInfo(d,n.dtype,g);break;case"prod":const{outVals:y,outShape:b,outDtype:x}=J4e(u.shape,u.dtype,m,l);p=s.makeTensorInfo(b,x,y);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const m=Te(f),y=Te(u.shape)/m,b={windowSize:m,inSize:m,batchSize:y,outSize:1},x=kVe[r]||q2(n.dtype),w=[{type:"int32",data:[m]}],S=new CVe(b,r,s.device.limits.maxComputeWorkgroupSizeX),C=s.runWebGPUProgram(S,[u],x,w);o.push(C),p=Kt({inputs:{x:C},attrs:{shape:d},backend:s})}return o.forEach(m=>s.disposeData(m.dataId)),p}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Yy(s,o,i,"all",t)}const EVe={kernelName:qS,backendName:"webgpu",kernelFunc:TVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Yy(s,o,i,"any",t)}const AVe={kernelName:XS,backendName:"webgpu",kernelFunc:IVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AQ{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[t];this.op=r==="min"?"<":">";const[i,o]=Qs(e,s);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=Ot(this.outputShape),Te(o)<32?(this.type="plain",this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${$f(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)s+=`outputCoords.${$f(i)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${xt("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${xt("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ch({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMax",[o[0]],l.shape.length);const u=new AQ(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const NVe={kernelName:$v,backendName:"webgpu",kernelFunc:MVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ve(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ch({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMin",[o[0]],l.shape.length);const u=new AQ(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const RVe={kernelName:Rv,backendName:"webgpu",kernelFunc:$Ve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PVe=yr({opType:bt.ASIN}),DVe={kernelName:Wg,backendName:"webgpu",kernelFunc:PVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OVe=yr({opType:bt.ASINH}),FVe={kernelName:Gg,backendName:"webgpu",kernelFunc:OVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LVe=yr({opType:bt.ATAN}),zVe={kernelName:Hg,backendName:"webgpu",kernelFunc:LVe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BVe=Xi({opType:yn.ATAN2}),VVe={kernelName:qg,backendName:"webgpu",kernelFunc:BVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UVe=yr({opType:bt.ATANH}),WVe={kernelName:jg,backendName:"webgpu",kernelFunc:UVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GVe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P_{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class TB{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r;return Yy(s,i,o,"max",t)}const HVe={kernelName:sw,backendName:"webgpu",kernelFunc:MQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Yy(s,o,i,"mean",t)}const jVe={kernelName:aw,backendName:"webgpu",kernelFunc:NQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(n,e,t,r){if(e.filterWidth===1&&e.filterHeight===1&&Rn(e.inShape,e.outShape))return Ya({inputs:{x:n},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=Kt({inputs:{x:n},backend:r,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=NQ({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(U(t==="max",()=>`Invalid pool type ${t}`),l=MQ({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Kt({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new GVe(e):(t==="avg"?s=new P_(e,"avg"):(U(t==="max",()=>`Invalid pool type ${t}`),s=new P_(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(s.shape,i,o,c,a,l);return $Q(s,u,"avg",t)}const XVe={kernelName:Pv,backendName:"webgpu",kernelFunc:qVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(s.shape,i,o,u,a,c,l),f=new TB(h,"avg"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const YVe={kernelName:Dv,backendName:"webgpu",kernelFunc:KVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class JVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Ll(o.shape,a,l,1,c,u),f=new JVe(h),d=1/(h.filterDepth*h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(f,[s],o.dtype,p)}const eUe={kernelName:YS,backendName:"webgpu",kernelFunc:QVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;TQ([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new ZVe(u),f=1/(u.filterHeight*u.filterWidth),d=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[f]}];return t.runWebGPUProgram(h,[s],o.dtype,d)}const nUe={kernelName:KS,backendName:"webgpu",kernelFunc:tUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rUe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return BN({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const sUe={kernelName:Ov,backendName:"webgpu",kernelFunc:rUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iUe{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ys(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ys(this.rank),t=oUe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((i,o)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((i,o)=>`sourceLoc.${VD[o]} = uniforms.start.${$f(o)} + coords.${VD[o]};`),`
      ${xt("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const VD=["x","y","z","w","u","v"];function oUe(n){if(n===1)return"sourceLoc";if(n<=6)return VD.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=hC(s,i,o);if(uN(s,a,l),t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.tensorMap.get(s.dataId),f=rVe(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}if(Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);const c=new iUe(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const aUe={kernelName:Sw,backendName:"webgpu",kernelFunc:jw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lUe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Vy(s.shape,i,a),c=Uy(l.length,i.length),u=Wy(s.shape,i,a),h=gN(o,i.length),f=yN(u,o,i.length),d=[],p=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),m=Ch({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Kt({inputs:{x:m},backend:t,attrs:{shape:u}}),y=jw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeData(b.dataId)),y},cUe={kernelName:Fv,backendName:"webgpu",kernelFunc:lUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uUe=`
  fn bincount_write(index: i32, value: f32) {
    ${zp("&result[index]","value","float32")}
  }
`,hUe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class RQ{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?hUe:uUe}
  ${xt("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=Te(s.shape),c=Te(i.shape)>0,u=[o],h=i.dtype,f=va({backend:t,attrs:{shape:u,value:0,dtype:h}}),d=new RQ([a],c),p=[{type:"int32",data:[o]}],m=c?[s,i]:[s];return t.runWebGPUProgram(d,m,h,p,f)}const dUe={kernelName:ZS,backendName:"webgpu",kernelFunc:fUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pUe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${xt("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mUe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e;if(t.shouldExecuteOnCPU([r,s])){const u=t.tensorMap.get(r.dataId),h=t.tensorMap.get(s.dataId),f=u.values,d=h.values,p=ln(Array.from(f),Array.from(d));return t.makeTensorInfo([p.length],"int32",Int32Array.from(p))}const i=Te(r.shape),o=Te(s.shape),a=Math.max(i,o),l=new pUe(a),c=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[r,s],"int32",c)}const gUe={kernelName:QS,backendName:"webgpu",kernelFunc:mUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PQ=Xi({opType:yn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Z4e}),yUe={kernelName:hw,backendName:"webgpu",kernelFunc:PQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return Ya({inputs:{x:s.complexTensorInfos.real},backend:t})}const bUe={kernelName:A2,backendName:"webgpu",kernelFunc:wC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vUe(n,e){const t=new Hw(n.shape,bt.TO_INT),r=e.runWebGPUProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Ya({inputs:{x:s},backend:t});const o=ms(s.shape),a=UD({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Ky({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(s.dtype==="complex64"){const o=wC({inputs:{input:s},backend:t}),a=UD({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeData(o.dataId),a}if(!SM(s.dtype,i)){const o=Ya({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.tensorMap.get(s.dataId).values,[a,l,c]=N4e(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return vUe(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",ci("bool",1)),l=PQ({inputs:{a:s,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const wUe={kernelName:Xg,backendName:"webgpu",kernelFunc:UD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xUe=yr({opType:bt.CEIL,cpuKernelImpl:$4e}),_Ue={kernelName:Kg,backendName:"webgpu",kernelFunc:xUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SUe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CUe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;const l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return Te(s.shape)%4===0?a=new SUe(s.shape):a=new CUe(s.shape),t.runWebGPUProgram(a,[s],s.dtype,l)}const TUe={kernelName:Yg,backendName:"webgpu",kernelFunc:kUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EUe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function IUe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.tensorMap.get(r.dataId),i=new EUe(r.shape),o=[uH(r,s.complexTensorInfos.real),uH(r,s.complexTensorInfos.imag)];return t.runWebGPUProgram(i,o,o[0].dtype)}const AUe={kernelName:Lv,backendName:"webgpu",kernelFunc:IUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MUe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ba(e,1),this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${xt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return Ya({inputs:{x:s.complexTensorInfos.imag},backend:t})}const NUe={kernelName:v2,backendName:"webgpu",kernelFunc:VN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(x=>wC({inputs:{input:x},backend:t})),m=n.map(x=>VN({inputs:{input:x},backend:t})),g=A1(p,e,t),y=A1(m,e,t),b=Ky({inputs:{real:g,imag:y},backend:t});return p.forEach(x=>t.disposeData(x.dataId)),m.forEach(x=>t.disposeData(x.dataId)),t.disposeData(g.dataId),t.disposeData(y.dataId),b}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const p=n.map(S=>{const k=[-1,Te(S.shape.slice(e))];return Kt({inputs:{x:S},backend:t,attrs:{shape:k}})}),m=p.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=ba(p.map(S=>S.shape),1),y=p[0].shape[0]===1,b=R4e(m,g,r,y),x=ba(n.map(S=>S.shape),e),w=t.makeTensorInfo(x,r,b);return p.forEach(S=>t.disposeData(S.dataId)),w}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const p=[];for(let g=0;g<n.length;g+=i){const y=n.slice(g,g+i);p.push(A1(y,e,t))}const m=A1(p,e,t);for(const g of p)t.disposeData(g.dataId);return m}const{tensors2D:o,outShape:a}=$Ue(n,e,t),l=o.map(p=>p.shape),c=new MUe(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let p=1;p<h.length;p++)h[p]=h[p-1]+l[p][1],u.push({type:"int32",data:[h[p]]})}const f=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(p=>t.disposeData(p.dataId));const d=Kt({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),d}function $Ue(n,e,t){const r=ba(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Kt({inputs:{x:i},backend:t,attrs:{shape:[Te(i.shape.slice(0,e)),Te(i.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(c=>c.shape);dN(o,i);const a=ba(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?Ya({inputs:{x:l[0]},backend:t}):A1(l,i,t)}const RUe={kernelName:zv,backendName:"webgpu",kernelFunc:DQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PUe(n,e,t,r,s=!1,i=null,o=!1,a=4,l=4,c=4){const u=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},h=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=n?"uniforms.xShape[1]":"uniforms.xShape[2]",m=n?"uniforms.xShape[2]":"uniforms.xShape[3]",g=n?"row":"col",y=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${Vn(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${m}) {
        ${f}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,x=n?e&&r?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Vn(a)}(0.0);`:r&&t?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Vn(a)}(0.0);`,w=`${h(l)}`,S=Vn(c),C=Vn(n?a:l),k=Vn(n?l:a);return`
      ${Yf(i,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${C} {
        ${n?x:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?w:x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${S}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${Xy(s,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class DUe{constructor(e,t,r,s,i=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=SQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=CQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?LN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):zN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${PUe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OUe{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=s,t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Yf(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Xy(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${xt("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FUe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${xt("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function LUe({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,h=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=[];let d,p;if(h){const y=t.inHeight*t.inWidth*t.inChannels;d=Kt({inputs:{x:n},backend:r,attrs:{shape:[1,t.batchSize,y]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,y,t.outChannels]}})}else d=Kt({inputs:{x:n},backend:r,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(f.push(d),f.push(p),i!=null){const y=WI(i.shape,l);y!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:y}}),f.push(i))}if(s!=null){const y=WI(s.shape,l);y!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:y}}),f.push(s))}const m=BN({a:l?d:p,b:l?p:d,transposeA:c,transposeB:u,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),g=Kt({inputs:{x:m},backend:r,attrs:{shape:t.outShape}});f.push(m);for(const y of f)r.disposeData(y.dataId);return g}function zUe({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:f,padInfo:d,outWidth:p,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:b}=t,x=b==="channelsLast",w=l*c*u,S=m*p,C=x?[t.batchSize,S,w]:[t.batchSize,w,S],k=new FUe(C,x),A=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[f,h]},{type:"int32",data:[y,g]},{type:"int32",data:[p]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],M=r.runWebGPUProgram(k,[n],n.dtype,A),E=[];E.push(M);const N=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,w,-1]}});if(E.push(N),i!=null){const B=WI(i.shape,x);B!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:B}}),E.push(i))}if(s!=null){const B=WI(s.shape,x);B!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:B}}),E.push(s))}const D=BN({a:x?M:N,b:x?N:M,transposeA:!x,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),z=Kt({inputs:{x:D},backend:r,attrs:{shape:t.outShape}});E.push(D);for(const B of E)r.disposeData(B.dataId);return z}function OQ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=s!=null,c=i!=null,u=t.dataFormat==="channelsLast",h=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return LUe({x:n,filter:e,convInfo:t,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});const d=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),p=d>-1?d:r.thresholdToIncreaseWorkgroups,m=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(Ee().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=p)return zUe({x:n,filter:e,convInfo:t,backend:r,bias:s,preluActivationWeights:i,leakyreluAlpha:o,activation:a});let g;const y=[t.padInfo.top,t.padInfo.left],b=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(f)g=new OUe(t,l,a,c);else{const C=u?t.outHeight*t.outWidth:t.outChannels,k=u?t.outChannels:t.outHeight*t.outWidth,A=t.filterHeight*t.filterWidth*t.inChannels;b.push({type:"int32",data:[C]},{type:"int32",data:[k]},{type:"int32",data:[A]});const M=r.adapterInfo.isIntel();g=new DUe(t,C,k,A,l,a,c,M)}const x=[],w=[n,e];l&&(!u&&s.shape.length===1&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),x.push(s)),w.push(s)),c&&(!u&&i.shape.length===1&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),x.push(i)),w.push(i)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const S=r.runWebGPUProgram(g,w,n.dtype,b);for(const C of x)r.disposeData(C.dataId);return S}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BUe(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,h=nl(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h);return OQ({x:s,filter:i,convInfo:f,backend:r})}const VUe={kernelName:Bv,backendName:"webgpu",kernelFunc:BUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UUe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${xt()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class WUe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class GUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class HUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=nl(l),f=ts(s.shape,u,o,1,a,c,!1,h),d=new WUe(f),p=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return t.runWebGPUProgram(d,[s,i],s.dtype,p)}const qUe={kernelName:t2,backendName:"webgpu",kernelFunc:jUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XUe(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Vn(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Vn(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Vn(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Vn(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Vn(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Vn(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Vn(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class KUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=SQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=CQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?LN(this.elementsPerThread,this.workgroupSize):zN(this.elementsPerThread,this.workgroupSize);return`
    ${XUe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=nl(c),f=ts(o,i.shape,a,1,l,u,!1,h),d=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let p;if(Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.dataFormat!=="channelsLast")p=new UUe(f);else{p=new KUe(f);const m=f.inHeight*f.inWidth,g=f.inChannels,y=f.filterHeight*f.filterWidth*f.outChannels;d.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(p,[s,i],"float32",d)}const ZUe={kernelName:Vv,backendName:"webgpu",kernelFunc:YUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Lu(s.shape,i.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],f=new JUe(c),d=Mi(s.dtype,i.dtype);return t.runWebGPUProgram(f,[s,i],d,h)}const eWe={kernelName:Uv,backendName:"webgpu",kernelFunc:QUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Lu(s.shape,l,o,1,a),u=new GUe(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[s,i],i.dtype,h)}const nWe={kernelName:n2,backendName:"webgpu",kernelFunc:tWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rWe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,pad:a,inputShape:l}=r,c=Lu(l,i.shape,o,1,a),u=new HUe(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[s,i],s.dtype,h)}const sWe={kernelName:r2,backendName:"webgpu",kernelFunc:rWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iWe=yr({opType:bt.COS}),oWe={kernelName:Zg,backendName:"webgpu",kernelFunc:iWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aWe=yr({opType:bt.COSH}),lWe={kernelName:Jg,backendName:"webgpu",kernelFunc:aWe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cWe{constructor(e,t,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,r[0],r[1],e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uWe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new cWe(s.shape[3],i.shape,a,l),h=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[s,i,o],"float32",h)},hWe={kernelName:i2,backendName:"webgpu",kernelFunc:uWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var D_;(function(n){n.Prod="*",n.Sum="+"})(D_||(D_={}));class hH{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===D_.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${fH(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let i="",o="";return this.exclusive?(i=this.reverse?`end != ${s-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${s}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${xt("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${dH(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${o};
           ${dH(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${fH(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function fH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function dH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Ch({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ns(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Ya({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new hH(n,l.shape,!1,i),p=h,m=[{type:"float32",data:[f]}];h=t.runWebGPUProgram(d,[h],h.dtype,m),t.disposeData(p.dataId)}if(s){const f=new hH(n,l.shape,s,i),d=h,p=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(f,[h],h.dtype,p),t.disposeData(d.dataId)}if(a!=null){const f=Oh(a),d=Ch({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeData(h.dataId),t.disposeData(l.dataId),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return FQ(D_.Prod,s,t,i,o,a)}const dWe={kernelName:s2,backendName:"webgpu",kernelFunc:fWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return FQ(D_.Sum,s,t,i,o,a)}const mWe={kernelName:Wv,backendName:"webgpu",kernelFunc:pWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r,l=s.shape.length===1,u=Te(i.shape)>0,h=i.dtype,f=l?[s.shape[0]]:[s.shape[0],s.shape[1]],d=l?[o]:[s.shape[0],o],p=va({backend:t,attrs:{shape:d,value:0,dtype:h}}),m=new RQ(f,u,a),g=[{type:"int32",data:[o]}],y=u?[s,i]:[s];return t.runWebGPUProgram(m,y,h,g,p)}const yWe={kernelName:o2,backendName:"webgpu",kernelFunc:gWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bWe{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=[{type:"int32",data:[i]}],g=new bWe(p,o);return t.runWebGPUProgram(g,[s],s.dtype,m)}const wWe={kernelName:a2,backendName:"webgpu",kernelFunc:vWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xWe{constructor(e,t,r,s=!1,i=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=i,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Yf(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${xt()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Xy(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Ot(i),this.dispatch=_t(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Yf(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${xt("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Xy(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Yf(this.activation,this.hasPreluActivation,!1,4)}

      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Xy(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _We(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=nl(l);let f=c;f==null&&(f=[1,1]);const d=ts(s.shape,i.shape,o,f,a,u,!0,h),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],m=d.dataFormat==="channelsLast";let g;return!m&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new xWe(d.outShape,d.filterHeight,d.filterWidth):m&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?(g=new LQ(d),p.push({type:"int32",data:[g.virtualWidth]})):(g=new zQ(d),p.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[s,i],s.dtype,p)}const SWe={kernelName:Gv,backendName:"webgpu",kernelFunc:_We};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CWe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class kWe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ts(s.shape,u,o,a,l,c,!0),f=new CWe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],"float32",d)}const EWe={kernelName:l2,backendName:"webgpu",kernelFunc:TWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IWe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ts(u,i.shape,o,a,l,c,!0),f=new kWe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],s.dtype,d)}const AWe={kernelName:c2,backendName:"webgpu",kernelFunc:IWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MWe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NWe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=Kt({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new MWe(i),l=t.runWebGPUProgram(a,[o],o.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const $We={kernelName:u2,backendName:"webgpu",kernelFunc:NWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RWe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Pp(s.shape,i.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],f=new RWe(c);return t.runWebGPUProgram(f,[s,i],s.dtype,h)}const DWe={kernelName:Hv,backendName:"webgpu",kernelFunc:PWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OWe{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${zp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class FWe{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${zp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=Pp(s.shape,i.shape,a,l,"NHWC",c),h=i.dtype,f=new FWe(u,i.shape,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=va({backend:t,attrs:{shape:i.shape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const zWe={kernelName:b_,backendName:"webgpu",kernelFunc:LWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=Pp(s.shape,i.shape,a,l,"NHWC",c),h=s.dtype,f=new OWe(u,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=va({backend:t,attrs:{shape:u.inShape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const VWe={kernelName:y_,backendName:"webgpu",kernelFunc:BWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UWe{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=ov.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${xt("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WWe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=o||{},u=(c==null?void 0:c.alpha)||1,h=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",f=[a,l],d=new UWe(f,s.dtype,h);i.width=l,i.height=a;const p="webgpu";let m=i.getContext(p),g;m||(g=new OffscreenCanvas(l,a),m=g.getContext(p));const y=s.shape.length===3?s.shape[2]:1;m.configure({device:t.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=t.makeTensorInfo(f,b),w=t.tensorMap.get(x.dataId);w.resource=m.getCurrentTexture(),w.external=!0;const S=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(d,[s],b,S,x),g){const C=i.getContext("2d");if(!C)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");C.drawImage(g,0,0)}return t.disposeData(x.dataId),s}const GWe={kernelName:h2,backendName:"webgpu",kernelFunc:WWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BQ=Xi({opType:yn.MUL,cpuKernelImpl:K4e,supportsComplex:!0}),HWe={kernelName:gy,backendName:"webgpu",kernelFunc:BQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Yy(s,i,o,"sum",t)}const jWe={kernelName:Cw,backendName:"webgpu",kernelFunc:VQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qWe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=CN(s,i.length);TN(o.length,l,i);const{path:c,steps:u}=EN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=kN(d,l[g]);let x;IN(y)?x=i[g]:(x=Ch({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=Kt({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=BQ({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=VQ({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeData(m.dataId);return f}const XWe={kernelName:f2,backendName:"webgpu",kernelFunc:qWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KWe=yr({opType:bt.ELU}),YWe={kernelName:ey,backendName:"webgpu",kernelFunc:KWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZWe=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=new UI(yn.ELU_DER,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],r.dtype)},JWe={kernelName:d2,backendName:"webgpu",kernelFunc:ZWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QWe=Xi({opType:yn.EQUAL,dtype:"bool",cpuKernelImpl:P4e}),eGe={kernelName:jv,backendName:"webgpu",kernelFunc:QWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tGe=yr({opType:bt.ERF}),nGe={kernelName:ty,backendName:"webgpu",kernelFunc:tGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rGe=yr({opType:bt.EXP,cpuKernelImpl:D4e,dtype:"float32"}),sGe={kernelName:ny,backendName:"webgpu",kernelFunc:rGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),Kt({inputs:{x:i},backend:r,attrs:{shape:a}})}const iGe={kernelName:qv,backendName:"webgpu",kernelFunc:WD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oGe=yr({opType:bt.EXPM1,cpuKernelImpl:O4e}),aGe={kernelName:ry,backendName:"webgpu",kernelFunc:oGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pH{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(n,e,t){const r=t.tensorMap.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=[],l=Kt({inputs:{x:n},backend:t,attrs:{shape:[o,i]}});a.push(l);const c=l.shape,u=new pH("real",c),h=new pH("imag",c),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=e?2*Math.PI:-2*Math.PI,p=e?c[1]:1,m=[{type:"float32",data:[d]},{type:"float32",data:[p]}],g=t.runWebGPUProgram(u,f,"float32",m);a.push(g);const y=t.runWebGPUProgram(h,f,"float32",m);a.push(y);const b=Ky({inputs:{real:g,imag:y},backend:t});a.push(b);const x=Kt({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return a.forEach(w=>t.disposeData(w.dataId)),x}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lGe(n){const{inputs:e,backend:t}=n,{input:r}=e;return UQ(r,!1,t)}const cGe={kernelName:p2,backendName:"webgpu",kernelFunc:lGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uGe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hGe={kernelName:g2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new uGe(t.shape);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fGe=yr({opType:bt.FLOOR,cpuKernelImpl:F4e}),dGe={kernelName:sy,backendName:"webgpu",kernelFunc:fGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pGe=Xi({opType:yn.FLOOR_DIV,cpuKernelImpl:L4e,dtype:"int32"}),mGe={kernelName:iy,backendName:"webgpu",kernelFunc:pGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gGe{constructor(e,t,r=!1){this.pixelsOpType=ov.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${xt("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yGe={kernelName:v_,backendName:"webgpu",kernelFunc:bGe};let R0,y3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function bGe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[u,h]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],f=[h,u,i],d=Ee().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,p=o||a;if(c||l||p){let b;if(d)b=t.device.importExternalTexture({source:s});else{if(p){const R=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(R0==null||R!==y3)&&(y3=R,R0=document.createElement("canvas").getContext("2d",{willReadFrequently:y3})),R0.canvas.width=u,R0.canvas.height=h,R0.drawImage(s,0,0,u,h),s=R0.canvas}const E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N="rgba8unorm",O=t.textureManager.acquireTexture(f[1],f[0],N,E);t.queue.copyExternalImageToTexture({source:s},{texture:O},[f[1],f[0]]),b=O}const x=Te(f),w=Jt(f),S=new gGe(f,i,d),C=[{type:"uint32",data:[x]},{type:"uint32",data:[i]},{type:"uint32",data:[...w]}],k=t.makeTensorInfo([h,u],"int32"),A=t.tensorMap.get(k.dataId);A.resource=b;const M=t.runWebGPUProgram(S,[k],"int32",C);return t.disposeData(k.dataId),M}const m=s.data;let g=m;if(i!=null&&i!==4){g=new Uint8Array(s.width*s.height*i);const b=m.length;let x=0;for(let w=0;w<b;w++)w%4<i&&(g[x++]=m[w])}const y=t.makeTensorInfo(f,"int32",new Int32Array(g));return t.uploadToGPU(y.dataId),y}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vGe{constructor(e,t,r,s,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r),this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ln(e,s),this.variableNames.push("offset")),i!=null&&(ln(e,i),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${xt("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wGe={kernelName:Xv,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r,scale:s,offset:i,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[r,o,a];let h=null;i!=null&&(h=i.shape,u.push(i));let f=null;s!=null&&(f=s.shape,u.push(s));const d=new vGe(r.shape,o.shape,a.shape,h,f),p=[{type:"float32",data:[l]}];return c.runWebGPUProgram(d,u,r.dtype,p)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=nl(u),g=ts(s.shape,i.shape,l,h,c,f,!1,m);return OQ({x:s,filter:i,convInfo:g,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}const _Ge={kernelName:jb,backendName:"webgpu",kernelFunc:xGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r;let p=u;p==null&&(p=[1,1]),U(Ri(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const m=ts(s.shape,i.shape,l,p,c,h,!0),g=[s,i],y=o!=null,b=a!=null;y&&g.push(o),b&&g.push(a);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(w=new LQ(m,y,f,b),x.push({type:"int32",data:[w.virtualWidth]})):(w=new zQ(m,y,f,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),f==="leakyrelu"&&(x.push({type:"float32",data:[d]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,g,"float32",x)}const CGe={kernelName:qb,backendName:"webgpu",kernelFunc:SGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kGe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ys(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TGe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=uC(r,s),f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=Kt({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=t.readSync(s.dataId),x=t.bufferSync(r),w=z4e(b,x,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,w.values)}const p=new kGe(o,[c,u]),m=[{type:"int32",data:[o]},{type:"int32",data:h}],g=t.runWebGPUProgram(p,[d,f],d.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),y}const EGe={kernelName:y2,backendName:"webgpu",kernelFunc:TGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IGe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=AGe(this.aShape);return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function AGe(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let r=0;r<n.length;r++)r===2?t.push("indexZ"):t.push(`${e[r]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=An(o,s.shape)[0],c=MN(s,i,l,a),u=Te(i.shape),h=[],f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Kt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])){const x=t.tensorMap.get(d.dataId).values,w=Sn(d.shape,d.dtype,x),C=t.tensorMap.get(f.dataId).values,k=Sn(f.shape,f.dtype,C),A=B4e(k,w,p);return h.forEach(M=>t.disposeData(M.dataId)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}const m=new IGe(f.shape,p),g=t.runWebGPUProgram(m,[f,d],f.dtype);h.push(g);const y=Kt({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeData(b.dataId)),y}const MGe={kernelName:Kv,backendName:"webgpu",kernelFunc:WQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NGe=Xi({opType:yn.GREATER,cpuKernelImpl:U4e,dtype:"bool"}),$Ge={kernelName:Yv,backendName:"webgpu",kernelFunc:NGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RGe=Xi({opType:yn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:V4e}),PGe={kernelName:oy,backendName:"webgpu",kernelFunc:RGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DGe(n){const{inputs:e,backend:t}=n,{input:r}=e;return UQ(r,!0,t)}const OGe={kernelName:b2,backendName:"webgpu",kernelFunc:DGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FGe=yr({opType:bt.IS_FINITE,dtype:"bool"}),LGe={kernelName:ly,backendName:"webgpu",kernelFunc:FGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zGe=yr({opType:bt.IS_INF,dtype:"bool"}),BGe={kernelName:cy,backendName:"webgpu",kernelFunc:zGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VGe=yr({opType:bt.IS_NAN,dtype:"bool"}),UGe={kernelName:uy,backendName:"webgpu",kernelFunc:VGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=[{type:"float32",data:[i]}],a=new Hw(s.shape,bt.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[s],"float32",o)}const GGe={kernelName:Zv,backendName:"webgpu",kernelFunc:WGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HGe=Xi({opType:yn.LESS,dtype:"bool",cpuKernelImpl:G4e}),jGe={kernelName:Jv,backendName:"webgpu",kernelFunc:HGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qGe=Xi({opType:yn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:W4e}),XGe={kernelName:Qv,backendName:"webgpu",kernelFunc:qGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KGe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YGe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=(s-r)/(i-1),a=new KGe(i),l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const ZGe={kernelName:w2,backendName:"webgpu",kernelFunc:YGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JGe=yr({opType:bt.LOG,cpuKernelImpl:H4e}),QGe={kernelName:hy,backendName:"webgpu",kernelFunc:JGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eHe=yr({opType:bt.LOG1P}),tHe={kernelName:fy,backendName:"webgpu",kernelFunc:eHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nHe=Xi({opType:yn.LOGICAL_AND,dtype:"bool"}),rHe={kernelName:ew,backendName:"webgpu",kernelFunc:nHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sHe=yr({opType:bt.LOGICAL_NOT}),iHe={kernelName:tw,backendName:"webgpu",kernelFunc:sHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oHe=Xi({opType:yn.LOGICAL_OR}),aHe={kernelName:nw,backendName:"webgpu",kernelFunc:oHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GQ=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class lHe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${GQ}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class cHe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,U(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${xt()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${GQ}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;let c;i>16?c=new lHe(s.shape):c=new cHe(s.shape,i);const u=[{type:"int32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const hHe={kernelName:rw,backendName:"webgpu",kernelFunc:uHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fHe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new fHe(s.shape),f=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(h,[s,i,o],s.dtype,f)}const pHe={kernelName:x2,backendName:"webgpu",kernelFunc:dHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mHe=Xi({opType:yn.MAX,cpuKernelImpl:q4e}),gHe={kernelName:dy,backendName:"webgpu",kernelFunc:mHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(s.shape,i,o,c,a,l);return $Q(s,u,"max",t)}const bHe={kernelName:iw,backendName:"webgpu",kernelFunc:yHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(s.shape,i,o,u,a,c,l),f=new TB(h,"max"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const wHe={kernelName:ow,backendName:"webgpu",kernelFunc:vHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xHe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class _He{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new TB(f,"max",!0);let p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[o],"int32",p),g=new _He(f);p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],o.dtype,p);return t.disposeData(m.dataId),y}const CHe={kernelName:S2,backendName:"webgpu",kernelFunc:SHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;TQ([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=new P_(f,"max",!0);let p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[a],"int32",p),g=new xHe(f);p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],a.dtype,p);return t.disposeData(m.dataId),y}const THe={kernelName:_2,backendName:"webgpu",kernelFunc:kHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EHe(n){const{inputs:e,backend:t,attrs:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=r,{x:l}=e;U(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];U(Ri(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ko(l.shape,s,i,c,o),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let f=new P_(u,"max",!1);const d=t.runWebGPUProgram(f,[l],l.dtype,h);f=new P_(u,"max",!0,!0,a);const p=t.runWebGPUProgram(f,[l],"int32",h);return[d,p]}const IHe={kernelName:C2,backendName:"webgpu",kernelFunc:EHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Yy(s,i,o,"min",t)}const MHe={kernelName:lw,backendName:"webgpu",kernelFunc:AHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NHe=Xi({opType:yn.MIN,cpuKernelImpl:X4e}),$He={kernelName:py,backendName:"webgpu",kernelFunc:NHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RHe{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,i)=>s[0]+e[i]+s[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),r=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),s=e===1?"start":"start[i]",i=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Ys(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${s}) {
              ${o} = ${s} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${i}) {
              ${o} = (${i} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PHe={kernelName:cw,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=t,a=s.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new RHe(r.shape,s,i);return o.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DHe=Xi({opType:yn.MOD}),OHe={kernelName:my,backendName:"webgpu",kernelFunc:DHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FHe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LHe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${xt("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=Kt({inputs:{x:s},backend:t,attrs:{shape:[Te(s.shape)/s.shape[i],s.shape[i]]}}),a=new LHe(o.shape),l=t.runWebGPUProgram(a,[o],s.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const zHe={kernelName:Ew,backendName:"webgpu",kernelFunc:HQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BHe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:HQ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new FHe(c,i),f=[{type:"float32",data:[o]},{type:"int32",data:[u]}],d=t.runWebGPUProgram(h,[l],"int32",f);return a||t.disposeData(l.dataId),d}const VHe={kernelName:k2,backendName:"webgpu",kernelFunc:BHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UHe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.tensorMap.get(r.dataId),[o,a]=Y4e(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}const s=new Hw(r.shape,bt.NEG);return t.runWebGPUProgram(s,[r],r.dtype)}const WHe={kernelName:uw,backendName:"webgpu",kernelFunc:UHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=oC(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const HHe={kernelName:T2,backendName:"webgpu",kernelFunc:GHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=aC(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const qHe={kernelName:E2,backendName:"webgpu",kernelFunc:jHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XHe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KHe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new XHe(c,o),h=Kt({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=[{type:"float32",data:[a]},{type:"float32",data:[l]}],d=t.runWebGPUProgram(u,[h],i,f);t.disposeData(h.dataId);const p=[...s.shape,o],m=Kt({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeData(d.dataId),m}const YHe={kernelName:dw,backendName:"webgpu",kernelFunc:KHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=wC({inputs:{input:r},backend:t}),i=GI({inputs:{x:s},backend:t}),o=VN({inputs:{input:r},backend:t}),a=GI({inputs:{x:o},backend:t}),l=Ky({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return va({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const ZHe={kernelName:Mw,backendName:"webgpu",kernelFunc:GI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=wC({inputs:{input:r},backend:t}),i=jQ({inputs:{x:s},backend:t}),o=VN({inputs:{input:r},backend:t}),a=GI({inputs:{x:o},backend:t}),l=Ky({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return va({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const JHe={kernelName:fw,backendName:"webgpu",kernelFunc:jQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QHe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return WD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=WD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=DQ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeData(u.dataId)),c}const e6e={kernelName:pw,backendName:"webgpu",kernelFunc:QHe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQ(n,e=!1){const t=n.length,r=Ys(t),s=n.map((h,f)=>`uniforms.pad${f}[0]`).join(","),i=n.map((h,f)=>`uniforms.pad${f}[0] + uniforms.xShape${t>1?`[${f}]`:""}`).join(","),o=t>1?`${r}(${s})`:`${s}`,a=t>1?`${r}(${i})`:`${i}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class t6e{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${qQ(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n6e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(i.every(c=>Rn(c,[0,0])))return Ya({inputs:{x:s},backend:t});if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return va({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=[{type:"float32",data:[o]}];i.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new t6e(s.shape,i);return t.runWebGPUProgram(l,[s],s.dtype,a)},r6e={kernelName:mw,backendName:"webgpu",kernelFunc:n6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s6e=Xi({opType:yn.POW}),i6e={kernelName:yy,backendName:"webgpu",kernelFunc:s6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o6e(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=new UI(yn.PRELU,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],"float32")}const a6e={kernelName:gw,backendName:"webgpu",kernelFunc:o6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Yy(s,i,o,"prod",t)}const c6e={kernelName:yw,backendName:"webgpu",kernelFunc:l6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u6e=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=Q4e(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},h6e={kernelName:I2,backendName:"webgpu",kernelFunc:u6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f6e=Xi({opType:yn.DIV}),d6e={kernelName:Qg,backendName:"webgpu",kernelFunc:f6e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p6e=yr({opType:bt.RECIPROCAL}),m6e={kernelName:by,backendName:"webgpu",kernelFunc:p6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g6e=yr({opType:bt.RELU}),y6e={kernelName:vy,backendName:"webgpu",kernelFunc:g6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b6e=yr({opType:bt.RELU6}),v6e={kernelName:wy,backendName:"webgpu",kernelFunc:b6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w6e{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,size:o,halfPixelCenters:a}=r,[l,c]=o,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[a?.5:0]}],p=new w6e(s.shape,l,c);return t.runWebGPUProgram(p,[s],"float32",d)}const _6e={kernelName:ww,backendName:"webgpu",kernelFunc:x6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S6e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new S6e(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[d]},{type:"float32",data:[p]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const k6e={kernelName:N2,backendName:"webgpu",kernelFunc:C6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T6e{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[i?.5:0]}],p=new T6e(s.shape,l,c,o);return t.runWebGPUProgram(p,[s],s.dtype,d)}const I6e={kernelName:vw,backendName:"webgpu",kernelFunc:E6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A6e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new A6e(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const N6e={kernelName:M2,backendName:"webgpu",kernelFunc:M6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $6e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length;if(o===0)return Ya({inputs:{x:s},backend:t});const a=s.shape,l=[1,1,1,1];a.forEach((g,y)=>{const b=y+4-o;l[b]=g});const c=An(i,s.shape),u=[0,0,0,0];c.forEach(g=>{const y=g+4-o;u[y]=1});const h=[{type:"int32",data:u}],f=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),d=new $6e(l),p=t.runWebGPUProgram(d,[f],f.dtype,h);t.disposeData(f.dataId);const m=Kt({inputs:{x:p},backend:t,attrs:{shape:a}});return t.disposeData(p.dataId),m}const P6e={kernelName:xw,backendName:"webgpu",kernelFunc:R6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D6e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O6e={kernelName:G2,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new D6e(r.shape,i),[c,u]=mN(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof i=="number"?h.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):h.push({type:"float32",data:i}),a.runWebGPUProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F6e=yr({opType:bt.ROUND}),L6e={kernelName:xy,backendName:"webgpu",kernelFunc:F6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z6e=yr({opType:bt.RSQRT,cpuKernelImpl:eVe}),B6e={kernelName:_y,backendName:"webgpu",kernelFunc:z6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q1{constructor(e,t,r,s,i,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${i.length}`;const c=Ys(i.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",i="";this.dispatchLayout.x.length===1?(s="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${i}
      ${xt("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Lm(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?zp("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V6e(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=zu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=Kt({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=p.dtype,g=va({backend:t,attrs:{shape:f,value:0,dtype:m}}),y=Te(p.shape),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[y]}],x=new Q1(p.shape,a,d.shape.length,p.shape.length,u,f,m),w=t.runWebGPUProgram(x,[p,d],m,b,g),S=Kt({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(w.dataId),S}const U6e={kernelName:$2,backendName:"webgpu",kernelFunc:V6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W6e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6e(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new W6e([i.shape[0],i.shape[1]],o),l=[{type:"int32",data:[s.shape[1]]}];return t.runWebGPUProgram(a,[s,i],"int32",l)}const H6e={kernelName:P2,backendName:"webgpu",kernelFunc:G6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j6e{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${s[a]}`),a<this.cRank&&i.push(`${s[a]}`);e=i.join(),t=o.join()}return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6e(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new j6e(r.shape.length,s.shape,s.shape.length);return t.runWebGPUProgram(o,[r,s,i],Mi(s.dtype,i.dtype))}const X6e={kernelName:_w,backendName:"webgpu",kernelFunc:q6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K6e=yr({opType:bt.SELU}),Y6e={kernelName:Sy,backendName:"webgpu",kernelFunc:K6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z6e=yr({opType:bt.SIGMOID}),J6e={kernelName:Ey,backendName:"webgpu",kernelFunc:Z6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q6e=yr({opType:bt.SIGN}),e5e={kernelName:Ty,backendName:"webgpu",kernelFunc:Q6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5e=yr({opType:bt.SIN}),n5e={kernelName:Cy,backendName:"webgpu",kernelFunc:t5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r5e=yr({opType:bt.SINH}),s5e={kernelName:ky,backendName:"webgpu",kernelFunc:r5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i5e=yr({opType:bt.SOFTPLUS}),o5e={kernelName:Iy,backendName:"webgpu",kernelFunc:i5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a5e{constructor(e,t,r,s,i,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[i[l]];this.outputShape=a,this.newDim=i,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ys(s.length)}, paddedXShapeStrides : ${Ys(o)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Ys(this.outputShape.length),t=IQ(this.newDim);return`
      ${LE(this.paddedXShape,"PaddedX")}
      ${xt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${qQ(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l5e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<s.shape.length;++b)l.push([0,0]);const c=l.map((b,x)=>b[0]+s.shape[x]+b[1]),u=Vy(c,i,a,!1),h=Uy(u.length,i.length,!1),f=Wy(c,i,a,!1),d=Jt(c),p=new a5e(s.shape,c,l,u,h,d.length),m=[{type:"int32",data:u},{type:"int32",data:d}];l.map(b=>m.push({type:"int32",data:[b[0],b[1]]}));const g=t.runWebGPUProgram(p,[s],s.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeData(g.dataId),y},c5e={kernelName:kw,backendName:"webgpu",kernelFunc:l5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u5e{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Ot([t]),this.dispatch=_t(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${zp("&result[outIndex]","value",this.type)}
      }
    }
  `}}class h5e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Ot(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${zp("&result[segmentId]","1","int32")}
      }
    }
  `}}class f5e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XQ(n,e,t,r=!1,s){const o=Te(n.shape)/n.shape[0],a=n.dtype,l=Te(e.shape),c=s.readSync(t.dataId),h=l>0?c[l-1]+1:0;let f;const d=n.shape.slice();d[0]=h;const p=l*o,m=va({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new u5e(d,p,a);let g=[{type:"int32",data:[o]},{type:"int32",data:[p]}];const y=s.runWebGPUProgram(f,[n,e,t],a,g,m);if(r)return y;const b=va({backend:s,attrs:{shape:[h],value:0,dtype:"int32"}});f=new h5e(h,t.shape);const x=s.runWebGPUProgram(f,[t],"int32",null,b),w=va({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new f5e(d,a),g=[{type:"int32",data:[o]}];const S=s.runWebGPUProgram(f,[y,x],a,g,w);return s.disposeData(y.dataId),s.disposeData(x.dataId),S}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return XQ(r,s,i,!1,t)}const p5e={kernelName:D2,backendName:"webgpu",kernelFunc:d5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return XQ(r,s,i,!0,t)}const g5e={kernelName:O2,backendName:"webgpu",kernelFunc:m5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y5e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*t[s];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=b5e(this.rank,"uniforms.");return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function b5e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n;s++)r.push(`(${t[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(t.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>Cc(f)):l,u=Sn(s.shape,s.dtype,c),h=aVe(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new y5e(s.shape,i);return t.runWebGPUProgram(o,[s],s.dtype)}const v5e={kernelName:Py,backendName:"webgpu",kernelFunc:EB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5e(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=zu(i,s,a),d=!1;if(i.dtype==="string"){const A=t.bufferSync(s),M=t.bufferSync(i),E=Cc(t.readSync(o.dataId)[0]),N=tVe(A,M,a,f,u,c,l,h,E,d);return t.makeTensorInfo(a,N.dtype,N.values)}const p=[f/u,u],m=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),g=i.shape.length?Kt({inputs:{x:i},backend:t,attrs:{shape:[c,u]}}):Ya({inputs:{x:i},backend:t}),y=g.dtype,b=t.makeTensorInfo([],y,ji(1,y)),x=Kt({inputs:{x:o},backend:t,attrs:{shape:Array(p.length).fill(1)}}),w=EB({inputs:{x},backend:t,attrs:{reps:p}}),S=Te([c,u]),C=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[S]}];switch(c){case 0:break;case 1:{const A=new Q1([c,u],l,m.shape.length,g.shape.length,h,p,y,d);t.runWebGPUProgram(A,[g,m],y,C,w)}break;default:{const A=new Q1([c,u],l,m.shape.length,b.shape.length,h,p,y,d);t.runWebGPUProgram(A,[b,m],y,C,w)}{const A=new Q1([c,u],l,m.shape.length,g.shape.length,h,p,y);t.runWebGPUProgram(A,[g,m],y,C,w)}}const k=Kt({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),k}const x5e={kernelName:F2,backendName:"webgpu",kernelFunc:w5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=AN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=jw({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const S5e={kernelName:Tw,backendName:"webgpu",kernelFunc:_5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C5e=yr({opType:bt.SQRT}),k5e={kernelName:Ay,backendName:"webgpu",kernelFunc:C5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T5e={kernelName:L2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e,s=new Hw(t.shape,bt.SQUARE);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E5e=Xi({opType:yn.SQUARED_DIFFERENCE}),I5e={kernelName:My,backendName:"webgpu",kernelFunc:E5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5e({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=new Hw(r.shape,bt.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(s,[r],r.dtype,i)}const M5e={kernelName:Dy,backendName:"webgpu",kernelFunc:A5e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N5e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ys(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let s=0;t=this.outputShape.map((i,o)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${s-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${xt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=fN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=Kt({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=hN(b,x,w),k=jw({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});S=Kt({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeData(k.dataId)}else if(t.shouldExecuteOnCPU([s])){const k=t.readSync(s.dataId),A=Sn(s.shape,s.dtype,k),M=sVe(d,A,w,b);S=t.makeTensorInfo(p,s.dtype,M.values)}else{const k=new N5e(d),A=[{type:"int32",data:b},{type:"int32",data:w}],M=t.runWebGPUProgram(k,[s],s.dtype,A);S=Kt({inputs:{x:M},backend:t,attrs:{shape:p}}),t.disposeData(M.dataId)}return S}const R5e={kernelName:B2,backendName:"webgpu",kernelFunc:$5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5e(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=iVe(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const D5e={kernelName:V2,backendName:"webgpu",kernelFunc:P5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O5e=Xi({opType:yn.SUB,cpuKernelImpl:oVe,supportsComplex:!0}),F5e={kernelName:Ny,backendName:"webgpu",kernelFunc:O5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L5e=yr({opType:bt.TAN}),z5e={kernelName:$y,backendName:"webgpu",kernelFunc:L5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B5e=yr({opType:bt.TANH}),V5e={kernelName:Ry,backendName:"webgpu",kernelFunc:B5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5e(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=zu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=[],p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}});d.push(p);const m=Kt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});d.push(m);const g=Kt({inputs:{x:s},backend:t,attrs:{shape:f}});d.push(g);const y=EB({inputs:{x:g},backend:t,attrs:{reps:Array(f.length).fill(1)}}),b=new Q1([l,c],a,p.shape.length,m.shape.length,u,f,s.dtype,!1),x=Te([l,c]),w=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[x]}],S=t.runWebGPUProgram(b,[m,p],g.dtype,w,y);d.push(S);const C=Kt({inputs:{x:S},backend:t,attrs:{shape:s.shape}});return d.forEach(k=>t.disposeData(k.dataId)),C}const W5e={kernelName:R2,backendName:"webgpu",kernelFunc:U5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class H5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0(n,e){e!==null&&n.disposeData(e.dataId)}function mH(n){let e=1;for(;e<n;)e*=2;return e}function j5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=s.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([s])){const S=t.readSync(s.dataId),[C,k]=lVe(S,a,s.dtype,i,o);return[t.makeTensorInfo(C.shape,C.dtype,C.values),t.makeTensorInfo(k.shape,k.dtype,k.values)]}if(i===0)return a[a.length-1]=0,[t.makeTensorInfo(a,s.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[s,va({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=Te(a)/l,h=Kt({inputs:{x:s},attrs:{shape:[u,l]},backend:t}),f=mH(i),d=mH(l);let p=null;const m=()=>p===null?[h,h]:[h,p],g=(S,C,k)=>{const A=m(),M=new G5e(k),N=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[S]},{type:"int32",data:[C]}],O=p;p=t.runWebGPUProgram(M,A,"int32",N),P0(t,O)};for(let S=1;S<f;S*=2){const C=S*2;for(let k=S;k>=1;k/=2)g(C,k,[u,d])}for(let S=d;S>f;S/=2){const C=m(),k=new H5e([u,S/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[f]}],E=p;p=t.runWebGPUProgram(k,C,"int32",M),P0(t,E);const N=f/2,O=N*2;for(let R=N;R>=1;R/=2)g(O,R,p.shape)}let y=p;p=jw({inputs:{x:p},backend:t,attrs:{begin:0,size:[u,i]}}),P0(t,y);let b=WQ({inputs:{x:h,indices:p},backend:t,attrs:{axis:1,batchDims:1}});P0(t,h);const x=a.slice(0,-1);x.push(i),y=p,p=Kt({inputs:{x:p},attrs:{shape:x},backend:t}),P0(t,y);const w=b;return b=Kt({inputs:{x:b},attrs:{shape:x},backend:t}),P0(t,w),[b,p]}const q5e={kernelName:U2,backendName:"webgpu",kernelFunc:j5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X5e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${xt("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5e(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new X5e(g),b=o==="nearest"?1:2;let x;switch(a){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[l]}];return t.runWebGPUProgram(y,[s,i],"float32",w)}const Y5e={kernelName:W2,backendName:"webgpu",kernelFunc:K5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z5e(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=jw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Kt({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeData(m.dataId)),p}const J5e={kernelName:Iw,backendName:"webgpu",kernelFunc:Z5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q5e{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${zp("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eje(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=Ch({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=ns(1,a)[0]);const f=iB(h.shape,c,o),d=Te([h.shape[c]]),p=Kt({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=s.dtype,g=[p.shape[0],o],y=va({backend:t,attrs:{shape:g,value:0,dtype:m}}),b=new Q5e(p.shape,g,m),x=[{type:"int32",data:[o]},{type:"int32",data:[Te(p.shape)]}],w=t.runWebGPUProgram(b,[p,i],m,x,y),S=Kt({inputs:{x:w},backend:t,attrs:{shape:f}});l.push(w);let C=S;if(u!=null){l.push(S);const k=Oh(u);C=Ch({inputs:{x:C},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeData(k.dataId)),C}const tje={kernelName:Aw,backendName:"webgpu",kernelFunc:eje};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nje=[E4e,hVe,dVe,mVe,yVe,wVe,EVe,AVe,NVe,RVe,DVe,FVe,zVe,VVe,WVe,XVe,YVe,eUe,nUe,sUe,cUe,dUe,gUe,wUe,_Ue,TUe,A4e,AUe,RUe,VUe,qUe,ZUe,eWe,nWe,sWe,oWe,lWe,hWe,dWe,mWe,yWe,wWe,EWe,AWe,SWe,$We,DWe,zWe,VWe,GWe,XWe,YWe,JWe,eGe,nGe,sGe,iGe,aGe,cGe,C4e,hGe,yGe,dGe,mGe,wGe,_Ge,CGe,EGe,MGe,$Ge,PGe,I4e,OGe,NUe,LGe,BGe,UGe,GGe,jGe,XGe,ZGe,tHe,QGe,rHe,iHe,aHe,hHe,pHe,HVe,gHe,bHe,THe,wHe,CHe,IHe,jVe,MHe,$He,PHe,OHe,VHe,HWe,WHe,HHe,qHe,yUe,YHe,JHe,e6e,r6e,i6e,a6e,c6e,h6e,bUe,d6e,m6e,y6e,v6e,k4e,_6e,k6e,I6e,N6e,P6e,O6e,L6e,B6e,U6e,H6e,X6e,Y6e,J6e,e5e,n5e,s5e,aUe,M5e,R5e,D5e,zHe,o5e,c5e,p5e,g5e,x5e,S5e,k5e,T5e,I5e,F5e,jWe,z5e,V5e,W5e,v5e,q5e,Y5e,SVe,J5e,tje,ZHe];for(const n of nje)H2(n);function GD(n){"@babel/helpers - typeof";return GD=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},GD(n)}function Bu(n,e){if(e.length<n)throw new TypeError(n+" argument"+(n>1?"s":"")+" required, but only "+e.length+" present")}function qo(n){Bu(1,arguments);var e=Object.prototype.toString.call(n);return n instanceof Date||GD(n)==="object"&&e==="[object Date]"?new Date(n.getTime()):typeof n=="number"||e==="[object Number]"?new Date(n):((typeof n=="string"||e==="[object String]")&&typeof console<"u"&&(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn(new Error().stack)),new Date(NaN))}var rje={};function sje(){return rje}function gH(n){var e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds()));return e.setUTCFullYear(n.getFullYear()),n.getTime()-e.getTime()}function zE(n,e){Bu(2,arguments);var t=qo(n),r=qo(e),s=t.getTime()-r.getTime();return s<0?-1:s>0?1:s}function ije(n,e){Bu(2,arguments);var t=qo(n),r=qo(e),s=t.getFullYear()-r.getFullYear(),i=t.getMonth()-r.getMonth();return s*12+i}function oje(n,e){return Bu(2,arguments),qo(n).getTime()-qo(e).getTime()}var yH={ceil:Math.ceil,round:Math.round,floor:Math.floor,trunc:function(e){return e<0?Math.ceil(e):Math.floor(e)}},aje="trunc";function lje(n){return n?yH[n]:yH[aje]}function cje(n){Bu(1,arguments);var e=qo(n);return e.setHours(23,59,59,999),e}function uje(n){Bu(1,arguments);var e=qo(n),t=e.getMonth();return e.setFullYear(e.getFullYear(),t+1,0),e.setHours(23,59,59,999),e}function hje(n){Bu(1,arguments);var e=qo(n);return cje(e).getTime()===uje(e).getTime()}function fje(n,e){Bu(2,arguments);var t=qo(n),r=qo(e),s=zE(t,r),i=Math.abs(ije(t,r)),o;if(i<1)o=0;else{t.getMonth()===1&&t.getDate()>27&&t.setDate(30),t.setMonth(t.getMonth()-s*i);var a=zE(t,r)===-s;hje(qo(n))&&i===1&&zE(n,r)===1&&(a=!1),o=s*(i-Number(a))}return o===0?0:o}function dje(n,e,t){Bu(2,arguments);var r=oje(n,e)/1e3;return lje(t==null?void 0:t.roundingMethod)(r)}var pje={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}},mje=function(e,t,r){var s,i=pje[e];return typeof i=="string"?s=i:t===1?s=i.one:s=i.other.replace("{{count}}",t.toString()),r!=null&&r.addSuffix?r.comparison&&r.comparison>0?"in "+s:s+" ago":s};const gje=mje;function b3(n){return function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=e.width?String(e.width):n.defaultWidth,r=n.formats[t]||n.formats[n.defaultWidth];return r}}var yje={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},bje={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},vje={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},wje={date:b3({formats:yje,defaultWidth:"full"}),time:b3({formats:bje,defaultWidth:"full"}),dateTime:b3({formats:vje,defaultWidth:"full"})};const xje=wje;var _je={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"},Sje=function(e,t,r,s){return _je[e]};const Cje=Sje;function jx(n){return function(e,t){var r=t!=null&&t.context?String(t.context):"standalone",s;if(r==="formatting"&&n.formattingValues){var i=n.defaultFormattingWidth||n.defaultWidth,o=t!=null&&t.width?String(t.width):i;s=n.formattingValues[o]||n.formattingValues[i]}else{var a=n.defaultWidth,l=t!=null&&t.width?String(t.width):n.defaultWidth;s=n.values[l]||n.values[a]}var c=n.argumentCallback?n.argumentCallback(e):e;return s[c]}}var kje={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},Tje={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},Eje={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},Ije={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},Aje={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},Mje={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},Nje=function(e,t){var r=Number(e),s=r%100;if(s>20||s<10)switch(s%10){case 1:return r+"st";case 2:return r+"nd";case 3:return r+"rd"}return r+"th"},$je={ordinalNumber:Nje,era:jx({values:kje,defaultWidth:"wide"}),quarter:jx({values:Tje,defaultWidth:"wide",argumentCallback:function(e){return e-1}}),month:jx({values:Eje,defaultWidth:"wide"}),day:jx({values:Ije,defaultWidth:"wide"}),dayPeriod:jx({values:Aje,defaultWidth:"wide",formattingValues:Mje,defaultFormattingWidth:"wide"})};const Rje=$je;function qx(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=t.width,s=r&&n.matchPatterns[r]||n.matchPatterns[n.defaultMatchWidth],i=e.match(s);if(!i)return null;var o=i[0],a=r&&n.parsePatterns[r]||n.parsePatterns[n.defaultParseWidth],l=Array.isArray(a)?Dje(a,function(h){return h.test(o)}):Pje(a,function(h){return h.test(o)}),c;c=n.valueCallback?n.valueCallback(l):l,c=t.valueCallback?t.valueCallback(c):c;var u=e.slice(o.length);return{value:c,rest:u}}}function Pje(n,e){for(var t in n)if(n.hasOwnProperty(t)&&e(n[t]))return t}function Dje(n,e){for(var t=0;t<n.length;t++)if(e(n[t]))return t}function Oje(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=e.match(n.matchPattern);if(!r)return null;var s=r[0],i=e.match(n.parsePattern);if(!i)return null;var o=n.valueCallback?n.valueCallback(i[0]):i[0];o=t.valueCallback?t.valueCallback(o):o;var a=e.slice(s.length);return{value:o,rest:a}}}var Fje=/^(\d+)(th|st|nd|rd)?/i,Lje=/\d+/i,zje={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},Bje={any:[/^b/i,/^(a|c)/i]},Vje={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},Uje={any:[/1/i,/2/i,/3/i,/4/i]},Wje={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},Gje={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},Hje={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},jje={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},qje={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},Xje={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},Kje={ordinalNumber:Oje({matchPattern:Fje,parsePattern:Lje,valueCallback:function(e){return parseInt(e,10)}}),era:qx({matchPatterns:zje,defaultMatchWidth:"wide",parsePatterns:Bje,defaultParseWidth:"any"}),quarter:qx({matchPatterns:Vje,defaultMatchWidth:"wide",parsePatterns:Uje,defaultParseWidth:"any",valueCallback:function(e){return e+1}}),month:qx({matchPatterns:Wje,defaultMatchWidth:"wide",parsePatterns:Gje,defaultParseWidth:"any"}),day:qx({matchPatterns:Hje,defaultMatchWidth:"wide",parsePatterns:jje,defaultParseWidth:"any"}),dayPeriod:qx({matchPatterns:qje,defaultMatchWidth:"any",parsePatterns:Xje,defaultParseWidth:"any"})};const Yje=Kje;var Zje={code:"en-US",formatDistance:gje,formatLong:xje,formatRelative:Cje,localize:Rje,match:Yje,options:{weekStartsOn:0,firstWeekContainsDate:1}};const Jje=Zje;function KQ(n,e){if(n==null)throw new TypeError("assign requires that input parameter not be null or undefined");for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function Qje(n){return KQ({},n)}var bH=1440,e8e=2520,v3=43200,t8e=86400;function n8e(n,e,t){var r,s;Bu(2,arguments);var i=sje(),o=(r=(s=t==null?void 0:t.locale)!==null&&s!==void 0?s:i.locale)!==null&&r!==void 0?r:Jje;if(!o.formatDistance)throw new RangeError("locale must contain formatDistance property");var a=zE(n,e);if(isNaN(a))throw new RangeError("Invalid time value");var l=KQ(Qje(t),{addSuffix:!!(t!=null&&t.addSuffix),comparison:a}),c,u;a>0?(c=qo(e),u=qo(n)):(c=qo(n),u=qo(e));var h=dje(u,c),f=(gH(u)-gH(c))/1e3,d=Math.round((h-f)/60),p;if(d<2)return t!=null&&t.includeSeconds?h<5?o.formatDistance("lessThanXSeconds",5,l):h<10?o.formatDistance("lessThanXSeconds",10,l):h<20?o.formatDistance("lessThanXSeconds",20,l):h<40?o.formatDistance("halfAMinute",0,l):h<60?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",1,l):d===0?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",d,l);if(d<45)return o.formatDistance("xMinutes",d,l);if(d<90)return o.formatDistance("aboutXHours",1,l);if(d<bH){var m=Math.round(d/60);return o.formatDistance("aboutXHours",m,l)}else{if(d<e8e)return o.formatDistance("xDays",1,l);if(d<v3){var g=Math.round(d/bH);return o.formatDistance("xDays",g,l)}else if(d<t8e)return p=Math.round(d/v3),o.formatDistance("aboutXMonths",p,l)}if(p=fje(u,c),p<12){var y=Math.round(d/v3);return o.formatDistance("xMonths",y,l)}else{var b=p%12,x=Math.floor(p/12);return b<3?o.formatDistance("aboutXYears",x,l):b<9?o.formatDistance("overXYears",x,l):o.formatDistance("almostXYears",x+1,l)}}function r8e(n,e){return Bu(1,arguments),n8e(n,Date.now(),e)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function YQ(n,e){for(var t=e.length,r=new Array(t+1),s=0;s<t;++s)r[s]=e[s];return r[t]=n,r}function s8e(n,e){var t=n.length,r=e.length,s=new Array(t+r),i=0;for(i=0;i<t;i++)s[i]=n[i];for(var o=0;o<r;o++)s[i++]=e[o];return s}function i8e(n,e){for(var t=e.length,r=new Array(t),s=0;s<t;++s)r[s]=n(e[s]);return r}function UN(n,e,t){for(var r=e,s=0,i=t.length;s<i;++s)r=n(r,t[s],s);return r}function o8e(n,e){if(n<0)throw new TypeError("i must be >= 0");var t=e.length;return t===0||n>=t?e:t===1?[]:a8e(n,e,t-1)}function a8e(n,e,t){var r=new Array(t),s;for(s=0;s<n;++s)r[s]=e[s];for(s=n;s<t;++s)r[s]=e[s+1];return r}function l8e(n,e){for(var t=e.length,r=new Array(t),s=0,i=void 0,o=0;o<t;++o)i=e[o],n(i)||(r[s]=i,++s);return r.length=s,r}function ZQ(n,e){for(var t=0,r=e.length;t<r;++t)if(n===e[t])return t;return-1}/** @license MIT License (c) copyright 2010-2016 original author or authors */var c8e=function(n){return n},u8e=function(n,e){return function(t){return n(e(t))}},h8e=function(n,e){return n(e)};function Tr(n){function e(t,r){switch(arguments.length){case 0:return e;case 1:return function(s){return n(t,s)};default:return n(t,r)}}return e}function Vu(n){function e(t,r,s){switch(arguments.length){case 0:return e;case 1:return Tr(function(i,o){return n(t,i,o)});case 2:return function(i){return n(t,r,i)};default:return n(t,r,s)}}return e}var f8e=function(){function n(e,t,r,s,i){this.time=e,this.localOffset=t,this.period=r,this.task=s,this.scheduler=i,this.active=!0}return n.prototype.run=function(){return this.task.run(this.time-this.localOffset)},n.prototype.error=function(e){return this.task.error(this.time-this.localOffset,e)},n.prototype.dispose=function(){return this.active=!1,this.scheduler.cancel(this),this.task.dispose()},n}(),JQ=function(){function n(e,t){this.origin=e,this.scheduler=t}return n.prototype.currentTime=function(){return this.scheduler.currentTime()-this.origin},n.prototype.scheduleTask=function(e,t,r,s){return this.scheduler.scheduleTask(e+this.origin,t,r,s)},n.prototype.relative=function(e){return new n(e+this.origin,this.scheduler)},n.prototype.cancel=function(e){return this.scheduler.cancel(e)},n.prototype.cancelAll=function(e){return this.scheduler.cancelAll(e)},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var d8e=function(n){return Promise.resolve(n).then(QQ)};function QQ(n){try{return n.run()}catch(e){return n.error(e)}}/** @license MIT License (c) copyright 2010-2017 original author or authors */var p8e=function(){function n(e,t){var r=this;this._runReadyTasksBound=function(){return r._runReadyTasks()},this.timer=e,this.timeline=t,this._timer=null,this._nextArrival=1/0}return n.prototype.currentTime=function(){return this.timer.now()},n.prototype.scheduleTask=function(e,t,r,s){var i=this.currentTime()+Math.max(0,t),o=new f8e(i,e,r,s,this);return this.timeline.add(o),this._scheduleNextRun(),o},n.prototype.relative=function(e){return new JQ(e,this)},n.prototype.cancel=function(e){e.active=!1,this.timeline.remove(e)&&this._reschedule()},n.prototype.cancelAll=function(e){this.timeline.removeAll(e),this._reschedule()},n.prototype._reschedule=function(){this.timeline.isEmpty()?this._unschedule():this._scheduleNextRun()},n.prototype._unschedule=function(){this.timer.clearTimer(this._timer),this._timer=null},n.prototype._scheduleNextRun=function(){if(!this.timeline.isEmpty()){var e=this.timeline.nextArrival();this._timer===null?this._scheduleNextArrival(e):e<this._nextArrival&&(this._unschedule(),this._scheduleNextArrival(e))}},n.prototype._scheduleNextArrival=function(e){this._nextArrival=e;var t=Math.max(0,e-this.currentTime());this._timer=this.timer.setTimer(this._runReadyTasksBound,t)},n.prototype._runReadyTasks=function(){this._timer=null,this.timeline.runTasks(this.currentTime(),QQ),this._scheduleNextRun()},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var m8e=function(){function n(){this.tasks=[]}return n.prototype.nextArrival=function(){return this.isEmpty()?1/0:this.tasks[0].time},n.prototype.isEmpty=function(){return this.tasks.length===0},n.prototype.add=function(e){eee(e,this.tasks)},n.prototype.remove=function(e){var t=nee(tee(e),this.tasks);if(t>=0&&t<this.tasks.length){var r=this.tasks[t].events,s=ZQ(e,r);if(s>=0)return r.splice(s,1),r.length===0&&this.tasks.splice(t,1),!0}return!1},n.prototype.removeAll=function(e){for(var t=0;t<this.tasks.length;++t)w8e(e,this.tasks[t])},n.prototype.runTasks=function(e,t){for(var r=this.tasks,s=r.length,i=0;i<s&&r[i].time<=e;)++i;this.tasks=r.slice(i);for(var o=0;o<i;++o)this.tasks=g8e(t,r[o].events,this.tasks)},n}();function g8e(n,e,t){for(var r=0;r<e.length;++r){var s=e[r];s.active&&(n(s),s.period>=0&&s.active&&(s.time=s.time+s.period,eee(s,t)))}return t}function eee(n,e){var t=e.length,r=tee(n);if(t===0){e.push(HD(r,[n]));return}var s=nee(r,e);s>=t?e.push(HD(r,[n])):y8e(n,e,r,s)}function y8e(n,e,t,r){var s=e[r];t===s.time?b8e(n,s.events):e.splice(r,0,HD(t,[n]))}function b8e(n,e){e.length===0||n.time>=e[e.length-1].time?e.push(n):v8e(n,e)}function v8e(n,e){for(var t=0;t<e.length;t++)if(n.time<e[t].time){e.splice(t,0,n);break}}function tee(n){return Math.floor(n.time)}function w8e(n,e){e.events=l8e(n,e.events)}function nee(n,e){for(var t=0,r=e.length,s,i;t<r;){if(s=Math.floor((t+r)/2),i=e[s],n===i.time)return s;n<i.time?r=s:t=s+1}return r}var HD=function(n,e){return{time:n,events:e}};/** @license MIT License (c) copyright 2010-2017 original author or authors */var x8e=function(){function n(e){this._clock=e}return n.prototype.now=function(){return this._clock.now()},n.prototype.setTimer=function(e,t){return t<=0?_8e(e):setTimeout(e,t)},n.prototype.clearTimer=function(e){return e instanceof ree?e.cancel():clearTimeout(e)},n}(),ree=function(){function n(e){this.f=e,this.active=!0}return n.prototype.run=function(){if(this.active)return this.f()},n.prototype.error=function(e){throw e},n.prototype.cancel=function(){this.active=!1},n}();function _8e(n){var e=new ree(n);return d8e(e),e}var S8e=function(){function n(e,t){this.origin=t,this.clock=e}return n.prototype.now=function(){return this.clock.now()-this.origin},n}(),C8e=function(){function n(e,t){this.origin=t,this.hrtime=e}return n.prototype.now=function(){var e=this.hrtime(this.origin);return(e[0]*1e9+e[1])/1e6},n}(),see=function(n){return new S8e(n,n.now())},k8e=function(){return see(performance)},T8e=function(){return see(Date)},E8e=function(){return new C8e(process.hrtime,process.hrtime())},I8e=function(){return typeof performance<"u"&&typeof performance.now=="function"?k8e():typeof process<"u"&&typeof process.hrtime=="function"?E8e():T8e()},BE=function(n){return n.currentTime()},WN=Tr(function(n,e){return e.scheduleTask(0,0,-1,n)}),HI=Vu(function(n,e,t){return t.scheduleTask(0,n,-1,e)}),A8e=Vu(function(n,e,t){return t.scheduleTask(0,0,n,e)}),M8e=function(n){return n.dispose()},IB=Tr(function(n,e){return new JQ(n,e)}),N8e=function(){return new p8e($8e(),new m8e)},$8e=function(){return new x8e(I8e())},O_=function(){return iee},iee=new(function(){function n(){}return n.prototype.dispose=function(){},n}()),R8e=function(n){return n===iee},AB=function(n){return new P8e(n)},P8e=function(){function n(e){this.disposed=!1,this.disposable=e}return n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable&&(this.disposable.dispose(),this.disposable=void 0))},n}();/** @license MIT License (c) copyright 2010 original author or authors */var xC=function(n){var e=UN(D8e,[],n);return e.length===0?O_():new oee(e)},qw=Tr(function(n,e){return xC([n,e])}),D8e=function(n,e){return R8e(e)?n:e instanceof oee?s8e(n,e.disposables):YQ(e,n)},oee=function(){function n(e){this.disposables=e}return n.prototype.dispose=function(){L8e(O8e(this.disposables))},n}(),O8e=function(n){return UN(F8e,[],n)},F8e=function(n,e){try{e.dispose()}catch(t){n.push(t)}return n},L8e=function(n){if(n.length>0)throw new aee(n.length+" errors",n)},aee=function(){function n(e,t){this.name="DisposeAllError",this.message=e,this.errors=t,Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,n),this.stack=""+this.stack+z8e(this.errors)}return n}();aee.prototype=Object.create(Error.prototype);var z8e=function(n){return UN(B8e,"",n)},B8e=function(n,e,t){return n+(`
[`+(t+1)+"] "+e.stack)};/** @license MIT License (c) copyright 2010-2017 original author or authors */var yg=Vu(function(n,e,t){try{e.dispose()}catch(r){t.error(n,r)}});/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var jD=function(n,e){return jD=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])},jD(n,e)};function Yr(n,e){jD(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function lee(n){setTimeout(V8e,0,n)}function V8e(n){throw n}/** @license MIT License (c) copyright 2010-2016 original author or authors */var U8e=function(n,e,t){return new G8e(n,e,t)},MB=function(n,e){return new H8e(n,e)},cee=function(n){return new j8e(n)},W8e=function(n,e){return new q8e(n,e)},GN=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.dispose=function(){this.active=!1},n.prototype.run=function(e){this.active&&this.runIfActive(e)},n.prototype.error=function(e,t){if(!this.active)return lee(t);this.sink.error(e,t)},n}(),G8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.runEvent=t,i.value=r,i}return e.prototype.runIfActive=function(t){this.runEvent(t,this.value,this.sink)},e}(GN),H8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.event(t,this.value)},e}(GN),j8e=function(n){Yr(e,n);function e(){return n!==null&&n.apply(this,arguments)||this}return e.prototype.runIfActive=function(t){this.sink.end(t)},e}(GN),q8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.error(t,this.value)},e}(GN);/** @license MIT License (c) copyright 2010-2017 original author or authors */var Ki=function(){return hee},Ni=function(n){return n===hee},uee=function(n){return n.some(Ni)},X8e=function(){function n(){}return n.prototype.run=function(e,t){return WN(cee(e),t)},n}(),hee=new X8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var F_=function(){return Y8e},K8e=function(){function n(){}return n.prototype.run=function(){return O_()},n}(),Y8e=new K8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var fee=function(n,e){return new Z8e(n,e)},Z8e=function(){function n(e,t){this.time=e,this.value=t}return n.prototype.run=function(e,t){return HI(this.time,U8e(J8e,this.value,e),t)},n}();function J8e(n,e,t){t.event(n,e),t.end(n)}/** @license MIT License (c) copyright 2010-2017 original author or authors */var qD=function(n){return fee(0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var Q8e=function(n){return new eqe(n)},eqe=function(){function n(e){this.period=e}return n.prototype.run=function(e,t){return A8e(this.period,MB(void 0,e),t)},n}(),HN=function(){function n(){this.disposable=void 0,this.disposed=!1}return n.prototype.setDisposable=function(e){if(this.disposable!==void 0)throw new Error("setDisposable called more than once");this.disposable=e,this.disposed&&e.dispose()},n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable!==void 0&&this.disposable.dispose())},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var tqe=Tr(function(n,e){return new Promise(function(t,r){return nqe(n,e,t,r)})});function nqe(n,e,t,r){var s=new HN,i=new rqe(t,r,s);s.setDisposable(n.run(i,e))}var rqe=function(){function n(e,t,r){this._end=e,this._error=t,this._disposable=r,this.active=!0}return n.prototype.event=function(){},n.prototype.end=function(){this.active&&this.dispose(this._error,this._end,void 0)},n.prototype.error=function(e,t){this.dispose(this._error,this._error,t)},n.prototype.dispose=function(e,t,r){this.active=!1,sqe(e,t,r,this._disposable)},n}();function sqe(n,e,t,r){try{r.dispose()}catch(s){n(s);return}e(t)}var dee=function(n,e,t){return t.run(n,e)},w3=function(){function n(e,t){this.sink=t,this.offset=e}return n.prototype.event=function(e,t){this.sink.event(e+this.offset,t)},n.prototype.error=function(e,t){this.sink.error(e+this.offset,t)},n.prototype.end=function(e){this.sink.end(e+this.offset)},n}(),NB=function(n,e){return new iqe(n,e)},iqe=function(){function n(e,t){this.origin=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(oqe(this.origin,e),IB(this.origin,t))},n}(),oqe=function(n,e){return e instanceof w3?new w3(n+e.offset,e.sink):new w3(n,e)},Is=function(){function n(e){this.sink=e}return n.prototype.end=function(e){return this.sink.end(e)},n.prototype.error=function(e,t){return this.sink.error(e,t)},n}();/** @license MIT License (c) copyright 2010 original author or authors */var aqe=function(n,e,t){return Ni(t)?Ki():new lqe(n,e,t)},lqe=function(){function n(e,t,r){this.step=e,this.seed=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new cqe(this.step,this.seed,e),t)},n}(),cqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.step=t,i.seed=r,i}return e.prototype.event=function(t,r){var s=this.step(this.seed,r);this.seed=s.seed,this.sink.event(t,s.value)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var uqe=function(n,e,t){return new hqe(n,e,t)},hqe=function(){function n(e,t,r){this.source=r,this.f=e,this.value=t}return n.prototype.run=function(e,t){var r=WN(MB(this.value,e),t),s=this.source.run(new fqe(this.f,this.value,e),t);return qw(r,s)},n}(),fqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.value=r,i}return e.prototype.event=function(t,r){var s=this.f;this.value=s(this.value,r),this.sink.event(t,this.value)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var pee=function(n,e){return new dqe(n,e)},dqe=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new pqe(this.f,this.source,e,t)},n}(),pqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.f=t,o.scheduler=i,o.active=!0,o.disposable=AB(r.run(o,i)),o}return e.prototype.event=function(t,r){this.active&&this.sink.event(t,r)},e.prototype.end=function(t){this.active&&(yg(t,this.disposable,this.sink),this.startNext(t,this.sink))},e.prototype.startNext=function(t,r){try{this.disposable=this.continue(this.f,t,r)}catch(s){r.error(t,s)}},e.prototype.continue=function(t,r,s){return dee(s,this.scheduler,NB(r,t()))},e.prototype.dispose=function(){return this.active=!1,this.disposable.dispose()},e}(Is);/** @license MIT License (c) copyright 2010-2017 original author or authors */var mqe=function(n,e){return pee(function(){return e},qD(n))};/** @license MIT License (c) copyright 2010-2016 original author or authors */var mee=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new gqe(this.p,e),t)},n.create=function(e,t){return Ni(t)?t:t instanceof n?new n(yqe(t.p,e),t.source):new n(e,t)},n}(),gqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s}return e.prototype.event=function(t,r){var s=this.p;s(r)&&this.sink.event(t,r)},e}(Is),yqe=function(n,e){return function(t){return n(t)&&e(t)}};/** @license MIT License (c) copyright 2010-2016 original author or authors */var bqe=function(){function n(e,t,r){this.p=e,this.f=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new vqe(this.p,this.f,e),t)},n}(),vqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.p=t,i.f=r,i}return e.prototype.event=function(t,r){var s=this.f,i=this.p;i(r)&&this.sink.event(t,s(r))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var _C=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new wqe(this.f,e),t)},n.create=function(e,t){return Ni(t)?Ki():t instanceof n?new n(u8e(e,t.f),t.source):t instanceof mee?new bqe(t.p,e,t.source):new n(e,t)},n}(),wqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(r))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var jN=function(n,e){return _C.create(n,e)},xqe=function(n,e){return jN(function(){return n},e)},_qe=function(n,e){return new Sqe(n,e)},Sqe=function(){function n(e,t){this.source=t,this.f=e}return n.prototype.run=function(e,t){return this.source.run(new Cqe(this.f,e),t)},n}(),Cqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;s(r),this.sink.event(t,r)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var $B=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.index=t,s.active=!0,s.value=void 0,s}return e.prototype.event=function(t,r){this.active&&(this.value=r,this.sink.event(t,this))},e.prototype.end=function(t){this.active&&(this.active=!1,this.sink.event(t,this))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */function gee(n,e){switch(e.length){case 0:return n();case 1:return n(e[0]);case 2:return n(e[0],e[1]);case 3:return n(e[0],e[1],e[2]);case 4:return n(e[0],e[1],e[2],e[3]);case 5:return n(e[0],e[1],e[2],e[3],e[4]);default:return n.apply(void 0,e)}}/** @license MIT License (c) copyright 2010 original author or authors */var yee=function(n,e,t){return kqe(n,[e,t])},kqe=function(n,e){return e.length===0||uee(e)?Ki():e.length===1?jN(n,e[0]):new Tqe(n,e)},Tqe=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Eqe(s,i.length,e,this.f),a=void 0,l=0;l<r;++l)a=i[l]=new $B(l,o),s[l]=this.sources[l].run(a,t);return xC(s)},n}(),Eqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.disposables=t,o.f=i,o.awaiting=r,o.values=new Array(r),o.hasValue=new Array(r).fill(!1),o.activeCount=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=r.index,i=this.updateReady(s);this.values[s]=r.value,i===0&&this.sink.event(t,gee(this.f,this.values))},e.prototype.updateReady=function(t){return this.awaiting>0&&(this.hasValue[t]||(this.hasValue[t]=!0,this.awaiting-=1)),this.awaiting},e.prototype.dispose=function(t,r){yg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */function Iqe(n,e){return yee(h8e,n,e)}/** @license MIT License (c) copyright 2010 original author or authors */var bee=function(n,e){return qN(c8e,n,e)},qN=function(n,e,t){return Ni(t)?Ki():new Aqe(n,e,t)},Aqe=function(){function n(e,t,r){this.f=e,this.concurrency=t,this.source=r}return n.prototype.run=function(e,t){return new Nqe(this.f,this.concurrency,this.source,e,t)},n}(),Mqe=function(n){return n.length>0},Nqe=function(){function n(e,t,r,s,i){this.f=e,this.concurrency=t,this.sink=s,this.scheduler=i,this.pending=[],this.current=[],this.disposable=AB(r.run(this,i)),this.active=!0}return n.prototype.event=function(e,t){this.addInner(e,t)},n.prototype.addInner=function(e,t){this.current.length<this.concurrency?this.startInner(e,t):this.pending.push(t)},n.prototype.startInner=function(e,t){try{this.initInner(e,t)}catch(r){this.error(e,r)}},n.prototype.initInner=function(e,t){var r=new Rqe(e,this,this.sink);r.disposable=$qe(this.f,e,t,r,this.scheduler),this.current.push(r)},n.prototype.end=function(e){this.active=!1,yg(e,this.disposable,this.sink),this.checkEnd(e)},n.prototype.error=function(e,t){this.active=!1,this.sink.error(e,t)},n.prototype.dispose=function(){this.active=!1,this.pending.length=0,this.disposable.dispose(),xC(this.current).dispose()},n.prototype.endInner=function(e,t){var r=this.current.indexOf(t);r>=0&&this.current.splice(r,1),yg(e,t,this);var s=this.pending;Mqe(s)?this.startInner(e,s.shift()):this.checkEnd(e)},n.prototype.checkEnd=function(e){!this.active&&this.current.length===0&&this.sink.end(e)},n}(),$qe=function(n,e,t,r,s){return n(t).run(r,IB(e,s))},Rqe=function(){function n(e,t,r){this.time=e,this.outer=t,this.sink=r,this.disposable=O_()}return n.prototype.event=function(e,t){this.sink.event(e+this.time,t)},n.prototype.end=function(e){this.outer.endInner(e+this.time,this)},n.prototype.error=function(e,t){this.outer.error(e+this.time,t)},n.prototype.dispose=function(){return this.disposable.dispose()},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var Pqe=function(n,e){return qN(n,1/0,e)},vee=function(n){return bee(1/0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var Dqe=function(n,e){return qN(n,1,e)};/** @license MIT License (c) copyright 2010-2016 original author or authors */function Oqe(n,e){return Fqe([n,e])}var Fqe=function(n){return Lqe(zqe(n))},Lqe=function(n){return n.length===0?Ki():n.length===1?n[0]:new wee(UN(Vqe,[],n))},zqe=function(n){return n.filter(Bqe)},Bqe=function(n){return!Ni(n)},Vqe=function(n,e){return n.concat(e instanceof wee?e.sources:e)},wee=function(){function n(e){this.sources=e}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Uqe(s,i,e),a=void 0,l=0;l<r;++l)a=i[l]=new $B(l,o),s[l]=this.sources[l].run(a,t);return xC(s)},n}(),Uqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.disposables=t,i.activeCount=r.length,i}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}this.sink.event(t,r.value)},e.prototype.dispose=function(t,r){yg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Is);/** @license MIT License (c) copyright 2010 original author or authors */var Wqe=function(n,e){return xee(function(t){return t},n,e)},xee=function(n,e,t){return Ni(t)||Ni(e)?Ki():new Gqe(n,e,t)},Gqe=function(){function n(e,t,r){this.f=e,this.values=t,this.sampler=r}return n.prototype.run=function(e,t){var r=new Hqe(this.f,e),s=this.values.run(r.latest,t),i=this.sampler.run(r,t);return qw(i,s)},n}(),Hqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s.latest=new jqe(s),s}return e.prototype.event=function(t,r){if(this.latest.hasValue){var s=this.f;this.sink.event(t,s(this.latest.value,r))}},e}(Is),jqe=function(n){Yr(e,n);function e(t){var r=n.call(this,t)||this;return r.hasValue=!1,r}return e.prototype.event=function(t,r){this.value=r,this.hasValue=!0},e.prototype.end=function(){},e}(Is);/** @license MIT License (c) copyright 2010 original author or authors */var _ee=function(n,e){var t=Math.max(0,n),r=Math.max(t,e);return{min:t,max:r}},qqe=function(n,e){return _ee(n.min+e.min,Math.min(n.max,n.min+e.max))},Xqe=function(n){return n.min>=n.max},Kqe=function(n){return n.min<=0&&n.max===1/0},See=function(n,e){return RB(0,n,e)},Yqe=function(n,e){return RB(n,1/0,e)},RB=function(n,e,t){return PB(_ee(n,e),t)},PB=function(n,e){return Zqe(n,e)?Ki():e instanceof _C?Qqe(n,e):e instanceof Cee?e9e(n,e):Jqe(n,e)},Zqe=function(n,e){return Ni(e)||Xqe(n)},Jqe=function(n,e){return Kqe(n)?e:new Cee(n,e)},Qqe=function(n,e){return _C.create(e.f,PB(n,e.source))},e9e=function(n,e){return PB(qqe(e.bounds,n),e.source)},Cee=function(){function n(e,t){this.source=t,this.bounds=e}return n.prototype.run=function(e,t){var r=new HN,s=new t9e(this.bounds.min,this.bounds.max-this.bounds.min,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),t9e=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.skip=t,o.take=r,o.disposable=i,o}return e.prototype.event=function(t,r){if(this.skip>0){this.skip-=1;return}this.take!==0&&(this.take-=1,this.sink.event(t,r),this.take===0&&(this.disposable.dispose(),this.sink.end(t)))},e}(Is),n9e=function(n,e){return Ni(e)?Ki():new r9e(n,e)},r9e=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){var r=new HN,s=new s9e(this.p,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),s9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.p=t,i.active=!0,i.disposable=s,i}return e.prototype.event=function(t,r){if(this.active){var s=this.p;this.active=s(r),this.active?this.sink.event(t,r):(this.disposable.dispose(),this.sink.end(t))}},e}(Is),i9e=function(n,e){return Ni(e)?Ki():new o9e(n,e)},o9e=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new a9e(this.p,e),t)},n}(),a9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!0,s}return e.prototype.event=function(t,r){if(this.skipping){var s=this.p;if(this.skipping=s(r),this.skipping)return}this.sink.event(t,r)},e}(Is),l9e=function(n,e){return Ni(e)?Ki():new c9e(n,e)},c9e=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new u9e(this.p,e),t)},n}(),u9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!1,s}return e.prototype.event=function(t,r){if(!this.skipping){var s=this.p;this.skipping=s(r),this.sink.event(t,r),this.skipping&&this.sink.end(t)}},e}(Is);/** @license MIT License (c) copyright 2017 original author or authors */var h9e=function(n,e){return kee(f9e,n,e)},kee=function(n,e,t){return Ni(t)||e.length===0?Ki():new d9e(n,e,See(e.length,t))},f9e=function(n){return n},d9e=function(){function n(e,t,r){this.f=e,this.items=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new p9e(this.f,this.items,e),t)},n}(),p9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.items=r,i.index=0,i}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(this.items[this.index],r)),this.index+=1},e}(Is),m9e=2,g9e=1e4,y9e=function(){function n(){this.head=0,this.tail=0,this.capacityMask=3,this.list=new Array(4)}return n.prototype.push=function(e){var t=this.tail;return this.list[t]=e,this.tail=t+1&this.capacityMask,this.tail===this.head&&this.growArray(),this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.shift=function(){var e=this.head;if(e!==this.tail){var t=this.list[e];return this.list[e]=void 0,this.head=e+1&this.capacityMask,e<m9e&&this.tail>g9e&&this.tail<=this.list.length>>>2&&this.shrinkArray(),t}},n.prototype.isEmpty=function(){return this.head===this.tail},n.prototype.length=function(){return this.head===this.tail?0:this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.growArray=function(){this.head&&(this.list=this.copyArray(),this.head=0),this.tail=this.list.length,this.list.length*=2,this.capacityMask=this.capacityMask<<1|1},n.prototype.shrinkArray=function(){this.list.length>>>=1,this.capacityMask>>>=1},n.prototype.copyArray=function(){var e=[],t=this.list,r=t.length,s;for(s=this.head;s<r;s++)e.push(t[s]);for(s=0;s<this.tail;s++)e.push(t[s]);return e},n}();/** @license MIT License (c) copyright 2010 original author or authors */function b9e(n,e,t){return v9e(n,[e,t])}var v9e=function(n,e){return e.length===0||uee(e)?Ki():e.length===1?jN(n,e[0]):new w9e(n,e)},w9e=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Array(r),a=new x9e(this.f,o,i,e),l=void 0,c=0;c<r;++c)o[c]=new y9e,l=i[c]=new $B(c,a),s[c]=this.sources[c].run(l,t);return xC(s)},n}(),x9e=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,i)||this;return o.f=t,o.sinks=s,o.buffers=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=this.buffers,i=s[r.index];if(i.push(r.value),i.length()===1){if(!k9e(s))return;_9e(this.f,t,s,this.sink),C9e(this.buffers,this.sinks)&&this.sink.end(t)}},e.prototype.dispose=function(t,r){var s=this.buffers[r];s.isEmpty()&&this.sink.end(t)},e}(Is),_9e=function(n,e,t,r){return r.event(e,gee(n,i8e(S9e,t)))},S9e=function(n){return n.shift()};function C9e(n,e){for(var t=0,r=n.length;t<r;++t)if(n[t].isEmpty()&&!e[t].active)return!0;return!1}function k9e(n){for(var e=0,t=n.length;e<t;++e)if(n[e].isEmpty())return!1;return!0}/** @license MIT License (c) copyright 2010-2016 original author or authors */var T9e=function(n){return Ni(n)?Ki():new E9e(n)},E9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){var r=new I9e(e,t);return qw(r,this.source.run(r,t))},n}(),I9e=function(){function n(e,t){this.sink=e,this.scheduler=t,this.current=null,this.ended=!1}return n.prototype.event=function(e,t){this.disposeCurrent(e),this.current=new A9e(t,e,1/0,this,this.sink,this.scheduler)},n.prototype.end=function(e){this.ended=!0,this.checkEnd(e)},n.prototype.error=function(e,t){this.ended=!0,this.sink.error(e,t)},n.prototype.dispose=function(){return this.disposeCurrent(BE(this.scheduler))},n.prototype.disposeCurrent=function(e){if(this.current!==null)return this.current.dispose(e)},n.prototype.disposeInner=function(e,t){t.dispose(e),t===this.current&&(this.current=null)},n.prototype.checkEnd=function(e){this.ended&&this.current===null&&this.sink.end(e)},n.prototype.endInner=function(e,t){this.disposeInner(e,t),this.checkEnd(e)},n.prototype.errorInner=function(e,t,r){this.disposeInner(e,r),this.sink.error(e,t)},n}(),A9e=function(){function n(e,t,r,s,i,o){this.min=t,this.max=r,this.outer=s,this.sink=i,this.disposable=e.run(this,IB(t,o))}return n.prototype.event=function(e,t){var r=Math.max(0,e+this.min);r<this.max&&this.sink.event(r,t)},n.prototype.end=function(e){this.outer.endInner(e+this.min,this)},n.prototype.error=function(e,t){this.outer.errorInner(e+this.min,t,this)},n.prototype.dispose=function(e){yg(e,this.disposable,this.sink)},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function M9e(n,e){return mee.create(n,e)}var N9e=function(n){return Tee(P9e,n)},Tee=function(n,e){return Ni(e)?Ki():new $9e(n,e)},$9e=function(){function n(e,t){this.equals=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new R9e(this.equals,e),t)},n}(),R9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.equals=t,s.value=void 0,s.init=!0,s}return e.prototype.event=function(t,r){this.init?(this.init=!1,this.value=r,this.sink.event(t,r)):this.equals(this.value,r)||(this.value=r,this.sink.event(t,r))},e}(Is);function P9e(n,e){return n===e}/** @license MIT License (c) copyright 2010-2016 original author or authors */var Eee=function(n,e){return new O9e(n,e)},Iee=function(n,e){return new F9e(n,e)},D9e=function(n,e){return Eee(vee(n),Iee(n,e))},O9e=function(){function n(e,t){this.maxSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new HN,s=this.source.run(e,t),i=this.maxSignal.run(new B9e(e,r),t);return r.setDisposable(qw(s,i)),r},n}(),F9e=function(){function n(e,t){this.minSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new z9e(this.minSignal,e,t),s=this.source.run(new L9e(r,e),t);return qw(r,s)},n}(),L9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.min=t,s}return e.prototype.event=function(t,r){this.min.allow&&this.sink.event(t,r)},e}(Is),z9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.allow=!1,i.disposable=t.run(i,s),i}return e.prototype.event=function(){this.allow=!0,this.dispose()},e.prototype.end=function(){},e.prototype.dispose=function(){this.disposable.dispose()},e}(Is),B9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,t)||this;return s.disposable=r,s}return e.prototype.event=function(t){this.disposable.dispose(),this.sink.end(t)},e.prototype.end=function(){},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var V9e=function(n,e){return n<=0?e:new U9e(n,e)},U9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){var r=new W9e(this.dt,e,t);return qw(r,this.source.run(r,t))},n}(),W9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.dt=t,i.scheduler=s,i.tasks=[],i}return e.prototype.dispose=function(){this.tasks.forEach(M8e)},e.prototype.event=function(t,r){this.tasks.push(HI(this.dt,MB(r,this.sink),this.scheduler))},e.prototype.end=function(){this.tasks.push(HI(this.dt,cee(this.sink),this.scheduler))},e}(Is);/** @license MIT License (c) copyright 2010-2017 original author or authors */var Aee=function(n,e){return Ni(e)?Ki():e instanceof _C?G9e(n,e):e instanceof XD?H9e(n,e):new XD(n,e)},G9e=function(n,e){return _C.create(e.f,Aee(n,e.source))},H9e=function(n,e){return new XD(Math.max(n,e.period),e.source)},XD=function(){function n(e,t){this.period=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new j9e(this.period,e),t)},n}(),j9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.time=0,s.period=t,s}return e.prototype.event=function(t,r){t>=this.time&&(this.time=t+this.period,this.sink.event(t,r))},e}(Is),q9e=function(n,e){return Ni(e)?Ki():new X9e(n,e)},X9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){return new K9e(this.dt,this.source,e,t)},n}(),K9e=function(){function n(e,t,r,s){this.dt=e,this.sink=r,this.scheduler=s,this.timer=null,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){this.clearTimer(),this.value=t,this.timer=HI(this.dt,new Y9e(this,t),this.scheduler)},n.prototype.handleEventFromTask=function(e,t){this.clearTimer(),this.sink.event(e,t)},n.prototype.end=function(e){this.clearTimer()&&(this.sink.event(e,this.value),this.value=void 0),this.sink.end(e)},n.prototype.error=function(e,t){this.clearTimer(),this.sink.error(e,t)},n.prototype.dispose=function(){this.clearTimer(),this.disposable.dispose()},n.prototype.clearTimer=function(){return this.timer===null?!1:(this.timer.dispose(),this.timer=null,!0)},n}(),Y9e=function(){function n(e,t){this.sink=e,this.value=t}return n.prototype.run=function(e){this.sink.handleEventFromTask(e,this.value)},n.prototype.error=function(e,t){this.sink.error(e,t)},n.prototype.dispose=function(){},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var Z9e=function(n){return Ni(n)?Ki():new J9e(n)},J9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){return this.source.run(new Q9e(e,t),t)},n}(),Q9e=function(){function n(e,t){var r=this;this.eventBound=function(s){return r.sink.event(BE(r.scheduler),s)},this.endBound=function(){return r.sink.end(BE(r.scheduler))},this.errorBound=function(s){return r.sink.error(BE(r.scheduler),s)},this.sink=e,this.scheduler=t,this.queue=Promise.resolve()}return n.prototype.event=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.handlePromise(t)}).catch(this.errorBound)},n.prototype.end=function(){this.queue=this.queue.then(this.endBound).catch(this.errorBound)},n.prototype.error=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.errorBound(t)}).catch(lee)},n.prototype.handlePromise=function(e){return e.then(this.eventBound)},n}(),e7e=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.event=function(e,t){this.active&&this.sink.event(e,t)},n.prototype.end=function(e){this.active&&(this.disable(),this.sink.end(e))},n.prototype.error=function(e,t){this.disable(),this.sink.error(e,t)},n.prototype.disable=function(){return this.active=!1,this.sink},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function Mee(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}function Nee(n,e){try{e.end(n)}catch(t){e.error(n,t)}}/** @license MIT License (c) copyright 2010-2016 original author or authors */var t7e=function(n,e){return Ni(e)?Ki():new s7e(n,e)},n7e=function(n){return new r7e(n)},r7e=function(){function n(e){this.value=e}return n.prototype.run=function(e,t){return WN(W8e(this.value,e),t)},n}(),s7e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new i7e(this.f,this.source,e,t)},n}(),i7e=function(){function n(e,t,r,s){this.f=e,this.sink=new e7e(r),this.scheduler=s,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){Mee(e,t,this.sink)},n.prototype.end=function(e){Nee(e,this.sink)},n.prototype.error=function(e,t){var r=this.sink.disable();yg(e,this.disposable,this.sink),this._startNext(e,t,r)},n.prototype._startNext=function(e,t,r){try{this.disposable=this._continue(this.f,e,t,r)}catch(s){r.error(e,s)}},n.prototype._continue=function(e,t,r,s){return dee(s,this.scheduler,NB(t,e(r)))},n.prototype.dispose=function(){return this.disposable.dispose()},n}(),o7e=function(n){return n instanceof vH||Ni(n)?n:new vH(n)},vH=function(){function n(e){this.source=new a7e(e)}return n.prototype.run=function(e,t){return this.source.run(e,t)},n}(),a7e=function(){function n(e){this.source=e,this.sinks=[],this.disposable=O_()}return n.prototype.run=function(e,t){var r=this.add(e);return r===1&&(this.disposable=this.source.run(this,t)),AB(new l7e(this,e))},n.prototype.dispose=function(){var e=this.disposable;return this.disposable=O_(),e.dispose()},n.prototype.add=function(e){return this.sinks=YQ(e,this.sinks),this.sinks.length},n.prototype.remove=function(e){var t=ZQ(e,this.sinks);return t>=0&&(this.sinks=o8e(t,this.sinks)),this.sinks.length},n.prototype.event=function(e,t){var r=this.sinks;if(r.length===1)return r[0].event(e,t);for(var s=0;s<r.length;++s)Mee(e,t,r[s])},n.prototype.end=function(e){for(var t=this.sinks,r=0;r<t.length;++r)Nee(e,t[r])},n.prototype.error=function(e,t){for(var r=this.sinks,s=0;s<r.length;++s)r[s].error(e,t)},n}(),l7e=function(){function n(e,t){this.source=e,this.sink=t}return n.prototype.dispose=function(){this.source.remove(this.sink)===0&&this.source.dispose()},n}(),c7e=Tr(NB),u7e=Vu(aqe),h7e=Vu(uqe),f7e=Tr(mqe),wH=Tr(jN),d7e=Tr(xqe),xH=Tr(_qe),p7e=Tr(Iqe),m7e=Tr(Pqe),g7e=Tr(pee),y7e=Tr(Dqe),b7e=Tr(bee),v7e=Vu(qN),_H=Tr(Oqe),w7e=Vu(yee),SH=Tr(Wqe),x7e=Vu(xee),_7e=Vu(kee),S7e=Tr(h9e),C7e=Vu(b9e),k7e=Tr(M9e),T7e=Tr(Tee),E7e=Tr(See),I7e=Tr(Yqe),A7e=Vu(RB),M7e=Tr(n9e),N7e=Tr(i9e),$7e=Tr(l9e),CH=Tr(Eee),R7e=Tr(Iee),P7e=Tr(D9e),D7e=Tr(V9e),O7e=Tr(Aee),F7e=Tr(q9e),L7e=Tr(t7e),kH=function(){var n=[];return[function(e){return z7e(n,e)},new B7e(n)]},z7e=function(n,e){return n.forEach(function(t){var r=t.sink,s=t.scheduler;return U7e(s.currentTime(),e,r)})},B7e=function(){function n(e){this.sinks=e}return n.prototype.run=function(e,t){var r={sink:e,scheduler:t};return this.sinks.push(r),new V7e(r,this.sinks)},n}(),V7e=function(){function n(e,t){this.sink=e,this.sinks=t}return n.prototype.dispose=function(){var e=this.sinks.indexOf(this.sink);e>=0&&this.sinks.splice(e,1)},n}();function U7e(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}const W7e=n=>{const e=new Set;do for(const t of Reflect.ownKeys(n))e.add([n,t]);while((n=Reflect.getPrototypeOf(n))&&n!==Object.prototype);return e};function G7e(n,{include:e,exclude:t}={}){const r=s=>{const i=o=>typeof o=="string"?s===o:o.test(s);return e?e.some(i):t?!t.some(i):!0};for(const[s,i]of W7e(n.constructor.prototype)){if(i==="constructor"||!r(i))continue;const o=Reflect.getOwnPropertyDescriptor(s,i);o&&typeof o.value=="function"&&(n[i]=n[i].bind(n))}return n}var KD={exports:{}},H7e=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,j7e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],$ee=function(e){var t=e,r=e.indexOf("["),s=e.indexOf("]");r!=-1&&s!=-1&&(e=e.substring(0,r)+e.substring(r,s).replace(/:/g,";")+e.substring(s,e.length));for(var i=H7e.exec(e||""),o={},a=14;a--;)o[j7e[a]]=i[a]||"";return r!=-1&&s!=-1&&(o.source=t,o.host=o.host.substring(1,o.host.length-1).replace(/;/g,":"),o.authority=o.authority.replace("[","").replace("]","").replace(/;/g,":"),o.ipv6uri=!0),o.pathNames=q7e(o,o.path),o.queryKey=X7e(o,o.query),o};function q7e(n,e){var t=/\/{2,9}/g,r=e.replace(t,"/").split("/");return(e.substr(0,1)=="/"||e.length===0)&&r.splice(0,1),e.substr(e.length-1,1)=="/"&&r.splice(r.length-1,1),r}function X7e(n,e){var t={};return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(r,s,i){s&&(t[s]=i)}),t}var YD={exports:{}},ZD={exports:{}},L_=1e3,z_=L_*60,B_=z_*60,V_=B_*24,K7e=V_*365.25,Y7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return Z7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?Q7e(n):J7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function Z7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*K7e;case"days":case"day":case"d":return t*V_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*B_;case"minutes":case"minute":case"mins":case"min":case"m":return t*z_;case"seconds":case"second":case"secs":case"sec":case"s":return t*L_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function J7e(n){return n>=V_?Math.round(n/V_)+"d":n>=B_?Math.round(n/B_)+"h":n>=z_?Math.round(n/z_)+"m":n>=L_?Math.round(n/L_)+"s":n+"ms"}function Q7e(n){return nT(n,V_,"day")||nT(n,B_,"hour")||nT(n,z_,"minute")||nT(n,L_,"second")||n+" ms"}function nT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=Y7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(ZD,ZD.exports);var eXe=ZD.exports;(function(n,e){e=n.exports=eXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(YD,YD.exports);var XN=YD.exports,tXe=$ee,TH=XN("socket.io-client:url"),nXe=rXe;function rXe(n,e){var t=n;e=e||typeof location<"u"&&location,n==null&&(n=e.protocol+"//"+e.host),typeof n=="string"&&(n.charAt(0)==="/"&&(n.charAt(1)==="/"?n=e.protocol+n:n=e.host+n),/^(https?|wss?):\/\//.test(n)||(TH("protocol-less url %s",n),typeof e<"u"?n=e.protocol+"//"+n:n="https://"+n),TH("parse %s",n),t=tXe(n)),t.port||(/^(http|ws)$/.test(t.protocol)?t.port="80":/^(http|ws)s$/.test(t.protocol)&&(t.port="443")),t.path=t.path||"/";var r=t.host.indexOf(":")!==-1,s=r?"["+t.host+"]":t.host;return t.id=t.protocol+"://"+s+":"+t.port,t.href=t.protocol+"://"+s+(e&&e.port===t.port?"":":"+t.port),t}var KN={},JD={exports:{}},QD={exports:{}},U_=1e3,W_=U_*60,G_=W_*60,H_=G_*24,sXe=H_*365.25,iXe=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return oXe(n);if(t==="number"&&isNaN(n)===!1)return e.long?lXe(n):aXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function oXe(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*sXe;case"days":case"day":case"d":return t*H_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*G_;case"minutes":case"minute":case"mins":case"min":case"m":return t*W_;case"seconds":case"second":case"secs":case"sec":case"s":return t*U_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function aXe(n){return n>=H_?Math.round(n/H_)+"d":n>=G_?Math.round(n/G_)+"h":n>=W_?Math.round(n/W_)+"m":n>=U_?Math.round(n/U_)+"s":n+"ms"}function lXe(n){return rT(n,H_,"day")||rT(n,G_,"hour")||rT(n,W_,"minute")||rT(n,U_,"second")||n+" ms"}function rT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=iXe,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(QD,QD.exports);var cXe=QD.exports;(function(n,e){e=n.exports=cXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(JD,JD.exports);var uXe=JD.exports,Ree={exports:{}};(function(n){n.exports=e;function e(r){if(r)return t(r)}function t(r){for(var s in e.prototype)r[s]=e.prototype[s];return r}e.prototype.on=e.prototype.addEventListener=function(r,s){return this._callbacks=this._callbacks||{},(this._callbacks["$"+r]=this._callbacks["$"+r]||[]).push(s),this},e.prototype.once=function(r,s){function i(){this.off(r,i),s.apply(this,arguments)}return i.fn=s,this.on(r,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(r,s){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var i=this._callbacks["$"+r];if(!i)return this;if(arguments.length==1)return delete this._callbacks["$"+r],this;for(var o,a=0;a<i.length;a++)if(o=i[a],o===s||o.fn===s){i.splice(a,1);break}return i.length===0&&delete this._callbacks["$"+r],this},e.prototype.emit=function(r){this._callbacks=this._callbacks||{};for(var s=new Array(arguments.length-1),i=this._callbacks["$"+r],o=1;o<arguments.length;o++)s[o-1]=arguments[o];if(i){i=i.slice(0);for(var o=0,a=i.length;o<a;++o)i[o].apply(this,s)}return this},e.prototype.listeners=function(r){return this._callbacks=this._callbacks||{},this._callbacks["$"+r]||[]},e.prototype.hasListeners=function(r){return!!this.listeners(r).length}})(Ree);var Xw=Ree.exports,YN={},hXe={}.toString,Pee=Array.isArray||function(n){return hXe.call(n)=="[object Array]"},Dee=mXe,fXe=typeof Buffer=="function"&&typeof Buffer.isBuffer=="function",dXe=typeof ArrayBuffer=="function",pXe=function(n){return typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(n):n.buffer instanceof ArrayBuffer};function mXe(n){return fXe&&Buffer.isBuffer(n)||dXe&&(n instanceof ArrayBuffer||pXe(n))}var DB=Pee,Oee=Dee,Fee=Object.prototype.toString,gXe=typeof Blob=="function"||typeof Blob<"u"&&Fee.call(Blob)==="[object BlobConstructor]",yXe=typeof File=="function"||typeof File<"u"&&Fee.call(File)==="[object FileConstructor]";YN.deconstructPacket=function(n){var e=[],t=n.data,r=n;return r.data=eO(t,e),r.attachments=e.length,{packet:r,buffers:e}};function eO(n,e){if(!n)return n;if(Oee(n)){var t={_placeholder:!0,num:e.length};return e.push(n),t}else if(DB(n)){for(var r=new Array(n.length),s=0;s<n.length;s++)r[s]=eO(n[s],e);return r}else if(typeof n=="object"&&!(n instanceof Date)){var r={};for(var i in n)r[i]=eO(n[i],e);return r}return n}YN.reconstructPacket=function(n,e){return n.data=tO(n.data,e),n.attachments=void 0,n};function tO(n,e){if(!n)return n;if(n&&n._placeholder===!0){var t=typeof n.num=="number"&&n.num>=0&&n.num<e.length;if(t)return e[n.num];throw new Error("illegal attachments")}else if(DB(n))for(var r=0;r<n.length;r++)n[r]=tO(n[r],e);else if(typeof n=="object")for(var s in n)n[s]=tO(n[s],e);return n}YN.removeBlobs=function(n,e){function t(i,o,a){if(!i)return i;if(gXe&&i instanceof Blob||yXe&&i instanceof File){r++;var l=new FileReader;l.onload=function(){a?a[o]=this.result:s=this.result,--r||e(s)},l.readAsArrayBuffer(i)}else if(DB(i))for(var c=0;c<i.length;c++)t(i[c],c,i);else if(typeof i=="object"&&!Oee(i))for(var u in i)t(i[u],u,i)}var r=0,s=n;t(s),r||e(s)};(function(n){var e=uXe("socket.io-parser"),t=Xw,r=YN,s=Pee,i=Dee;n.protocol=4,n.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],n.CONNECT=0,n.DISCONNECT=1,n.EVENT=2,n.ACK=3,n.ERROR=4,n.BINARY_EVENT=5,n.BINARY_ACK=6,n.Encoder=o,n.Decoder=h;function o(){}var a=n.ERROR+'"encode error"';o.prototype.encode=function(g,y){if(e("encoding packet %j",g),n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)u(g,y);else{var b=l(g);y([b])}};function l(g){var y=""+g.type;if((n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)&&(y+=g.attachments+"-"),g.nsp&&g.nsp!=="/"&&(y+=g.nsp+","),g.id!=null&&(y+=g.id),g.data!=null){var b=c(g.data);if(b!==!1)y+=b;else return a}return e("encoded %j as %s",g,y),y}function c(g){try{return JSON.stringify(g)}catch{return!1}}function u(g,y){function b(x){var w=r.deconstructPacket(x),S=l(w.packet),C=w.buffers;C.unshift(S),y(C)}r.removeBlobs(g,b)}function h(){this.reconstructor=null}t(h.prototype),h.prototype.add=function(g){var y;if(typeof g=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");y=f(g),n.BINARY_EVENT===y.type||n.BINARY_ACK===y.type?(this.reconstructor=new p(y),this.reconstructor.reconPack.attachments===0&&this.emit("decoded",y)):this.emit("decoded",y)}else if(i(g)||g.base64)if(this.reconstructor)y=this.reconstructor.takeBinaryData(g),y&&(this.reconstructor=null,this.emit("decoded",y));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+g)};function f(g){var y=0,b={type:Number(g.charAt(0))};if(n.types[b.type]==null)return m("unknown packet type "+b.type);if(n.BINARY_EVENT===b.type||n.BINARY_ACK===b.type){for(var x=y+1;g.charAt(++y)!=="-"&&y!=g.length;);var w=g.substring(x,y);if(w!=Number(w)||g.charAt(y)!=="-")throw new Error("Illegal attachments");b.attachments=Number(w)}if(g.charAt(y+1)==="/"){for(var x=y+1;++y;){var S=g.charAt(y);if(S===","||y===g.length)break}b.nsp=g.substring(x,y)}else b.nsp="/";var C=g.charAt(y+1);if(C!==""&&Number(C)==C){for(var x=y+1;++y;){var S=g.charAt(y);if(S==null||Number(S)!=S){--y;break}if(y===g.length)break}b.id=Number(g.substring(x,y+1))}if(g.charAt(++y)){var k=d(g.substr(y)),A=k!==!1&&(b.type===n.ERROR||s(k));if(A)b.data=k;else return m("invalid payload")}return e("decoded %s as %j",g,b),b}function d(g){try{return JSON.parse(g)}catch{return!1}}h.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()};function p(g){this.reconPack=g,this.buffers=[]}p.prototype.takeBinaryData=function(g){if(this.buffers.push(g),this.buffers.length===this.reconPack.attachments){var y=r.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),y}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]};function m(g){return{type:n.ERROR,data:"parser error: "+g}}})(KN);var OB={exports:{}},ZN={},nO={exports:{}};try{nO.exports=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{nO.exports=!1}var bXe=nO.exports,FB=function(){return typeof self<"u"?self:typeof window<"u"?window:Function("return this")()}(),vXe=bXe,wXe=FB,LB=function(n){var e=n.xdomain,t=n.xscheme,r=n.enablesXDR;try{if(typeof XMLHttpRequest<"u"&&(!e||vXe))return new XMLHttpRequest}catch{}try{if(typeof XDomainRequest<"u"&&!t&&r)return new XDomainRequest}catch{}if(!e)try{return new wXe[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}},zB={exports:{}},Zy={},xXe=Object.keys||function(e){var t=[],r=Object.prototype.hasOwnProperty;for(var s in e)r.call(e,s)&&t.push(s);return t},x3,EH;function _Xe(){if(EH)return x3;EH=1;var n={}.toString;return x3=Array.isArray||function(e){return n.call(e)=="[object Array]"},x3}var _3,IH;function Lee(){if(IH)return _3;IH=1;var n=_Xe(),e=Object.prototype.toString,t=typeof Blob=="function"||typeof Blob<"u"&&e.call(Blob)==="[object BlobConstructor]",r=typeof File=="function"||typeof File<"u"&&e.call(File)==="[object FileConstructor]";_3=s;function s(i){if(!i||typeof i!="object")return!1;if(n(i)){for(var o=0,a=i.length;o<a;o++)if(s(i[o]))return!0;return!1}if(typeof Buffer=="function"&&Buffer.isBuffer&&Buffer.isBuffer(i)||typeof ArrayBuffer=="function"&&i instanceof ArrayBuffer||t&&i instanceof Blob||r&&i instanceof File)return!0;if(i.toJSON&&typeof i.toJSON=="function"&&arguments.length===1)return s(i.toJSON(),!0);for(var l in i)if(Object.prototype.hasOwnProperty.call(i,l)&&s(i[l]))return!0;return!1}return _3}var SXe=function(n,e,t){var r=n.byteLength;if(e=e||0,t=t||r,n.slice)return n.slice(e,t);if(e<0&&(e+=r),t<0&&(t+=r),t>r&&(t=r),e>=r||e>=t||r===0)return new ArrayBuffer(0);for(var s=new Uint8Array(n),i=new Uint8Array(t-e),o=e,a=0;o<t;o++,a++)i[a]=s[o];return i.buffer},CXe=kXe;function kXe(n,e,t){var r=!1;return t=t||TXe,s.count=n,n===0?e():s;function s(i,o){if(s.count<=0)throw new Error("after called too many times");--s.count,i?(r=!0,e(i),e=t):s.count===0&&!r&&e(null,o)}}function TXe(){}/*! https://mths.be/utf8js v2.1.2 by @mathias */var $d=String.fromCharCode;function zee(n){for(var e=[],t=0,r=n.length,s,i;t<r;)s=n.charCodeAt(t++),s>=55296&&s<=56319&&t<r?(i=n.charCodeAt(t++),(i&64512)==56320?e.push(((s&1023)<<10)+(i&1023)+65536):(e.push(s),t--)):e.push(s);return e}function EXe(n){for(var e=n.length,t=-1,r,s="";++t<e;)r=n[t],r>65535&&(r-=65536,s+=$d(r>>>10&1023|55296),r=56320|r&1023),s+=$d(r);return s}function Bee(n,e){if(n>=55296&&n<=57343){if(e)throw Error("Lone surrogate U+"+n.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function S3(n,e){return $d(n>>e&63|128)}function IXe(n,e){if(!(n&4294967168))return $d(n);var t="";return n&4294965248?n&4294901760?n&4292870144||(t=$d(n>>18&7|240),t+=S3(n,12),t+=S3(n,6)):(Bee(n,e)||(n=65533),t=$d(n>>12&15|224),t+=S3(n,6)):t=$d(n>>6&31|192),t+=$d(n&63|128),t}function AXe(n,e){e=e||{};for(var t=e.strict!==!1,r=zee(n),s=r.length,i=-1,o,a="";++i<s;)o=r[i],a+=IXe(o,t);return a}function D0(){if(Od>=qI)throw Error("Invalid byte index");var n=jI[Od]&255;if(Od++,(n&192)==128)return n&63;throw Error("Invalid continuation byte")}function MXe(n){var e,t,r,s,i;if(Od>qI)throw Error("Invalid byte index");if(Od==qI)return!1;if(e=jI[Od]&255,Od++,!(e&128))return e;if((e&224)==192){if(t=D0(),i=(e&31)<<6|t,i>=128)return i;throw Error("Invalid continuation byte")}if((e&240)==224){if(t=D0(),r=D0(),i=(e&15)<<12|t<<6|r,i>=2048)return Bee(i,n)?i:65533;throw Error("Invalid continuation byte")}if((e&248)==240&&(t=D0(),r=D0(),s=D0(),i=(e&7)<<18|t<<12|r<<6|s,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}var jI,qI,Od;function NXe(n,e){e=e||{};var t=e.strict!==!1;jI=zee(n),qI=jI.length,Od=0;for(var r=[],s;(s=MXe(t))!==!1;)r.push(s);return EXe(r)}var $Xe={version:"2.1.2",encode:AXe,decode:NXe},sT={},AH;function RXe(){return AH||(AH=1,function(n){sT.encode=function(e){var t=new Uint8Array(e),r,s=t.length,i="";for(r=0;r<s;r+=3)i+=n[t[r]>>2],i+=n[(t[r]&3)<<4|t[r+1]>>4],i+=n[(t[r+1]&15)<<2|t[r+2]>>6],i+=n[t[r+2]&63];return s%3===2?i=i.substring(0,i.length-1)+"=":s%3===1&&(i=i.substring(0,i.length-2)+"=="),i},sT.decode=function(e){var t=e.length*.75,r=e.length,s,i=0,o,a,l,c;e[e.length-1]==="="&&(t--,e[e.length-2]==="="&&t--);var u=new ArrayBuffer(t),h=new Uint8Array(u);for(s=0;s<r;s+=4)o=n.indexOf(e[s]),a=n.indexOf(e[s+1]),l=n.indexOf(e[s+2]),c=n.indexOf(e[s+3]),h[i++]=o<<2|a>>4,h[i++]=(a&15)<<4|l>>2,h[i++]=(l&3)<<6|c&63;return u}}("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),sT}var C3,MH;function PXe(){if(MH)return C3;MH=1;var n=typeof n<"u"?n:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:typeof MSBlobBuilder<"u"?MSBlobBuilder:typeof MozBlobBuilder<"u"?MozBlobBuilder:!1,e=function(){try{var a=new Blob(["hi"]);return a.size===2}catch{return!1}}(),t=e&&function(){try{var a=new Blob([new Uint8Array([1,2])]);return a.size===2}catch{return!1}}(),r=n&&n.prototype.append&&n.prototype.getBlob;function s(a){return a.map(function(l){if(l.buffer instanceof ArrayBuffer){var c=l.buffer;if(l.byteLength!==c.byteLength){var u=new Uint8Array(l.byteLength);u.set(new Uint8Array(c,l.byteOffset,l.byteLength)),c=u.buffer}return c}return l})}function i(a,l){l=l||{};var c=new n;return s(a).forEach(function(u){c.append(u)}),l.type?c.getBlob(l.type):c.getBlob()}function o(a,l){return new Blob(s(a),l||{})}return typeof Blob<"u"&&(i.prototype=Blob.prototype,o.prototype=Blob.prototype),C3=function(){return e?t?Blob:o:r?i:void 0}(),C3}(function(n){var e=xXe,t=Lee(),r=SXe,s=CXe,i=$Xe,o;typeof ArrayBuffer<"u"&&(o=RXe());var a=typeof navigator<"u"&&/Android/i.test(navigator.userAgent),l=typeof navigator<"u"&&/PhantomJS/i.test(navigator.userAgent),c=a||l;n.protocol=3;var u=n.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},h=e(u),f={type:"error",data:"parser error"},d=PXe();n.encodePacket=function(w,S,C,k){typeof S=="function"&&(k=S,S=!1),typeof C=="function"&&(k=C,C=null);var A=w.data===void 0?void 0:w.data.buffer||w.data;if(typeof ArrayBuffer<"u"&&A instanceof ArrayBuffer)return m(w,S,k);if(typeof d<"u"&&A instanceof d)return y(w,S,k);if(A&&A.base64)return p(w,k);var M=u[w.type];return w.data!==void 0&&(M+=C?i.encode(String(w.data),{strict:!1}):String(w.data)),k(""+M)};function p(w,S){var C="b"+n.packets[w.type]+w.data.data;return S(C)}function m(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=w.data,A=new Uint8Array(k),M=new Uint8Array(1+k.byteLength);M[0]=u[w.type];for(var E=0;E<A.length;E++)M[E+1]=A[E];return C(M.buffer)}function g(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=new FileReader;return k.onload=function(){n.encodePacket({type:w.type,data:k.result},S,!0,C)},k.readAsArrayBuffer(w.data)}function y(w,S,C){if(!S)return n.encodeBase64Packet(w,C);if(c)return g(w,S,C);var k=new Uint8Array(1);k[0]=u[w.type];var A=new d([k.buffer,w.data]);return C(A)}n.encodeBase64Packet=function(w,S){var C="b"+n.packets[w.type];if(typeof d<"u"&&w.data instanceof d){var k=new FileReader;return k.onload=function(){var O=k.result.split(",")[1];S(C+O)},k.readAsDataURL(w.data)}var A;try{A=String.fromCharCode.apply(null,new Uint8Array(w.data))}catch{for(var M=new Uint8Array(w.data),E=new Array(M.length),N=0;N<M.length;N++)E[N]=M[N];A=String.fromCharCode.apply(null,E)}return C+=btoa(A),S(C)},n.decodePacket=function(w,S,C){if(w===void 0)return f;if(typeof w=="string"){if(w.charAt(0)==="b")return n.decodeBase64Packet(w.substr(1),S);if(C&&(w=b(w),w===!1))return f;var A=w.charAt(0);return Number(A)!=A||!h[A]?f:w.length>1?{type:h[A],data:w.substring(1)}:{type:h[A]}}var k=new Uint8Array(w),A=k[0],M=r(w,1);return d&&S==="blob"&&(M=new d([M])),{type:h[A],data:M}};function b(w){try{w=i.decode(w,{strict:!1})}catch{return!1}return w}n.decodeBase64Packet=function(w,S){var C=h[w.charAt(0)];if(!o)return{type:C,data:{base64:!0,data:w.substr(1)}};var k=o.decode(w.substr(1));return S==="blob"&&d&&(k=new d([k])),{type:C,data:k}},n.encodePayload=function(w,S,C){typeof S=="function"&&(C=S,S=null);var k=t(w);if(S&&k)return d&&!c?n.encodePayloadAsBlob(w,C):n.encodePayloadAsArrayBuffer(w,C);if(!w.length)return C("0:");function A(E){return E.length+":"+E}function M(E,N){n.encodePacket(E,k?S:!1,!1,function(O){N(null,A(O))})}x(w,M,function(E,N){return C(N.join(""))})};function x(w,S,C){for(var k=new Array(w.length),A=s(w.length,C),M=function(N,O,R){S(O,function(D,z){k[N]=z,R(D,k)})},E=0;E<w.length;E++)M(E,w[E],A)}n.decodePayload=function(w,S,C){if(typeof w!="string")return n.decodePayloadAsBinary(w,S,C);typeof S=="function"&&(C=S,S=null);var k;if(w==="")return C(f,0,1);for(var A="",M,E,N=0,O=w.length;N<O;N++){var R=w.charAt(N);if(R!==":"){A+=R;continue}if(A===""||A!=(M=Number(A))||(E=w.substr(N+1,M),A!=E.length))return C(f,0,1);if(E.length){if(k=n.decodePacket(E,S,!1),f.type===k.type&&f.data===k.data)return C(f,0,1);var D=C(k,N+M,O);if(D===!1)return}N+=M,A=""}if(A!=="")return C(f,0,1)},n.encodePayloadAsArrayBuffer=function(w,S){if(!w.length)return S(new ArrayBuffer(0));function C(k,A){n.encodePacket(k,!0,!0,function(M){return A(null,M)})}x(w,C,function(k,A){var M=A.reduce(function(O,R){var D;return typeof R=="string"?D=R.length:D=R.byteLength,O+D.toString().length+D+2},0),E=new Uint8Array(M),N=0;return A.forEach(function(O){var R=typeof O=="string",D=O;if(R){for(var X=new Uint8Array(O.length),z=0;z<O.length;z++)X[z]=O.charCodeAt(z);D=X.buffer}R?E[N++]=0:E[N++]=1;for(var B=D.byteLength.toString(),z=0;z<B.length;z++)E[N++]=parseInt(B[z]);E[N++]=255;for(var X=new Uint8Array(D),z=0;z<X.length;z++)E[N++]=X[z]}),S(E.buffer)})},n.encodePayloadAsBlob=function(w,S){function C(k,A){n.encodePacket(k,!0,!0,function(M){var E=new Uint8Array(1);if(E[0]=1,typeof M=="string"){for(var N=new Uint8Array(M.length),O=0;O<M.length;O++)N[O]=M.charCodeAt(O);M=N.buffer,E[0]=0}for(var R=M instanceof ArrayBuffer?M.byteLength:M.size,D=R.toString(),z=new Uint8Array(D.length+1),O=0;O<D.length;O++)z[O]=parseInt(D[O]);if(z[D.length]=255,d){var B=new d([E.buffer,z.buffer,M]);A(null,B)}})}x(w,C,function(k,A){return S(new d(A))})},n.decodePayloadAsBinary=function(w,S,C){typeof S=="function"&&(C=S,S=null);for(var k=w,A=[];k.byteLength>0;){for(var M=new Uint8Array(k),E=M[0]===0,N="",O=1;M[O]!==255;O++){if(N.length>310)return C(f,0,1);N+=M[O]}k=r(k,2+N.length),N=parseInt(N);var R=r(k,0,N);if(E)try{R=String.fromCharCode.apply(null,new Uint8Array(R))}catch{var D=new Uint8Array(R);R="";for(var O=0;O<D.length;O++)R+=String.fromCharCode(D[O])}A.push(R),k=r(k,N)}var z=A.length;A.forEach(function(B,X){C(n.decodePacket(B,S,!0),X,z)})}})(Zy);var k3,NH;function BB(){if(NH)return k3;NH=1;var n=Zy,e=Xw;k3=t;function t(r){this.path=r.path,this.hostname=r.hostname,this.port=r.port,this.secure=r.secure,this.query=r.query,this.timestampParam=r.timestampParam,this.timestampRequests=r.timestampRequests,this.readyState="",this.agent=r.agent||!1,this.socket=r.socket,this.enablesXDR=r.enablesXDR,this.withCredentials=r.withCredentials,this.pfx=r.pfx,this.key=r.key,this.passphrase=r.passphrase,this.cert=r.cert,this.ca=r.ca,this.ciphers=r.ciphers,this.rejectUnauthorized=r.rejectUnauthorized,this.forceNode=r.forceNode,this.isReactNative=r.isReactNative,this.extraHeaders=r.extraHeaders,this.localAddress=r.localAddress}return e(t.prototype),t.prototype.onError=function(r,s){var i=new Error(r);return i.type="TransportError",i.description=s,this.emit("error",i),this},t.prototype.open=function(){return(this.readyState==="closed"||this.readyState==="")&&(this.readyState="opening",this.doOpen()),this},t.prototype.close=function(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this},t.prototype.send=function(r){if(this.readyState==="open")this.write(r);else throw new Error("Transport not open")},t.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},t.prototype.onData=function(r){var s=n.decodePacket(r,this.socket.binaryType);this.onPacket(s)},t.prototype.onPacket=function(r){this.emit("packet",r)},t.prototype.onClose=function(){this.readyState="closed",this.emit("close")},k3}var iT={},$H;function JN(){return $H||($H=1,iT.encode=function(n){var e="";for(var t in n)n.hasOwnProperty(t)&&(e.length&&(e+="&"),e+=encodeURIComponent(t)+"="+encodeURIComponent(n[t]));return e},iT.decode=function(n){for(var e={},t=n.split("&"),r=0,s=t.length;r<s;r++){var i=t[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}),iT}var QN=function(n,e){var t=function(){};t.prototype=e.prototype,n.prototype=new t,n.prototype.constructor=n},Vee="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),XI=64,Uee={},RH=0,Fd=0,PH;function rO(n){var e="";do e=Vee[n%XI]+e,n=Math.floor(n/XI);while(n>0);return e}function DXe(n){var e=0;for(Fd=0;Fd<n.length;Fd++)e=e*XI+Uee[n.charAt(Fd)];return e}function VB(){var n=rO(+new Date);return n!==PH?(RH=0,PH=n):n+"."+rO(RH++)}for(;Fd<XI;Fd++)Uee[Vee[Fd]]=Fd;VB.encode=rO;VB.decode=DXe;var Wee=VB,sO={exports:{}},iO={exports:{}},j_=1e3,q_=j_*60,X_=q_*60,K_=X_*24,OXe=K_*365.25,FXe=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return LXe(n);if(t==="number"&&isNaN(n)===!1)return e.long?BXe(n):zXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function LXe(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*OXe;case"days":case"day":case"d":return t*K_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*X_;case"minutes":case"minute":case"mins":case"min":case"m":return t*q_;case"seconds":case"second":case"secs":case"sec":case"s":return t*j_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function zXe(n){return n>=K_?Math.round(n/K_)+"d":n>=X_?Math.round(n/X_)+"h":n>=q_?Math.round(n/q_)+"m":n>=j_?Math.round(n/j_)+"s":n+"ms"}function BXe(n){return oT(n,K_,"day")||oT(n,X_,"hour")||oT(n,q_,"minute")||oT(n,j_,"second")||n+" ms"}function oT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=FXe,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(iO,iO.exports);var VXe=iO.exports;(function(n,e){e=n.exports=VXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(sO,sO.exports);var e$=sO.exports,Gee=BB(),UXe=JN(),Hee=Zy,WXe=QN,GXe=Wee,au=e$("engine.io-client:polling"),jee=zh,HXe=function(){var n=LB,e=new n({xdomain:!1});return e.responseType!=null}();function zh(n){var e=n&&n.forceBase64;(!HXe||e)&&(this.supportsBinary=!1),Gee.call(this,n)}WXe(zh,Gee);zh.prototype.name="polling";zh.prototype.doOpen=function(){this.poll()};zh.prototype.pause=function(n){var e=this;this.readyState="pausing";function t(){au("paused"),e.readyState="paused",n()}if(this.polling||!this.writable){var r=0;this.polling&&(au("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){au("pre-pause polling complete"),--r||t()})),this.writable||(au("we are currently writing - waiting to pause"),r++,this.once("drain",function(){au("pre-pause writing complete"),--r||t()}))}else t()};zh.prototype.poll=function(){au("polling"),this.polling=!0,this.doPoll(),this.emit("poll")};zh.prototype.onData=function(n){var e=this;au("polling got data %s",n);var t=function(r,s,i){if(e.readyState==="opening"&&r.type==="open"&&e.onOpen(),r.type==="close")return e.onClose(),!1;e.onPacket(r)};Hee.decodePayload(n,this.socket.binaryType,t),this.readyState!=="closed"&&(this.polling=!1,this.emit("pollComplete"),this.readyState==="open"?this.poll():au('ignoring poll - transport state "%s"',this.readyState))};zh.prototype.doClose=function(){var n=this;function e(){au("writing close packet"),n.write([{type:"close"}])}this.readyState==="open"?(au("transport open - closing"),e()):(au("transport not open - deferring close"),this.once("open",e))};zh.prototype.write=function(n){var e=this;this.writable=!1;var t=function(){e.writable=!0,e.emit("drain")};Hee.encodePayload(n,this.supportsBinary,function(r){e.doWrite(r,t)})};zh.prototype.uri=function(){var n=this.query||{},e=this.secure?"https":"http",t="";this.timestampRequests!==!1&&(n[this.timestampParam]=GXe()),!this.supportsBinary&&!n.sid&&(n.b64=1),n=UXe.encode(n),this.port&&(e==="https"&&Number(this.port)!==443||e==="http"&&Number(this.port)!==80)&&(t=":"+this.port),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};var jXe=LB,qee=jee,qXe=Xw,XXe=QN,oO=e$("engine.io-client:polling-xhr"),KXe=FB;zB.exports=Kw;zB.exports.Request=Hi;function DH(){}function Kw(n){if(qee.call(this,n),this.requestTimeout=n.requestTimeout,this.extraHeaders=n.extraHeaders,typeof location<"u"){var e=location.protocol==="https:",t=location.port;t||(t=e?443:80),this.xd=typeof location<"u"&&n.hostname!==location.hostname||t!==n.port,this.xs=n.secure!==e}}XXe(Kw,qee);Kw.prototype.supportsBinary=!0;Kw.prototype.request=function(n){return n=n||{},n.uri=this.uri(),n.xd=this.xd,n.xs=this.xs,n.agent=this.agent||!1,n.supportsBinary=this.supportsBinary,n.enablesXDR=this.enablesXDR,n.withCredentials=this.withCredentials,n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,n.requestTimeout=this.requestTimeout,n.extraHeaders=this.extraHeaders,new Hi(n)};Kw.prototype.doWrite=function(n,e){var t=typeof n!="string"&&n!==void 0,r=this.request({method:"POST",data:n,isBinary:t}),s=this;r.on("success",e),r.on("error",function(i){s.onError("xhr post error",i)}),this.sendXhr=r};Kw.prototype.doPoll=function(){oO("xhr poll");var n=this.request(),e=this;n.on("data",function(t){e.onData(t)}),n.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=n};function Hi(n){this.method=n.method||"GET",this.uri=n.uri,this.xd=!!n.xd,this.xs=!!n.xs,this.async=n.async!==!1,this.data=n.data!==void 0?n.data:null,this.agent=n.agent,this.isBinary=n.isBinary,this.supportsBinary=n.supportsBinary,this.enablesXDR=n.enablesXDR,this.withCredentials=n.withCredentials,this.requestTimeout=n.requestTimeout,this.pfx=n.pfx,this.key=n.key,this.passphrase=n.passphrase,this.cert=n.cert,this.ca=n.ca,this.ciphers=n.ciphers,this.rejectUnauthorized=n.rejectUnauthorized,this.extraHeaders=n.extraHeaders,this.create()}qXe(Hi.prototype);Hi.prototype.create=function(){var n={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new jXe(n),t=this;try{oO("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch{}if(this.method==="POST")try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{e.setRequestHeader("Accept","*/*")}catch{}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){t.onLoad()},e.onerror=function(){t.onError(e.responseText)}):e.onreadystatechange=function(){if(e.readyState===2)try{var s=e.getResponseHeader("Content-Type");(t.supportsBinary&&s==="application/octet-stream"||s==="application/octet-stream; charset=UTF-8")&&(e.responseType="arraybuffer")}catch{}e.readyState===4&&(e.status===200||e.status===1223?t.onLoad():setTimeout(function(){t.onError(typeof e.status=="number"?e.status:0)},0))},oO("xhr data %s",this.data),e.send(this.data)}catch(s){setTimeout(function(){t.onError(s)},0);return}typeof document<"u"&&(this.index=Hi.requestsCount++,Hi.requests[this.index]=this)};Hi.prototype.onSuccess=function(){this.emit("success"),this.cleanup()};Hi.prototype.onData=function(n){this.emit("data",n),this.onSuccess()};Hi.prototype.onError=function(n){this.emit("error",n),this.cleanup(!0)};Hi.prototype.cleanup=function(n){if(!(typeof this.xhr>"u"||this.xhr===null)){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=DH:this.xhr.onreadystatechange=DH,n)try{this.xhr.abort()}catch{}typeof document<"u"&&delete Hi.requests[this.index],this.xhr=null}};Hi.prototype.onLoad=function(){var n;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch{}e==="application/octet-stream"||e==="application/octet-stream; charset=UTF-8"?n=this.xhr.response||this.xhr.responseText:n=this.xhr.responseText}catch(t){this.onError(t)}n!=null&&this.onData(n)};Hi.prototype.hasXDR=function(){return typeof XDomainRequest<"u"&&!this.xs&&this.enablesXDR};Hi.prototype.abort=function(){this.cleanup()};Hi.requestsCount=0;Hi.requests={};if(typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",OH);else if(typeof addEventListener=="function"){var YXe="onpagehide"in KXe?"pagehide":"unload";addEventListener(YXe,OH,!1)}}function OH(){for(var n in Hi.requests)Hi.requests.hasOwnProperty(n)&&Hi.requests[n].abort()}var ZXe=zB.exports,UB=jee,JXe=QN,FH=FB,QXe=Yw,eKe=/\n/g,tKe=/\\n/g,aT;function nKe(){}function Yw(n){UB.call(this,n),this.query=this.query||{},aT||(aT=FH.___eio=FH.___eio||[]),this.index=aT.length;var e=this;aT.push(function(t){e.onData(t)}),this.query.j=this.index,typeof addEventListener=="function"&&addEventListener("beforeunload",function(){e.script&&(e.script.onerror=nKe)},!1)}JXe(Yw,UB);Yw.prototype.supportsBinary=!1;Yw.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),UB.prototype.doClose.call(this)};Yw.prototype.doPoll=function(){var n=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(s){n.onError("jsonp poll error",s)};var t=document.getElementsByTagName("script")[0];t?t.parentNode.insertBefore(e,t):(document.head||document.body).appendChild(e),this.script=e;var r=typeof navigator<"u"&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var s=document.createElement("iframe");document.body.appendChild(s),document.body.removeChild(s)},100)};Yw.prototype.doWrite=function(n,e){var t=this;if(!this.form){var r=document.createElement("form"),s=document.createElement("textarea"),i=this.iframeId="eio_iframe_"+this.index,o;r.className="socketio",r.style.position="absolute",r.style.top="-1000px",r.style.left="-1000px",r.target=i,r.method="POST",r.setAttribute("accept-charset","utf-8"),s.name="d",r.appendChild(s),document.body.appendChild(r),this.form=r,this.area=s}this.form.action=this.uri();function a(){l(),e()}function l(){if(t.iframe)try{t.form.removeChild(t.iframe)}catch(u){t.onError("jsonp polling iframe removal error",u)}try{var c='<iframe src="javascript:0" name="'+t.iframeId+'">';o=document.createElement(c)}catch{o=document.createElement("iframe"),o.name=t.iframeId,o.src="javascript:0"}o.id=t.iframeId,t.form.appendChild(o),t.iframe=o}l(),n=n.replace(tKe,`\\
`),this.area.value=n.replace(eKe,"\\n");try{this.form.submit()}catch{}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){t.iframe.readyState==="complete"&&a()}:this.iframe.onload=a};var WB=BB(),rKe=Zy,sKe=JN(),iKe=QN,oKe=Wee,aKe=e$("engine.io-client:websocket"),KI,GB;typeof WebSocket<"u"?KI=WebSocket:typeof self<"u"&&(KI=self.WebSocket||self.MozWebSocket);if(typeof window>"u")try{GB=HK}catch{}var Rb=KI||GB,lKe=Ic;function Ic(n){var e=n&&n.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=n.perMessageDeflate,this.usingBrowserWebSocket=KI&&!n.forceNode,this.protocols=n.protocols,this.usingBrowserWebSocket||(Rb=GB),WB.call(this,n)}iKe(Ic,WB);Ic.prototype.name="websocket";Ic.prototype.supportsBinary=!0;Ic.prototype.doOpen=function(){if(this.check()){var n=this.uri(),e=this.protocols,t={};this.isReactNative||(t.agent=this.agent,t.perMessageDeflate=this.perMessageDeflate,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized),this.extraHeaders&&(t.headers=this.extraHeaders),this.localAddress&&(t.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new Rb(n,e):new Rb(n):new Rb(n,e,t)}catch(r){return this.emit("error",r)}this.ws.binaryType===void 0&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}};Ic.prototype.addEventListeners=function(){var n=this;this.ws.onopen=function(){n.onOpen()},this.ws.onclose=function(){n.onClose()},this.ws.onmessage=function(e){n.onData(e.data)},this.ws.onerror=function(e){n.onError("websocket error",e)}};Ic.prototype.write=function(n){var e=this;this.writable=!1;for(var t=n.length,r=0,s=t;r<s;r++)(function(o){rKe.encodePacket(o,e.supportsBinary,function(a){if(!e.usingBrowserWebSocket){var l={};if(o.options&&(l.compress=o.options.compress),e.perMessageDeflate){var c=typeof a=="string"?Buffer.byteLength(a):a.length;c<e.perMessageDeflate.threshold&&(l.compress=!1)}}try{e.usingBrowserWebSocket?e.ws.send(a):e.ws.send(a,l)}catch{aKe("websocket closed before onclose event")}--t||i()})})(n[r]);function i(){e.emit("flush"),setTimeout(function(){e.writable=!0,e.emit("drain")},0)}};Ic.prototype.onClose=function(){WB.prototype.onClose.call(this)};Ic.prototype.doClose=function(){typeof this.ws<"u"&&this.ws.close()};Ic.prototype.uri=function(){var n=this.query||{},e=this.secure?"wss":"ws",t="";this.port&&(e==="wss"&&Number(this.port)!==443||e==="ws"&&Number(this.port)!==80)&&(t=":"+this.port),this.timestampRequests&&(n[this.timestampParam]=oKe()),this.supportsBinary||(n.b64=1),n=sKe.encode(n),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};Ic.prototype.check=function(){return!!Rb&&!("__initialize"in Rb&&this.name===Ic.prototype.name)};var cKe=LB,uKe=ZXe,hKe=QXe,fKe=lKe;ZN.polling=dKe;ZN.websocket=fKe;function dKe(n){var e,t=!1,r=!1,s=n.jsonp!==!1;if(typeof location<"u"){var i=location.protocol==="https:",o=location.port;o||(o=i?443:80),t=n.hostname!==location.hostname||o!==n.port,r=n.secure!==i}if(n.xdomain=t,n.xscheme=r,e=new cKe(n),"open"in e&&!n.forceJSONP)return new uKe(n);if(!s)throw new Error("JSONP disabled");return new hKe(n)}var pKe=[].indexOf,Xee=function(n,e){if(pKe)return n.indexOf(e);for(var t=0;t<n.length;++t)if(n[t]===e)return t;return-1},mKe=ZN,gKe=Xw,xi=e$("engine.io-client:socket"),yKe=Xee,Kee=Zy,LH=$ee,bKe=JN(),vKe=mr;function mr(n,e){if(!(this instanceof mr))return new mr(n,e);e=e||{},n&&typeof n=="object"&&(e=n,n=null),n?(n=LH(n),e.hostname=n.host,e.secure=n.protocol==="https"||n.protocol==="wss",e.port=n.port,n.query&&(e.query=n.query)):e.host&&(e.hostname=LH(e.host).host),this.secure=e.secure!=null?e.secure:typeof location<"u"&&location.protocol==="https:",e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=e.port||(typeof location<"u"&&location.port?location.port:this.secure?443:80),this.query=e.query||{},typeof this.query=="string"&&(this.query=bKe.decode(this.query)),this.upgrade=e.upgrade!==!1,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=e.jsonp!==!1,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=e.withCredentials!==!1,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=e.perMessageDeflate!==!1?e.perMessageDeflate||{}:!1,this.perMessageDeflate===!0&&(this.perMessageDeflate={}),this.perMessageDeflate&&this.perMessageDeflate.threshold==null&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||void 0,this.key=e.key||void 0,this.passphrase=e.passphrase||void 0,this.cert=e.cert||void 0,this.ca=e.ca||void 0,this.ciphers=e.ciphers||void 0,this.rejectUnauthorized=e.rejectUnauthorized===void 0?!0:e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative",(typeof self>"u"||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}mr.priorWebsocketSuccess=!1;gKe(mr.prototype);mr.protocol=Kee.protocol;mr.Socket=mr;mr.Transport=BB();mr.transports=ZN;mr.parser=Zy;mr.prototype.createTransport=function(n){xi('creating transport "%s"',n);var e=wKe(this.query);e.EIO=Kee.protocol,e.transport=n;var t=this.transportOptions[n]||{};this.id&&(e.sid=this.id);var r=new mKe[n]({query:e,socket:this,agent:t.agent||this.agent,hostname:t.hostname||this.hostname,port:t.port||this.port,secure:t.secure||this.secure,path:t.path||this.path,forceJSONP:t.forceJSONP||this.forceJSONP,jsonp:t.jsonp||this.jsonp,forceBase64:t.forceBase64||this.forceBase64,enablesXDR:t.enablesXDR||this.enablesXDR,withCredentials:t.withCredentials||this.withCredentials,timestampRequests:t.timestampRequests||this.timestampRequests,timestampParam:t.timestampParam||this.timestampParam,policyPort:t.policyPort||this.policyPort,pfx:t.pfx||this.pfx,key:t.key||this.key,passphrase:t.passphrase||this.passphrase,cert:t.cert||this.cert,ca:t.ca||this.ca,ciphers:t.ciphers||this.ciphers,rejectUnauthorized:t.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:t.perMessageDeflate||this.perMessageDeflate,extraHeaders:t.extraHeaders||this.extraHeaders,forceNode:t.forceNode||this.forceNode,localAddress:t.localAddress||this.localAddress,requestTimeout:t.requestTimeout||this.requestTimeout,protocols:t.protocols||void 0,isReactNative:this.isReactNative});return r};function wKe(n){var e={};for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e}mr.prototype.open=function(){var n;if(this.rememberUpgrade&&mr.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)n="websocket";else if(this.transports.length===0){var e=this;setTimeout(function(){e.emit("error","No transports available")},0);return}else n=this.transports[0];this.readyState="opening";try{n=this.createTransport(n)}catch{this.transports.shift(),this.open();return}n.open(),this.setTransport(n)};mr.prototype.setTransport=function(n){xi("setting transport %s",n.name);var e=this;this.transport&&(xi("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=n,n.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})};mr.prototype.probe=function(n){xi('probing transport "%s"',n);var e=this.createTransport(n,{probe:1}),t=!1,r=this;mr.priorWebsocketSuccess=!1;function s(){if(r.onlyBinaryUpgrades){var h=!this.supportsBinary&&r.transport.supportsBinary;t=t||h}t||(xi('probe transport "%s" opened',n),e.send([{type:"ping",data:"probe"}]),e.once("packet",function(f){if(!t)if(f.type==="pong"&&f.data==="probe"){if(xi('probe transport "%s" pong',n),r.upgrading=!0,r.emit("upgrading",e),!e)return;mr.priorWebsocketSuccess=e.name==="websocket",xi('pausing current transport "%s"',r.transport.name),r.transport.pause(function(){t||r.readyState!=="closed"&&(xi("changing transport and sending upgrade packet"),u(),r.setTransport(e),e.send([{type:"upgrade"}]),r.emit("upgrade",e),e=null,r.upgrading=!1,r.flush())})}else{xi('probe transport "%s" failed',n);var d=new Error("probe error");d.transport=e.name,r.emit("upgradeError",d)}}))}function i(){t||(t=!0,u(),e.close(),e=null)}function o(h){var f=new Error("probe error: "+h);f.transport=e.name,i(),xi('probe transport "%s" failed because of error: %s',n,h),r.emit("upgradeError",f)}function a(){o("transport closed")}function l(){o("socket closed")}function c(h){e&&h.name!==e.name&&(xi('"%s" works - aborting "%s"',h.name,e.name),i())}function u(){e.removeListener("open",s),e.removeListener("error",o),e.removeListener("close",a),r.removeListener("close",l),r.removeListener("upgrading",c)}e.once("open",s),e.once("error",o),e.once("close",a),this.once("close",l),this.once("upgrading",c),e.open()};mr.prototype.onOpen=function(){if(xi("socket open"),this.readyState="open",mr.priorWebsocketSuccess=this.transport.name==="websocket",this.emit("open"),this.flush(),this.readyState==="open"&&this.upgrade&&this.transport.pause){xi("starting upgrade probes");for(var n=0,e=this.upgrades.length;n<e;n++)this.probe(this.upgrades[n])}};mr.prototype.onPacket=function(n){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(xi('socket receive: type "%s", data "%s"',n.type,n.data),this.emit("packet",n),this.emit("heartbeat"),n.type){case"open":this.onHandshake(JSON.parse(n.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=n.data,this.onError(e);break;case"message":this.emit("data",n.data),this.emit("message",n.data);break}else xi('packet received with socket readyState "%s"',this.readyState)};mr.prototype.onHandshake=function(n){this.emit("handshake",n),this.id=n.sid,this.transport.query.sid=n.sid,this.upgrades=this.filterUpgrades(n.upgrades),this.pingInterval=n.pingInterval,this.pingTimeout=n.pingTimeout,this.onOpen(),this.readyState!=="closed"&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))};mr.prototype.onHeartbeat=function(n){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){e.readyState!=="closed"&&e.onClose("ping timeout")},n||e.pingInterval+e.pingTimeout)};mr.prototype.setPing=function(){var n=this;clearTimeout(n.pingIntervalTimer),n.pingIntervalTimer=setTimeout(function(){xi("writing ping packet - expecting pong within %sms",n.pingTimeout),n.ping(),n.onHeartbeat(n.pingTimeout)},n.pingInterval)};mr.prototype.ping=function(){var n=this;this.sendPacket("ping",function(){n.emit("ping")})};mr.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,this.writeBuffer.length===0?this.emit("drain"):this.flush()};mr.prototype.flush=function(){this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(xi("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))};mr.prototype.write=mr.prototype.send=function(n,e,t){return this.sendPacket("message",n,e,t),this};mr.prototype.sendPacket=function(n,e,t,r){if(typeof e=="function"&&(r=e,e=void 0),typeof t=="function"&&(r=t,t=null),!(this.readyState==="closing"||this.readyState==="closed")){t=t||{},t.compress=t.compress!==!1;var s={type:n,data:e,options:t};this.emit("packetCreate",s),this.writeBuffer.push(s),r&&this.once("flush",r),this.flush()}};mr.prototype.close=function(){if(this.readyState==="opening"||this.readyState==="open"){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():e()}):this.upgrading?r():e()}function e(){n.onClose("forced close"),xi("socket closing - telling transport to close"),n.transport.close()}function t(){n.removeListener("upgrade",t),n.removeListener("upgradeError",t),e()}function r(){n.once("upgrade",t),n.once("upgradeError",t)}return this};mr.prototype.onError=function(n){xi("socket error %j",n),mr.priorWebsocketSuccess=!1,this.emit("error",n),this.onClose("transport error",n)};mr.prototype.onClose=function(n,e){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing"){xi('socket close with reason: "%s"',n);var t=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",n,e),t.writeBuffer=[],t.prevBufferLen=0}};mr.prototype.filterUpgrades=function(n){for(var e=[],t=0,r=n.length;t<r;t++)~yKe(this.transports,n[t])&&e.push(n[t]);return e};OB.exports=vKe;OB.exports.parser=Zy;var xKe=OB.exports,T3={exports:{}},E3,zH;function _Ke(){if(zH)return E3;zH=1,E3=n;function n(e,t){var r=[];t=t||0;for(var s=t||0;s<e.length;s++)r[s-t]=e[s];return r}return E3}var Yee=SKe;function SKe(n,e,t){return n.on(e,t),{destroy:function(){n.removeListener(e,t)}}}var BH=[].slice,Zee=function(n,e){if(typeof e=="string"&&(e=n[e]),typeof e!="function")throw new Error("bind() requires a function");var t=BH.call(arguments,2);return function(){return e.apply(n,t.concat(BH.call(arguments)))}},VH;function Jee(){return VH||(VH=1,function(n,e){var t=KN,r=Xw,s=_Ke(),i=Yee,o=Zee,a=XN("socket.io-client:socket"),l=JN(),c=Lee();n.exports=f;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},h=r.prototype.emit;function f(d,p,m){this.io=d,this.nsp=p,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},m&&m.query&&(this.query=m.query),this.io.autoConnect&&this.open()}r(f.prototype),f.prototype.subEvents=function(){if(!this.subs){var d=this.io;this.subs=[i(d,"open",o(this,"onopen")),i(d,"packet",o(this,"onpacket")),i(d,"close",o(this,"onclose"))]}},f.prototype.open=f.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.reconnecting||this.io.open(),this.io.readyState==="open"&&this.onopen(),this.emit("connecting"),this)},f.prototype.send=function(){var d=s(arguments);return d.unshift("message"),this.emit.apply(this,d),this},f.prototype.emit=function(d){if(u.hasOwnProperty(d))return h.apply(this,arguments),this;var p=s(arguments),m={type:(this.flags.binary!==void 0?this.flags.binary:c(p))?t.BINARY_EVENT:t.EVENT,data:p};return m.options={},m.options.compress=!this.flags||this.flags.compress!==!1,typeof p[p.length-1]=="function"&&(a("emitting packet with ack id %d",this.ids),this.acks[this.ids]=p.pop(),m.id=this.ids++),this.connected?this.packet(m):this.sendBuffer.push(m),this.flags={},this},f.prototype.packet=function(d){d.nsp=this.nsp,this.io.packet(d)},f.prototype.onopen=function(){if(a("transport is open - connecting"),this.nsp!=="/")if(this.query){var d=typeof this.query=="object"?l.encode(this.query):this.query;a("sending connect packet with query %s",d),this.packet({type:t.CONNECT,query:d})}else this.packet({type:t.CONNECT})},f.prototype.onclose=function(d){a("close (%s)",d),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",d)},f.prototype.onpacket=function(d){var p=d.nsp===this.nsp,m=d.type===t.ERROR&&d.nsp==="/";if(!(!p&&!m))switch(d.type){case t.CONNECT:this.onconnect();break;case t.EVENT:this.onevent(d);break;case t.BINARY_EVENT:this.onevent(d);break;case t.ACK:this.onack(d);break;case t.BINARY_ACK:this.onack(d);break;case t.DISCONNECT:this.ondisconnect();break;case t.ERROR:this.emit("error",d.data);break}},f.prototype.onevent=function(d){var p=d.data||[];a("emitting event %j",p),d.id!=null&&(a("attaching ack callback to event"),p.push(this.ack(d.id))),this.connected?h.apply(this,p):this.receiveBuffer.push(p)},f.prototype.ack=function(d){var p=this,m=!1;return function(){if(!m){m=!0;var g=s(arguments);a("sending ack %j",g),p.packet({type:c(g)?t.BINARY_ACK:t.ACK,id:d,data:g})}}},f.prototype.onack=function(d){var p=this.acks[d.id];typeof p=="function"?(a("calling ack %s with %j",d.id,d.data),p.apply(this,d.data),delete this.acks[d.id]):a("bad ack %s",d.id)},f.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emit("connect")},f.prototype.emitBuffered=function(){var d;for(d=0;d<this.receiveBuffer.length;d++)h.apply(this,this.receiveBuffer[d]);for(this.receiveBuffer=[],d=0;d<this.sendBuffer.length;d++)this.packet(this.sendBuffer[d]);this.sendBuffer=[]},f.prototype.ondisconnect=function(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},f.prototype.destroy=function(){if(this.subs){for(var d=0;d<this.subs.length;d++)this.subs[d].destroy();this.subs=null}this.io.destroy(this)},f.prototype.close=f.prototype.disconnect=function(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:t.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},f.prototype.compress=function(d){return this.flags.compress=d,this},f.prototype.binary=function(d){return this.flags.binary=d,this}}(T3)),T3.exports}var CKe=Zw;function Zw(n){n=n||{},this.ms=n.min||100,this.max=n.max||1e4,this.factor=n.factor||2,this.jitter=n.jitter>0&&n.jitter<=1?n.jitter:0,this.attempts=0}Zw.prototype.duration=function(){var n=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),t=Math.floor(e*this.jitter*n);n=Math.floor(e*10)&1?n+t:n-t}return Math.min(n,this.max)|0};Zw.prototype.reset=function(){this.attempts=0};Zw.prototype.setMin=function(n){this.ms=n};Zw.prototype.setMax=function(n){this.max=n};Zw.prototype.setJitter=function(n){this.jitter=n};var kKe=xKe,TKe=Jee(),EKe=Xw,IKe=KN,Md=Yee,O0=Zee,Go=XN("socket.io-client:manager"),Qee=Xee,AKe=CKe,ete=Object.prototype.hasOwnProperty,UH=kr;function kr(n,e){if(!(this instanceof kr))return new kr(n,e);n&&typeof n=="object"&&(e=n,n=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new AKe({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(e.timeout==null?2e4:e.timeout),this.readyState="closed",this.uri=n,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var t=e.parser||IKe;this.encoder=new t.Encoder,this.decoder=new t.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}kr.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var n in this.nsps)ete.call(this.nsps,n)&&this.nsps[n].emit.apply(this.nsps[n],arguments)};kr.prototype.updateSocketIds=function(){for(var n in this.nsps)ete.call(this.nsps,n)&&(this.nsps[n].id=this.generateId(n))};kr.prototype.generateId=function(n){return(n==="/"?"":n+"#")+this.engine.id};EKe(kr.prototype);kr.prototype.reconnection=function(n){return arguments.length?(this._reconnection=!!n,this):this._reconnection};kr.prototype.reconnectionAttempts=function(n){return arguments.length?(this._reconnectionAttempts=n,this):this._reconnectionAttempts};kr.prototype.reconnectionDelay=function(n){return arguments.length?(this._reconnectionDelay=n,this.backoff&&this.backoff.setMin(n),this):this._reconnectionDelay};kr.prototype.randomizationFactor=function(n){return arguments.length?(this._randomizationFactor=n,this.backoff&&this.backoff.setJitter(n),this):this._randomizationFactor};kr.prototype.reconnectionDelayMax=function(n){return arguments.length?(this._reconnectionDelayMax=n,this.backoff&&this.backoff.setMax(n),this):this._reconnectionDelayMax};kr.prototype.timeout=function(n){return arguments.length?(this._timeout=n,this):this._timeout};kr.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()};kr.prototype.open=kr.prototype.connect=function(n,e){if(Go("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;Go("opening %s",this.uri),this.engine=kKe(this.uri,this.opts);var t=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var s=Md(t,"open",function(){r.onopen(),n&&n()}),i=Md(t,"error",function(l){if(Go("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",l),n){var c=new Error("Connection error");c.data=l,n(c)}else r.maybeReconnectOnOpen()});if(this._timeout!==!1){var o=this._timeout;Go("connect attempt will timeout after %d",o),o===0&&s.destroy();var a=setTimeout(function(){Go("connect attempt timed out after %d",o),s.destroy(),t.close(),t.emit("error","timeout"),r.emitAll("connect_timeout",o)},o);this.subs.push({destroy:function(){clearTimeout(a)}})}return this.subs.push(s),this.subs.push(i),this};kr.prototype.onopen=function(){Go("open"),this.cleanup(),this.readyState="open",this.emit("open");var n=this.engine;this.subs.push(Md(n,"data",O0(this,"ondata"))),this.subs.push(Md(n,"ping",O0(this,"onping"))),this.subs.push(Md(n,"pong",O0(this,"onpong"))),this.subs.push(Md(n,"error",O0(this,"onerror"))),this.subs.push(Md(n,"close",O0(this,"onclose"))),this.subs.push(Md(this.decoder,"decoded",O0(this,"ondecoded")))};kr.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")};kr.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)};kr.prototype.ondata=function(n){this.decoder.add(n)};kr.prototype.ondecoded=function(n){this.emit("packet",n)};kr.prototype.onerror=function(n){Go("error",n),this.emitAll("error",n)};kr.prototype.socket=function(n,e){var t=this.nsps[n];if(!t){t=new TKe(this,n,e),this.nsps[n]=t;var r=this;t.on("connecting",s),t.on("connect",function(){t.id=r.generateId(n)}),this.autoConnect&&s()}function s(){~Qee(r.connecting,t)||r.connecting.push(t)}return t};kr.prototype.destroy=function(n){var e=Qee(this.connecting,n);~e&&this.connecting.splice(e,1),!this.connecting.length&&this.close()};kr.prototype.packet=function(n){Go("writing packet %j",n);var e=this;n.query&&n.type===0&&(n.nsp+="?"+n.query),e.encoding?e.packetBuffer.push(n):(e.encoding=!0,this.encoder.encode(n,function(t){for(var r=0;r<t.length;r++)e.engine.write(t[r],n.options);e.encoding=!1,e.processPacketQueue()}))};kr.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var n=this.packetBuffer.shift();this.packet(n)}};kr.prototype.cleanup=function(){Go("cleanup");for(var n=this.subs.length,e=0;e<n;e++){var t=this.subs.shift();t.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()};kr.prototype.close=kr.prototype.disconnect=function(){Go("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,this.readyState==="opening"&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()};kr.prototype.onclose=function(n){Go("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",n),this._reconnection&&!this.skipReconnect&&this.reconnect()};kr.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var n=this;if(this.backoff.attempts>=this._reconnectionAttempts)Go("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();Go("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var t=setTimeout(function(){n.skipReconnect||(Go("attempting reconnect"),n.emitAll("reconnect_attempt",n.backoff.attempts),n.emitAll("reconnecting",n.backoff.attempts),!n.skipReconnect&&n.open(function(r){r?(Go("reconnect attempt error"),n.reconnecting=!1,n.reconnect(),n.emitAll("reconnect_error",r.data)):(Go("reconnect success"),n.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(t)}})}};kr.prototype.onreconnect=function(){var n=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",n)};(function(n,e){var t=nXe,r=KN,s=UH,i=XN("socket.io-client");n.exports=e=a;var o=e.managers={};function a(l,c){typeof l=="object"&&(c=l,l=void 0),c=c||{};var u=t(l),h=u.source,f=u.id,d=u.path,p=o[f]&&d in o[f].nsps,m=c.forceNew||c["force new connection"]||c.multiplex===!1||p,g;return m?(i("ignoring socket cache for %s",h),g=s(h,c)):(o[f]||(i("new io instance for %s",h),o[f]=s(h,c)),g=o[f]),u.query&&!c.query&&(c.query=u.query),g.socket(u.path,c)}e.protocol=r.protocol,e.connect=a,e.Manager=UH,e.Socket=Jee()})(KD,KD.exports);var MKe=KD.exports;const NKe=Np(MKe);var aO={exports:{}},t$={},lO={exports:{}},I3,WH;function $Ke(){if(WH)return I3;WH=1;var n=1e3,e=n*60,t=e*60,r=t*24,s=r*7,i=r*365.25;I3=function(u,h){h=h||{};var f=typeof u;if(f==="string"&&u.length>0)return o(u);if(f==="number"&&isFinite(u))return h.long?l(u):a(u);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(u))};function o(u){if(u=String(u),!(u.length>100)){var h=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(u);if(h){var f=parseFloat(h[1]),d=(h[2]||"ms").toLowerCase();switch(d){case"years":case"year":case"yrs":case"yr":case"y":return f*i;case"weeks":case"week":case"w":return f*s;case"days":case"day":case"d":return f*r;case"hours":case"hour":case"hrs":case"hr":case"h":return f*t;case"minutes":case"minute":case"mins":case"min":case"m":return f*e;case"seconds":case"second":case"secs":case"sec":case"s":return f*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return f;default:return}}}}function a(u){var h=Math.abs(u);return h>=r?Math.round(u/r)+"d":h>=t?Math.round(u/t)+"h":h>=e?Math.round(u/e)+"m":h>=n?Math.round(u/n)+"s":u+"ms"}function l(u){var h=Math.abs(u);return h>=r?c(u,h,r,"day"):h>=t?c(u,h,t,"hour"):h>=e?c(u,h,e,"minute"):h>=n?c(u,h,n,"second"):u+" ms"}function c(u,h,f,d){var p=h>=f*1.5;return Math.round(u/f)+" "+d+(p?"s":"")}return I3}function RKe(n){t.debug=t,t.default=t,t.coerce=l,t.disable=i,t.enable=s,t.enabled=o,t.humanize=$Ke(),t.destroy=c,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let f=0;f<u.length;f++)h=(h<<5)-h+u.charCodeAt(f),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,f=null,d,p;function m(...g){if(!m.enabled)return;const y=m,b=Number(new Date),x=b-(h||b);y.diff=x,y.prev=h,y.curr=b,h=b,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let w=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(C,k)=>{if(C==="%%")return"%";w++;const A=t.formatters[k];if(typeof A=="function"){const M=g[w];C=A.call(y,M),g.splice(w,1),w--}return C}),t.formatArgs.call(y,g),(y.log||t.log).apply(y,g)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(d!==t.namespaces&&(d=t.namespaces,p=t.enabled(u)),p),set:g=>{f=g}}),typeof t.init=="function"&&t.init(m),m}function r(u,h){const f=t(this.namespace+(typeof h>"u"?":":h)+u);return f.log=this.log,f}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const f=(typeof u=="string"?u:"").split(/[\s,]+/),d=f.length;for(h=0;h<d;h++)f[h]&&(u=f[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.slice(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,f;for(h=0,f=t.skips.length;h<f;h++)if(t.skips[h].test(u))return!1;for(h=0,f=t.names.length;h<f;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function l(u){return u instanceof Error?u.stack||u.message:u}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var PKe=RKe;(function(n,e){e.formatArgs=r,e.save=s,e.load=i,e.useColors=t,e.storage=o(),e.destroy=(()=>{let l=!1;return()=>{l||(l=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(l){if(l[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+l[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;l.splice(1,0,c,"color: inherit");let u=0,h=0;l[0].replace(/%[a-zA-Z%]/g,f=>{f!=="%%"&&(u++,f==="%c"&&(h=u))}),l.splice(h,0,c)}e.log=console.debug||console.log||(()=>{});function s(l){try{l?e.storage.setItem("debug",l):e.storage.removeItem("debug")}catch{}}function i(){let l;try{l=e.storage.getItem("debug")}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}function o(){try{return localStorage}catch{}}n.exports=PKe(e);const{formatters:a}=n.exports;a.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}}})(lO,lO.exports);var HB=lO.exports;const GH=HB("@feathersjs/errors");function Qn(n,e,t,r,s){n=n||"Error";let i,o,a;n instanceof Error?(o=n.message||"Error",n.errors&&(i=n.errors)):typeof n=="object"?(o=n.message||"Error",s=n):o=n,s&&(a=JSON.parse(JSON.stringify(s)),a.errors?(i=a.errors,delete a.errors):s.errors&&(i=JSON.parse(JSON.stringify(s.errors)))),this.type="FeathersError",this.name=e,this.message=o,this.code=t,this.className=r,this.data=a,this.errors=i||{},GH(`${this.name}(${this.code}): ${this.message}`),GH(this.errors),Error.captureStackTrace?Error.captureStackTrace(this,Qn):this.stack=new Error().stack}function ho(n,e){n.prototype=Object.create(e.prototype),n.prototype.constructor=n}ho(Qn,Error);Object.defineProperty(Qn.prototype,"toJSON",{value:function(){return{name:this.name,message:this.message,code:this.code,className:this.className,data:this.data,errors:this.errors}}});function cO(n,e){Qn.call(this,n,"BadRequest",400,"bad-request",e)}ho(cO,Qn);function uO(n,e){Qn.call(this,n,"NotAuthenticated",401,"not-authenticated",e)}ho(uO,Qn);function hO(n,e){Qn.call(this,n,"PaymentError",402,"payment-error",e)}ho(hO,Qn);function fO(n,e){Qn.call(this,n,"Forbidden",403,"forbidden",e)}ho(fO,Qn);function dO(n,e){Qn.call(this,n,"NotFound",404,"not-found",e)}ho(dO,Qn);function pO(n,e){Qn.call(this,n,"MethodNotAllowed",405,"method-not-allowed",e)}ho(pO,Qn);function mO(n,e){Qn.call(this,n,"NotAcceptable",406,"not-acceptable",e)}ho(mO,Qn);function gO(n,e){Qn.call(this,n,"Timeout",408,"timeout",e)}ho(gO,Qn);function yO(n,e){Qn.call(this,n,"Conflict",409,"conflict",e)}ho(yO,Qn);function bO(n,e){Qn(this,n,"Gone",410,"gone")}ho(bO,Qn);function vO(n,e){Qn.call(this,n,"LengthRequired",411,"length-required",e)}ho(vO,Qn);function wO(n,e){Qn.call(this,n,"Unprocessable",422,"unprocessable",e)}ho(wO,Qn);function xO(n,e){Qn.call(this,n,"TooManyRequests",429,"too-many-requests",e)}ho(xO,Qn);function _O(n,e){Qn.call(this,n,"GeneralError",500,"general-error",e)}ho(_O,Qn);function SO(n,e){Qn.call(this,n,"NotImplemented",501,"not-implemented",e)}ho(SO,Qn);function CO(n,e){Qn.call(this,n,"BadGateway",502,"bad-gateway",e)}ho(CO,Qn);function kO(n,e){Qn.call(this,n,"Unavailable",503,"unavailable",e)}ho(kO,Qn);const tte={FeathersError:Qn,BadRequest:cO,NotAuthenticated:uO,PaymentError:hO,Forbidden:fO,NotFound:dO,MethodNotAllowed:pO,NotAcceptable:mO,Timeout:gO,Conflict:yO,Gone:bO,LengthRequired:vO,Unprocessable:wO,TooManyRequests:xO,GeneralError:_O,NotImplemented:SO,BadGateway:CO,Unavailable:kO,400:cO,401:uO,402:hO,403:fO,404:dO,405:pO,406:mO,408:gO,409:yO,410:bO,411:vO,422:wO,429:xO,500:_O,501:SO,502:CO,503:kO};function DKe(n){if(!n)return n;const e=tte[n.name],t=e?new e(n.message,n.data):new Error(n.message||n);return typeof n=="object"&&Object.assign(t,n),t}var SC=Object.assign({convert:DKe},tte),bg={};Object.defineProperty(bg,"__esModule",{value:!0});bg.StorageWrapper=bg.MemoryStorage=void 0;class OKe{constructor(){this.store={}}getItem(e){return Promise.resolve(this.store[e])}setItem(e,t){return Promise.resolve(this.store[e]=t)}removeItem(e){const t=this.store[e];return delete this.store[e],Promise.resolve(t)}}bg.MemoryStorage=OKe;class FKe{constructor(e){this.storage=e}getItem(e){return Promise.resolve(this.storage.getItem(e))}setItem(e,t){return Promise.resolve(this.storage.setItem(e,t))}removeItem(e){return Promise.resolve(this.storage.removeItem(e))}}bg.StorageWrapper=FKe;Object.defineProperty(t$,"__esModule",{value:!0});t$.AuthenticationClient=void 0;const HH=SC,LKe=bg,jH=(n,e)=>{const t=new RegExp(`(?:&?)${e}=([^&]*)`),r=n.hash?n.hash.match(t):null;if(r!==null){const[,s]=r;return[s,t]}return[null,t]};class zKe{constructor(e,t){const r=e.io||e.primus,s=new LKe.StorageWrapper(e.get("storage")||t.storage);this.app=e,this.options=t,this.authenticated=!1,this.app.set("storage",s),r&&this.handleSocket(r)}get service(){return this.app.service(this.options.path)}get storage(){return this.app.get("storage")}handleSocket(e){const t=this.app.io?"connect":"open",r=this.app.io?"disconnect":"disconnection";e.on(r,()=>{const s=new Promise(i=>e.once(t,o=>i(o))).then(()=>this.authenticated?this.reAuthenticate(!0):null);this.app.set("authentication",s)})}getFromLocation(e){const[t,r]=jH(e,this.options.locationKey);if(t!==null)return e.hash=e.hash.replace(r,""),Promise.resolve(t);const[s,i]=jH(e,this.options.locationErrorKey);return s!==null?(e.hash=e.hash.replace(i,""),Promise.reject(new HH.NotAuthenticated(decodeURIComponent(s)))):Promise.resolve(null)}setAccessToken(e){return this.storage.setItem(this.options.storageKey,e)}getAccessToken(){return this.storage.getItem(this.options.storageKey).then(e=>!e&&typeof window<"u"&&window.location?this.getFromLocation(window.location):e||null)}removeAccessToken(){return this.storage.removeItem(this.options.storageKey)}reset(){return this.app.set("authentication",null),this.authenticated=!1,Promise.resolve(null)}handleError(e,t){if(e.code===401||e.code===403){const r=this.removeAccessToken().then(()=>this.reset());return t==="logout"?r:r.then(()=>Promise.reject(e))}return Promise.reject(e)}reAuthenticate(e=!1,t){const r=this.app.get("authentication");return!r||e===!0?this.getAccessToken().then(s=>{if(!s)throw new HH.NotAuthenticated("No accessToken found in storage");return this.authenticate({strategy:t||this.options.jwtStrategy,accessToken:s})}):r}authenticate(e,t){if(!e)return this.reAuthenticate();const r=this.service.create(e,t).then(s=>{const{accessToken:i}=s;return this.authenticated=!0,this.app.emit("login",s),this.app.emit("authenticated",s),this.setAccessToken(i).then(()=>s)}).catch(s=>this.handleError(s,"authenticate"));return this.app.set("authentication",r),r}logout(){return Promise.resolve(this.app.get("authentication")).then(()=>this.service.remove(null).then(e=>this.removeAccessToken().then(()=>this.reset()).then(()=>(this.app.emit("logout",e),e)))).catch(e=>this.handleError(e,"logout"))}}t$.AuthenticationClient=zKe;var nte={},n$={},Bp={},bi={},jB={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.createSymbol=n.makeUrl=n.isPromise=n._=n.stripSlashes=void 0;function e(i){return i.replace(/^(\/+)|(\/+)$/g,"")}n.stripSlashes=e,n._={each(i,o){i&&typeof i.forEach=="function"?i.forEach(o):n._.isObject(i)&&Object.keys(i).forEach(a=>o(i[a],a))},some(i,o){return Object.keys(i).map(a=>[i[a],a]).some(([a,l])=>o(a,l))},every(i,o){return Object.keys(i).map(a=>[i[a],a]).every(([a,l])=>o(a,l))},keys(i){return Object.keys(i)},values(i){return n._.keys(i).map(o=>i[o])},isMatch(i,o){return n._.keys(o).every(a=>i[a]===o[a])},isEmpty(i){return n._.keys(i).length===0},isObject(i){return typeof i=="object"&&!Array.isArray(i)&&i!==null},isObjectOrArray(i){return typeof i=="object"&&i!==null},extend(i,...o){return Object.assign(i,...o)},omit(i,...o){const a=n._.extend({},i);return o.forEach(l=>delete a[l]),a},pick(i,...o){return o.reduce((a,l)=>(i[l]!==void 0&&(a[l]=i[l]),a),{})},merge(i,o){return n._.isObject(i)&&n._.isObject(o)&&Object.keys(o).forEach(a=>{n._.isObject(o[a])?(i[a]||Object.assign(i,{[a]:{}}),n._.merge(i[a],o[a])):Object.assign(i,{[a]:o[a]})}),i}};function t(i){return n._.isObject(i)&&typeof i.then=="function"}n.isPromise=t;function r(i,o={}){const a=typeof o.get=="function"?o.get.bind(o):()=>{},l=a("env")||"production",c=a("host")||{}.HOST_NAME||"localhost",u=l==="development"||l==="test"||l===void 0?"http":"https",h=a("port")||{}.PORT||3030,f=l==="development"||l==="test"||l===void 0?`:${h}`:"";return i=i||"",`${u}://${c}${f}/${n.stripSlashes(i)}`}n.makeUrl=r;function s(i){return typeof Symbol<"u"?Symbol(i):i}n.createSymbol=s})(jB);Object.defineProperty(bi,"__esModule",{value:!0});bi.enableHooks=bi.processHooks=bi.getHooks=bi.isHookObject=bi.convertHookData=bi.makeArguments=bi.defaultMakeArguments=bi.createHookObject=bi.ACTIVATE_HOOKS=void 0;const rte=jB,{each:TO,pick:BKe}=rte._;bi.ACTIVATE_HOOKS=(0,rte.createSymbol)("__feathersActivateHooks");function VKe(n,e={}){const t={};return Object.defineProperty(t,"toJSON",{value(){return BKe(this,"type","method","path","params","id","data","result","error")}}),Object.assign(t,e,{method:n,get path(){const{app:r,service:s}=e;return!s||!r||!r.services?null:Object.keys(r.services).find(i=>r.services[i]===s)}})}bi.createHookObject=VKe;function ste(n){const e=[];return typeof n.id<"u"&&e.push(n.id),n.data&&e.push(n.data),e.push(n.params||{}),e}bi.defaultMakeArguments=ste;function UKe(n){switch(n.method){case"find":return[n.params];case"get":case"remove":return[n.id,n.params];case"update":case"patch":return[n.id,n.data,n.params];case"create":return[n.data,n.params]}return ste(n)}bi.makeArguments=UKe;function ite(n){let e={};return Array.isArray(n)?e={all:n}:typeof n!="object"?e={all:[n]}:TO(n,function(t,r){e[r]=Array.isArray(t)?t:[t]}),e}bi.convertHookData=ite;function ote(n){return typeof n=="object"&&typeof n.method=="string"&&typeof n.type=="string"}bi.isHookObject=ote;function WKe(n,e,t,r,s=!1){const i=n.__hooks[t][r]||[],o=e.__hooks[t][r]||[];return s?o.concat(i):i.concat(o)}bi.getHooks=WKe;function GKe(n,e){let t=e;const r=i=>{if(i){if(!ote(i))throw new Error(`${t.type} hook for '${t.method}' method returned invalid hook object`);t=i}return t};return n.reduce((i,o)=>{const a=o.bind(this);return i.then(l=>a(l)).then(r)},Promise.resolve(t)).then(()=>t).catch(i=>{throw i.hook=t,i})}bi.processHooks=GKe;function HKe(n,e,t){if(typeof n.hooks=="function")return n;const r={};return t.forEach(s=>{r[s]={}}),Object.defineProperty(n,"__hooks",{configurable:!0,value:r,writable:!0}),Object.assign(n,{hooks(s){return TO(s,(i,o)=>{if(!this.__hooks[o])throw new Error(`'${o}' is not a valid hook type`);const a=ite(i);TO(a,(l,c)=>{if(c!=="all"&&e.indexOf(c)===-1)throw new Error(`'${c}' is not a valid hook method`)}),e.forEach(l=>{const c=this.__hooks[o][l]||(this.__hooks[o][l]=[]);a.all&&c.push.apply(c,a.all),a[l]&&c.push.apply(c,a[l])})}),this}})}bi.enableHooks=HKe;(function(n){var e=pt&&pt.__createBinding||(Object.create?function(o,a,l,c){c===void 0&&(c=l);var u=Object.getOwnPropertyDescriptor(a,l);(!u||("get"in u?!a.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return a[l]}}),Object.defineProperty(o,c,u)}:function(o,a,l,c){c===void 0&&(c=l),o[c]=a[l]}),t=pt&&pt.__setModuleDefault||(Object.create?function(o,a){Object.defineProperty(o,"default",{enumerable:!0,value:a})}:function(o,a){o.default=a}),r=pt&&pt.__importStar||function(o){if(o&&o.__esModule)return o;var a={};if(o!=null)for(var l in o)l!=="default"&&Object.prototype.hasOwnProperty.call(o,l)&&e(a,o,l);return t(a,o),a},s=pt&&pt.__exportStar||function(o,a){for(var l in o)l!=="default"&&!Object.prototype.hasOwnProperty.call(a,l)&&e(a,o,l)};Object.defineProperty(n,"__esModule",{value:!0}),n.hooks=void 0;const i=r(bi);s(jB,n),n.hooks=i})(Bp);Object.defineProperty(n$,"__esModule",{value:!0});n$.authentication=void 0;const jKe=Bp,qKe=()=>n=>{const{app:e,params:t,path:r,method:s,app:{authentication:i}}=n;return(0,jKe.stripSlashes)(i.options.path)===r&&s==="create"?n:Promise.resolve(e.get("authentication")).then(o=>(o&&(n.params=Object.assign({},o,t)),n))};n$.authentication=qKe;var r$={};Object.defineProperty(r$,"__esModule",{value:!0});r$.populateHeader=void 0;const XKe=()=>n=>{const{app:e,params:{accessToken:t}}=n,r=e.authentication;if(e.rest&&t){const{scheme:s,header:i}=r.options,o=`${s} ${t}`;n.params.headers=Object.assign({},{[i]:o},n.params.headers)}return n};r$.populateHeader=XKe;(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.populateHeader=n.authentication=void 0;var e=n$;Object.defineProperty(n,"authentication",{enumerable:!0,get:function(){return e.authentication}});var t=r$;Object.defineProperty(n,"populateHeader",{enumerable:!0,get:function(){return t.populateHeader}})})(nte);(function(n,e){var t=pt&&pt.__createBinding||(Object.create?function(u,h,f,d){d===void 0&&(d=f);var p=Object.getOwnPropertyDescriptor(h,f);(!p||("get"in p?!h.__esModule:p.writable||p.configurable))&&(p={enumerable:!0,get:function(){return h[f]}}),Object.defineProperty(u,d,p)}:function(u,h,f,d){d===void 0&&(d=f),u[d]=h[f]}),r=pt&&pt.__setModuleDefault||(Object.create?function(u,h){Object.defineProperty(u,"default",{enumerable:!0,value:h})}:function(u,h){u.default=h}),s=pt&&pt.__importStar||function(u){if(u&&u.__esModule)return u;var h={};if(u!=null)for(var f in u)f!=="default"&&Object.prototype.hasOwnProperty.call(u,f)&&t(h,u,f);return r(h,u),h};Object.defineProperty(e,"__esModule",{value:!0}),e.defaults=e.defaultStorage=e.hooks=e.MemoryStorage=e.AuthenticationClient=e.getDefaultStorage=void 0;const i=t$;Object.defineProperty(e,"AuthenticationClient",{enumerable:!0,get:function(){return i.AuthenticationClient}});const o=s(nte);e.hooks=o;const a=bg;Object.defineProperty(e,"MemoryStorage",{enumerable:!0,get:function(){return a.MemoryStorage}});const l=()=>{try{return new a.StorageWrapper(window.localStorage)}catch{}return new a.MemoryStorage};e.getDefaultStorage=l,e.defaultStorage=(0,e.getDefaultStorage)(),e.defaults={header:"Authorization",scheme:"Bearer",storageKey:"feathers-jwt",locationKey:"access_token",locationErrorKey:"error",jwtStrategy:"jwt",path:"/authentication",Authentication:i.AuthenticationClient,storage:e.defaultStorage};const c=(u={})=>{const h=Object.assign({},e.defaults,u),{Authentication:f}=h;return d=>{const p=new f(d,h);d.authentication=p,d.authenticate=p.authenticate.bind(p),d.reAuthenticate=p.reAuthenticate.bind(p),d.logout=p.logout.bind(p),d.hooks({before:{all:[o.authentication(),o.populateHeader()]}})}};e.default=c,n.exports=Object.assign(c,n.exports)})(aO,aO.exports);var KKe=aO.exports;const YKe=Np(KKe);var qB={exports:{}},ate={exports:{}};(function(n,e){(function(t,r){n.exports=r()})(pt,function(){var t=typeof Object.getOwnPropertySymbols=="function";function r(s,i,o,a){var l=typeof i=="function",c=function(){var u=this._super;this._super=l?i:s[o];var h=a.apply(this,arguments);return this._super=u,h};return l&&(Object.keys(i).forEach(function(u){c[u]=i[u]}),t&&Object.getOwnPropertySymbols(i).forEach(function(u){c[u]=i[u]})),c}return{create:function(){var s=Object.create(this),i=typeof s.__init=="string"?s.__init:"init";return typeof s[i]=="function"&&s[i].apply(s,arguments),s},mixin:function(s,i){var o=i||this,a=/\b_super\b/,l=Object.getPrototypeOf(o)||o.prototype,c={},u=s,h=function(d){var p=Object.getOwnPropertyDescriptor(u,d);!c[d]&&p&&(c[d]=p)};do Object.getOwnPropertyNames(u).forEach(h),t&&Object.getOwnPropertySymbols(u).forEach(h);while((u=Object.getPrototypeOf(u))&&Object.getPrototypeOf(u));var f=function(d){var p=c[d];typeof p.value=="function"&&a.test(p.value)&&(p.value=r(l,o[d],d,p.value)),Object.defineProperty(o,d,p)};return Object.keys(c).forEach(f),t&&Object.getOwnPropertySymbols(c).forEach(f),o},extend:function(s,i){return this.mixin(s,Object.create(i||this))},proxy:function(s){var i=this[s],o=Array.prototype.slice.call(arguments,1);return o.unshift(this),i.bind.apply(i,o)}}})})(ate);var XB=ate.exports,EO={exports:{}},KB={exports:{}},Pb=typeof Reflect=="object"?Reflect:null,qH=Pb&&typeof Pb.apply=="function"?Pb.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},VE;Pb&&typeof Pb.ownKeys=="function"?VE=Pb.ownKeys:Object.getOwnPropertySymbols?VE=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:VE=function(e){return Object.getOwnPropertyNames(e)};function ZKe(n){console&&console.warn&&console.warn(n)}var lte=Number.isNaN||function(e){return e!==e};function Xr(){Xr.init.call(this)}KB.exports=Xr;KB.exports.once=tYe;Xr.EventEmitter=Xr;Xr.prototype._events=void 0;Xr.prototype._eventsCount=0;Xr.prototype._maxListeners=void 0;var XH=10;function s$(n){if(typeof n!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(Xr,"defaultMaxListeners",{enumerable:!0,get:function(){return XH},set:function(n){if(typeof n!="number"||n<0||lte(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");XH=n}});Xr.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};Xr.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||lte(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function cte(n){return n._maxListeners===void 0?Xr.defaultMaxListeners:n._maxListeners}Xr.prototype.getMaxListeners=function(){return cte(this)};Xr.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var s=e==="error",i=this._events;if(i!==void 0)s=s&&i.error===void 0;else if(!s)return!1;if(s){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var l=i[e];if(l===void 0)return!1;if(typeof l=="function")qH(l,this,t);else for(var c=l.length,u=pte(l,c),r=0;r<c;++r)qH(u[r],this,t);return!0};function ute(n,e,t,r){var s,i,o;if(s$(t),i=n._events,i===void 0?(i=n._events=Object.create(null),n._eventsCount=0):(i.newListener!==void 0&&(n.emit("newListener",e,t.listener?t.listener:t),i=n._events),o=i[e]),o===void 0)o=i[e]=t,++n._eventsCount;else if(typeof o=="function"?o=i[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),s=cte(n),s>0&&o.length>s&&!o.warned){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,ZKe(a)}return n}Xr.prototype.addListener=function(e,t){return ute(this,e,t,!1)};Xr.prototype.on=Xr.prototype.addListener;Xr.prototype.prependListener=function(e,t){return ute(this,e,t,!0)};function JKe(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function hte(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},s=JKe.bind(r);return s.listener=t,r.wrapFn=s,s}Xr.prototype.once=function(e,t){return s$(t),this.on(e,hte(this,e,t)),this};Xr.prototype.prependOnceListener=function(e,t){return s$(t),this.prependListener(e,hte(this,e,t)),this};Xr.prototype.removeListener=function(e,t){var r,s,i,o,a;if(s$(t),s=this._events,s===void 0)return this;if(r=s[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;i===0?r.shift():QKe(r,i),r.length===1&&(s[e]=r[0]),s.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this};Xr.prototype.off=Xr.prototype.removeListener;Xr.prototype.removeAllListeners=function(e){var t,r,s;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var i=Object.keys(r),o;for(s=0;s<i.length;++s)o=i[s],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this};function fte(n,e,t){var r=n._events;if(r===void 0)return[];var s=r[e];return s===void 0?[]:typeof s=="function"?t?[s.listener||s]:[s]:t?eYe(s):pte(s,s.length)}Xr.prototype.listeners=function(e){return fte(this,e,!0)};Xr.prototype.rawListeners=function(e){return fte(this,e,!1)};Xr.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):dte.call(n,e)};Xr.prototype.listenerCount=dte;function dte(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}Xr.prototype.eventNames=function(){return this._eventsCount>0?VE(this._events):[]};function pte(n,e){for(var t=new Array(e),r=0;r<e;++r)t[r]=n[r];return t}function QKe(n,e){for(;e+1<n.length;e++)n[e]=n[e+1];n.pop()}function eYe(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}function tYe(n,e){return new Promise(function(t,r){function s(o){n.removeListener(e,i),r(o)}function i(){typeof n.removeListener=="function"&&n.removeListener("error",s),t([].slice.call(arguments))}mte(n,e,i,{once:!0}),e!=="error"&&nYe(n,s,{once:!0})})}function nYe(n,e,t){typeof n.on=="function"&&mte(n,"error",e,t)}function mte(n,e,t,r){if(typeof n.on=="function")r.once?n.once(e,t):n.on(e,t);else if(typeof n.addEventListener=="function")n.addEventListener(e,function s(i){r.once&&n.removeEventListener(e,s),t(i)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n)}var rYe=KB.exports;(function(n,e){const{EventEmitter:t}=rYe,r=XB,s=e.eventHook=function(){return function(a){const{app:l,service:c}=a,u=a.event===null?a.event:l.eventMappings[a.method],h=c._hookEvents&&c._hookEvents.indexOf(u)!==-1;u&&h&&a.type!=="error"&&(Array.isArray(a.result)?a.result:[a.result]).forEach(d=>c.emit(u,d,a))}},i=e.eventMixin=function(a){if(a._serviceEvents)return;const l=this,c=typeof a.on=="function"&&typeof a.emit=="function";typeof a.mixin=="function"&&!c&&a.mixin(t.prototype),Object.defineProperties(a,{_serviceEvents:{value:Array.isArray(a.events)?a.events.slice():[]},_hookEvents:{value:[]}}),Object.keys(l.eventMappings).forEach(u=>{const h=l.eventMappings[u],f=a._serviceEvents.indexOf(h)!==-1;typeof a[u]=="function"&&!f&&(a._serviceEvents.push(h),a._hookEvents.push(h))})};n.exports=function(){return function(o){Object.assign(o,{eventMappings:{create:"created",update:"updated",remove:"removed",patch:"patched"}}),o.hooks({finally:s()}),r.mixin(t.prototype,o),o.mixins.push(i)}}})(EO,EO.exports);var sYe=EO.exports,IO={exports:{}};const{_:iYe}=Bp,oYe=n=>{const{service:e,method:t}=n,r=e.methods[t];return n.arguments.forEach((s,i)=>{n[r[i]]=s}),n.params||(n.params={}),n},aYe=n=>{const{service:e,method:t,path:r}=n,s=e.methods[t];if(s.includes("id")&&n.id===void 0)throw new Error(`An id must be provided to the '${r}.${t}' method`);if(s.includes("data")&&!iYe.isObjectOrArray(n.data))throw new Error(`A data object must be provided to the '${r}.${t}' method`);return n};var lYe=[oYe,aYe];(function(n,e){const{hooks:t,isPromise:r}=Bp,s=lYe,{createHookObject:i,getHooks:o,processHooks:a,enableHooks:l,ACTIVATE_HOOKS:c}=t,u=function({app:d,service:p,method:m,original:g}){return(y={})=>{const b=d.hookTypes.reduce((x,w)=>{const S=y[w]||[];return x[w]=Array.isArray(S)?S:[S],x},{});return function(...x){const w=x[x.length-1]===!0?x.pop():!1,S=i(m,{type:"before",arguments:x,service:p,app:d});return Promise.resolve(S).then(C=>a.call(p,s.concat(b.before),C)).then(C=>typeof C.result<"u"?C:new Promise(A=>{const M=g||p[m],E=p.methods[m].map(O=>C[O]),N=M.apply(p,E);if(!r(N))throw new Error(`Service method '${C.method}' for '${C.path}' service must return a promise`);A(N)}).then(A=>(C.result=A,C)).catch(A=>{throw A.hook=C,A})).then(C=>{const k=Object.assign({},C,{type:"after"});return a.call(p,b.after,k)}).catch(C=>{const k=Object.assign({},C.hook,{type:"error",original:C.hook,error:C,result:void 0});return a.call(p,b.error,k).catch(A=>Object.assign({},A.hook,{error:A,result:void 0}))}).then(C=>a.call(p,b.finally,C).catch(k=>Object.assign({},k.hook,{error:k,result:void 0}))).then(C=>typeof C.error<"u"&&typeof C.result>"u"?Promise.reject(w?C:C.error):w?C:C.result)}}},h=e.hookMixin=function(d){if(typeof d.hooks=="function")return;d.methods=Object.getOwnPropertyNames(d).filter(y=>typeof d[y]=="function"&&d[y][c]).reduce((y,b)=>(y[b]=d[b][c],y),d.methods||{}),Object.assign(d.methods,{find:["params"],get:["id","params"],create:["data","params"],update:["id","data","params"],patch:["id","data","params"],remove:["id","params"]});const p=this,m=Object.keys(d.methods),g=m.reduce((y,b)=>(typeof d[b]!="function"||(y[b]=function(){const x=this,w=Array.from(arguments),S=x._super.bind(x);return u({app:p,service:x,method:b,original:S})({before:o(p,x,"before",b),after:o(p,x,"after",b,!0),error:o(p,x,"error",b,!0),finally:o(p,x,"finally",b,!0)})(...w)}),y),{});l(d,m,p.hookTypes),d.mixin(g)};n.exports=function(){return function(f){Object.assign(f,{hookTypes:["before","after","error","finally"]}),l(f,f.methods,f.hookTypes),f.mixins.push(h)}},n.exports.withHooks=u,n.exports.ACTIVATE_HOOKS=c,n.exports.activateHooks=function(d){return p=>(Object.defineProperty(p,c,{value:d}),p)}})(IO,IO.exports);var gte=IO.exports,yte="4.5.17";const A3=HB("feathers:application"),{stripSlashes:KH}=Bp,cYe=XB,uYe=sYe,hYe=gte,fYe=yte,YH=cYe.extend({create:null}),dYe={init(){Object.assign(this,{version:fYe,methods:["find","get","create","update","patch","remove"],mixins:[],services:{},providers:[],_setup:!1,settings:{}}),this.configure(hYe()),this.configure(uYe())},get(n){return this.settings[n]},set(n,e){return this.settings[n]=e,this},disable(n){return this.settings[n]=!1,this},disabled(n){return!this.settings[n]},enable(n){return this.settings[n]=!0,this},enabled(n){return!!this.settings[n]},configure(n){return n.call(this,this),this},service(n,e){if(typeof e<"u")throw new Error("Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.");const t=KH(n)||"/",r=this.services.hasOwnProperty(t)?this.services[t]:void 0;return typeof r>"u"&&typeof this.defaultService=="function"?this.use(t,this.defaultService(t)).service(t):r},use(n,e,t={}){if(typeof n!="string")throw new Error(`'${n}' is not a valid service path.`);const r=KH(n)||"/",s=typeof e.service=="function"&&e.services,i=this.methods.concat("setup").some(a=>typeof e[a]=="function");if(s){const a=e;return Object.keys(a.services).forEach(l=>this.use(`${r}/${l}`,a.service(l))),this}if(!i)throw new Error(`Invalid service object passed for path \`${r}\``);const o=YH.isPrototypeOf(e)?e:YH.extend(e);return A3(`Registering new service at \`${r}\``),this.mixins.forEach(a=>a.call(this,o,r,t)),typeof o._setup=="function"&&o._setup(this,r),this.providers.forEach(a=>a.call(this,o,r,t)),this._isSetup&&typeof o.setup=="function"&&(A3(`Setting up service for \`${r}\``),o.setup(this,r)),this.services[r]=o,this},setup(){return Object.keys(this.services).forEach(n=>{const e=this.services[n];A3(`Setting up service for \`${n}\``),typeof e.setup=="function"&&e.setup(this,n)}),this._isSetup=!0,this}};var pYe=dYe;const mYe=XB,gYe=pYe,yYe=yte,{ACTIVATE_HOOKS:bYe,activateHooks:vYe}=gte,wYe=Object.create(null);function CC(){const n=Object.create(wYe);return mYe.mixin(gYe,n),n.init(),n}CC.version=yYe;CC.ACTIVATE_HOOKS=bYe;CC.activateHooks=vYe;qB.exports=CC;qB.exports.default=CC;var xYe=qB.exports;const _Ye=Np(xYe);var YB={exports:{}},i$={},SYe=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(i$,"__esModule",{value:!0});i$.Service=void 0;const CYe=SYe(HB),ZH=SC,bte=(0,CYe.default)("@feathersjs/transport-commons/client"),kYe=["addListener","emit","listenerCount","listeners","on","once","prependListener","prependOnceListener","removeAllListeners","removeListener"],TYe=["eventNames","getMaxListeners","setMaxListeners"],EYe=n=>{TYe.forEach(e=>{n[e]=function(...t){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);return this.connection[e](...t)}}),kYe.forEach(e=>{n[e]=function(t,...r){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);const s=`${this.path} ${t}`;bte(`Calling emitter method ${e} with namespaced event '${s}'`);const i=this.connection[e](s,...r);return i===this.connection?this:i}})};let IYe=class{constructor(e){this.events=e.events,this.path=e.name,this.connection=e.connection,this.method=e.method,this.timeout=e.timeout||5e3,EYe(this)}send(e,...t){return new Promise((r,s)=>{const i=setTimeout(()=>s(new ZH.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${e} on ${this.path}`,{timeout:this.timeout,method:e,path:this.path})),this.timeout);t.unshift(e,this.path),t.push(function(o,a){return o=(0,ZH.convert)(o),clearTimeout(i),o?s(o):r(a)}),bte(`Sending socket.${this.method}`,t),this.connection[this.method](...t)})}find(e={}){return this.send("find",e.query||{})}get(e,t={}){return this.send("get",e,t.query||{})}create(e,t={}){return this.send("create",e,t.query||{})}update(e,t,r={}){return this.send("update",e,t,r.query||{})}patch(e,t,r={}){return this.send("patch",e,t,r.query||{})}remove(e,t={}){return this.send("remove",e,t.query||{})}off(e,...t){if(typeof this.connection.off=="function"){const r=this.connection.off(`${this.path} ${e}`,...t);return r===this.connection?this:r}else if(t.length===0)return this.removeAllListeners(e);return this.removeListener(e,...t)}};i$.Service=IYe;var AYe=i$.Service;const JH=AYe;function vte(n,e){if(!n)throw new Error("Socket.io connection needs to be provided");if(n&&n.io&&n.io.engine&&n.io.engine.transport&&n.io.engine.transport.query&&n.io.engine.transport.query.EIO>3)throw console.error("You are trying to use the Socket.io client version 3 or later with Feathers v4 which only supports Socket.io version 2. Please use socket.io-client version 2 instead."),new Error("socket.io-client must be version 2.x");const t=function(s){const i=Object.keys(this.eventMappings||{}).map(a=>this.eventMappings[a]),o=Object.assign({},e,{events:i,name:s,connection:n,method:"emit"});return new JH(o)},r=function(s){if(typeof s.defaultService=="function")throw new Error("Only one default client provider can be configured");s.io=n,s.defaultService=t};return r.Service=JH,r.service=t,r}YB.exports=vte;YB.exports.default=vte;var MYe=YB.exports;const NYe=Np(MYe);var ZB={exports:{}},wte={},o$={},AO={exports:{}};(function(n,e){Object.defineProperty(e,"__esModule",{value:!0}),e.OPERATORS=e.FILTERS=void 0;const t=Bp,r=SC;function s(u){if(typeof u<"u")return Math.abs(parseInt(u,10))}function i(u,h){if(h&&h.default){const f=typeof u=="number"&&!isNaN(u)?u:h.default,d=typeof h.max=="number"?h.max:Number.MAX_VALUE;return Math.min(f,d)}return u}function o(u){return typeof u!="object"||Array.isArray(u)?u:Object.keys(u).reduce((h,f)=>(h[f]=typeof u[f]=="object"?u[f]:parseInt(u[f],10),h),{})}function a(u,h,f){if(Array.isArray(u))return u.map(d=>a(d,h,f));if(t._.isObject(u)&&u.constructor==={}.constructor){const d={};return t._.each(u,(p,m)=>{if(m[0]==="$"){if(f[m]!==void 0)return;if(!h.includes(m))throw new r.BadRequest(`Invalid query parameter ${m}`,u)}d[m]=a(p,h,f)}),Object.getOwnPropertySymbols(u).forEach(p=>{d[p]=u[p]}),d}return u}function l(u,h,f,d){return Array.isArray(f)?t._.each(f,p=>{h[p]!==void 0&&(u[p]=h[p])}):t._.each(f,(p,m)=>{const g=p(h[m],d);g!==void 0&&(u[m]=g)}),u}e.FILTERS={$sort:u=>o(u),$limit:(u,h)=>i(s(u),h.paginate),$skip:u=>s(u),$select:u=>u},e.OPERATORS=["$in","$nin","$lt","$lte","$gt","$gte","$ne","$or"];function c(u,h={}){const{filters:f={},operators:d=[]}=h,p={};return p.filters=l({},u,e.FILTERS,h),p.filters=l(p.filters,u,f,h),p.query=a(u,e.OPERATORS.concat(d),p.filters),p}e.default=c,n.exports=Object.assign(c,n.exports)})(AO,AO.exports);var xte=AO.exports,$Ye=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(o$,"__esModule",{value:!0});o$.AdapterService=void 0;const M1=SC,RYe=$Ye(xte),F0=(n,e,...t)=>typeof n[e]!="function"?Promise.reject(new M1.NotImplemented(`Method ${e} not available`)):n[e](...t),PYe={find:!0,get:!1,update:!1};let DYe=class{constructor(e){this.options=Object.assign({id:"id",events:[],paginate:{},multi:!1,filters:[],whitelist:[]},e)}get id(){return this.options.id}get events(){return this.options.events}filterQuery(e={},t={}){const r=typeof e.paginate<"u"?e.paginate:this.options.paginate,{query:s={}}=e,i=Object.assign({operators:this.options.whitelist||[],filters:this.options.filters,paginate:r},t),o=(0,RYe.default)(s,i);return Object.assign(o,{paginate:r})}allowsMulti(e){const t=PYe[e];if(typeof t<"u")return t;const r=this.options.multi;return r===!0||r===!1?r:r.includes(e)}find(e){return F0(this,"_find",e)}get(e,t){return F0(this,"_get",e,t)}create(e,t){return Array.isArray(e)&&!this.allowsMulti("create")?Promise.reject(new M1.MethodNotAllowed("Can not create multiple entries")):F0(this,"_create",e,t)}update(e,t,r){return e===null||Array.isArray(t)?Promise.reject(new M1.BadRequest("You can not replace multiple instances. Did you mean 'patch'?")):F0(this,"_update",e,t,r)}patch(e,t,r){return e===null&&!this.allowsMulti("patch")?Promise.reject(new M1.MethodNotAllowed("Can not patch multiple entries")):F0(this,"_patch",e,t,r)}remove(e,t){return e===null&&!this.allowsMulti("remove")?Promise.reject(new M1.MethodNotAllowed("Can not remove multiple entries")):F0(this,"_remove",e,t)}};o$.AdapterService=DYe;var _te={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.sorter=n.compare=n.compareArrays=n.compareNSB=void 0;function e(i,o){return i<o?-1:i>o?1:0}n.compareNSB=e;function t(i,o){let a,l;for(a=0;a<Math.min(i.length,o.length);a+=1)if(l=n.compare(i[a],o[a]),l!==0)return l;return n.compareNSB(i.length,o.length)}n.compareArrays=t;function r(i,o,a=n.compareNSB){const{compareNSB:l,compare:c,compareArrays:u}=n;if(i===void 0)return o===void 0?0:-1;if(o===void 0)return i===void 0?0:1;if(i===null)return o===null?0:-1;if(o===null)return i===null?0:1;if(typeof i=="number")return typeof o=="number"?l(i,o):-1;if(typeof o=="number")return typeof i=="number"?l(i,o):1;if(typeof i=="string")return typeof o=="string"?a(i,o):-1;if(typeof o=="string")return typeof i=="string"?a(i,o):1;if(typeof i=="boolean")return typeof o=="boolean"?l(i,o):-1;if(typeof o=="boolean")return typeof i=="boolean"?l(i,o):1;if(i instanceof Date)return o instanceof Date?l(i.getTime(),o.getTime()):-1;if(o instanceof Date)return i instanceof Date?l(i.getTime(),o.getTime()):1;if(Array.isArray(i))return Array.isArray(o)?u(i,o):-1;if(Array.isArray(o))return Array.isArray(i)?u(i,o):1;const h=Object.keys(i).sort(),f=Object.keys(o).sort();let d=0;for(let p=0;p<Math.min(h.length,f.length);p+=1)if(d=c(i[h[p]],o[f[p]]),d!==0)return d;return l(h.length,f.length)}n.compare=r;function s(i){const o=Object.keys(i).map(a=>{const l=i[a];return{key:a,direction:l}});return function(a,l){let c;for(const u of o)if(c=u.direction*n.compare(a[u.key],l[u.key]),c!==0)return c;return 0}}n.sorter=s})(_te);(function(n){var e=pt&&pt.__createBinding||(Object.create?function(l,c,u,h){h===void 0&&(h=u);var f=Object.getOwnPropertyDescriptor(c,u);(!f||("get"in f?!c.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return c[u]}}),Object.defineProperty(l,h,f)}:function(l,c,u,h){h===void 0&&(h=u),l[h]=c[u]}),t=pt&&pt.__exportStar||function(l,c){for(var u in l)u!=="default"&&!Object.prototype.hasOwnProperty.call(c,u)&&e(c,l,u)},r=pt&&pt.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(n,"__esModule",{value:!0}),n.select=n.OPERATORS=n.FILTERS=n.filterQuery=n.AdapterService=void 0;const s=Bp;var i=o$;Object.defineProperty(n,"AdapterService",{enumerable:!0,get:function(){return i.AdapterService}});var o=xte;Object.defineProperty(n,"filterQuery",{enumerable:!0,get:function(){return r(o).default}}),Object.defineProperty(n,"FILTERS",{enumerable:!0,get:function(){return o.FILTERS}}),Object.defineProperty(n,"OPERATORS",{enumerable:!0,get:function(){return o.OPERATORS}}),t(_te,n);function a(l,...c){const u=l&&l.query&&l.query.$select;Array.isArray(u)&&c.length&&u.push(...c);const h=f=>Array.isArray(u)?s._.pick(f,...u):f;return f=>Array.isArray(f)?f.map(h):h(f)}n.select=a})(wte);function JB(n){var e="[object "+n+"]";return function(t){return Object.prototype.toString.call(t)===e}}var dp=JB("Array"),Ste=JB("Object"),OYe=JB("Function");function xc(n,e){return OYe(n.get)?n.get(e):n[e]}const FYe=n=>(e,t,r,s,i)=>i?!!i.find(([o,a,l])=>n(e,a,l)):n(e,t,r,s),lc=FYe(n=>function(e,t,r,s,i){if(!dp(t)||!t.length)return n(e,t);for(var o=0,a=t.length;o<a;o++)if(n(e,xc(t,o)))return!0;return!1});function Cte(n){return function(e,t,r,s){if(!dp(t)||!t.length)return n(e,t,r,s);for(var i=0,o=t.length;i<o;i++)if(!n(e,xc(t,i),t,s))return!1;return!0}}function hu(n,e,t,r,s){return n.validate(n.options,e,t,r,s)}var YI={$eq:lc(function(n,e){return n(e)}),$ne:Cte(function(n,e){return n(e)}),$gt:lc(function(n,e){return n(e)}),$gte:lc(function(n,e){return n(e)}),$lt:lc(function(n,e){return n(e)}),$lte:lc(function(n,e){return n(e)}),$mod:lc(function(n,e){return n(e)}),$in(n,e){return n(e)},$nin:function(n,e){return n(e)},$not:function(n,e,t,r){return n(e,t,r)},$type:function(n,e){return n(e)},$all:function(n,e,t,r,s){return YI.$and(n,e,t,r,s)},$size:function(n,e){return e?n===e.length:!1},$or:function(n,e,t,r){for(var s=0,i=n.length;s<i;s++)if(hu(xc(n,s),e,t,r))return!0;return!1},$nor:function(n,e,t,r){return!YI.$or(n,e,t,r)},$and:function(n,e,t,r,s){if(s){for(var i=0,o=n.length;i<o;i++)if(!hu(xc(n,i),e,t,r,s))return!1}else for(var i=0,o=n.length;i<o;i++)if(!hu(xc(n,i),e,t,r,s))return!1;return!0},$regex:lc(function(n,e){return typeof e=="string"&&n.test(e)}),$where:function(n,e,t,r){return n.call(e,e,t,r)},$elemMatch:function(n,e,t,r){return dp(e)?!!~LYe(e,n):hu(n,e,t,r)},$exists:function(n,e,t,r){return r.hasOwnProperty(t)===n}},e_={$eq:function(n,e,{comparable:t,compare:r}){return n instanceof RegExp?lc(function(s){return typeof s=="string"&&n.test(s)}):n instanceof Function?lc(n):dp(n)&&!n.length?lc(function(s){return dp(s)&&!s.length}):lc(n===null?function(s){return s==null}:function(s){return r(t(s),t(n))===0})},$gt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>0}},$gte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>=0}},$lt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<0}},$lte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<=0}},$in:function(n,e,t){const{comparable:r}=t;return function(s){if(s instanceof Array){for(var i=s.length;i--;)if(~n.indexOf(r(xc(s,i))))return!0}else{var o=r(s);if(o===s&&typeof s=="object"){for(var i=n.length;i--;)if(String(n[i])===String(s)&&String(s)!=="[object Object]")return!0}if(typeof o>"u"){for(var i=n.length;i--;)if(n[i]==null)return!0}for(var i=n.length;i--;){var a=Tte(xc(n,i),t),l=hu(a,o,i,n);if(l&&String(l)!=="[object Object]"&&String(o)!=="[object Object]")return!0}return!!~n.indexOf(o)}return!1}},$nin:function(n,e,t){const r=e_.$in(n,e,t);return function(s,i,o,a){return!r(s,i,o,a)}},$mod:function(n){return function(e){return e%n[0]==n[1]}},$ne:function(n,e,t){const r=e_.$eq(n,e,t);return Cte(function(s,i,o,a){return!r(s,i,o,a)})},$and:function(n,e,t){return n.map(yb(t))},$all:function(n,e,t){return e_.$and(n,e,t)},$or:function(n,e,t){return n.map(yb(t))},$nor:function(n,e,t){return n.map(yb(t))},$not:function(n,e,t){const r=yb(t)(n);return function(s,i,o){return!hu(r,s,i,o)}},$type:function(n){return function(e,t,r){return e!=null?e instanceof n||e.constructor==n:!1}},$regex:function(n,e){return new RegExp(n,e.$options)},$where:function(n){return typeof n=="string"?new Function("obj","return "+n):n},$elemMatch:function(n,e,t){return yb(t)(n)},$exists:function(n){return!!n}};function LYe(n,e){for(var t=0;t<n.length;t++)if(xc(n,t),hu(e,xc(n,t)))return t;return-1}function UE(n,e){return{options:n,validate:e}}function zYe({keyPath:n,child:e,query:t},r){const s=[];if(MO(r,n,0,r,s),s.length===1){const[i,o,a]=s[0];return hu(e,i,o,a)}return t&&typeof t.$ne<"u",s.map(([i])=>i),hu(e,void 0,void 0,void 0,s)}function MO(n,e,t,r,s){if(t===e.length||n==null){s.push([n,e[t-1],r]);return}var i=xc(e,t);if(dp(n)&&isNaN(Number(i)))for(var o=0,a=n.length;o<a;o++)MO(xc(n,o),e,t,n,s);else MO(xc(n,i),e,t+1,n,s)}function BYe(n,e,t){return UE({keyPath:n,child:e,query:t},zYe)}function VYe(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")}function yb(n){const{comparable:e,expressions:t}=n;var r=function(a){return(!a||!VYe(a))&&(a={$eq:a}),a},s=function(a){a=e(a);var l=[];for(var c in a){var u=a[c];if(c!=="$options"){var h=YI[c]||n&&t&&t[c];if(h)e_[c]&&(u=e_[c](u,a,n)),l.push(UE(e(u),h));else{if(c.charCodeAt(0)===36)throw new Error("Unknown operation "+c);var f=c.split(".");l.push(BYe(f,i(u),u))}}}return l.length===1?l[0]:UE(l,YI.$and)},i=function(a){return a=r(a),UYe(a)?UE(a,ZI):s(a)},o=function(a){return s(r(a))};return o}function ZI(n,e){if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Ste(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var t in n)if(!ZI(n[t],e[t]))return!1;return!0}else if(dp(n)){if(n.length!==e.length)return!1;for(var r=0,s=n.length;r<s;r++)if(!ZI(n[r],e[r]))return!1;return!0}else return n===e}function kte(n,e){if(!Ste(n))return e;for(var t in n)e.push(t),kte(n[t],e);return e}function UYe(n){return kte(n,[]).join(",").search(/[$.]/)===-1}function Tte(n,e){var t=yb(e)(n);return e&&e.select&&(t={options:t,validate:function(r,s,i,o){return hu(r,s&&e.select(s),i,o)}}),t}function WYe(n,e){e=Object.assign({compare:Ete,comparable:QB},e);var t=Tte(n,e);return function(r,s,i){return hu(t,r,s,i)}}function Ete(n,e){if(ZI(n,e))return 0;if(typeof n==typeof e){if(n>e)return 1;if(n<e)return-1}}function QB(n){return n instanceof Date?n.getTime():dp(n)?n.map(QB):n&&typeof n.toJSON=="function"?n.toJSON():n}const GYe=Object.freeze(Object.defineProperty({__proto__:null,comparable:QB,compare:Ete,default:WYe},Symbol.toStringTag,{value:"Module"})),HYe=Gf(GYe),jYe=SC,{_:L0}=Bp,{sorter:qYe,select:XYe,AdapterService:KYe}=wte,YYe=HYe.default,lT=(n,...e)=>XYe(...e)(JSON.parse(JSON.stringify(n)));let Ite=class extends KYe{constructor(e={}){super(L0.extend({id:"id",matcher:YYe,sorter:qYe},e)),this._uId=e.startId||0,this.store=e.store||{}}async getEntries(e={}){const{query:t}=this.filterQuery(e);return this._find(Object.assign({},e,{paginate:!1,query:t}))}async _find(e={}){const{query:t,filters:r,paginate:s}=this.filterQuery(e);let i=L0.values(this.store).filter(this.options.matcher(t));const o=i.length;r.$sort!==void 0&&i.sort(this.options.sorter(r.$sort)),r.$skip!==void 0&&(i=i.slice(r.$skip)),r.$limit!==void 0&&(i=i.slice(0,r.$limit));const a={total:o,limit:r.$limit,skip:r.$skip||0,data:i.map(l=>lT(l,e))};return s&&s.default?a:a.data}async _get(e,t={}){if(e in this.store){const{query:r}=this.filterQuery(t),s=this.store[e];if(this.options.matcher(r)(s))return lT(s,t,this.id)}throw new jYe.NotFound(`No record found for id '${e}'`)}async _create(e,t={}){if(Array.isArray(e))return Promise.all(e.map(o=>this._create(o,t)));const r=e[this.id]||this._uId++,s=L0.extend({},e,{[this.id]:r}),i=this.store[r]=s;return lT(i,t,this.id)}async _update(e,t,r={}){const i=(await this._get(e))[this.id];return e=i==e?i:e,this.store[e]=L0.extend({},t,{[this.id]:e}),this._get(e,r)}async _patch(e,t,r={}){const s=i=>{const o=i[this.id];return this.store[o]=L0.extend(this.store[o],L0.omit(t,this.id)),lT(this.store[o],r,this.id)};return e===null?(await this.getEntries(r)).map(s):s(await this._get(e,r))}async _remove(e,t={}){if(e===null){const s=await this.getEntries(t);return Promise.all(s.map(i=>this._remove(i[this.id],t)))}const r=await this._get(e,t);return delete this.store[e],r}};ZB.exports=n=>new Ite(n);ZB.exports.Service=Ite;var Ate=ZB.exports;const ZYe=Np(Ate);var e4={exports:{}};const{Service:JYe}=Ate,QH=[];class Mte extends JYe{constructor(e={}){if(super(e),this._storageKey=e.name||"feathers",this._storage=e.storage||typeof window<"u"&&window.localStorage,this._throttle=e.throttle||200,this._reuseKeys=e.reuseKeys||!1,this.store=null,!this._storage)throw new Error("The `storage` option needs to be provided");if(QH.indexOf(this._storageKey)===-1)QH.push(this._storageKey);else if(!this._reuseKeys)throw new Error(`The storage name '${this._storageKey}' is already in use by another instance.`);this.ready()}ready(){return this.store?Promise.resolve(this.store):Promise.resolve(this._storage.getItem(this._storageKey)).then(e=>JSON.parse(e||"{}")).then(e=>{const t=Object.keys(e),r=e[t[t.length-1]];return this._uId=t.length&&typeof r[this.id]<"u"?r[this.id]+1:this._uId,this.store=e})}flush(e){return this._timeout||(this._timeout=setTimeout(()=>{this._storage.setItem(this._storageKey,JSON.stringify(this.store)),delete this._timeout},this._throttle)),e}execute(e,...t){return this.ready().then(()=>super[e](...t))}find(...e){return this.execute("find",...e)}get(...e){return this.execute("get",...e)}create(...e){return this.execute("create",...e).then(t=>this.flush(t))}patch(...e){return this.execute("patch",...e).then(t=>this.flush(t))}update(...e){return this.execute("update",...e).then(t=>this.flush(t))}remove(...e){return this.execute("remove",...e).then(t=>this.flush(t))}}e4.exports=function(e){return new Mte(e)};e4.exports.Service=Mte;var QYe=e4.exports;const eZe=Np(QYe);var JI={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */JI.exports;(function(n,e){(function(){var t,r="4.17.21",s=200,i="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",o="Expected a function",a="Invalid `variable` option passed into `_.template`",l="__lodash_hash_undefined__",c=500,u="__lodash_placeholder__",h=1,f=2,d=4,p=1,m=2,g=1,y=2,b=4,x=8,w=16,S=32,C=64,k=128,A=256,M=512,E=30,N="...",O=800,R=16,D=1,z=2,B=3,X=1/0,G=9007199254740991,te=17976931348623157e292,ge=0/0,ae=4294967295,Ne=ae-1,ke=ae>>>1,De=[["ary",k],["bind",g],["bindKey",y],["curry",x],["curryRight",w],["flip",M],["partial",S],["partialRight",C],["rearg",A]],be="[object Arguments]",Xe="[object Array]",Oe="[object AsyncFunction]",it="[object Boolean]",We="[object Date]",dt="[object DOMException]",ct="[object Error]",Ve="[object Function]",ze="[object GeneratorFunction]",Be="[object Map]",ut="[object Number]",Ke="[object Null]",ee="[object Object]",J="[object Promise]",rt="[object Proxy]",Ge="[object RegExp]",ye="[object Set]",Ze="[object String]",yt="[object Symbol]",Ct="[object Undefined]",ft="[object WeakMap]",ce="[object WeakSet]",nt="[object ArrayBuffer]",St="[object DataView]",gt="[object Float32Array]",Gt="[object Float64Array]",Mn="[object Int8Array]",Cr="[object Int16Array]",Bs="[object Int32Array]",As="[object Uint8Array]",Ms="[object Uint8ClampedArray]",Vh="[object Uint16Array]",Ul="[object Uint32Array]",Wl=/\b__p \+= '';/g,go=/\b(__p \+=) '' \+/g,Gl=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Lc=/&(?:amp|lt|gt|quot|#39);/g,zc=/[&<>"']/g,Di=RegExp(Lc.source),Uh=RegExp(zc.source),il=/<%-([\s\S]+?)%>/g,Wh=/<%([\s\S]+?)%>/g,re=/<%=([\s\S]+?)%>/g,Ue=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Fe=/^\w*$/,Je=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,vt=/[\\^$.*+?()[\]{}|]/g,zn=RegExp(vt.source),sn=/^\s+/,Tn=/\s/,En=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Nn=/\{\n\/\* \[wrapped with (.+)\] \*/,er=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,ur=/[()=,{}\[\]\/\s]/,Oi=/\\(\\)?/g,xr=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Zi=/\w*$/,Ar=/^[-+]0x[0-9a-f]+$/i,Io=/^0b[01]+$/i,rs=/^\[object .+?Constructor\]$/,yo=/^0o[0-7]+$/i,Ao=/^(?:0|[1-9]\d*)$/,Ns=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,bo=/($^)/,Gh=/['\n\r\u2028\u2029\\]/g,ol="\\ud800-\\udfff",Ji="\\u0300-\\u036f",Bc="\\ufe20-\\ufe2f",Ma="\\u20d0-\\u20ff",$s=Ji+Bc+Ma,Vc="\\u2700-\\u27bf",Qi="a-z\\xdf-\\xf6\\xf8-\\xff",Vs="\\xac\\xb1\\xd7\\xf7",Hh="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",u0="\\u2000-\\u206f",jh=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",eo="A-Z\\xc0-\\xd6\\xd8-\\xde",qh="\\ufe0e\\ufe0f",rd=Vs+Hh+u0+jh,qu="['’]",sd="["+ol+"]",Xh="["+rd+"]",Hl="["+$s+"]",Zr="\\d+",h0="["+Vc+"]",id="["+Qi+"]",Uc="[^"+ol+rd+Zr+Vc+Qi+eo+"]",Kh="\\ud83c[\\udffb-\\udfff]",f0="(?:"+Hl+"|"+Kh+")",d0="[^"+ol+"]",H="(?:\\ud83c[\\udde6-\\uddff]){2}",Y="[\\ud800-\\udbff][\\udc00-\\udfff]",pe="["+eo+"]",Re="\\u200d",at="(?:"+id+"|"+Uc+")",Vt="(?:"+pe+"|"+Uc+")",$n="(?:"+qu+"(?:d|ll|m|re|s|t|ve))?",Rs="(?:"+qu+"(?:D|LL|M|RE|S|T|VE))?",Us=f0+"?",pi="["+qh+"]?",Na="(?:"+Re+"(?:"+[d0,H,Y].join("|")+")"+pi+Us+")*",xx="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Kp="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",ek=pi+Us+Na,J$="(?:"+[h0,H,Y].join("|")+")"+ek,Q$="(?:"+[d0+Hl+"?",Hl,H,Y,sd].join("|")+")",eR=RegExp(qu,"g"),_x=RegExp(Hl,"g"),p0=RegExp(Kh+"(?="+Kh+")|"+Q$+ek,"g"),tk=RegExp([pe+"?"+id+"+"+$n+"(?="+[Xh,pe,"$"].join("|")+")",Vt+"+"+Rs+"(?="+[Xh,pe+at,"$"].join("|")+")",pe+"?"+at+"+"+$n,pe+"+"+Rs,Kp,xx,Zr,J$].join("|"),"g"),Yp=RegExp("["+Re+ol+$s+qh+"]"),al=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,tR=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],nR=-1,Br={};Br[gt]=Br[Gt]=Br[Mn]=Br[Cr]=Br[Bs]=Br[As]=Br[Ms]=Br[Vh]=Br[Ul]=!0,Br[be]=Br[Xe]=Br[nt]=Br[it]=Br[St]=Br[We]=Br[ct]=Br[Ve]=Br[Be]=Br[ut]=Br[ee]=Br[Ge]=Br[ye]=Br[Ze]=Br[ft]=!1;var Rr={};Rr[be]=Rr[Xe]=Rr[nt]=Rr[St]=Rr[it]=Rr[We]=Rr[gt]=Rr[Gt]=Rr[Mn]=Rr[Cr]=Rr[Bs]=Rr[Be]=Rr[ut]=Rr[ee]=Rr[Ge]=Rr[ye]=Rr[Ze]=Rr[yt]=Rr[As]=Rr[Ms]=Rr[Vh]=Rr[Ul]=!0,Rr[ct]=Rr[Ve]=Rr[ft]=!1;var Sx={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},Cx={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},od={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},nk={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},kx=parseFloat,rR=parseInt,rk=typeof pt=="object"&&pt&&pt.Object===Object&&pt,Zp=typeof self=="object"&&self&&self.Object===Object&&self,mi=rk||Zp||Function("return this")(),m0=e&&!e.nodeType&&e,Yh=m0&&!0&&n&&!n.nodeType&&n,sk=Yh&&Yh.exports===m0,ad=sk&&rk.process,oa=function(){try{var Ae=Yh&&Yh.require&&Yh.require("util").types;return Ae||ad&&ad.binding&&ad.binding("util")}catch{}}(),ik=oa&&oa.isArrayBuffer,Tx=oa&&oa.isDate,ok=oa&&oa.isMap,ak=oa&&oa.isRegExp,g0=oa&&oa.isSet,y0=oa&&oa.isTypedArray;function Mo(Ae,je,Le){switch(Le.length){case 0:return Ae.call(je);case 1:return Ae.call(je,Le[0]);case 2:return Ae.call(je,Le[0],Le[1]);case 3:return Ae.call(je,Le[0],Le[1],Le[2])}return Ae.apply(je,Le)}function sR(Ae,je,Le,jt){for(var Pn=-1,Er=Ae==null?0:Ae.length;++Pn<Er;){var Li=Ae[Pn];je(jt,Li,Le(Li),Ae)}return jt}function $a(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function iR(Ae,je){for(var Le=Ae==null?0:Ae.length;Le--&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function lk(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(!je(Ae[Le],Le,Ae))return!1;return!0}function Wc(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Pn=0,Er=[];++Le<jt;){var Li=Ae[Le];je(Li,Le,Ae)&&(Er[Pn++]=Li)}return Er}function b0(Ae,je){var Le=Ae==null?0:Ae.length;return!!Le&&T(Ae,je,0)>-1}function Ex(Ae,je,Le){for(var jt=-1,Pn=Ae==null?0:Ae.length;++jt<Pn;)if(Le(je,Ae[jt]))return!0;return!1}function Vr(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Pn=Array(jt);++Le<jt;)Pn[Le]=je(Ae[Le],Le,Ae);return Pn}function Xu(Ae,je){for(var Le=-1,jt=je.length,Pn=Ae.length;++Le<jt;)Ae[Pn+Le]=je[Le];return Ae}function Ix(Ae,je,Le,jt){var Pn=-1,Er=Ae==null?0:Ae.length;for(jt&&Er&&(Le=Ae[++Pn]);++Pn<Er;)Le=je(Le,Ae[Pn],Pn,Ae);return Le}function oR(Ae,je,Le,jt){var Pn=Ae==null?0:Ae.length;for(jt&&Pn&&(Le=Ae[--Pn]);Pn--;)Le=je(Le,Ae[Pn],Pn,Ae);return Le}function ld(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(je(Ae[Le],Le,Ae))return!0;return!1}var aR=ne("length");function lR(Ae){return Ae.split("")}function cR(Ae){return Ae.match(_n)||[]}function Ax(Ae,je,Le){var jt;return Le(Ae,function(Pn,Er,Li){if(je(Pn,Er,Li))return jt=Er,!1}),jt}function Jp(Ae,je,Le,jt){for(var Pn=Ae.length,Er=Le+(jt?1:-1);jt?Er--:++Er<Pn;)if(je(Ae[Er],Er,Ae))return Er;return-1}function T(Ae,je,Le){return je===je?Mue(Ae,je,Le):Jp(Ae,L,Le)}function $(Ae,je,Le,jt){for(var Pn=Le-1,Er=Ae.length;++Pn<Er;)if(jt(Ae[Pn],je))return Pn;return-1}function L(Ae){return Ae!==Ae}function W(Ae,je){var Le=Ae==null?0:Ae.length;return Le?Pe(Ae,je)/Le:ge}function ne(Ae){return function(je){return je==null?t:je[Ae]}}function oe(Ae){return function(je){return Ae==null?t:Ae[je]}}function ie(Ae,je,Le,jt,Pn){return Pn(Ae,function(Er,Li,Jr){Le=jt?(jt=!1,Er):je(Le,Er,Li,Jr)}),Le}function Ce(Ae,je){var Le=Ae.length;for(Ae.sort(je);Le--;)Ae[Le]=Ae[Le].value;return Ae}function Pe(Ae,je){for(var Le,jt=-1,Pn=Ae.length;++jt<Pn;){var Er=je(Ae[jt]);Er!==t&&(Le=Le===t?Er:Le+Er)}return Le}function ht(Ae,je){for(var Le=-1,jt=Array(Ae);++Le<Ae;)jt[Le]=je(Le);return jt}function Et(Ae,je){return Vr(je,function(Le){return[Le,Ae[Le]]})}function hn(Ae){return Ae&&Ae.slice(0,fU(Ae)+1).replace(sn,"")}function Ut(Ae){return function(je){return Ae(je)}}function Rt(Ae,je){return Vr(je,function(Le){return Ae[Le]})}function an(Ae,je){return Ae.has(je)}function Bn(Ae,je){for(var Le=-1,jt=Ae.length;++Le<jt&&T(je,Ae[Le],0)>-1;);return Le}function Ur(Ae,je){for(var Le=Ae.length;Le--&&T(je,Ae[Le],0)>-1;);return Le}function Wr(Ae,je){for(var Le=Ae.length,jt=0;Le--;)Ae[Le]===je&&++jt;return jt}var Fi=oe(Sx),Ra=oe(Cx);function No(Ae){return"\\"+nk[Ae]}function br(Ae,je){return Ae==null?t:Ae[je]}function xs(Ae){return Yp.test(Ae)}function Ku(Ae){return al.test(Ae)}function uR(Ae){for(var je,Le=[];!(je=Ae.next()).done;)Le.push(je.value);return Le}function Mx(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt,Pn){Le[++je]=[Pn,jt]}),Le}function ck(Ae,je){return function(Le){return Ae(je(Le))}}function Yu(Ae,je){for(var Le=-1,jt=Ae.length,Pn=0,Er=[];++Le<jt;){var Li=Ae[Le];(Li===je||Li===u)&&(Ae[Le]=u,Er[Pn++]=Le)}return Er}function v0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=jt}),Le}function w0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=[jt,jt]}),Le}function Mue(Ae,je,Le){for(var jt=Le-1,Pn=Ae.length;++jt<Pn;)if(Ae[jt]===je)return jt;return-1}function Nue(Ae,je,Le){for(var jt=Le+1;jt--;)if(Ae[jt]===je)return jt;return jt}function x0(Ae){return xs(Ae)?Rue(Ae):aR(Ae)}function Gc(Ae){return xs(Ae)?Pue(Ae):lR(Ae)}function fU(Ae){for(var je=Ae.length;je--&&Tn.test(Ae.charAt(je)););return je}var $ue=oe(od);function Rue(Ae){for(var je=p0.lastIndex=0;p0.test(Ae);)++je;return je}function Pue(Ae){return Ae.match(p0)||[]}function Due(Ae){return Ae.match(tk)||[]}var Oue=function Ae(je){je=je==null?mi:_0.defaults(mi.Object(),je,_0.pick(mi,tR));var Le=je.Array,jt=je.Date,Pn=je.Error,Er=je.Function,Li=je.Math,Jr=je.Object,hR=je.RegExp,Fue=je.String,jl=je.TypeError,uk=Le.prototype,Lue=Er.prototype,S0=Jr.prototype,hk=je["__core-js_shared__"],fk=Lue.toString,Pr=S0.hasOwnProperty,zue=0,dU=function(){var v=/[^.]+$/.exec(hk&&hk.keys&&hk.keys.IE_PROTO||"");return v?"Symbol(src)_1."+v:""}(),dk=S0.toString,Bue=fk.call(Jr),Vue=mi._,Uue=hR("^"+fk.call(Pr).replace(vt,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),pk=sk?je.Buffer:t,cd=je.Symbol,mk=je.Uint8Array,pU=pk?pk.allocUnsafe:t,gk=ck(Jr.getPrototypeOf,Jr),mU=Jr.create,gU=S0.propertyIsEnumerable,yk=uk.splice,yU=cd?cd.isConcatSpreadable:t,Nx=cd?cd.iterator:t,Qp=cd?cd.toStringTag:t,bk=function(){try{var v=sm(Jr,"defineProperty");return v({},"",{}),v}catch{}}(),Wue=je.clearTimeout!==mi.clearTimeout&&je.clearTimeout,Gue=jt&&jt.now!==mi.Date.now&&jt.now,Hue=je.setTimeout!==mi.setTimeout&&je.setTimeout,vk=Li.ceil,wk=Li.floor,fR=Jr.getOwnPropertySymbols,jue=pk?pk.isBuffer:t,bU=je.isFinite,que=uk.join,Xue=ck(Jr.keys,Jr),zi=Li.max,$o=Li.min,Kue=jt.now,Yue=je.parseInt,vU=Li.random,Zue=uk.reverse,dR=sm(je,"DataView"),$x=sm(je,"Map"),pR=sm(je,"Promise"),C0=sm(je,"Set"),Rx=sm(je,"WeakMap"),Px=sm(Jr,"create"),xk=Rx&&new Rx,k0={},Jue=im(dR),Que=im($x),ehe=im(pR),the=im(C0),nhe=im(Rx),_k=cd?cd.prototype:t,Dx=_k?_k.valueOf:t,wU=_k?_k.toString:t;function q(v){if(Ws(v)&&!On(v)&&!(v instanceof sr)){if(v instanceof ql)return v;if(Pr.call(v,"__wrapped__"))return xW(v)}return new ql(v)}var T0=function(){function v(){}return function(_){if(!Ps(_))return{};if(mU)return mU(_);v.prototype=_;var I=new v;return v.prototype=t,I}}();function Sk(){}function ql(v,_){this.__wrapped__=v,this.__actions__=[],this.__chain__=!!_,this.__index__=0,this.__values__=t}q.templateSettings={escape:il,evaluate:Wh,interpolate:re,variable:"",imports:{_:q}},q.prototype=Sk.prototype,q.prototype.constructor=q,ql.prototype=T0(Sk.prototype),ql.prototype.constructor=ql;function sr(v){this.__wrapped__=v,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=ae,this.__views__=[]}function rhe(){var v=new sr(this.__wrapped__);return v.__actions__=Pa(this.__actions__),v.__dir__=this.__dir__,v.__filtered__=this.__filtered__,v.__iteratees__=Pa(this.__iteratees__),v.__takeCount__=this.__takeCount__,v.__views__=Pa(this.__views__),v}function she(){if(this.__filtered__){var v=new sr(this);v.__dir__=-1,v.__filtered__=!0}else v=this.clone(),v.__dir__*=-1;return v}function ihe(){var v=this.__wrapped__.value(),_=this.__dir__,I=On(v),P=_<0,V=I?v.length:0,K=yfe(0,V,this.__views__),le=K.start,xe=K.end,Me=xe-le,Qe=P?xe:le-1,et=this.__iteratees__,lt=et.length,Ft=0,tn=$o(Me,this.__takeCount__);if(!I||!P&&V==Me&&tn==Me)return GU(v,this.__actions__);var mn=[];e:for(;Me--&&Ft<tn;){Qe+=_;for(var Xn=-1,gn=v[Qe];++Xn<lt;){var tr=et[Xn],hr=tr.iteratee,ul=tr.type,ca=hr(gn);if(ul==z)gn=ca;else if(!ca){if(ul==D)continue e;break e}}mn[Ft++]=gn}return mn}sr.prototype=T0(Sk.prototype),sr.prototype.constructor=sr;function em(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function ohe(){this.__data__=Px?Px(null):{},this.size=0}function ahe(v){var _=this.has(v)&&delete this.__data__[v];return this.size-=_?1:0,_}function lhe(v){var _=this.__data__;if(Px){var I=_[v];return I===l?t:I}return Pr.call(_,v)?_[v]:t}function che(v){var _=this.__data__;return Px?_[v]!==t:Pr.call(_,v)}function uhe(v,_){var I=this.__data__;return this.size+=this.has(v)?0:1,I[v]=Px&&_===t?l:_,this}em.prototype.clear=ohe,em.prototype.delete=ahe,em.prototype.get=lhe,em.prototype.has=che,em.prototype.set=uhe;function Zh(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function hhe(){this.__data__=[],this.size=0}function fhe(v){var _=this.__data__,I=Ck(_,v);if(I<0)return!1;var P=_.length-1;return I==P?_.pop():yk.call(_,I,1),--this.size,!0}function dhe(v){var _=this.__data__,I=Ck(_,v);return I<0?t:_[I][1]}function phe(v){return Ck(this.__data__,v)>-1}function mhe(v,_){var I=this.__data__,P=Ck(I,v);return P<0?(++this.size,I.push([v,_])):I[P][1]=_,this}Zh.prototype.clear=hhe,Zh.prototype.delete=fhe,Zh.prototype.get=dhe,Zh.prototype.has=phe,Zh.prototype.set=mhe;function Jh(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function ghe(){this.size=0,this.__data__={hash:new em,map:new($x||Zh),string:new em}}function yhe(v){var _=Ok(this,v).delete(v);return this.size-=_?1:0,_}function bhe(v){return Ok(this,v).get(v)}function vhe(v){return Ok(this,v).has(v)}function whe(v,_){var I=Ok(this,v),P=I.size;return I.set(v,_),this.size+=I.size==P?0:1,this}Jh.prototype.clear=ghe,Jh.prototype.delete=yhe,Jh.prototype.get=bhe,Jh.prototype.has=vhe,Jh.prototype.set=whe;function tm(v){var _=-1,I=v==null?0:v.length;for(this.__data__=new Jh;++_<I;)this.add(v[_])}function xhe(v){return this.__data__.set(v,l),this}function _he(v){return this.__data__.has(v)}tm.prototype.add=tm.prototype.push=xhe,tm.prototype.has=_he;function Hc(v){var _=this.__data__=new Zh(v);this.size=_.size}function She(){this.__data__=new Zh,this.size=0}function Che(v){var _=this.__data__,I=_.delete(v);return this.size=_.size,I}function khe(v){return this.__data__.get(v)}function The(v){return this.__data__.has(v)}function Ehe(v,_){var I=this.__data__;if(I instanceof Zh){var P=I.__data__;if(!$x||P.length<s-1)return P.push([v,_]),this.size=++I.size,this;I=this.__data__=new Jh(P)}return I.set(v,_),this.size=I.size,this}Hc.prototype.clear=She,Hc.prototype.delete=Che,Hc.prototype.get=khe,Hc.prototype.has=The,Hc.prototype.set=Ehe;function xU(v,_){var I=On(v),P=!I&&om(v),V=!I&&!P&&pd(v),K=!I&&!P&&!V&&M0(v),le=I||P||V||K,xe=le?ht(v.length,Fue):[],Me=xe.length;for(var Qe in v)(_||Pr.call(v,Qe))&&!(le&&(Qe=="length"||V&&(Qe=="offset"||Qe=="parent")||K&&(Qe=="buffer"||Qe=="byteLength"||Qe=="byteOffset")||nf(Qe,Me)))&&xe.push(Qe);return xe}function _U(v){var _=v.length;return _?v[kR(0,_-1)]:t}function Ihe(v,_){return Fk(Pa(v),nm(_,0,v.length))}function Ahe(v){return Fk(Pa(v))}function mR(v,_,I){(I!==t&&!jc(v[_],I)||I===t&&!(_ in v))&&Qh(v,_,I)}function Ox(v,_,I){var P=v[_];(!(Pr.call(v,_)&&jc(P,I))||I===t&&!(_ in v))&&Qh(v,_,I)}function Ck(v,_){for(var I=v.length;I--;)if(jc(v[I][0],_))return I;return-1}function Mhe(v,_,I,P){return ud(v,function(V,K,le){_(P,V,I(V),le)}),P}function SU(v,_){return v&&Ju(_,to(_),v)}function Nhe(v,_){return v&&Ju(_,Oa(_),v)}function Qh(v,_,I){_=="__proto__"&&bk?bk(v,_,{configurable:!0,enumerable:!0,value:I,writable:!0}):v[_]=I}function gR(v,_){for(var I=-1,P=_.length,V=Le(P),K=v==null;++I<P;)V[I]=K?t:YR(v,_[I]);return V}function nm(v,_,I){return v===v&&(I!==t&&(v=v<=I?v:I),_!==t&&(v=v>=_?v:_)),v}function Xl(v,_,I,P,V,K){var le,xe=_&h,Me=_&f,Qe=_&d;if(I&&(le=V?I(v,P,V,K):I(v)),le!==t)return le;if(!Ps(v))return v;var et=On(v);if(et){if(le=vfe(v),!xe)return Pa(v,le)}else{var lt=Ro(v),Ft=lt==Ve||lt==ze;if(pd(v))return qU(v,xe);if(lt==ee||lt==be||Ft&&!V){if(le=Me||Ft?{}:fW(v),!xe)return Me?lfe(v,Nhe(le,v)):afe(v,SU(le,v))}else{if(!Rr[lt])return V?v:{};le=wfe(v,lt,xe)}}K||(K=new Hc);var tn=K.get(v);if(tn)return tn;K.set(v,le),VW(v)?v.forEach(function(gn){le.add(Xl(gn,_,I,gn,v,K))}):zW(v)&&v.forEach(function(gn,tr){le.set(tr,Xl(gn,_,I,tr,v,K))});var mn=Qe?Me?OR:DR:Me?Oa:to,Xn=et?t:mn(v);return $a(Xn||v,function(gn,tr){Xn&&(tr=gn,gn=v[tr]),Ox(le,tr,Xl(gn,_,I,tr,v,K))}),le}function $he(v){var _=to(v);return function(I){return CU(I,v,_)}}function CU(v,_,I){var P=I.length;if(v==null)return!P;for(v=Jr(v);P--;){var V=I[P],K=_[V],le=v[V];if(le===t&&!(V in v)||!K(le))return!1}return!0}function kU(v,_,I){if(typeof v!="function")throw new jl(o);return Wx(function(){v.apply(t,I)},_)}function Fx(v,_,I,P){var V=-1,K=b0,le=!0,xe=v.length,Me=[],Qe=_.length;if(!xe)return Me;I&&(_=Vr(_,Ut(I))),P?(K=Ex,le=!1):_.length>=s&&(K=an,le=!1,_=new tm(_));e:for(;++V<xe;){var et=v[V],lt=I==null?et:I(et);if(et=P||et!==0?et:0,le&&lt===lt){for(var Ft=Qe;Ft--;)if(_[Ft]===lt)continue e;Me.push(et)}else K(_,lt,P)||Me.push(et)}return Me}var ud=JU(Zu),TU=JU(bR,!0);function Rhe(v,_){var I=!0;return ud(v,function(P,V,K){return I=!!_(P,V,K),I}),I}function kk(v,_,I){for(var P=-1,V=v.length;++P<V;){var K=v[P],le=_(K);if(le!=null&&(xe===t?le===le&&!cl(le):I(le,xe)))var xe=le,Me=K}return Me}function Phe(v,_,I,P){var V=v.length;for(I=Wn(I),I<0&&(I=-I>V?0:V+I),P=P===t||P>V?V:Wn(P),P<0&&(P+=V),P=I>P?0:WW(P);I<P;)v[I++]=_;return v}function EU(v,_){var I=[];return ud(v,function(P,V,K){_(P,V,K)&&I.push(P)}),I}function vo(v,_,I,P,V){var K=-1,le=v.length;for(I||(I=_fe),V||(V=[]);++K<le;){var xe=v[K];_>0&&I(xe)?_>1?vo(xe,_-1,I,P,V):Xu(V,xe):P||(V[V.length]=xe)}return V}var yR=QU(),IU=QU(!0);function Zu(v,_){return v&&yR(v,_,to)}function bR(v,_){return v&&IU(v,_,to)}function Tk(v,_){return Wc(_,function(I){return rf(v[I])})}function rm(v,_){_=fd(_,v);for(var I=0,P=_.length;v!=null&&I<P;)v=v[Qu(_[I++])];return I&&I==P?v:t}function AU(v,_,I){var P=_(v);return On(v)?P:Xu(P,I(v))}function aa(v){return v==null?v===t?Ct:Ke:Qp&&Qp in Jr(v)?gfe(v):Afe(v)}function vR(v,_){return v>_}function Dhe(v,_){return v!=null&&Pr.call(v,_)}function Ohe(v,_){return v!=null&&_ in Jr(v)}function Fhe(v,_,I){return v>=$o(_,I)&&v<zi(_,I)}function wR(v,_,I){for(var P=I?Ex:b0,V=v[0].length,K=v.length,le=K,xe=Le(K),Me=1/0,Qe=[];le--;){var et=v[le];le&&_&&(et=Vr(et,Ut(_))),Me=$o(et.length,Me),xe[le]=!I&&(_||V>=120&&et.length>=120)?new tm(le&&et):t}et=v[0];var lt=-1,Ft=xe[0];e:for(;++lt<V&&Qe.length<Me;){var tn=et[lt],mn=_?_(tn):tn;if(tn=I||tn!==0?tn:0,!(Ft?an(Ft,mn):P(Qe,mn,I))){for(le=K;--le;){var Xn=xe[le];if(!(Xn?an(Xn,mn):P(v[le],mn,I)))continue e}Ft&&Ft.push(mn),Qe.push(tn)}}return Qe}function Lhe(v,_,I,P){return Zu(v,function(V,K,le){_(P,I(V),K,le)}),P}function Lx(v,_,I){_=fd(_,v),v=gW(v,_);var P=v==null?v:v[Qu(Yl(_))];return P==null?t:Mo(P,v,I)}function MU(v){return Ws(v)&&aa(v)==be}function zhe(v){return Ws(v)&&aa(v)==nt}function Bhe(v){return Ws(v)&&aa(v)==We}function zx(v,_,I,P,V){return v===_?!0:v==null||_==null||!Ws(v)&&!Ws(_)?v!==v&&_!==_:Vhe(v,_,I,P,zx,V)}function Vhe(v,_,I,P,V,K){var le=On(v),xe=On(_),Me=le?Xe:Ro(v),Qe=xe?Xe:Ro(_);Me=Me==be?ee:Me,Qe=Qe==be?ee:Qe;var et=Me==ee,lt=Qe==ee,Ft=Me==Qe;if(Ft&&pd(v)){if(!pd(_))return!1;le=!0,et=!1}if(Ft&&!et)return K||(K=new Hc),le||M0(v)?cW(v,_,I,P,V,K):pfe(v,_,Me,I,P,V,K);if(!(I&p)){var tn=et&&Pr.call(v,"__wrapped__"),mn=lt&&Pr.call(_,"__wrapped__");if(tn||mn){var Xn=tn?v.value():v,gn=mn?_.value():_;return K||(K=new Hc),V(Xn,gn,I,P,K)}}return Ft?(K||(K=new Hc),mfe(v,_,I,P,V,K)):!1}function Uhe(v){return Ws(v)&&Ro(v)==Be}function xR(v,_,I,P){var V=I.length,K=V,le=!P;if(v==null)return!K;for(v=Jr(v);V--;){var xe=I[V];if(le&&xe[2]?xe[1]!==v[xe[0]]:!(xe[0]in v))return!1}for(;++V<K;){xe=I[V];var Me=xe[0],Qe=v[Me],et=xe[1];if(le&&xe[2]){if(Qe===t&&!(Me in v))return!1}else{var lt=new Hc;if(P)var Ft=P(Qe,et,Me,v,_,lt);if(!(Ft===t?zx(et,Qe,p|m,P,lt):Ft))return!1}}return!0}function NU(v){if(!Ps(v)||Cfe(v))return!1;var _=rf(v)?Uue:rs;return _.test(im(v))}function Whe(v){return Ws(v)&&aa(v)==Ge}function Ghe(v){return Ws(v)&&Ro(v)==ye}function Hhe(v){return Ws(v)&&Wk(v.length)&&!!Br[aa(v)]}function $U(v){return typeof v=="function"?v:v==null?Fa:typeof v=="object"?On(v)?DU(v[0],v[1]):PU(v):eG(v)}function _R(v){if(!Ux(v))return Xue(v);var _=[];for(var I in Jr(v))Pr.call(v,I)&&I!="constructor"&&_.push(I);return _}function jhe(v){if(!Ps(v))return Ife(v);var _=Ux(v),I=[];for(var P in v)P=="constructor"&&(_||!Pr.call(v,P))||I.push(P);return I}function SR(v,_){return v<_}function RU(v,_){var I=-1,P=Da(v)?Le(v.length):[];return ud(v,function(V,K,le){P[++I]=_(V,K,le)}),P}function PU(v){var _=LR(v);return _.length==1&&_[0][2]?pW(_[0][0],_[0][1]):function(I){return I===v||xR(I,v,_)}}function DU(v,_){return BR(v)&&dW(_)?pW(Qu(v),_):function(I){var P=YR(I,v);return P===t&&P===_?ZR(I,v):zx(_,P,p|m)}}function Ek(v,_,I,P,V){v!==_&&yR(_,function(K,le){if(V||(V=new Hc),Ps(K))qhe(v,_,le,I,Ek,P,V);else{var xe=P?P(UR(v,le),K,le+"",v,_,V):t;xe===t&&(xe=K),mR(v,le,xe)}},Oa)}function qhe(v,_,I,P,V,K,le){var xe=UR(v,I),Me=UR(_,I),Qe=le.get(Me);if(Qe){mR(v,I,Qe);return}var et=K?K(xe,Me,I+"",v,_,le):t,lt=et===t;if(lt){var Ft=On(Me),tn=!Ft&&pd(Me),mn=!Ft&&!tn&&M0(Me);et=Me,Ft||tn||mn?On(xe)?et=xe:ni(xe)?et=Pa(xe):tn?(lt=!1,et=qU(Me,!0)):mn?(lt=!1,et=XU(Me,!0)):et=[]:Gx(Me)||om(Me)?(et=xe,om(xe)?et=GW(xe):(!Ps(xe)||rf(xe))&&(et=fW(Me))):lt=!1}lt&&(le.set(Me,et),V(et,Me,P,K,le),le.delete(Me)),mR(v,I,et)}function OU(v,_){var I=v.length;if(I)return _+=_<0?I:0,nf(_,I)?v[_]:t}function FU(v,_,I){_.length?_=Vr(_,function(K){return On(K)?function(le){return rm(le,K.length===1?K[0]:K)}:K}):_=[Fa];var P=-1;_=Vr(_,Ut(fn()));var V=RU(v,function(K,le,xe){var Me=Vr(_,function(Qe){return Qe(K)});return{criteria:Me,index:++P,value:K}});return Ce(V,function(K,le){return ofe(K,le,I)})}function Xhe(v,_){return LU(v,_,function(I,P){return ZR(v,P)})}function LU(v,_,I){for(var P=-1,V=_.length,K={};++P<V;){var le=_[P],xe=rm(v,le);I(xe,le)&&Bx(K,fd(le,v),xe)}return K}function Khe(v){return function(_){return rm(_,v)}}function CR(v,_,I,P){var V=P?$:T,K=-1,le=_.length,xe=v;for(v===_&&(_=Pa(_)),I&&(xe=Vr(v,Ut(I)));++K<le;)for(var Me=0,Qe=_[K],et=I?I(Qe):Qe;(Me=V(xe,et,Me,P))>-1;)xe!==v&&yk.call(xe,Me,1),yk.call(v,Me,1);return v}function zU(v,_){for(var I=v?_.length:0,P=I-1;I--;){var V=_[I];if(I==P||V!==K){var K=V;nf(V)?yk.call(v,V,1):IR(v,V)}}return v}function kR(v,_){return v+wk(vU()*(_-v+1))}function Yhe(v,_,I,P){for(var V=-1,K=zi(vk((_-v)/(I||1)),0),le=Le(K);K--;)le[P?K:++V]=v,v+=I;return le}function TR(v,_){var I="";if(!v||_<1||_>G)return I;do _%2&&(I+=v),_=wk(_/2),_&&(v+=v);while(_);return I}function Yn(v,_){return WR(mW(v,_,Fa),v+"")}function Zhe(v){return _U(N0(v))}function Jhe(v,_){var I=N0(v);return Fk(I,nm(_,0,I.length))}function Bx(v,_,I,P){if(!Ps(v))return v;_=fd(_,v);for(var V=-1,K=_.length,le=K-1,xe=v;xe!=null&&++V<K;){var Me=Qu(_[V]),Qe=I;if(Me==="__proto__"||Me==="constructor"||Me==="prototype")return v;if(V!=le){var et=xe[Me];Qe=P?P(et,Me,xe):t,Qe===t&&(Qe=Ps(et)?et:nf(_[V+1])?[]:{})}Ox(xe,Me,Qe),xe=xe[Me]}return v}var BU=xk?function(v,_){return xk.set(v,_),v}:Fa,Qhe=bk?function(v,_){return bk(v,"toString",{configurable:!0,enumerable:!1,value:QR(_),writable:!0})}:Fa;function efe(v){return Fk(N0(v))}function Kl(v,_,I){var P=-1,V=v.length;_<0&&(_=-_>V?0:V+_),I=I>V?V:I,I<0&&(I+=V),V=_>I?0:I-_>>>0,_>>>=0;for(var K=Le(V);++P<V;)K[P]=v[P+_];return K}function tfe(v,_){var I;return ud(v,function(P,V,K){return I=_(P,V,K),!I}),!!I}function Ik(v,_,I){var P=0,V=v==null?P:v.length;if(typeof _=="number"&&_===_&&V<=ke){for(;P<V;){var K=P+V>>>1,le=v[K];le!==null&&!cl(le)&&(I?le<=_:le<_)?P=K+1:V=K}return V}return ER(v,_,Fa,I)}function ER(v,_,I,P){var V=0,K=v==null?0:v.length;if(K===0)return 0;_=I(_);for(var le=_!==_,xe=_===null,Me=cl(_),Qe=_===t;V<K;){var et=wk((V+K)/2),lt=I(v[et]),Ft=lt!==t,tn=lt===null,mn=lt===lt,Xn=cl(lt);if(le)var gn=P||mn;else Qe?gn=mn&&(P||Ft):xe?gn=mn&&Ft&&(P||!tn):Me?gn=mn&&Ft&&!tn&&(P||!Xn):tn||Xn?gn=!1:gn=P?lt<=_:lt<_;gn?V=et+1:K=et}return $o(K,Ne)}function VU(v,_){for(var I=-1,P=v.length,V=0,K=[];++I<P;){var le=v[I],xe=_?_(le):le;if(!I||!jc(xe,Me)){var Me=xe;K[V++]=le===0?0:le}}return K}function UU(v){return typeof v=="number"?v:cl(v)?ge:+v}function ll(v){if(typeof v=="string")return v;if(On(v))return Vr(v,ll)+"";if(cl(v))return wU?wU.call(v):"";var _=v+"";return _=="0"&&1/v==-X?"-0":_}function hd(v,_,I){var P=-1,V=b0,K=v.length,le=!0,xe=[],Me=xe;if(I)le=!1,V=Ex;else if(K>=s){var Qe=_?null:ffe(v);if(Qe)return v0(Qe);le=!1,V=an,Me=new tm}else Me=_?[]:xe;e:for(;++P<K;){var et=v[P],lt=_?_(et):et;if(et=I||et!==0?et:0,le&&lt===lt){for(var Ft=Me.length;Ft--;)if(Me[Ft]===lt)continue e;_&&Me.push(lt),xe.push(et)}else V(Me,lt,I)||(Me!==xe&&Me.push(lt),xe.push(et))}return xe}function IR(v,_){return _=fd(_,v),v=gW(v,_),v==null||delete v[Qu(Yl(_))]}function WU(v,_,I,P){return Bx(v,_,I(rm(v,_)),P)}function Ak(v,_,I,P){for(var V=v.length,K=P?V:-1;(P?K--:++K<V)&&_(v[K],K,v););return I?Kl(v,P?0:K,P?K+1:V):Kl(v,P?K+1:0,P?V:K)}function GU(v,_){var I=v;return I instanceof sr&&(I=I.value()),Ix(_,function(P,V){return V.func.apply(V.thisArg,Xu([P],V.args))},I)}function AR(v,_,I){var P=v.length;if(P<2)return P?hd(v[0]):[];for(var V=-1,K=Le(P);++V<P;)for(var le=v[V],xe=-1;++xe<P;)xe!=V&&(K[V]=Fx(K[V]||le,v[xe],_,I));return hd(vo(K,1),_,I)}function HU(v,_,I){for(var P=-1,V=v.length,K=_.length,le={};++P<V;){var xe=P<K?_[P]:t;I(le,v[P],xe)}return le}function MR(v){return ni(v)?v:[]}function NR(v){return typeof v=="function"?v:Fa}function fd(v,_){return On(v)?v:BR(v,_)?[v]:wW(Mr(v))}var nfe=Yn;function dd(v,_,I){var P=v.length;return I=I===t?P:I,!_&&I>=P?v:Kl(v,_,I)}var jU=Wue||function(v){return mi.clearTimeout(v)};function qU(v,_){if(_)return v.slice();var I=v.length,P=pU?pU(I):new v.constructor(I);return v.copy(P),P}function $R(v){var _=new v.constructor(v.byteLength);return new mk(_).set(new mk(v)),_}function rfe(v,_){var I=_?$R(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.byteLength)}function sfe(v){var _=new v.constructor(v.source,Zi.exec(v));return _.lastIndex=v.lastIndex,_}function ife(v){return Dx?Jr(Dx.call(v)):{}}function XU(v,_){var I=_?$R(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.length)}function KU(v,_){if(v!==_){var I=v!==t,P=v===null,V=v===v,K=cl(v),le=_!==t,xe=_===null,Me=_===_,Qe=cl(_);if(!xe&&!Qe&&!K&&v>_||K&&le&&Me&&!xe&&!Qe||P&&le&&Me||!I&&Me||!V)return 1;if(!P&&!K&&!Qe&&v<_||Qe&&I&&V&&!P&&!K||xe&&I&&V||!le&&V||!Me)return-1}return 0}function ofe(v,_,I){for(var P=-1,V=v.criteria,K=_.criteria,le=V.length,xe=I.length;++P<le;){var Me=KU(V[P],K[P]);if(Me){if(P>=xe)return Me;var Qe=I[P];return Me*(Qe=="desc"?-1:1)}}return v.index-_.index}function YU(v,_,I,P){for(var V=-1,K=v.length,le=I.length,xe=-1,Me=_.length,Qe=zi(K-le,0),et=Le(Me+Qe),lt=!P;++xe<Me;)et[xe]=_[xe];for(;++V<le;)(lt||V<K)&&(et[I[V]]=v[V]);for(;Qe--;)et[xe++]=v[V++];return et}function ZU(v,_,I,P){for(var V=-1,K=v.length,le=-1,xe=I.length,Me=-1,Qe=_.length,et=zi(K-xe,0),lt=Le(et+Qe),Ft=!P;++V<et;)lt[V]=v[V];for(var tn=V;++Me<Qe;)lt[tn+Me]=_[Me];for(;++le<xe;)(Ft||V<K)&&(lt[tn+I[le]]=v[V++]);return lt}function Pa(v,_){var I=-1,P=v.length;for(_||(_=Le(P));++I<P;)_[I]=v[I];return _}function Ju(v,_,I,P){var V=!I;I||(I={});for(var K=-1,le=_.length;++K<le;){var xe=_[K],Me=P?P(I[xe],v[xe],xe,I,v):t;Me===t&&(Me=v[xe]),V?Qh(I,xe,Me):Ox(I,xe,Me)}return I}function afe(v,_){return Ju(v,zR(v),_)}function lfe(v,_){return Ju(v,uW(v),_)}function Mk(v,_){return function(I,P){var V=On(I)?sR:Mhe,K=_?_():{};return V(I,v,fn(P,2),K)}}function E0(v){return Yn(function(_,I){var P=-1,V=I.length,K=V>1?I[V-1]:t,le=V>2?I[2]:t;for(K=v.length>3&&typeof K=="function"?(V--,K):t,le&&la(I[0],I[1],le)&&(K=V<3?t:K,V=1),_=Jr(_);++P<V;){var xe=I[P];xe&&v(_,xe,P,K)}return _})}function JU(v,_){return function(I,P){if(I==null)return I;if(!Da(I))return v(I,P);for(var V=I.length,K=_?V:-1,le=Jr(I);(_?K--:++K<V)&&P(le[K],K,le)!==!1;);return I}}function QU(v){return function(_,I,P){for(var V=-1,K=Jr(_),le=P(_),xe=le.length;xe--;){var Me=le[v?xe:++V];if(I(K[Me],Me,K)===!1)break}return _}}function cfe(v,_,I){var P=_&g,V=Vx(v);function K(){var le=this&&this!==mi&&this instanceof K?V:v;return le.apply(P?I:this,arguments)}return K}function eW(v){return function(_){_=Mr(_);var I=xs(_)?Gc(_):t,P=I?I[0]:_.charAt(0),V=I?dd(I,1).join(""):_.slice(1);return P[v]()+V}}function I0(v){return function(_){return Ix(JW(ZW(_).replace(eR,"")),v,"")}}function Vx(v){return function(){var _=arguments;switch(_.length){case 0:return new v;case 1:return new v(_[0]);case 2:return new v(_[0],_[1]);case 3:return new v(_[0],_[1],_[2]);case 4:return new v(_[0],_[1],_[2],_[3]);case 5:return new v(_[0],_[1],_[2],_[3],_[4]);case 6:return new v(_[0],_[1],_[2],_[3],_[4],_[5]);case 7:return new v(_[0],_[1],_[2],_[3],_[4],_[5],_[6])}var I=T0(v.prototype),P=v.apply(I,_);return Ps(P)?P:I}}function ufe(v,_,I){var P=Vx(v);function V(){for(var K=arguments.length,le=Le(K),xe=K,Me=A0(V);xe--;)le[xe]=arguments[xe];var Qe=K<3&&le[0]!==Me&&le[K-1]!==Me?[]:Yu(le,Me);if(K-=Qe.length,K<I)return iW(v,_,Nk,V.placeholder,t,le,Qe,t,t,I-K);var et=this&&this!==mi&&this instanceof V?P:v;return Mo(et,this,le)}return V}function tW(v){return function(_,I,P){var V=Jr(_);if(!Da(_)){var K=fn(I,3);_=to(_),I=function(xe){return K(V[xe],xe,V)}}var le=v(_,I,P);return le>-1?V[K?_[le]:le]:t}}function nW(v){return tf(function(_){var I=_.length,P=I,V=ql.prototype.thru;for(v&&_.reverse();P--;){var K=_[P];if(typeof K!="function")throw new jl(o);if(V&&!le&&Dk(K)=="wrapper")var le=new ql([],!0)}for(P=le?P:I;++P<I;){K=_[P];var xe=Dk(K),Me=xe=="wrapper"?FR(K):t;Me&&VR(Me[0])&&Me[1]==(k|x|S|A)&&!Me[4].length&&Me[9]==1?le=le[Dk(Me[0])].apply(le,Me[3]):le=K.length==1&&VR(K)?le[xe]():le.thru(K)}return function(){var Qe=arguments,et=Qe[0];if(le&&Qe.length==1&&On(et))return le.plant(et).value();for(var lt=0,Ft=I?_[lt].apply(this,Qe):et;++lt<I;)Ft=_[lt].call(this,Ft);return Ft}})}function Nk(v,_,I,P,V,K,le,xe,Me,Qe){var et=_&k,lt=_&g,Ft=_&y,tn=_&(x|w),mn=_&M,Xn=Ft?t:Vx(v);function gn(){for(var tr=arguments.length,hr=Le(tr),ul=tr;ul--;)hr[ul]=arguments[ul];if(tn)var ca=A0(gn),hl=Wr(hr,ca);if(P&&(hr=YU(hr,P,V,tn)),K&&(hr=ZU(hr,K,le,tn)),tr-=hl,tn&&tr<Qe){var ri=Yu(hr,ca);return iW(v,_,Nk,gn.placeholder,I,hr,ri,xe,Me,Qe-tr)}var qc=lt?I:this,of=Ft?qc[v]:v;return tr=hr.length,xe?hr=Mfe(hr,xe):mn&&tr>1&&hr.reverse(),et&&Me<tr&&(hr.length=Me),this&&this!==mi&&this instanceof gn&&(of=Xn||Vx(of)),of.apply(qc,hr)}return gn}function rW(v,_){return function(I,P){return Lhe(I,v,_(P),{})}}function $k(v,_){return function(I,P){var V;if(I===t&&P===t)return _;if(I!==t&&(V=I),P!==t){if(V===t)return P;typeof I=="string"||typeof P=="string"?(I=ll(I),P=ll(P)):(I=UU(I),P=UU(P)),V=v(I,P)}return V}}function RR(v){return tf(function(_){return _=Vr(_,Ut(fn())),Yn(function(I){var P=this;return v(_,function(V){return Mo(V,P,I)})})})}function Rk(v,_){_=_===t?" ":ll(_);var I=_.length;if(I<2)return I?TR(_,v):_;var P=TR(_,vk(v/x0(_)));return xs(_)?dd(Gc(P),0,v).join(""):P.slice(0,v)}function hfe(v,_,I,P){var V=_&g,K=Vx(v);function le(){for(var xe=-1,Me=arguments.length,Qe=-1,et=P.length,lt=Le(et+Me),Ft=this&&this!==mi&&this instanceof le?K:v;++Qe<et;)lt[Qe]=P[Qe];for(;Me--;)lt[Qe++]=arguments[++xe];return Mo(Ft,V?I:this,lt)}return le}function sW(v){return function(_,I,P){return P&&typeof P!="number"&&la(_,I,P)&&(I=P=t),_=sf(_),I===t?(I=_,_=0):I=sf(I),P=P===t?_<I?1:-1:sf(P),Yhe(_,I,P,v)}}function Pk(v){return function(_,I){return typeof _=="string"&&typeof I=="string"||(_=Zl(_),I=Zl(I)),v(_,I)}}function iW(v,_,I,P,V,K,le,xe,Me,Qe){var et=_&x,lt=et?le:t,Ft=et?t:le,tn=et?K:t,mn=et?t:K;_|=et?S:C,_&=~(et?C:S),_&b||(_&=~(g|y));var Xn=[v,_,V,tn,lt,mn,Ft,xe,Me,Qe],gn=I.apply(t,Xn);return VR(v)&&yW(gn,Xn),gn.placeholder=P,bW(gn,v,_)}function PR(v){var _=Li[v];return function(I,P){if(I=Zl(I),P=P==null?0:$o(Wn(P),292),P&&bU(I)){var V=(Mr(I)+"e").split("e"),K=_(V[0]+"e"+(+V[1]+P));return V=(Mr(K)+"e").split("e"),+(V[0]+"e"+(+V[1]-P))}return _(I)}}var ffe=C0&&1/v0(new C0([,-0]))[1]==X?function(v){return new C0(v)}:n3;function oW(v){return function(_){var I=Ro(_);return I==Be?Mx(_):I==ye?w0(_):Et(_,v(_))}}function ef(v,_,I,P,V,K,le,xe){var Me=_&y;if(!Me&&typeof v!="function")throw new jl(o);var Qe=P?P.length:0;if(Qe||(_&=~(S|C),P=V=t),le=le===t?le:zi(Wn(le),0),xe=xe===t?xe:Wn(xe),Qe-=V?V.length:0,_&C){var et=P,lt=V;P=V=t}var Ft=Me?t:FR(v),tn=[v,_,I,P,V,et,lt,K,le,xe];if(Ft&&Efe(tn,Ft),v=tn[0],_=tn[1],I=tn[2],P=tn[3],V=tn[4],xe=tn[9]=tn[9]===t?Me?0:v.length:zi(tn[9]-Qe,0),!xe&&_&(x|w)&&(_&=~(x|w)),!_||_==g)var mn=cfe(v,_,I);else _==x||_==w?mn=ufe(v,_,xe):(_==S||_==(g|S))&&!V.length?mn=hfe(v,_,I,P):mn=Nk.apply(t,tn);var Xn=Ft?BU:yW;return bW(Xn(mn,tn),v,_)}function aW(v,_,I,P){return v===t||jc(v,S0[I])&&!Pr.call(P,I)?_:v}function lW(v,_,I,P,V,K){return Ps(v)&&Ps(_)&&(K.set(_,v),Ek(v,_,t,lW,K),K.delete(_)),v}function dfe(v){return Gx(v)?t:v}function cW(v,_,I,P,V,K){var le=I&p,xe=v.length,Me=_.length;if(xe!=Me&&!(le&&Me>xe))return!1;var Qe=K.get(v),et=K.get(_);if(Qe&&et)return Qe==_&&et==v;var lt=-1,Ft=!0,tn=I&m?new tm:t;for(K.set(v,_),K.set(_,v);++lt<xe;){var mn=v[lt],Xn=_[lt];if(P)var gn=le?P(Xn,mn,lt,_,v,K):P(mn,Xn,lt,v,_,K);if(gn!==t){if(gn)continue;Ft=!1;break}if(tn){if(!ld(_,function(tr,hr){if(!an(tn,hr)&&(mn===tr||V(mn,tr,I,P,K)))return tn.push(hr)})){Ft=!1;break}}else if(!(mn===Xn||V(mn,Xn,I,P,K))){Ft=!1;break}}return K.delete(v),K.delete(_),Ft}function pfe(v,_,I,P,V,K,le){switch(I){case St:if(v.byteLength!=_.byteLength||v.byteOffset!=_.byteOffset)return!1;v=v.buffer,_=_.buffer;case nt:return!(v.byteLength!=_.byteLength||!K(new mk(v),new mk(_)));case it:case We:case ut:return jc(+v,+_);case ct:return v.name==_.name&&v.message==_.message;case Ge:case Ze:return v==_+"";case Be:var xe=Mx;case ye:var Me=P&p;if(xe||(xe=v0),v.size!=_.size&&!Me)return!1;var Qe=le.get(v);if(Qe)return Qe==_;P|=m,le.set(v,_);var et=cW(xe(v),xe(_),P,V,K,le);return le.delete(v),et;case yt:if(Dx)return Dx.call(v)==Dx.call(_)}return!1}function mfe(v,_,I,P,V,K){var le=I&p,xe=DR(v),Me=xe.length,Qe=DR(_),et=Qe.length;if(Me!=et&&!le)return!1;for(var lt=Me;lt--;){var Ft=xe[lt];if(!(le?Ft in _:Pr.call(_,Ft)))return!1}var tn=K.get(v),mn=K.get(_);if(tn&&mn)return tn==_&&mn==v;var Xn=!0;K.set(v,_),K.set(_,v);for(var gn=le;++lt<Me;){Ft=xe[lt];var tr=v[Ft],hr=_[Ft];if(P)var ul=le?P(hr,tr,Ft,_,v,K):P(tr,hr,Ft,v,_,K);if(!(ul===t?tr===hr||V(tr,hr,I,P,K):ul)){Xn=!1;break}gn||(gn=Ft=="constructor")}if(Xn&&!gn){var ca=v.constructor,hl=_.constructor;ca!=hl&&"constructor"in v&&"constructor"in _&&!(typeof ca=="function"&&ca instanceof ca&&typeof hl=="function"&&hl instanceof hl)&&(Xn=!1)}return K.delete(v),K.delete(_),Xn}function tf(v){return WR(mW(v,t,CW),v+"")}function DR(v){return AU(v,to,zR)}function OR(v){return AU(v,Oa,uW)}var FR=xk?function(v){return xk.get(v)}:n3;function Dk(v){for(var _=v.name+"",I=k0[_],P=Pr.call(k0,_)?I.length:0;P--;){var V=I[P],K=V.func;if(K==null||K==v)return V.name}return _}function A0(v){var _=Pr.call(q,"placeholder")?q:v;return _.placeholder}function fn(){var v=q.iteratee||e3;return v=v===e3?$U:v,arguments.length?v(arguments[0],arguments[1]):v}function Ok(v,_){var I=v.__data__;return Sfe(_)?I[typeof _=="string"?"string":"hash"]:I.map}function LR(v){for(var _=to(v),I=_.length;I--;){var P=_[I],V=v[P];_[I]=[P,V,dW(V)]}return _}function sm(v,_){var I=br(v,_);return NU(I)?I:t}function gfe(v){var _=Pr.call(v,Qp),I=v[Qp];try{v[Qp]=t;var P=!0}catch{}var V=dk.call(v);return P&&(_?v[Qp]=I:delete v[Qp]),V}var zR=fR?function(v){return v==null?[]:(v=Jr(v),Wc(fR(v),function(_){return gU.call(v,_)}))}:r3,uW=fR?function(v){for(var _=[];v;)Xu(_,zR(v)),v=gk(v);return _}:r3,Ro=aa;(dR&&Ro(new dR(new ArrayBuffer(1)))!=St||$x&&Ro(new $x)!=Be||pR&&Ro(pR.resolve())!=J||C0&&Ro(new C0)!=ye||Rx&&Ro(new Rx)!=ft)&&(Ro=function(v){var _=aa(v),I=_==ee?v.constructor:t,P=I?im(I):"";if(P)switch(P){case Jue:return St;case Que:return Be;case ehe:return J;case the:return ye;case nhe:return ft}return _});function yfe(v,_,I){for(var P=-1,V=I.length;++P<V;){var K=I[P],le=K.size;switch(K.type){case"drop":v+=le;break;case"dropRight":_-=le;break;case"take":_=$o(_,v+le);break;case"takeRight":v=zi(v,_-le);break}}return{start:v,end:_}}function bfe(v){var _=v.match(Nn);return _?_[1].split(er):[]}function hW(v,_,I){_=fd(_,v);for(var P=-1,V=_.length,K=!1;++P<V;){var le=Qu(_[P]);if(!(K=v!=null&&I(v,le)))break;v=v[le]}return K||++P!=V?K:(V=v==null?0:v.length,!!V&&Wk(V)&&nf(le,V)&&(On(v)||om(v)))}function vfe(v){var _=v.length,I=new v.constructor(_);return _&&typeof v[0]=="string"&&Pr.call(v,"index")&&(I.index=v.index,I.input=v.input),I}function fW(v){return typeof v.constructor=="function"&&!Ux(v)?T0(gk(v)):{}}function wfe(v,_,I){var P=v.constructor;switch(_){case nt:return $R(v);case it:case We:return new P(+v);case St:return rfe(v,I);case gt:case Gt:case Mn:case Cr:case Bs:case As:case Ms:case Vh:case Ul:return XU(v,I);case Be:return new P;case ut:case Ze:return new P(v);case Ge:return sfe(v);case ye:return new P;case yt:return ife(v)}}function xfe(v,_){var I=_.length;if(!I)return v;var P=I-1;return _[P]=(I>1?"& ":"")+_[P],_=_.join(I>2?", ":" "),v.replace(En,`{
/* [wrapped with `+_+`] */
`)}function _fe(v){return On(v)||om(v)||!!(yU&&v&&v[yU])}function nf(v,_){var I=typeof v;return _=_??G,!!_&&(I=="number"||I!="symbol"&&Ao.test(v))&&v>-1&&v%1==0&&v<_}function la(v,_,I){if(!Ps(I))return!1;var P=typeof _;return(P=="number"?Da(I)&&nf(_,I.length):P=="string"&&_ in I)?jc(I[_],v):!1}function BR(v,_){if(On(v))return!1;var I=typeof v;return I=="number"||I=="symbol"||I=="boolean"||v==null||cl(v)?!0:Fe.test(v)||!Ue.test(v)||_!=null&&v in Jr(_)}function Sfe(v){var _=typeof v;return _=="string"||_=="number"||_=="symbol"||_=="boolean"?v!=="__proto__":v===null}function VR(v){var _=Dk(v),I=q[_];if(typeof I!="function"||!(_ in sr.prototype))return!1;if(v===I)return!0;var P=FR(I);return!!P&&v===P[0]}function Cfe(v){return!!dU&&dU in v}var kfe=hk?rf:s3;function Ux(v){var _=v&&v.constructor,I=typeof _=="function"&&_.prototype||S0;return v===I}function dW(v){return v===v&&!Ps(v)}function pW(v,_){return function(I){return I==null?!1:I[v]===_&&(_!==t||v in Jr(I))}}function Tfe(v){var _=Vk(v,function(P){return I.size===c&&I.clear(),P}),I=_.cache;return _}function Efe(v,_){var I=v[1],P=_[1],V=I|P,K=V<(g|y|k),le=P==k&&I==x||P==k&&I==A&&v[7].length<=_[8]||P==(k|A)&&_[7].length<=_[8]&&I==x;if(!(K||le))return v;P&g&&(v[2]=_[2],V|=I&g?0:b);var xe=_[3];if(xe){var Me=v[3];v[3]=Me?YU(Me,xe,_[4]):xe,v[4]=Me?Yu(v[3],u):_[4]}return xe=_[5],xe&&(Me=v[5],v[5]=Me?ZU(Me,xe,_[6]):xe,v[6]=Me?Yu(v[5],u):_[6]),xe=_[7],xe&&(v[7]=xe),P&k&&(v[8]=v[8]==null?_[8]:$o(v[8],_[8])),v[9]==null&&(v[9]=_[9]),v[0]=_[0],v[1]=V,v}function Ife(v){var _=[];if(v!=null)for(var I in Jr(v))_.push(I);return _}function Afe(v){return dk.call(v)}function mW(v,_,I){return _=zi(_===t?v.length-1:_,0),function(){for(var P=arguments,V=-1,K=zi(P.length-_,0),le=Le(K);++V<K;)le[V]=P[_+V];V=-1;for(var xe=Le(_+1);++V<_;)xe[V]=P[V];return xe[_]=I(le),Mo(v,this,xe)}}function gW(v,_){return _.length<2?v:rm(v,Kl(_,0,-1))}function Mfe(v,_){for(var I=v.length,P=$o(_.length,I),V=Pa(v);P--;){var K=_[P];v[P]=nf(K,I)?V[K]:t}return v}function UR(v,_){if(!(_==="constructor"&&typeof v[_]=="function")&&_!="__proto__")return v[_]}var yW=vW(BU),Wx=Hue||function(v,_){return mi.setTimeout(v,_)},WR=vW(Qhe);function bW(v,_,I){var P=_+"";return WR(v,xfe(P,Nfe(bfe(P),I)))}function vW(v){var _=0,I=0;return function(){var P=Kue(),V=R-(P-I);if(I=P,V>0){if(++_>=O)return arguments[0]}else _=0;return v.apply(t,arguments)}}function Fk(v,_){var I=-1,P=v.length,V=P-1;for(_=_===t?P:_;++I<_;){var K=kR(I,V),le=v[K];v[K]=v[I],v[I]=le}return v.length=_,v}var wW=Tfe(function(v){var _=[];return v.charCodeAt(0)===46&&_.push(""),v.replace(Je,function(I,P,V,K){_.push(V?K.replace(Oi,"$1"):P||I)}),_});function Qu(v){if(typeof v=="string"||cl(v))return v;var _=v+"";return _=="0"&&1/v==-X?"-0":_}function im(v){if(v!=null){try{return fk.call(v)}catch{}try{return v+""}catch{}}return""}function Nfe(v,_){return $a(De,function(I){var P="_."+I[0];_&I[1]&&!b0(v,P)&&v.push(P)}),v.sort()}function xW(v){if(v instanceof sr)return v.clone();var _=new ql(v.__wrapped__,v.__chain__);return _.__actions__=Pa(v.__actions__),_.__index__=v.__index__,_.__values__=v.__values__,_}function $fe(v,_,I){(I?la(v,_,I):_===t)?_=1:_=zi(Wn(_),0);var P=v==null?0:v.length;if(!P||_<1)return[];for(var V=0,K=0,le=Le(vk(P/_));V<P;)le[K++]=Kl(v,V,V+=_);return le}function Rfe(v){for(var _=-1,I=v==null?0:v.length,P=0,V=[];++_<I;){var K=v[_];K&&(V[P++]=K)}return V}function Pfe(){var v=arguments.length;if(!v)return[];for(var _=Le(v-1),I=arguments[0],P=v;P--;)_[P-1]=arguments[P];return Xu(On(I)?Pa(I):[I],vo(_,1))}var Dfe=Yn(function(v,_){return ni(v)?Fx(v,vo(_,1,ni,!0)):[]}),Ofe=Yn(function(v,_){var I=Yl(_);return ni(I)&&(I=t),ni(v)?Fx(v,vo(_,1,ni,!0),fn(I,2)):[]}),Ffe=Yn(function(v,_){var I=Yl(_);return ni(I)&&(I=t),ni(v)?Fx(v,vo(_,1,ni,!0),t,I):[]});function Lfe(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),Kl(v,_<0?0:_,P)):[]}function zfe(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),_=P-_,Kl(v,0,_<0?0:_)):[]}function Bfe(v,_){return v&&v.length?Ak(v,fn(_,3),!0,!0):[]}function Vfe(v,_){return v&&v.length?Ak(v,fn(_,3),!0):[]}function Ufe(v,_,I,P){var V=v==null?0:v.length;return V?(I&&typeof I!="number"&&la(v,_,I)&&(I=0,P=V),Phe(v,_,I,P)):[]}function _W(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Wn(I);return V<0&&(V=zi(P+V,0)),Jp(v,fn(_,3),V)}function SW(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=P-1;return I!==t&&(V=Wn(I),V=I<0?zi(P+V,0):$o(V,P-1)),Jp(v,fn(_,3),V,!0)}function CW(v){var _=v==null?0:v.length;return _?vo(v,1):[]}function Wfe(v){var _=v==null?0:v.length;return _?vo(v,X):[]}function Gfe(v,_){var I=v==null?0:v.length;return I?(_=_===t?1:Wn(_),vo(v,_)):[]}function Hfe(v){for(var _=-1,I=v==null?0:v.length,P={};++_<I;){var V=v[_];P[V[0]]=V[1]}return P}function kW(v){return v&&v.length?v[0]:t}function jfe(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Wn(I);return V<0&&(V=zi(P+V,0)),T(v,_,V)}function qfe(v){var _=v==null?0:v.length;return _?Kl(v,0,-1):[]}var Xfe=Yn(function(v){var _=Vr(v,MR);return _.length&&_[0]===v[0]?wR(_):[]}),Kfe=Yn(function(v){var _=Yl(v),I=Vr(v,MR);return _===Yl(I)?_=t:I.pop(),I.length&&I[0]===v[0]?wR(I,fn(_,2)):[]}),Yfe=Yn(function(v){var _=Yl(v),I=Vr(v,MR);return _=typeof _=="function"?_:t,_&&I.pop(),I.length&&I[0]===v[0]?wR(I,t,_):[]});function Zfe(v,_){return v==null?"":que.call(v,_)}function Yl(v){var _=v==null?0:v.length;return _?v[_-1]:t}function Jfe(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=P;return I!==t&&(V=Wn(I),V=V<0?zi(P+V,0):$o(V,P-1)),_===_?Nue(v,_,V):Jp(v,L,V,!0)}function Qfe(v,_){return v&&v.length?OU(v,Wn(_)):t}var ede=Yn(TW);function TW(v,_){return v&&v.length&&_&&_.length?CR(v,_):v}function tde(v,_,I){return v&&v.length&&_&&_.length?CR(v,_,fn(I,2)):v}function nde(v,_,I){return v&&v.length&&_&&_.length?CR(v,_,t,I):v}var rde=tf(function(v,_){var I=v==null?0:v.length,P=gR(v,_);return zU(v,Vr(_,function(V){return nf(V,I)?+V:V}).sort(KU)),P});function sde(v,_){var I=[];if(!(v&&v.length))return I;var P=-1,V=[],K=v.length;for(_=fn(_,3);++P<K;){var le=v[P];_(le,P,v)&&(I.push(le),V.push(P))}return zU(v,V),I}function GR(v){return v==null?v:Zue.call(v)}function ide(v,_,I){var P=v==null?0:v.length;return P?(I&&typeof I!="number"&&la(v,_,I)?(_=0,I=P):(_=_==null?0:Wn(_),I=I===t?P:Wn(I)),Kl(v,_,I)):[]}function ode(v,_){return Ik(v,_)}function ade(v,_,I){return ER(v,_,fn(I,2))}function lde(v,_){var I=v==null?0:v.length;if(I){var P=Ik(v,_);if(P<I&&jc(v[P],_))return P}return-1}function cde(v,_){return Ik(v,_,!0)}function ude(v,_,I){return ER(v,_,fn(I,2),!0)}function hde(v,_){var I=v==null?0:v.length;if(I){var P=Ik(v,_,!0)-1;if(jc(v[P],_))return P}return-1}function fde(v){return v&&v.length?VU(v):[]}function dde(v,_){return v&&v.length?VU(v,fn(_,2)):[]}function pde(v){var _=v==null?0:v.length;return _?Kl(v,1,_):[]}function mde(v,_,I){return v&&v.length?(_=I||_===t?1:Wn(_),Kl(v,0,_<0?0:_)):[]}function gde(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),_=P-_,Kl(v,_<0?0:_,P)):[]}function yde(v,_){return v&&v.length?Ak(v,fn(_,3),!1,!0):[]}function bde(v,_){return v&&v.length?Ak(v,fn(_,3)):[]}var vde=Yn(function(v){return hd(vo(v,1,ni,!0))}),wde=Yn(function(v){var _=Yl(v);return ni(_)&&(_=t),hd(vo(v,1,ni,!0),fn(_,2))}),xde=Yn(function(v){var _=Yl(v);return _=typeof _=="function"?_:t,hd(vo(v,1,ni,!0),t,_)});function _de(v){return v&&v.length?hd(v):[]}function Sde(v,_){return v&&v.length?hd(v,fn(_,2)):[]}function Cde(v,_){return _=typeof _=="function"?_:t,v&&v.length?hd(v,t,_):[]}function HR(v){if(!(v&&v.length))return[];var _=0;return v=Wc(v,function(I){if(ni(I))return _=zi(I.length,_),!0}),ht(_,function(I){return Vr(v,ne(I))})}function EW(v,_){if(!(v&&v.length))return[];var I=HR(v);return _==null?I:Vr(I,function(P){return Mo(_,t,P)})}var kde=Yn(function(v,_){return ni(v)?Fx(v,_):[]}),Tde=Yn(function(v){return AR(Wc(v,ni))}),Ede=Yn(function(v){var _=Yl(v);return ni(_)&&(_=t),AR(Wc(v,ni),fn(_,2))}),Ide=Yn(function(v){var _=Yl(v);return _=typeof _=="function"?_:t,AR(Wc(v,ni),t,_)}),Ade=Yn(HR);function Mde(v,_){return HU(v||[],_||[],Ox)}function Nde(v,_){return HU(v||[],_||[],Bx)}var $de=Yn(function(v){var _=v.length,I=_>1?v[_-1]:t;return I=typeof I=="function"?(v.pop(),I):t,EW(v,I)});function IW(v){var _=q(v);return _.__chain__=!0,_}function Rde(v,_){return _(v),v}function Lk(v,_){return _(v)}var Pde=tf(function(v){var _=v.length,I=_?v[0]:0,P=this.__wrapped__,V=function(K){return gR(K,v)};return _>1||this.__actions__.length||!(P instanceof sr)||!nf(I)?this.thru(V):(P=P.slice(I,+I+(_?1:0)),P.__actions__.push({func:Lk,args:[V],thisArg:t}),new ql(P,this.__chain__).thru(function(K){return _&&!K.length&&K.push(t),K}))});function Dde(){return IW(this)}function Ode(){return new ql(this.value(),this.__chain__)}function Fde(){this.__values__===t&&(this.__values__=UW(this.value()));var v=this.__index__>=this.__values__.length,_=v?t:this.__values__[this.__index__++];return{done:v,value:_}}function Lde(){return this}function zde(v){for(var _,I=this;I instanceof Sk;){var P=xW(I);P.__index__=0,P.__values__=t,_?V.__wrapped__=P:_=P;var V=P;I=I.__wrapped__}return V.__wrapped__=v,_}function Bde(){var v=this.__wrapped__;if(v instanceof sr){var _=v;return this.__actions__.length&&(_=new sr(this)),_=_.reverse(),_.__actions__.push({func:Lk,args:[GR],thisArg:t}),new ql(_,this.__chain__)}return this.thru(GR)}function Vde(){return GU(this.__wrapped__,this.__actions__)}var Ude=Mk(function(v,_,I){Pr.call(v,I)?++v[I]:Qh(v,I,1)});function Wde(v,_,I){var P=On(v)?lk:Rhe;return I&&la(v,_,I)&&(_=t),P(v,fn(_,3))}function Gde(v,_){var I=On(v)?Wc:EU;return I(v,fn(_,3))}var Hde=tW(_W),jde=tW(SW);function qde(v,_){return vo(zk(v,_),1)}function Xde(v,_){return vo(zk(v,_),X)}function Kde(v,_,I){return I=I===t?1:Wn(I),vo(zk(v,_),I)}function AW(v,_){var I=On(v)?$a:ud;return I(v,fn(_,3))}function MW(v,_){var I=On(v)?iR:TU;return I(v,fn(_,3))}var Yde=Mk(function(v,_,I){Pr.call(v,I)?v[I].push(_):Qh(v,I,[_])});function Zde(v,_,I,P){v=Da(v)?v:N0(v),I=I&&!P?Wn(I):0;var V=v.length;return I<0&&(I=zi(V+I,0)),Gk(v)?I<=V&&v.indexOf(_,I)>-1:!!V&&T(v,_,I)>-1}var Jde=Yn(function(v,_,I){var P=-1,V=typeof _=="function",K=Da(v)?Le(v.length):[];return ud(v,function(le){K[++P]=V?Mo(_,le,I):Lx(le,_,I)}),K}),Qde=Mk(function(v,_,I){Qh(v,I,_)});function zk(v,_){var I=On(v)?Vr:RU;return I(v,fn(_,3))}function epe(v,_,I,P){return v==null?[]:(On(_)||(_=_==null?[]:[_]),I=P?t:I,On(I)||(I=I==null?[]:[I]),FU(v,_,I))}var tpe=Mk(function(v,_,I){v[I?0:1].push(_)},function(){return[[],[]]});function npe(v,_,I){var P=On(v)?Ix:ie,V=arguments.length<3;return P(v,fn(_,4),I,V,ud)}function rpe(v,_,I){var P=On(v)?oR:ie,V=arguments.length<3;return P(v,fn(_,4),I,V,TU)}function spe(v,_){var I=On(v)?Wc:EU;return I(v,Uk(fn(_,3)))}function ipe(v){var _=On(v)?_U:Zhe;return _(v)}function ope(v,_,I){(I?la(v,_,I):_===t)?_=1:_=Wn(_);var P=On(v)?Ihe:Jhe;return P(v,_)}function ape(v){var _=On(v)?Ahe:efe;return _(v)}function lpe(v){if(v==null)return 0;if(Da(v))return Gk(v)?x0(v):v.length;var _=Ro(v);return _==Be||_==ye?v.size:_R(v).length}function cpe(v,_,I){var P=On(v)?ld:tfe;return I&&la(v,_,I)&&(_=t),P(v,fn(_,3))}var upe=Yn(function(v,_){if(v==null)return[];var I=_.length;return I>1&&la(v,_[0],_[1])?_=[]:I>2&&la(_[0],_[1],_[2])&&(_=[_[0]]),FU(v,vo(_,1),[])}),Bk=Gue||function(){return mi.Date.now()};function hpe(v,_){if(typeof _!="function")throw new jl(o);return v=Wn(v),function(){if(--v<1)return _.apply(this,arguments)}}function NW(v,_,I){return _=I?t:_,_=v&&_==null?v.length:_,ef(v,k,t,t,t,t,_)}function $W(v,_){var I;if(typeof _!="function")throw new jl(o);return v=Wn(v),function(){return--v>0&&(I=_.apply(this,arguments)),v<=1&&(_=t),I}}var jR=Yn(function(v,_,I){var P=g;if(I.length){var V=Yu(I,A0(jR));P|=S}return ef(v,P,_,I,V)}),RW=Yn(function(v,_,I){var P=g|y;if(I.length){var V=Yu(I,A0(RW));P|=S}return ef(_,P,v,I,V)});function PW(v,_,I){_=I?t:_;var P=ef(v,x,t,t,t,t,t,_);return P.placeholder=PW.placeholder,P}function DW(v,_,I){_=I?t:_;var P=ef(v,w,t,t,t,t,t,_);return P.placeholder=DW.placeholder,P}function OW(v,_,I){var P,V,K,le,xe,Me,Qe=0,et=!1,lt=!1,Ft=!0;if(typeof v!="function")throw new jl(o);_=Zl(_)||0,Ps(I)&&(et=!!I.leading,lt="maxWait"in I,K=lt?zi(Zl(I.maxWait)||0,_):K,Ft="trailing"in I?!!I.trailing:Ft);function tn(ri){var qc=P,of=V;return P=V=t,Qe=ri,le=v.apply(of,qc),le}function mn(ri){return Qe=ri,xe=Wx(tr,_),et?tn(ri):le}function Xn(ri){var qc=ri-Me,of=ri-Qe,tG=_-qc;return lt?$o(tG,K-of):tG}function gn(ri){var qc=ri-Me,of=ri-Qe;return Me===t||qc>=_||qc<0||lt&&of>=K}function tr(){var ri=Bk();if(gn(ri))return hr(ri);xe=Wx(tr,Xn(ri))}function hr(ri){return xe=t,Ft&&P?tn(ri):(P=V=t,le)}function ul(){xe!==t&&jU(xe),Qe=0,P=Me=V=xe=t}function ca(){return xe===t?le:hr(Bk())}function hl(){var ri=Bk(),qc=gn(ri);if(P=arguments,V=this,Me=ri,qc){if(xe===t)return mn(Me);if(lt)return jU(xe),xe=Wx(tr,_),tn(Me)}return xe===t&&(xe=Wx(tr,_)),le}return hl.cancel=ul,hl.flush=ca,hl}var fpe=Yn(function(v,_){return kU(v,1,_)}),dpe=Yn(function(v,_,I){return kU(v,Zl(_)||0,I)});function ppe(v){return ef(v,M)}function Vk(v,_){if(typeof v!="function"||_!=null&&typeof _!="function")throw new jl(o);var I=function(){var P=arguments,V=_?_.apply(this,P):P[0],K=I.cache;if(K.has(V))return K.get(V);var le=v.apply(this,P);return I.cache=K.set(V,le)||K,le};return I.cache=new(Vk.Cache||Jh),I}Vk.Cache=Jh;function Uk(v){if(typeof v!="function")throw new jl(o);return function(){var _=arguments;switch(_.length){case 0:return!v.call(this);case 1:return!v.call(this,_[0]);case 2:return!v.call(this,_[0],_[1]);case 3:return!v.call(this,_[0],_[1],_[2])}return!v.apply(this,_)}}function mpe(v){return $W(2,v)}var gpe=nfe(function(v,_){_=_.length==1&&On(_[0])?Vr(_[0],Ut(fn())):Vr(vo(_,1),Ut(fn()));var I=_.length;return Yn(function(P){for(var V=-1,K=$o(P.length,I);++V<K;)P[V]=_[V].call(this,P[V]);return Mo(v,this,P)})}),qR=Yn(function(v,_){var I=Yu(_,A0(qR));return ef(v,S,t,_,I)}),FW=Yn(function(v,_){var I=Yu(_,A0(FW));return ef(v,C,t,_,I)}),ype=tf(function(v,_){return ef(v,A,t,t,t,_)});function bpe(v,_){if(typeof v!="function")throw new jl(o);return _=_===t?_:Wn(_),Yn(v,_)}function vpe(v,_){if(typeof v!="function")throw new jl(o);return _=_==null?0:zi(Wn(_),0),Yn(function(I){var P=I[_],V=dd(I,0,_);return P&&Xu(V,P),Mo(v,this,V)})}function wpe(v,_,I){var P=!0,V=!0;if(typeof v!="function")throw new jl(o);return Ps(I)&&(P="leading"in I?!!I.leading:P,V="trailing"in I?!!I.trailing:V),OW(v,_,{leading:P,maxWait:_,trailing:V})}function xpe(v){return NW(v,1)}function _pe(v,_){return qR(NR(_),v)}function Spe(){if(!arguments.length)return[];var v=arguments[0];return On(v)?v:[v]}function Cpe(v){return Xl(v,d)}function kpe(v,_){return _=typeof _=="function"?_:t,Xl(v,d,_)}function Tpe(v){return Xl(v,h|d)}function Epe(v,_){return _=typeof _=="function"?_:t,Xl(v,h|d,_)}function Ipe(v,_){return _==null||CU(v,_,to(_))}function jc(v,_){return v===_||v!==v&&_!==_}var Ape=Pk(vR),Mpe=Pk(function(v,_){return v>=_}),om=MU(function(){return arguments}())?MU:function(v){return Ws(v)&&Pr.call(v,"callee")&&!gU.call(v,"callee")},On=Le.isArray,Npe=ik?Ut(ik):zhe;function Da(v){return v!=null&&Wk(v.length)&&!rf(v)}function ni(v){return Ws(v)&&Da(v)}function $pe(v){return v===!0||v===!1||Ws(v)&&aa(v)==it}var pd=jue||s3,Rpe=Tx?Ut(Tx):Bhe;function Ppe(v){return Ws(v)&&v.nodeType===1&&!Gx(v)}function Dpe(v){if(v==null)return!0;if(Da(v)&&(On(v)||typeof v=="string"||typeof v.splice=="function"||pd(v)||M0(v)||om(v)))return!v.length;var _=Ro(v);if(_==Be||_==ye)return!v.size;if(Ux(v))return!_R(v).length;for(var I in v)if(Pr.call(v,I))return!1;return!0}function Ope(v,_){return zx(v,_)}function Fpe(v,_,I){I=typeof I=="function"?I:t;var P=I?I(v,_):t;return P===t?zx(v,_,t,I):!!P}function XR(v){if(!Ws(v))return!1;var _=aa(v);return _==ct||_==dt||typeof v.message=="string"&&typeof v.name=="string"&&!Gx(v)}function Lpe(v){return typeof v=="number"&&bU(v)}function rf(v){if(!Ps(v))return!1;var _=aa(v);return _==Ve||_==ze||_==Oe||_==rt}function LW(v){return typeof v=="number"&&v==Wn(v)}function Wk(v){return typeof v=="number"&&v>-1&&v%1==0&&v<=G}function Ps(v){var _=typeof v;return v!=null&&(_=="object"||_=="function")}function Ws(v){return v!=null&&typeof v=="object"}var zW=ok?Ut(ok):Uhe;function zpe(v,_){return v===_||xR(v,_,LR(_))}function Bpe(v,_,I){return I=typeof I=="function"?I:t,xR(v,_,LR(_),I)}function Vpe(v){return BW(v)&&v!=+v}function Upe(v){if(kfe(v))throw new Pn(i);return NU(v)}function Wpe(v){return v===null}function Gpe(v){return v==null}function BW(v){return typeof v=="number"||Ws(v)&&aa(v)==ut}function Gx(v){if(!Ws(v)||aa(v)!=ee)return!1;var _=gk(v);if(_===null)return!0;var I=Pr.call(_,"constructor")&&_.constructor;return typeof I=="function"&&I instanceof I&&fk.call(I)==Bue}var KR=ak?Ut(ak):Whe;function Hpe(v){return LW(v)&&v>=-G&&v<=G}var VW=g0?Ut(g0):Ghe;function Gk(v){return typeof v=="string"||!On(v)&&Ws(v)&&aa(v)==Ze}function cl(v){return typeof v=="symbol"||Ws(v)&&aa(v)==yt}var M0=y0?Ut(y0):Hhe;function jpe(v){return v===t}function qpe(v){return Ws(v)&&Ro(v)==ft}function Xpe(v){return Ws(v)&&aa(v)==ce}var Kpe=Pk(SR),Ype=Pk(function(v,_){return v<=_});function UW(v){if(!v)return[];if(Da(v))return Gk(v)?Gc(v):Pa(v);if(Nx&&v[Nx])return uR(v[Nx]());var _=Ro(v),I=_==Be?Mx:_==ye?v0:N0;return I(v)}function sf(v){if(!v)return v===0?v:0;if(v=Zl(v),v===X||v===-X){var _=v<0?-1:1;return _*te}return v===v?v:0}function Wn(v){var _=sf(v),I=_%1;return _===_?I?_-I:_:0}function WW(v){return v?nm(Wn(v),0,ae):0}function Zl(v){if(typeof v=="number")return v;if(cl(v))return ge;if(Ps(v)){var _=typeof v.valueOf=="function"?v.valueOf():v;v=Ps(_)?_+"":_}if(typeof v!="string")return v===0?v:+v;v=hn(v);var I=Io.test(v);return I||yo.test(v)?rR(v.slice(2),I?2:8):Ar.test(v)?ge:+v}function GW(v){return Ju(v,Oa(v))}function Zpe(v){return v?nm(Wn(v),-G,G):v===0?v:0}function Mr(v){return v==null?"":ll(v)}var Jpe=E0(function(v,_){if(Ux(_)||Da(_)){Ju(_,to(_),v);return}for(var I in _)Pr.call(_,I)&&Ox(v,I,_[I])}),HW=E0(function(v,_){Ju(_,Oa(_),v)}),Hk=E0(function(v,_,I,P){Ju(_,Oa(_),v,P)}),Qpe=E0(function(v,_,I,P){Ju(_,to(_),v,P)}),eme=tf(gR);function tme(v,_){var I=T0(v);return _==null?I:SU(I,_)}var nme=Yn(function(v,_){v=Jr(v);var I=-1,P=_.length,V=P>2?_[2]:t;for(V&&la(_[0],_[1],V)&&(P=1);++I<P;)for(var K=_[I],le=Oa(K),xe=-1,Me=le.length;++xe<Me;){var Qe=le[xe],et=v[Qe];(et===t||jc(et,S0[Qe])&&!Pr.call(v,Qe))&&(v[Qe]=K[Qe])}return v}),rme=Yn(function(v){return v.push(t,lW),Mo(jW,t,v)});function sme(v,_){return Ax(v,fn(_,3),Zu)}function ime(v,_){return Ax(v,fn(_,3),bR)}function ome(v,_){return v==null?v:yR(v,fn(_,3),Oa)}function ame(v,_){return v==null?v:IU(v,fn(_,3),Oa)}function lme(v,_){return v&&Zu(v,fn(_,3))}function cme(v,_){return v&&bR(v,fn(_,3))}function ume(v){return v==null?[]:Tk(v,to(v))}function hme(v){return v==null?[]:Tk(v,Oa(v))}function YR(v,_,I){var P=v==null?t:rm(v,_);return P===t?I:P}function fme(v,_){return v!=null&&hW(v,_,Dhe)}function ZR(v,_){return v!=null&&hW(v,_,Ohe)}var dme=rW(function(v,_,I){_!=null&&typeof _.toString!="function"&&(_=dk.call(_)),v[_]=I},QR(Fa)),pme=rW(function(v,_,I){_!=null&&typeof _.toString!="function"&&(_=dk.call(_)),Pr.call(v,_)?v[_].push(I):v[_]=[I]},fn),mme=Yn(Lx);function to(v){return Da(v)?xU(v):_R(v)}function Oa(v){return Da(v)?xU(v,!0):jhe(v)}function gme(v,_){var I={};return _=fn(_,3),Zu(v,function(P,V,K){Qh(I,_(P,V,K),P)}),I}function yme(v,_){var I={};return _=fn(_,3),Zu(v,function(P,V,K){Qh(I,V,_(P,V,K))}),I}var bme=E0(function(v,_,I){Ek(v,_,I)}),jW=E0(function(v,_,I,P){Ek(v,_,I,P)}),vme=tf(function(v,_){var I={};if(v==null)return I;var P=!1;_=Vr(_,function(K){return K=fd(K,v),P||(P=K.length>1),K}),Ju(v,OR(v),I),P&&(I=Xl(I,h|f|d,dfe));for(var V=_.length;V--;)IR(I,_[V]);return I});function wme(v,_){return qW(v,Uk(fn(_)))}var xme=tf(function(v,_){return v==null?{}:Xhe(v,_)});function qW(v,_){if(v==null)return{};var I=Vr(OR(v),function(P){return[P]});return _=fn(_),LU(v,I,function(P,V){return _(P,V[0])})}function _me(v,_,I){_=fd(_,v);var P=-1,V=_.length;for(V||(V=1,v=t);++P<V;){var K=v==null?t:v[Qu(_[P])];K===t&&(P=V,K=I),v=rf(K)?K.call(v):K}return v}function Sme(v,_,I){return v==null?v:Bx(v,_,I)}function Cme(v,_,I,P){return P=typeof P=="function"?P:t,v==null?v:Bx(v,_,I,P)}var XW=oW(to),KW=oW(Oa);function kme(v,_,I){var P=On(v),V=P||pd(v)||M0(v);if(_=fn(_,4),I==null){var K=v&&v.constructor;V?I=P?new K:[]:Ps(v)?I=rf(K)?T0(gk(v)):{}:I={}}return(V?$a:Zu)(v,function(le,xe,Me){return _(I,le,xe,Me)}),I}function Tme(v,_){return v==null?!0:IR(v,_)}function Eme(v,_,I){return v==null?v:WU(v,_,NR(I))}function Ime(v,_,I,P){return P=typeof P=="function"?P:t,v==null?v:WU(v,_,NR(I),P)}function N0(v){return v==null?[]:Rt(v,to(v))}function Ame(v){return v==null?[]:Rt(v,Oa(v))}function Mme(v,_,I){return I===t&&(I=_,_=t),I!==t&&(I=Zl(I),I=I===I?I:0),_!==t&&(_=Zl(_),_=_===_?_:0),nm(Zl(v),_,I)}function Nme(v,_,I){return _=sf(_),I===t?(I=_,_=0):I=sf(I),v=Zl(v),Fhe(v,_,I)}function $me(v,_,I){if(I&&typeof I!="boolean"&&la(v,_,I)&&(_=I=t),I===t&&(typeof _=="boolean"?(I=_,_=t):typeof v=="boolean"&&(I=v,v=t)),v===t&&_===t?(v=0,_=1):(v=sf(v),_===t?(_=v,v=0):_=sf(_)),v>_){var P=v;v=_,_=P}if(I||v%1||_%1){var V=vU();return $o(v+V*(_-v+kx("1e-"+((V+"").length-1))),_)}return kR(v,_)}var Rme=I0(function(v,_,I){return _=_.toLowerCase(),v+(I?YW(_):_)});function YW(v){return JR(Mr(v).toLowerCase())}function ZW(v){return v=Mr(v),v&&v.replace(Ns,Fi).replace(_x,"")}function Pme(v,_,I){v=Mr(v),_=ll(_);var P=v.length;I=I===t?P:nm(Wn(I),0,P);var V=I;return I-=_.length,I>=0&&v.slice(I,V)==_}function Dme(v){return v=Mr(v),v&&Uh.test(v)?v.replace(zc,Ra):v}function Ome(v){return v=Mr(v),v&&zn.test(v)?v.replace(vt,"\\$&"):v}var Fme=I0(function(v,_,I){return v+(I?"-":"")+_.toLowerCase()}),Lme=I0(function(v,_,I){return v+(I?" ":"")+_.toLowerCase()}),zme=eW("toLowerCase");function Bme(v,_,I){v=Mr(v),_=Wn(_);var P=_?x0(v):0;if(!_||P>=_)return v;var V=(_-P)/2;return Rk(wk(V),I)+v+Rk(vk(V),I)}function Vme(v,_,I){v=Mr(v),_=Wn(_);var P=_?x0(v):0;return _&&P<_?v+Rk(_-P,I):v}function Ume(v,_,I){v=Mr(v),_=Wn(_);var P=_?x0(v):0;return _&&P<_?Rk(_-P,I)+v:v}function Wme(v,_,I){return I||_==null?_=0:_&&(_=+_),Yue(Mr(v).replace(sn,""),_||0)}function Gme(v,_,I){return(I?la(v,_,I):_===t)?_=1:_=Wn(_),TR(Mr(v),_)}function Hme(){var v=arguments,_=Mr(v[0]);return v.length<3?_:_.replace(v[1],v[2])}var jme=I0(function(v,_,I){return v+(I?"_":"")+_.toLowerCase()});function qme(v,_,I){return I&&typeof I!="number"&&la(v,_,I)&&(_=I=t),I=I===t?ae:I>>>0,I?(v=Mr(v),v&&(typeof _=="string"||_!=null&&!KR(_))&&(_=ll(_),!_&&xs(v))?dd(Gc(v),0,I):v.split(_,I)):[]}var Xme=I0(function(v,_,I){return v+(I?" ":"")+JR(_)});function Kme(v,_,I){return v=Mr(v),I=I==null?0:nm(Wn(I),0,v.length),_=ll(_),v.slice(I,I+_.length)==_}function Yme(v,_,I){var P=q.templateSettings;I&&la(v,_,I)&&(_=t),v=Mr(v),_=Hk({},_,P,aW);var V=Hk({},_.imports,P.imports,aW),K=to(V),le=Rt(V,K),xe,Me,Qe=0,et=_.interpolate||bo,lt="__p += '",Ft=hR((_.escape||bo).source+"|"+et.source+"|"+(et===re?xr:bo).source+"|"+(_.evaluate||bo).source+"|$","g"),tn="//# sourceURL="+(Pr.call(_,"sourceURL")?(_.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++nR+"]")+`
`;v.replace(Ft,function(gn,tr,hr,ul,ca,hl){return hr||(hr=ul),lt+=v.slice(Qe,hl).replace(Gh,No),tr&&(xe=!0,lt+=`' +
__e(`+tr+`) +
'`),ca&&(Me=!0,lt+=`';
`+ca+`;
__p += '`),hr&&(lt+=`' +
((__t = (`+hr+`)) == null ? '' : __t) +
'`),Qe=hl+gn.length,gn}),lt+=`';
`;var mn=Pr.call(_,"variable")&&_.variable;if(!mn)lt=`with (obj) {
`+lt+`
}
`;else if(ur.test(mn))throw new Pn(a);lt=(Me?lt.replace(Wl,""):lt).replace(go,"$1").replace(Gl,"$1;"),lt="function("+(mn||"obj")+`) {
`+(mn?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(xe?", __e = _.escape":"")+(Me?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+lt+`return __p
}`;var Xn=QW(function(){return Er(K,tn+"return "+lt).apply(t,le)});if(Xn.source=lt,XR(Xn))throw Xn;return Xn}function Zme(v){return Mr(v).toLowerCase()}function Jme(v){return Mr(v).toUpperCase()}function Qme(v,_,I){if(v=Mr(v),v&&(I||_===t))return hn(v);if(!v||!(_=ll(_)))return v;var P=Gc(v),V=Gc(_),K=Bn(P,V),le=Ur(P,V)+1;return dd(P,K,le).join("")}function ege(v,_,I){if(v=Mr(v),v&&(I||_===t))return v.slice(0,fU(v)+1);if(!v||!(_=ll(_)))return v;var P=Gc(v),V=Ur(P,Gc(_))+1;return dd(P,0,V).join("")}function tge(v,_,I){if(v=Mr(v),v&&(I||_===t))return v.replace(sn,"");if(!v||!(_=ll(_)))return v;var P=Gc(v),V=Bn(P,Gc(_));return dd(P,V).join("")}function nge(v,_){var I=E,P=N;if(Ps(_)){var V="separator"in _?_.separator:V;I="length"in _?Wn(_.length):I,P="omission"in _?ll(_.omission):P}v=Mr(v);var K=v.length;if(xs(v)){var le=Gc(v);K=le.length}if(I>=K)return v;var xe=I-x0(P);if(xe<1)return P;var Me=le?dd(le,0,xe).join(""):v.slice(0,xe);if(V===t)return Me+P;if(le&&(xe+=Me.length-xe),KR(V)){if(v.slice(xe).search(V)){var Qe,et=Me;for(V.global||(V=hR(V.source,Mr(Zi.exec(V))+"g")),V.lastIndex=0;Qe=V.exec(et);)var lt=Qe.index;Me=Me.slice(0,lt===t?xe:lt)}}else if(v.indexOf(ll(V),xe)!=xe){var Ft=Me.lastIndexOf(V);Ft>-1&&(Me=Me.slice(0,Ft))}return Me+P}function rge(v){return v=Mr(v),v&&Di.test(v)?v.replace(Lc,$ue):v}var sge=I0(function(v,_,I){return v+(I?" ":"")+_.toUpperCase()}),JR=eW("toUpperCase");function JW(v,_,I){return v=Mr(v),_=I?t:_,_===t?Ku(v)?Due(v):cR(v):v.match(_)||[]}var QW=Yn(function(v,_){try{return Mo(v,t,_)}catch(I){return XR(I)?I:new Pn(I)}}),ige=tf(function(v,_){return $a(_,function(I){I=Qu(I),Qh(v,I,jR(v[I],v))}),v});function oge(v){var _=v==null?0:v.length,I=fn();return v=_?Vr(v,function(P){if(typeof P[1]!="function")throw new jl(o);return[I(P[0]),P[1]]}):[],Yn(function(P){for(var V=-1;++V<_;){var K=v[V];if(Mo(K[0],this,P))return Mo(K[1],this,P)}})}function age(v){return $he(Xl(v,h))}function QR(v){return function(){return v}}function lge(v,_){return v==null||v!==v?_:v}var cge=nW(),uge=nW(!0);function Fa(v){return v}function e3(v){return $U(typeof v=="function"?v:Xl(v,h))}function hge(v){return PU(Xl(v,h))}function fge(v,_){return DU(v,Xl(_,h))}var dge=Yn(function(v,_){return function(I){return Lx(I,v,_)}}),pge=Yn(function(v,_){return function(I){return Lx(v,I,_)}});function t3(v,_,I){var P=to(_),V=Tk(_,P);I==null&&!(Ps(_)&&(V.length||!P.length))&&(I=_,_=v,v=this,V=Tk(_,to(_)));var K=!(Ps(I)&&"chain"in I)||!!I.chain,le=rf(v);return $a(V,function(xe){var Me=_[xe];v[xe]=Me,le&&(v.prototype[xe]=function(){var Qe=this.__chain__;if(K||Qe){var et=v(this.__wrapped__),lt=et.__actions__=Pa(this.__actions__);return lt.push({func:Me,args:arguments,thisArg:v}),et.__chain__=Qe,et}return Me.apply(v,Xu([this.value()],arguments))})}),v}function mge(){return mi._===this&&(mi._=Vue),this}function n3(){}function gge(v){return v=Wn(v),Yn(function(_){return OU(_,v)})}var yge=RR(Vr),bge=RR(lk),vge=RR(ld);function eG(v){return BR(v)?ne(Qu(v)):Khe(v)}function wge(v){return function(_){return v==null?t:rm(v,_)}}var xge=sW(),_ge=sW(!0);function r3(){return[]}function s3(){return!1}function Sge(){return{}}function Cge(){return""}function kge(){return!0}function Tge(v,_){if(v=Wn(v),v<1||v>G)return[];var I=ae,P=$o(v,ae);_=fn(_),v-=ae;for(var V=ht(P,_);++I<v;)_(I);return V}function Ege(v){return On(v)?Vr(v,Qu):cl(v)?[v]:Pa(wW(Mr(v)))}function Ige(v){var _=++zue;return Mr(v)+_}var Age=$k(function(v,_){return v+_},0),Mge=PR("ceil"),Nge=$k(function(v,_){return v/_},1),$ge=PR("floor");function Rge(v){return v&&v.length?kk(v,Fa,vR):t}function Pge(v,_){return v&&v.length?kk(v,fn(_,2),vR):t}function Dge(v){return W(v,Fa)}function Oge(v,_){return W(v,fn(_,2))}function Fge(v){return v&&v.length?kk(v,Fa,SR):t}function Lge(v,_){return v&&v.length?kk(v,fn(_,2),SR):t}var zge=$k(function(v,_){return v*_},1),Bge=PR("round"),Vge=$k(function(v,_){return v-_},0);function Uge(v){return v&&v.length?Pe(v,Fa):0}function Wge(v,_){return v&&v.length?Pe(v,fn(_,2)):0}return q.after=hpe,q.ary=NW,q.assign=Jpe,q.assignIn=HW,q.assignInWith=Hk,q.assignWith=Qpe,q.at=eme,q.before=$W,q.bind=jR,q.bindAll=ige,q.bindKey=RW,q.castArray=Spe,q.chain=IW,q.chunk=$fe,q.compact=Rfe,q.concat=Pfe,q.cond=oge,q.conforms=age,q.constant=QR,q.countBy=Ude,q.create=tme,q.curry=PW,q.curryRight=DW,q.debounce=OW,q.defaults=nme,q.defaultsDeep=rme,q.defer=fpe,q.delay=dpe,q.difference=Dfe,q.differenceBy=Ofe,q.differenceWith=Ffe,q.drop=Lfe,q.dropRight=zfe,q.dropRightWhile=Bfe,q.dropWhile=Vfe,q.fill=Ufe,q.filter=Gde,q.flatMap=qde,q.flatMapDeep=Xde,q.flatMapDepth=Kde,q.flatten=CW,q.flattenDeep=Wfe,q.flattenDepth=Gfe,q.flip=ppe,q.flow=cge,q.flowRight=uge,q.fromPairs=Hfe,q.functions=ume,q.functionsIn=hme,q.groupBy=Yde,q.initial=qfe,q.intersection=Xfe,q.intersectionBy=Kfe,q.intersectionWith=Yfe,q.invert=dme,q.invertBy=pme,q.invokeMap=Jde,q.iteratee=e3,q.keyBy=Qde,q.keys=to,q.keysIn=Oa,q.map=zk,q.mapKeys=gme,q.mapValues=yme,q.matches=hge,q.matchesProperty=fge,q.memoize=Vk,q.merge=bme,q.mergeWith=jW,q.method=dge,q.methodOf=pge,q.mixin=t3,q.negate=Uk,q.nthArg=gge,q.omit=vme,q.omitBy=wme,q.once=mpe,q.orderBy=epe,q.over=yge,q.overArgs=gpe,q.overEvery=bge,q.overSome=vge,q.partial=qR,q.partialRight=FW,q.partition=tpe,q.pick=xme,q.pickBy=qW,q.property=eG,q.propertyOf=wge,q.pull=ede,q.pullAll=TW,q.pullAllBy=tde,q.pullAllWith=nde,q.pullAt=rde,q.range=xge,q.rangeRight=_ge,q.rearg=ype,q.reject=spe,q.remove=sde,q.rest=bpe,q.reverse=GR,q.sampleSize=ope,q.set=Sme,q.setWith=Cme,q.shuffle=ape,q.slice=ide,q.sortBy=upe,q.sortedUniq=fde,q.sortedUniqBy=dde,q.split=qme,q.spread=vpe,q.tail=pde,q.take=mde,q.takeRight=gde,q.takeRightWhile=yde,q.takeWhile=bde,q.tap=Rde,q.throttle=wpe,q.thru=Lk,q.toArray=UW,q.toPairs=XW,q.toPairsIn=KW,q.toPath=Ege,q.toPlainObject=GW,q.transform=kme,q.unary=xpe,q.union=vde,q.unionBy=wde,q.unionWith=xde,q.uniq=_de,q.uniqBy=Sde,q.uniqWith=Cde,q.unset=Tme,q.unzip=HR,q.unzipWith=EW,q.update=Eme,q.updateWith=Ime,q.values=N0,q.valuesIn=Ame,q.without=kde,q.words=JW,q.wrap=_pe,q.xor=Tde,q.xorBy=Ede,q.xorWith=Ide,q.zip=Ade,q.zipObject=Mde,q.zipObjectDeep=Nde,q.zipWith=$de,q.entries=XW,q.entriesIn=KW,q.extend=HW,q.extendWith=Hk,t3(q,q),q.add=Age,q.attempt=QW,q.camelCase=Rme,q.capitalize=YW,q.ceil=Mge,q.clamp=Mme,q.clone=Cpe,q.cloneDeep=Tpe,q.cloneDeepWith=Epe,q.cloneWith=kpe,q.conformsTo=Ipe,q.deburr=ZW,q.defaultTo=lge,q.divide=Nge,q.endsWith=Pme,q.eq=jc,q.escape=Dme,q.escapeRegExp=Ome,q.every=Wde,q.find=Hde,q.findIndex=_W,q.findKey=sme,q.findLast=jde,q.findLastIndex=SW,q.findLastKey=ime,q.floor=$ge,q.forEach=AW,q.forEachRight=MW,q.forIn=ome,q.forInRight=ame,q.forOwn=lme,q.forOwnRight=cme,q.get=YR,q.gt=Ape,q.gte=Mpe,q.has=fme,q.hasIn=ZR,q.head=kW,q.identity=Fa,q.includes=Zde,q.indexOf=jfe,q.inRange=Nme,q.invoke=mme,q.isArguments=om,q.isArray=On,q.isArrayBuffer=Npe,q.isArrayLike=Da,q.isArrayLikeObject=ni,q.isBoolean=$pe,q.isBuffer=pd,q.isDate=Rpe,q.isElement=Ppe,q.isEmpty=Dpe,q.isEqual=Ope,q.isEqualWith=Fpe,q.isError=XR,q.isFinite=Lpe,q.isFunction=rf,q.isInteger=LW,q.isLength=Wk,q.isMap=zW,q.isMatch=zpe,q.isMatchWith=Bpe,q.isNaN=Vpe,q.isNative=Upe,q.isNil=Gpe,q.isNull=Wpe,q.isNumber=BW,q.isObject=Ps,q.isObjectLike=Ws,q.isPlainObject=Gx,q.isRegExp=KR,q.isSafeInteger=Hpe,q.isSet=VW,q.isString=Gk,q.isSymbol=cl,q.isTypedArray=M0,q.isUndefined=jpe,q.isWeakMap=qpe,q.isWeakSet=Xpe,q.join=Zfe,q.kebabCase=Fme,q.last=Yl,q.lastIndexOf=Jfe,q.lowerCase=Lme,q.lowerFirst=zme,q.lt=Kpe,q.lte=Ype,q.max=Rge,q.maxBy=Pge,q.mean=Dge,q.meanBy=Oge,q.min=Fge,q.minBy=Lge,q.stubArray=r3,q.stubFalse=s3,q.stubObject=Sge,q.stubString=Cge,q.stubTrue=kge,q.multiply=zge,q.nth=Qfe,q.noConflict=mge,q.noop=n3,q.now=Bk,q.pad=Bme,q.padEnd=Vme,q.padStart=Ume,q.parseInt=Wme,q.random=$me,q.reduce=npe,q.reduceRight=rpe,q.repeat=Gme,q.replace=Hme,q.result=_me,q.round=Bge,q.runInContext=Ae,q.sample=ipe,q.size=lpe,q.snakeCase=jme,q.some=cpe,q.sortedIndex=ode,q.sortedIndexBy=ade,q.sortedIndexOf=lde,q.sortedLastIndex=cde,q.sortedLastIndexBy=ude,q.sortedLastIndexOf=hde,q.startCase=Xme,q.startsWith=Kme,q.subtract=Vge,q.sum=Uge,q.sumBy=Wge,q.template=Yme,q.times=Tge,q.toFinite=sf,q.toInteger=Wn,q.toLength=WW,q.toLower=Zme,q.toNumber=Zl,q.toSafeInteger=Zpe,q.toString=Mr,q.toUpper=Jme,q.trim=Qme,q.trimEnd=ege,q.trimStart=tge,q.truncate=nge,q.unescape=rge,q.uniqueId=Ige,q.upperCase=sge,q.upperFirst=JR,q.each=AW,q.eachRight=MW,q.first=kW,t3(q,function(){var v={};return Zu(q,function(_,I){Pr.call(q.prototype,I)||(v[I]=_)}),v}(),{chain:!1}),q.VERSION=r,$a(["bind","bindKey","curry","curryRight","partial","partialRight"],function(v){q[v].placeholder=q}),$a(["drop","take"],function(v,_){sr.prototype[v]=function(I){I=I===t?1:zi(Wn(I),0);var P=this.__filtered__&&!_?new sr(this):this.clone();return P.__filtered__?P.__takeCount__=$o(I,P.__takeCount__):P.__views__.push({size:$o(I,ae),type:v+(P.__dir__<0?"Right":"")}),P},sr.prototype[v+"Right"]=function(I){return this.reverse()[v](I).reverse()}}),$a(["filter","map","takeWhile"],function(v,_){var I=_+1,P=I==D||I==B;sr.prototype[v]=function(V){var K=this.clone();return K.__iteratees__.push({iteratee:fn(V,3),type:I}),K.__filtered__=K.__filtered__||P,K}}),$a(["head","last"],function(v,_){var I="take"+(_?"Right":"");sr.prototype[v]=function(){return this[I](1).value()[0]}}),$a(["initial","tail"],function(v,_){var I="drop"+(_?"":"Right");sr.prototype[v]=function(){return this.__filtered__?new sr(this):this[I](1)}}),sr.prototype.compact=function(){return this.filter(Fa)},sr.prototype.find=function(v){return this.filter(v).head()},sr.prototype.findLast=function(v){return this.reverse().find(v)},sr.prototype.invokeMap=Yn(function(v,_){return typeof v=="function"?new sr(this):this.map(function(I){return Lx(I,v,_)})}),sr.prototype.reject=function(v){return this.filter(Uk(fn(v)))},sr.prototype.slice=function(v,_){v=Wn(v);var I=this;return I.__filtered__&&(v>0||_<0)?new sr(I):(v<0?I=I.takeRight(-v):v&&(I=I.drop(v)),_!==t&&(_=Wn(_),I=_<0?I.dropRight(-_):I.take(_-v)),I)},sr.prototype.takeRightWhile=function(v){return this.reverse().takeWhile(v).reverse()},sr.prototype.toArray=function(){return this.take(ae)},Zu(sr.prototype,function(v,_){var I=/^(?:filter|find|map|reject)|While$/.test(_),P=/^(?:head|last)$/.test(_),V=q[P?"take"+(_=="last"?"Right":""):_],K=P||/^find/.test(_);V&&(q.prototype[_]=function(){var le=this.__wrapped__,xe=P?[1]:arguments,Me=le instanceof sr,Qe=xe[0],et=Me||On(le),lt=function(tr){var hr=V.apply(q,Xu([tr],xe));return P&&Ft?hr[0]:hr};et&&I&&typeof Qe=="function"&&Qe.length!=1&&(Me=et=!1);var Ft=this.__chain__,tn=!!this.__actions__.length,mn=K&&!Ft,Xn=Me&&!tn;if(!K&&et){le=Xn?le:new sr(this);var gn=v.apply(le,xe);return gn.__actions__.push({func:Lk,args:[lt],thisArg:t}),new ql(gn,Ft)}return mn&&Xn?v.apply(this,xe):(gn=this.thru(lt),mn?P?gn.value()[0]:gn.value():gn)})}),$a(["pop","push","shift","sort","splice","unshift"],function(v){var _=uk[v],I=/^(?:push|sort|unshift)$/.test(v)?"tap":"thru",P=/^(?:pop|shift)$/.test(v);q.prototype[v]=function(){var V=arguments;if(P&&!this.__chain__){var K=this.value();return _.apply(On(K)?K:[],V)}return this[I](function(le){return _.apply(On(le)?le:[],V)})}}),Zu(sr.prototype,function(v,_){var I=q[_];if(I){var P=I.name+"";Pr.call(k0,P)||(k0[P]=[]),k0[P].push({name:_,func:I})}}),k0[Nk(t,y).name]=[{name:"wrapper",func:t}],sr.prototype.clone=rhe,sr.prototype.reverse=she,sr.prototype.value=ihe,q.prototype.at=Pde,q.prototype.chain=Dde,q.prototype.commit=Ode,q.prototype.next=Fde,q.prototype.plant=zde,q.prototype.reverse=Bde,q.prototype.toJSON=q.prototype.valueOf=q.prototype.value=Vde,q.prototype.first=q.prototype.head,Nx&&(q.prototype[Nx]=Lde),q},_0=Oue();Yh?((Yh.exports=_0)._=_0,m0._=_0):mi._=_0}).call(pt)})(JI,JI.exports);var tZe=JI.exports;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var NO=function(n,e){return NO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])},NO(n,e)};function Eo(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");NO(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var t4=function(n){var e="[object "+n+"]";return function(t){return nZe(t)===e}},nZe=function(n){return Object.prototype.toString.call(n)},av=function(n){return n instanceof Date?n.getTime():Jw(n)?n.map(av):n&&typeof n.toJSON=="function"?n.toJSON():n},Jw=t4("Array"),rZe=t4("Object"),sZe=t4("Function"),iZe=function(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")&&!n.toJSON},$O=function(n,e){if(n==null&&n==e||n===e)return!0;if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Jw(n)){if(n.length!==e.length)return!1;for(var t=0,r=n.length;t<r;t++)if(!$O(n[t],e[t]))return!1;return!0}else if(rZe(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var s in n)if(!$O(n[s],e[s]))return!1;return!0}return!1},RO=function(n,e,t,r,s,i){var o=e[r];if(Jw(n)&&isNaN(Number(o))){for(var a=0,l=n.length;a<l;a++)if(!RO(n[a],e,t,r,a,n))return!1}return r===e.length||n==null?t(n,s,i,r===0):RO(n[o],e,t,r+1,o,n)},Uu=function(){function n(e,t,r,s){this.params=e,this.owneryQuery=t,this.options=r,this.name=s,this.init()}return n.prototype.init=function(){},n.prototype.reset=function(){this.done=!1,this.keep=!1},n}(),n4=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s)||this;return o.children=i,o}return e.prototype.reset=function(){this.keep=!1,this.done=!1;for(var t=0,r=this.children.length;t<r;t++)this.children[t].reset()},e.prototype.childrenNext=function(t,r,s,i){for(var o=!0,a=!0,l=0,c=this.children.length;l<c;l++){var u=this.children[l];if(u.done||u.next(t,r,s,i),u.keep||(a=!1),u.done){if(!u.keep)break}else o=!1}this.done=o,this.keep=a},e}(Uu),Nte=function(n){Eo(e,n);function e(t,r,s,i,o){var a=n.call(this,t,r,s,i)||this;return a.name=o,a}return e}(n4),oZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(n4),PO=function(n){Eo(e,n);function e(t,r,s,i,o){var a=n.call(this,r,s,i,o)||this;return a.keyPath=t,a.propop=!0,a._nextNestedValue=function(l,c,u,h){return a.childrenNext(l,c,u,h),!a.done},a}return e.prototype.next=function(t,r,s){RO(t,this.keyPath,this._nextNestedValue,0,r,s)},e}(n4),r4=function(n,e){if(n instanceof Function)return n;if(n instanceof RegExp)return function(r){var s=typeof r=="string"&&n.test(r);return n.lastIndex=0,s};var t=av(n);return function(r){return e(t,av(r))}},Vp=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=r4(this.params,this.options.compare)},e.prototype.next=function(t,r,s){(!Array.isArray(s)||s.hasOwnProperty(r))&&this._test(t,r,s)&&(this.done=!0,this.keep=!0)},e}(Uu),aZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(){this.done=!0,this.keep=!1},e}(Uu),lZe=function(n){return function(e,t,r,s){return e==null?new aZe(e,t,r,s):n(e,t,r,s)}},a$=function(n){return lZe(function(e,t,r,s){var i=typeof av(e),o=n(e);return new Vp(function(a){return typeof av(a)===i&&o(a)},t,r,s)})},cZe=function(n,e,t,r){var s=r.operations[n];return s||$te(n),s(e,t,r,n)},$te=function(n){throw new Error("Unsupported operation: "+n)},Rte=function(n,e){for(var t in n)if(e.operations.hasOwnProperty(t)||t.charAt(0)==="$")return!0;return!1},uZe=function(n,e,t,r,s){if(Rte(e,s)){var i=Pte(e,t,s),o=i[0],a=i[1];if(a.length)throw new Error("Property queries must contain only operations, or exact objects.");return new PO(n,e,r,s,o)}return new PO(n,e,r,s,[new Vp(e,r,s)])},Qw=function(n,e,t){e===void 0&&(e=null);var r=t===void 0?{}:t,s=r.compare,i=r.operations,o={compare:s||$O,operations:Object.assign({},i||{})},a=Pte(n,null,o),l=a[0],c=a[1],u=[];return l.length&&u.push(new PO([],n,e,o,l)),u.push.apply(u,c),u.length===1?u[0]:new oZe(n,e,o,u)},Pte=function(n,e,t){var r=[],s=[];if(!iZe(n))return r.push(new Vp(n,n,t)),[r,s];for(var i in n)if(t.operations.hasOwnProperty(i)){var o=cZe(i,n[i],n,t);if(o&&!o.propop&&e&&!t.operations[e])throw new Error("Malformed query. "+i+" cannot be matched against property.");o!=null&&r.push(o)}else i.charAt(0)==="$"?$te(i):s.push(uZe(i.split("."),n[i],i,n,t));return[r,s]},hZe=function(n){return function(e,t,r){return n.reset(),n.next(e,t,r),n.keep}},fZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=r4(this.params,this.options.compare)},e.prototype.reset=function(){n.prototype.reset.call(this),this.keep=!0},e.prototype.next=function(t){this._test(t)&&(this.done=!0,this.keep=!1)},e}(Uu),dZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){if(!this.params||typeof this.params!="object")throw new Error("Malformed query. $elemMatch must by an object.");this._queryOperation=Qw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t){if(Jw(t)){for(var r=0,s=t.length;r<s;r++){this._queryOperation.reset();var i=t[r];this._queryOperation.next(i,r,t,!1),this.keep=this.keep||this._queryOperation.keep}this.done=!0}else this.done=!1,this.keep=!1},e}(Uu),pZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._queryOperation=Qw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t,r,s,i){this._queryOperation.next(t,r,s,i),this.done=this._queryOperation.done,this.keep=!this._queryOperation.keep},e}(Uu),Dte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){},e.prototype.next=function(t){Jw(t)&&t.length===this.params&&(this.done=!0,this.keep=!0)},e}(Uu),Ote=function(n){if(n.length===0)throw new Error("$and/$or/$nor must be a nonempty array")},Fte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.init=function(){var t=this;Ote(this.params),this._ops=this.params.map(function(r){return Qw(r,null,t.options)})},e.prototype.reset=function(){this.done=!1,this.keep=!1;for(var t=0,r=this._ops.length;t<r;t++)this._ops[t].reset()},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._ops.length;a<l;a++){var c=this._ops[a];if(c.next(t,r,s),c.keep){i=!0,o=c.keep;break}}this.keep=o,this.done=i},e}(Uu),mZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.next=function(t,r,s){n.prototype.next.call(this,t,r,s),this.keep=!this.keep},e}(Fte),Lte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){var t=this;this._testers=this.params.map(function(r){if(Rte(r,t.options))throw new Error("cannot nest $ under "+t.name.toLowerCase());return r4(r,t.options.compare)})},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._testers.length;a<l;a++){var c=this._testers[a];if(c(t)){i=!0,o=!0;break}}this.keep=o,this.done=i},e}(Uu),gZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,i)||this;return o.propop=!0,o._in=new Lte(t,r,s,i),o}return e.prototype.next=function(t,r,s,i){this._in.next(t,r,s),Jw(s)&&!i?this._in.keep?(this.keep=!1,this.done=!0):r==s.length-1&&(this.keep=!0,this.done=!0):(this.keep=!this._in.keep,this.done=!0)},e.prototype.reset=function(){n.prototype.reset.call(this),this._in.reset()},e}(Uu),yZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s){s.hasOwnProperty(r)===this.params&&(this.done=!0,this.keep=!0)},e}(Uu),bZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return Qw(a,r,s)}),i)||this;return o.propop=!1,Ote(t),o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(Nte),vZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return Qw(a,r,s)}),i)||this;return o.propop=!0,o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(Nte),wZe=function(n,e,t){return new Vp(n,e,t)},xZe=function(n,e,t,r){return new fZe(n,e,t,r)},_Ze=function(n,e,t,r){return new Fte(n,e,t,r)},SZe=function(n,e,t,r){return new mZe(n,e,t,r)},CZe=function(n,e,t,r){return new dZe(n,e,t,r)},kZe=function(n,e,t,r){return new gZe(n,e,t,r)},TZe=function(n,e,t,r){return new Lte(n,e,t,r)},EZe=a$(function(n){return function(e){return e<n}}),IZe=a$(function(n){return function(e){return e<=n}}),AZe=a$(function(n){return function(e){return e>n}}),MZe=a$(function(n){return function(e){return e>=n}}),NZe=function(n,e,t){var r=n[0],s=n[1];return new Vp(function(i){return av(i)%r===s},e,t)},$Ze=function(n,e,t,r){return new yZe(n,e,t,r)},RZe=function(n,e,t){return new Vp(new RegExp(n,e.$options),e,t)},PZe=function(n,e,t,r){return new pZe(n,e,t,r)},e6={number:function(n){return typeof n=="number"},string:function(n){return typeof n=="string"},bool:function(n){return typeof n=="boolean"},array:function(n){return Array.isArray(n)},null:function(n){return n===null},timestamp:function(n){return n instanceof Date}},DZe=function(n,e,t){return new Vp(function(r){if(typeof n=="string"){if(!e6[n])throw new Error("Type alias does not exist");return e6[n](r)}return r!=null?r instanceof n||r.constructor===n:!1},e,t)},OZe=function(n,e,t,r){return new bZe(n,e,t,r)},FZe=function(n,e,t,r){return new vZe(n,e,t,r)},LZe=function(n,e,t){return new Dte(n,e,t,"$size")},zZe=function(){return null},BZe=function(n,e,t){var r;if(sZe(n))r=n;else if(!{}.CSP_ENABLED)r=new Function("obj","return "+n);else throw new Error('In CSP mode, sift does not support strings in "$where" condition');return new Vp(function(s){return r.bind(s)(s)},e,t)},VZe=Object.freeze({__proto__:null,$Size:Dte,$eq:wZe,$ne:xZe,$or:_Ze,$nor:SZe,$elemMatch:CZe,$nin:kZe,$in:TZe,$lt:EZe,$lte:IZe,$gt:AZe,$gte:MZe,$mod:NZe,$exists:$Ze,$regex:RZe,$not:PZe,$type:DZe,$and:OZe,$all:FZe,$size:LZe,$options:zZe,$where:BZe}),UZe=function(n,e,t){var r=t===void 0?{}:t,s=r.compare,i=r.operations;return Qw(n,e,{compare:s,operations:Object.assign({},VZe,i||{})})},WZe=function(n,e){e===void 0&&(e={});var t=UZe(n,null,e);return hZe(t)};const t6=WZe;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZe=Ee();GZe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var rc;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(rc||(rc={}));var n6;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(n6||(n6={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s4={};function HZe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};s4[n]=t}function zte(n){return s4[n]}function jZe(n){delete s4[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F(n,e,t,r,s){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return ao(e.inputNames[c],t,r,s);if(i.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((p,m)=>{var g;return((g=f[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(p=>ao(p,t,r,s))}const u=ao(e.inputNames[c],t,r,s),h=u.dataSync();return i.type==="number"?h[0]:Tl(u.shape,h)}const o=e.attrParams[n];return o&&o.value}function ao(n,e,t,r){const[s,i]=Va(n,t);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[QI(s,a)]);return o!==void 0?e[QI(s,o)][i]:void 0}function r6(n,e,t){return e[QI(n,t.currentContextId)]}function vf(n,e){const[t,r,s]=Va(n,e);return[QI(t,e&&e.currentContextId),r,s]}function QI(n,e){return e?`${n}-${e}`:n}function Va(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const i=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[i,a,o]}return t&&e.parseNodeNameCache.set(n,s),s}function WE(n,e,t){let r=F("pad",n,e,t);if(r==="explicit"){r=F("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[i*2],s[i][1]=r[i*2+1];return s}return r}function wf(n){return n.kept?n:mh(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],XZe=Object.freeze(Object.defineProperty({__proto__:null,json:qZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],YZe=Object.freeze(Object.defineProperty({__proto__:null,json:KZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],JZe=Object.freeze(Object.defineProperty({__proto__:null,json:ZZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],eJe=Object.freeze(Object.defineProperty({__proto__:null,json:QZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tJe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],nJe=Object.freeze(Object.defineProperty({__proto__:null,json:tJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rJe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sJe=Object.freeze(Object.defineProperty({__proto__:null,json:rJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],oJe=Object.freeze(Object.defineProperty({__proto__:null,json:iJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],lJe=Object.freeze(Object.defineProperty({__proto__:null,json:aJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],uJe=Object.freeze(Object.defineProperty({__proto__:null,json:cJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hJe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],fJe=Object.freeze(Object.defineProperty({__proto__:null,json:hJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],pJe=Object.freeze(Object.defineProperty({__proto__:null,json:dJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],gJe=Object.freeze(Object.defineProperty({__proto__:null,json:mJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],bJe=Object.freeze(Object.defineProperty({__proto__:null,json:yJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vJe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wJe=Object.freeze(Object.defineProperty({__proto__:null,json:vJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xJe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],_Je=Object.freeze(Object.defineProperty({__proto__:null,json:xJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],CJe=Object.freeze(Object.defineProperty({__proto__:null,json:SJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],TJe=Object.freeze(Object.defineProperty({__proto__:null,json:kJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EJe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],IJe=Object.freeze(Object.defineProperty({__proto__:null,json:EJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AJe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],MJe=Object.freeze(Object.defineProperty({__proto__:null,json:AJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s6{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[XZe,YZe,JZe,eJe,nJe,sJe,oJe,lJe,uJe,fJe,pJe,gJe,bJe,wJe,_Je,CJe,TJe,IJe,MJe],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],i=[],o=[],a=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?i.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[x,,w]=vf(y),S=a[x];if(S.outputs!=null){const C=S.outputs.indexOf(w);if(C!==-1){const k=`${x}:${C}`;g.inputNames[b]=k}}g.inputs.push(S),S.children.push(g)})}),Object.keys(h).length===0?f.forEach(m=>{const g=a[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{const[g]=vf(m),y=a[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=vf(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:t,functions:d};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=zte(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=DO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=DO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=UO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=UO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=FO(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=FO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=VO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=VO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=OO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=OO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=GO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=GO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=BO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=BO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=WO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=WO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=LO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=LO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=zO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=zO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=i6(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=i6(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let i={};t!=null&&(i=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&s.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=vf(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:i4(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),i[f]=d}),Object.keys(i).forEach(h=>{const f=i[h];f.inputNames.forEach((d,p)=>{const[m,,g]=vf(d),y=i[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const x=`${m}:${b}`;f.inputNames[p]=x}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=vf(c[h.name]),p=i[f];p!=null&&(p.defaultOutput=d,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function NJe(n){const e=Ee().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Bte(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):NJe(n);return e?t:t.toLowerCase()}function DO(n,e,t,r=!1){const s=n[e];return s!=null?Bte(s.s,r):t}function OO(n,e,t){const r=n[e];return r?r.b:t}function FO(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function i4(n){switch(typeof n=="string"&&(n=rc[n]),n){case rc.DT_FLOAT:case rc.DT_HALF:return"float32";case rc.DT_INT32:case rc.DT_INT64:case rc.DT_INT8:case rc.DT_UINT8:return"int32";case rc.DT_BOOL:return"bool";case rc.DT_DOUBLE:return"float32";case rc.DT_STRING:return"string";default:return null}}function i6(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function LO(n,e,t){const r=n[e];return r&&r.type?i4(r.type):t}function zO(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>i4(s)):t}function Vte(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function BO(n,e,t){const r=n[e];return r&&r.shape?Vte(r.shape):t}function VO(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function UO(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(i=>Bte(i,r)):t}function WO(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Vte(s)):t}function GO(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Je{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return ao(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ao(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return FO(this.node.rawAttrs,e,t);if(r.s!=null)return DO(this.node.rawAttrs,e,t);if(r.b!=null)return OO(this.node.rawAttrs,e,t);if(r.shape!=null)return BO(this.node.rawAttrs,e,t);if(r.type!=null)return LO(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return VO(this.node.rawAttrs,e,t);if(r.list.s!=null)return UO(this.node.rawAttrs,e,t);if(r.list.shape!=null)return WO(this.node.rawAttrs,e,t);if(r.list.b!=null)return GO(this.node.rawAttrs,e,t);if(r.list.type!=null)return zO(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:zL,abs:wi,acos:XX,acosh:KX,add:qe,addN:YX,all:KL,any:AI,argMax:ug,argMin:ZX,asin:JX,asinh:QX,atan:eK,atan2:tK,atanh:nK,avgPool:OM,avgPool3d:ZL,basicLSTMCell:rK,batchNorm:Y2,batchNorm2d:JL,batchNorm3d:QL,batchNorm4d:ez,batchToSpaceND:FM,bincount:tz,bitwiseAnd:sK,booleanMaskAsync:dY,broadcastArgs:iK,broadcastTo:$b,buffer:Sn,cast:wt,ceil:oK,clipByValue:xa,clone:mh,complex:Of,concat:cs,concat1d:nz,concat2d:rz,concat3d:sz,concat4d:iz,conv1d:oz,conv2d:cp,conv2dTranspose:lz,conv3d:cz,conv3dTranspose:uz,cos:LM,cosh:hz,cosineWindow:nN,cumprod:MI,cumsum:fz,denseBincount:NI,depthToSpace:lK,depthwiseConv2d:Z2,diag:cK,dilation2d:uK,div:Lt,divNoNan:hK,dot:fK,dropout:Vz,einsum:Om,elu:J2,enclosingPowerOfTwo:Uz,ensureShape:dK,equal:vu,erf:pK,euclideanNorm:yK,exp:Yo,expandDims:oi,expm1:bK,eye:zM,fft:ZM,fill:Fy,floor:Q2,floorDiv:XL,fused:_Y,gather:eC,gatherND:yY,greater:rl,greaterEqual:Dp,ifft:A_,imag:tC,image:Ci,inTopKAsync:bY,irfft:Pz,isFinite:vK,isInf:wK,isNaN:xK,leakyRelu:BM,less:I_,lessEqual:Ly,linalg:Hz,linspace:_K,localResponseNormalization:SK,log:Nl,log1p:VM,logSigmoid:kK,logSoftmax:pz,logSumExp:WM,logicalAnd:_h,logicalNot:GM,logicalOr:mz,logicalXor:TK,losses:EY,lowerBound:EK,matMul:Hn,max:wc,maxPool:jM,maxPool3d:gz,maxPoolWithArgmax:IK,maximum:jf,mean:Ds,meshgrid:AK,min:E_,minimum:hp,mirrorPad:yz,mod:MK,moments:nC,movingAverage:pY,mul:fe,multiRNNCell:NK,multinomial:$K,neg:us,norm:Nw,notEqual:Zb,oneHot:Jb,ones:ma,onesLike:$l,op:he,outerProduct:RK,pad:wu,pad1d:PK,pad2d:DK,pad3d:OK,pad4d:FK,pool:LK,pow:up,prelu:XM,print:qL,prod:zK,raggedGather:BK,raggedRange:VK,raggedTensorToTensor:UK,rand:WK,randomGamma:XK,randomNormal:KM,randomStandardNormal:KK,randomUniform:Op,randomUniformInt:YK,range:fg,real:Qb,reciprocal:ZK,relu:Fh,relu6:Ez,reshape:ve,reverse:Tc,reverse1d:JK,reverse2d:QK,reverse3d:eY,reverse4d:tY,rfft:JM,round:Iz,rsqrt:Az,scalar:en,scatterND:mY,searchSorted:HM,selu:Mz,separableConv2d:Nz,setdiff1dAsync:nY,sigmoid:El,sign:rY,signal:TY,sin:$z,sinh:Rz,slice:dn,slice1d:rC,slice2d:YM,slice3d:sC,slice4d:ev,softmax:iC,softplus:$w,spaceToBatchND:qM,sparse:IY,sparseToDense:gY,spectral:kY,split:qa,sqrt:So,square:Or,squaredDifference:Dz,squeeze:vr,stack:_a,step:Pw,stridedSlice:sY,string:AY,sub:Dt,sum:Yt,tan:iY,tanh:Yb,tensor:Ei,tensor1d:Ks,tensor2d:Xa,tensor3d:Oz,tensor4d:oY,tensor5d:aY,tensor6d:lY,tensorScatterUpdate:cY,tile:pc,topk:uY,transpose:rr,truncatedNormal:eN,unique:hY,unsortedSegmentSum:Lz,unstack:Ec,upperBound:fY,variable:zz,where:_o,whereAsync:Bz,zeros:ms,zerosLike:lr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RJe=(n,e,t,r=fo)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(F("a",n,e,t),F("b",n,e,t))];case"AddN":return[r.addN(F("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(F("a",n,e,t),F("b",n,e,t))];case"Mul":return[r.mul(F("a",n,e,t),F("b",n,e,t))];case"RealDiv":case"Div":return[r.div(F("a",n,e,t),F("b",n,e,t))];case"DivNoNan":return[r.divNoNan(F("a",n,e,t),F("b",n,e,t))];case"FloorDiv":return[r.floorDiv(F("a",n,e,t),F("b",n,e,t))];case"Sub":return[r.sub(F("a",n,e,t),F("b",n,e,t))];case"Minimum":return[r.minimum(F("a",n,e,t),F("b",n,e,t))];case"Maximum":return[r.maximum(F("a",n,e,t),F("b",n,e,t))];case"Pow":return[r.pow(F("a",n,e,t),F("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PJe=(n,e,t,r=fo)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(F("x",n,e,t))];case"Acos":return[r.acos(F("x",n,e,t))];case"Acosh":return[r.acosh(F("x",n,e,t))];case"Asin":return[r.asin(F("x",n,e,t))];case"Asinh":return[r.asinh(F("x",n,e,t))];case"Atan":return[r.atan(F("x",n,e,t))];case"Atan2":return[r.atan2(F("x",n,e,t),F("y",n,e,t))];case"Atanh":return[r.atanh(F("x",n,e,t))];case"Ceil":return[r.ceil(F("x",n,e,t))];case"Complex":return[r.complex(F("real",n,e,t),F("imag",n,e,t))];case"Cos":return[r.cos(F("x",n,e,t))];case"Cosh":return[r.cosh(F("x",n,e,t))];case"Elu":return[r.elu(F("x",n,e,t))];case"Erf":return[r.erf(F("x",n,e,t))];case"Exp":return[r.exp(F("x",n,e,t))];case"Expm1":return[r.expm1(F("x",n,e,t))];case"Floor":return[r.floor(F("x",n,e,t))];case"Log":return[r.log(F("x",n,e,t))];case"Log1p":return[r.log1p(F("x",n,e,t))];case"Imag":return[r.imag(F("x",n,e,t))];case"Neg":return[r.neg(F("x",n,e,t))];case"Reciprocal":return[r.reciprocal(F("x",n,e,t))];case"Real":return[r.real(F("x",n,e,t))];case"Relu":return[r.relu(F("x",n,e,t))];case"Round":return[r.round(F("x",n,e,t))];case"Selu":return[r.selu(F("x",n,e,t))];case"Sigmoid":return[r.sigmoid(F("x",n,e,t))];case"Sin":return[r.sin(F("x",n,e,t))];case"Sign":return[r.sign(F("x",n,e,t))];case"Sinh":return[r.sinh(F("x",n,e,t))];case"Softplus":return[r.softplus(F("x",n,e,t))];case"Sqrt":return[r.sqrt(F("x",n,e,t))];case"Square":return[r.square(F("x",n,e,t))];case"Tanh":return[r.tanh(F("x",n,e,t))];case"Tan":return[r.tan(F("x",n,e,t))];case"ClipByValue":return[r.clipByValue(F("x",n,e,t),F("clipValueMin",n,e,t),F("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(F("x",n,e,t))];case"Rsqrt":return[r.rsqrt(ao(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(F("x",n,e,t),F("alpha",n,e,t))];case"Prelu":return[r.prelu(F("x",n,e,t),F("alpha",n,e,t))];case"IsNan":return[r.isNaN(ao(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(ao(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(ao(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ac(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){U(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=e[r];U(s<0||i<0||s===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function o6(n){return!(typeof n=="number"||n.some(e=>e<0))}function Xx(n,e,t){let r=HO(n,t);const s=!o6(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(i=>{r=HO(i.shape,r)}),!o6(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function HO(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],i=e[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DJe{constructor(e,t,r,s,i,o,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=en(0),Xs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ac(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Xs(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Ei([],[0].concat(this.elementShape));const r=this.readMany(e);return ac(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),_a(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ei([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return ac(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),cs(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Ec(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=r===0?0:t.size/r,o=[];Se(()=>{t=ve(t,[1,r,i]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:s[l-1],0],h=[1,e[l],i];o[l]=ve(dn(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vg{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);ac(t,i.shape,"TensorList shape mismatch: "),Xs(i)}),this.idTensor=en(0),this.maxNumElements=s,Xs(this.idTensor)}copy(){return new vg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ac(e,this.elementShape,"TensorList shape mismatch: ");const s=Xx(this.elementShape,this.tensors,e);return Se(()=>{const i=this.tensors.map(o=>ve(o,s));return _a(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Xx(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,ac(s.shape,e,"TensorList shape mismatch: "),ve(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ac(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Xs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new vg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ac(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Xx(this.elementShape,this.tensors,t);return ve(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ac(this.elementShape,t.shape,"TensorList shape mismatch: "),Xs(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ac(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Xx(this.elementShape,this.tensors,r);return e.length===0?Ei([],[0].concat(s)):Se(()=>{const i=e.map(o=>ve(this.tensors[o],s));return _a(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ac(this.elementShape,t,"TensorList shape mismatch: ");const r=Xx(this.elementShape,this.tensors,t);return this.size()===0?Ei([],[0].concat(r)):Se(()=>{const s=this.tensors.map(i=>ve(i,r));return cs(s,0)})}}function OJe(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);ac(s,e,"TensorList shape mismatch: ");const i=Ec(n);return new vg(i,e,r)}function FJe(n,e,t,r){return new vg([],n,e,r)}function LJe(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new vg([],t,n.dtype,r),o=Ec(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function zJe(n,e,t){let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=HO(i,t),a=r===0?0:n.size/r,l=Se(()=>{const u=[];n=ve(n,[1,r,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:s[h-1],0],p=[1,e[h],a];u[h]=ve(dn(n,d,p),o)}return n.dispose(),u}),c=new vg([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BJe=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=F("thenBranch",n,e,t),s=F("elseBranch",n,e,t),i=F("cond",n,e,t),o=F("args",n,e,t);return(await i.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=F("body",n,e,t),s=F("cond",n,e,t),i=F("args",n,e,t),o=await t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=i;for(;l[0];){const u=c;c=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(d=>d.id);u.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=F("pred",n,e,t);return[wf(r)]}case"Switch":{const r=F("pred",n,e,t);let s=F("data",n,e,t);return s.kept||(s=wf(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>ao(s,e,t)!==void 0);if(r){const s=ao(r,e,t);return[wf(s)]}return}case"Enter":{const r=F("frameName",n,e,t),s=F("tensor",n,e,t);return t.enterFrame(r),[wf(s)]}case"Exit":{const r=F("tensor",n,e,t);return t.exitFrame(),[wf(r)]}case"NextIteration":{const r=F("tensor",n,e,t);return t.nextIteration(),[wf(r)]}case"TensorArrayV3":{const r=F("size",n,e,t),s=F("dtype",n,e,t),i=F("elementShape",n,e,t),o=F("dynamicSize",n,e,t),a=F("clearAfterRead",n,e,t),l=F("identicalElementShapes",n,e,t),c=F("name",n,e,t),u=new DJe(c,s,r,i,l,o,a);return t.addTensorArray(u),[u.idTensor,en(1)]}case"TensorArrayWriteV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),i=F("dtype",n,e,t);return[s.concat(i)]}case"TensorArraySplitV3":{const r=F("tensorArrayId",n,e,t),s=F("tensor",n,e,t),i=F("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[en(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=F("indices",n,e,t),s=F("tensor",n,e,t),i=F("elementShape",n,e,t),o=F("numElements",n,e,t),a=LJe(s,r,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=F("elementShape",n,e,t),s=F("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=F(i,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=FJe(r,s,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=F("tensorListId",n,e,t),s=F("indices",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=F("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=OJe(r,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id),i=F("dtype",n,e,t),o=F("elementShape",n,e,t);return[s.concat(i,o)]}case"TensorListPushBack":{const r=F("tensorListId",n,e,t),s=F("tensor",n,e,t),i=t.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("lengths",n,e,t),o=zJe(r,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id);return[en(s.size(),"int32")]}case"TensorListResize":{const r=F("tensorListId",n,e,t),s=F("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a6(n,e,t){const[r,s]=F("fusedOps",n,e,t),i=r==="biasadd",o=!i,a=s==="prelu",l=r==="fusedbatchnorm",c=F("numArgs",n,e,t);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=F("strides",n,e,t),h=WE(n,e,t),f=F("dataFormat",n,e,t).toUpperCase(),d=F("dilations",n,e,t);let[p,m]=F("args",n,e,t);o&&(m=p,p=void 0);const g=F("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:f,dilations:d,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const VJe=(n,e,t,r=fo)=>{switch(n.op){case"Conv1D":{const s=F("stride",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilation",n,e,t);return[r.conv1d(F("x",n,e,t),F("filter",n,e,t),s,i,o,a)]}case"Conv2D":{const s=F("strides",n,e,t),i=WE(n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv2d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=a6(n,e,t);return[r.fused.conv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=a6(n,e,t);return[r.fused.depthwiseConv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=F("outputShape",n,e,t),i=F("strides",n,e,t),o=WE(n,e,t);return[r.conv2dTranspose(F("x",n,e,t),F("filter",n,e,t),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=F("strides",n,e,t),i=WE(n,e,t),o=F("dilations",n,e,t),a=F("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(F("input",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv3d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t),a=F("includeBatchInIndex",n,e,t),{result:l,indexes:c}=r.maxPoolWithArgmax(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dilations",n,e,t),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(F("x",n,e,t),F("filter",n,e,t),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJe=(n,e,t,r=fo)=>{switch(n.op){case"Fill":{const s=F("shape",n,e,t),i=F("dtype",n,e,t),o=F("value",n,e,t);return[r.fill(s,o,i)]}case"LinSpace":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("num",n,e,t);return[r.linspace(s,i,o)]}case"Multinomial":{const s=F("logits",n,e,t),i=F("numSamples",n,e,t),o=F("seed",n,e,t);return[r.multinomial(s,i,o)]}case"OneHot":{const s=F("indices",n,e,t),i=F("depth",n,e,t),o=F("onValue",n,e,t),a=F("offValue",n,e,t),l=F("dtype",n,e,t);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(F("shape",n,e,t),F("dtype",n,e,t))];case"OnesLike":return[r.onesLike(F("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(F("shape",n,e,t),F("dtype",n,e,t),F("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("seed",n,e,t))];case"Range":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("step",n,e,t);return[r.range(s,i,o,F("dtype",n,e,t))]}case"TruncatedNormal":{const s=F("shape",n,e,t),i=F("mean",n,e,t),o=F("stdDev",n,e,t),a=F("seed",n,e,t);return[r.truncatedNormal(s,i,o,F("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(F("shape",n,e,t),F("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(n,e,t){const r=F("boxes",n,e,t),s=F("scores",n,e,t),i=F("maxOutputSize",n,e,t),o=F("iouThreshold",n,e,t),a=F("scoreThreshold",n,e,t),l=F("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const WJe=async(n,e,t,r,s=fo)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=M3(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=M3(n,e,t),u=F("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(i,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=M3(n,e,t);return[await s.image.nonMaxSuppressionAsync(i,o,a,l,c)]}case"Where":{const i=s.cast(F("condition",n,e,t),"bool"),o=[await s.whereAsync(i)];return i.dispose(),o}case"ListDiff":return s.setdiff1dAsync(F("x",n,e,t),F("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GJe=(n,e,t,r=fo)=>{switch(n.op){case"LowerBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.lowerBound(s,i)]}case"TopKV2":{const s=F("x",n,e,t),i=F("k",n,e,t),o=F("sorted",n,e,t),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.upperBound(s,i)]}case"Unique":{const s=F("x",n,e,t),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=F("x",n,e,t),i=F("axis",n,e,t),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HJe=(n,e,t,r=fo)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=F("default",n,e,t);return[ao(n.name,e,t)||s];case"Placeholder":return[ao(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=F("x",n,e,t);return[wf(u)]}case"IdentityN":return F("x",n,e,t).map(u=>wf(u));case"Snapshot":const i=F("x",n,e,t);return[wf(i)];case"Shape":return[r.tensor1d(F("x",n,e,t).shape,"int32")];case"ShapeN":return F("x",n,e,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(F("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(F("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=F("x",n,e,t),a=F("data",n,e,t),l=F("message",n,e,t),c=F("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jJe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=en(0),this.tensorMap=new Map,Xs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return en(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Se(()=>{const s=Ec(t),i=r.length,o=s.length;U(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=r[a],c=s[a];Xs(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Se(()=>{const s=[];for(let i=0;i<r.length;i++){const o=r[i],a=this.findWithDefault(o,t);s.push(a)}return _a(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJe=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const i=F("keyDType",n,e,t),o=F("valueDType",n,e,t),a=new jJe(i,o);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("values",n,e,t);return[await r.getHashTableById(s.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=F("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XJe=(n,e,t,r=fo)=>{switch(n.op){case"ResizeBilinear":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=F("image",n,e,t),i=F("boxes",n,e,t),o=F("boxInd",n,e,t),a=F("cropSize",n,e,t),l=F("method",n,e,t),c=F("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=F("images",n,e,t),i=F("transforms",n,e,t),o=F("outputShape",n,e,t),a=F("fillValue",n,e,t),l=F("interpolation",n,e,t),c=F("fillMode",n,e,t);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJe=(n,e,t,r=fo)=>{switch(n.op){case"Equal":return[r.equal(F("a",n,e,t),F("b",n,e,t))];case"NotEqual":return[r.notEqual(F("a",n,e,t),F("b",n,e,t))];case"Greater":return[r.greater(F("a",n,e,t),F("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(F("a",n,e,t),F("b",n,e,t))];case"Less":return[r.less(F("a",n,e,t),F("b",n,e,t))];case"LessEqual":return[r.lessEqual(F("a",n,e,t),F("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(F("a",n,e,t),F("b",n,e,t))];case"LogicalNot":return[r.logicalNot(F("a",n,e,t))];case"LogicalOr":return[r.logicalOr(F("a",n,e,t),F("b",n,e,t))];case"Select":case"SelectV2":return[r.where(F("condition",n,e,t),F("a",n,e,t),F("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJe=(n,e,t,r=fo)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(F("a",n,e,t),F("b",n,e,t),F("transposeA",n,e,t),F("transposeB",n,e,t))];case"Einsum":return[r.einsum(F("equation",n,e,t),...F("tensors",n,e,t))];case"Transpose":return[r.transpose(F("x",n,e,t),F("perm",n,e,t))];case"_FusedMatMul":const[s,i]=F("fusedOps",n,e,t),o=s==="biasadd",a=i==="prelu",l=F("numArgs",n,e,t),c=F("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=F("args",n,e,t);return[r.fused.matMul({a:F("a",n,e,t),b:F("b",n,e,t),transposeA:F("transposeA",n,e,t),transposeB:F("transposeB",n,e,t),bias:u,activation:i,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(F("a",n,e,t),F("numLower",n,e,t),F("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJe=(n,e,t,r=fo)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(F("x",n,e,t),F("axis",n,e,t),F("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(F("x",n,e,t),F("radius",n,e,t),F("bias",n,e,t),F("alpha",n,e,t),F("beta",n,e,t))];case"Softmax":return[r.softmax(F("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJe=(n,e,t,r=fo)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(F("paramsNestedSplits",n,e,t),F("paramsDenseValues",n,e,t),F("indices",n,e,t),F("outputRaggedRank",n,e,t));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(F("starts",n,e,t),F("limits",n,e,t),F("splits",n,e,t));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(F("shape",n,e,t),F("values",n,e,t),F("defaultValue",n,e,t),F("rowPartitionTensors",n,e,t),F("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJe=(n,e,t,r=fo)=>{switch(n.op){case"Max":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.max(F("x",n,e,t),a,l)]}case"Mean":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.mean(F("x",n,e,t),a,l)]}case"Min":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.min(F("x",n,e,t),a,l)]}case"Sum":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.sum(F("x",n,e,t),a,l)]}case"All":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.all(F("x",n,e,t),a,l)]}case"Any":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.any(F("x",n,e,t),a,l)]}case"ArgMax":{const a=F("axis",n,e,t);return[r.argMax(F("x",n,e,t),a)]}case"ArgMin":{const a=F("axis",n,e,t);return[r.argMin(F("x",n,e,t),a)]}case"Prod":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.prod(F("x",n,e,t),a,l)]}case"Cumprod":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumprod(F("x",n,e,t),a,l,c)]}case"Cumsum":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumsum(F("x",n,e,t),a,l,c)]}case"Bincount":const s=F("x",n,e,t),i=F("weights",n,e,t),o=F("size",n,e,t);return[r.bincount(s,i,o)];case"DenseBincount":{const a=F("x",n,e,t),l=F("weights",n,e,t),c=F("size",n,e,t),u=F("binaryOutput",n,e,t);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eQe=(n,e,t,r=fo)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=F("n",n,e,t),i=F("axis",n,e,t);let o=F("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=F("axis",n,e,t),i=F("batchDims",n,e,t),o=F("x",n,e,t),a=F("indices",n,e,t);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=F("dims",n,e,t),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=F("x",n,e,t);return[r.reverse(o,i)]}case"ReverseV2":{const s=F("axis",n,e,t),i=F("x",n,e,t);return[r.reverse(i,s)]}case"Slice":{const s=F("begin",n,e,t),i=F("size",n,e,t);return[r.slice(F("x",n,e,t),s,i)]}case"StridedSlice":{const s=F("begin",n,e,t),i=F("end",n,e,t),o=F("strides",n,e,t),a=F("beginMask",n,e,t),l=F("endMask",n,e,t),c=F("ellipsisMask",n,e,t),u=F("newAxisMask",n,e,t),h=F("shrinkAxisMask",n,e,t),f=F("x",n,e,t);return[r.stridedSlice(f,s,i,o,a,l,c,u,h)]}case"Pack":return Se(()=>{const s=F("axis",n,e,t),i=F("tensors",n,e,t),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=Rn(c.shape,o);if(!u&&!Rn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=F("axis",n,e,t),i=F("tensor",n,e,t);return r.unstack(i,s)}case"Tile":{const s=F("reps",n,e,t);return[r.tile(F("x",n,e,t),s)]}case"Split":case"SplitV":{const s=F("axis",n,e,t),i=F("numOrSizeSplits",n,e,t),o=F("x",n,e,t);return r.split(o,i,s)}case"ScatterNd":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("shape",n,e,t);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gatherND(s,i)]}case"SparseToDense":{const s=F("sparseIndices",n,e,t),i=F("outputShape",n,e,t),o=F("sparseValues",n,e,t),a=F("defaultValue",n,e,t);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("tensor",n,e,t);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tQe=(n,e,t,r=fo)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(F("indices",n,e,t),F("values",n,e,t),F("denseShape",n,e,t),F("defaultValue",n,e,t));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(F("inputIndices",n,e,t),F("inputShape",n,e,t),F("newShape",n,e,t));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nQe=(n,e,t,r=fo)=>{switch(n.op){case"FFT":return[r.fft(F("x",n,e,t))];case"IFFT":return[r.ifft(F("x",n,e,t))];case"RFFT":return[r.rfft(F("x",n,e,t))];case"IRFFT":return[r.irfft(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rQe=(n,e,t,r=fo)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(F("input",n,e,t),F("pattern",n,e,t),F("rewrite",n,e,t),F("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(F("data",n,e,t),F("dataSplits",n,e,t),F("separator",n,e,t),F("nGramWidths",n,e,t),F("leftPad",n,e,t),F("rightPad",n,e,t),F("padWidth",n,e,t),F("preserveShortSequences",n,e,t));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(F("input",n,e,t),F("delimiter",n,e,t),F("skipEmpty",n,e,t));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(F("input",n,e,t),F("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sQe=(n,e,t,r=fo)=>{switch(n.op){case"Cast":return[r.cast(F("x",n,e,t),F("dtype",n,e,t))];case"ExpandDims":{const s=F("axis",n,e,t);return[r.expandDims(F("x",n,e,t),s)]}case"Squeeze":{const s=F("axis",n,e,t);return[r.squeeze(F("x",n,e,t),s)]}case"Reshape":return[r.reshape(F("x",n,e,t),F("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(F("x",n,e,t),F("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(F("x",n,e,t),F("padding",n,e,t),F("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(F("x",n,e,t),F("padding",n,e,t),F("constantValue",n,e,t))];case"SpaceToBatchND":{const s=F("blockShape",n,e,t),i=F("paddings",n,e,t);return[r.spaceToBatchND(F("x",n,e,t),s,i)]}case"BatchToSpaceND":{const s=F("blockShape",n,e,t),i=F("crops",n,e,t);return[r.batchToSpaceND(F("x",n,e,t),s,i)]}case"DepthToSpace":{const s=F("blockSize",n,e,t),i=F("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(F("x",n,e,t),s,i)]}case"BroadcastTo":return[r.broadcastTo(F("x",n,e,t),F("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(F("s0",n,e,t),F("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6(n,e,t,r,s=Se){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>RJe(o,a,l));case"basic_math":return s(()=>PJe(o,a,l));case"control":return BJe(o,a,l);case"convolution":return s(()=>VJe(o,a,l));case"creation":return s(()=>UJe(o,a,l));case"dynamic":return WJe(o,a,l);case"evaluation":return s(()=>GJe(o,a,l));case"image":return s(()=>XJe(o,a,l));case"graph":return s(()=>HJe(o,a,l));case"logical":return s(()=>KJe(o,a,l));case"matrices":return s(()=>YJe(o,a,l));case"normalization":return s(()=>ZJe(o,a,l));case"ragged":return s(()=>JJe(o,a,l));case"reduction":return s(()=>QJe(o,a,l));case"slice_join":return s(()=>eQe(o,a,l));case"sparse":return s(()=>tQe(o,a,l));case"spectral":return s(()=>nQe(o,a,l));case"string":return s(()=>rQe(o,a,l));case"transformation":return s(()=>sQe(o,a,l));case"hash_table":return qJe(o,a,l,r);case"custom":const c=zte(o.op);if(c&&c.customExecutor)return c.customExecutor(new $Je(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return ap(i)?i.then(o=>[].concat(o)):[].concat(i)}class c6{constructor(e={},t={},r={},s={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6(n,e,t,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(n).map(f=>Va(f)[0]));r=r||[];const u=new Set(r.map(f=>Va(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if((zm(f)||fQe(f)||dQe(f))&&o==null&&(o=f,a=o.children.map(d=>d.name).filter(d=>s.has(d))),s.add(f.name),t[f.name]==null&&!c.has(f.name)&&!u.has(f.name)){if(f.inputs.length===0){i.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}function iQe(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(g=>Va(g)[0]).map(g=>n.nodes[g]),i=n.initNodes||[],o=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...s,...n.weights,...i]).filter(o),c=a([...l,...Object.values(n.nodes)]).filter(o),u=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)o(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const f=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),d=[...f];for(;f.length>0;){const g=f.pop(),y=u.get(g);for(const b of y.children.filter(o))--h[b.name]===0&&(d.push(b.name),f.push(b.name))}const p=d.map(g=>u.get(g)),m=oQe(p,l);return aQe(m,l),m}function oQe(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return n.filter(o=>s.has(o.name))}class cT extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function aQe(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new cT(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new cT(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!t.has(l.name))throw new cT(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new cT(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function lQe(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>zm(a)?t:l),s=a=>{const l=r[e.get(a.name)];return l??-1},i=n.map((a,l)=>a.children.map(s).reduce((c,u)=>Math.max(c,u),r[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===t)continue;const c=n[a],u=n[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const cQe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),uQe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),hQe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function zm(n){return cQe.has(n.op)}function fQe(n){return uQe.has(n.op)}function dQe(n){return hQe.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eA{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new eA(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(i=>i.name).sort(),s=t.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=u6(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const c=t.map(h=>h.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}const a=iQe(this.graph,r),l=lQe(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Xs(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(f=>this.graph.nodes[Va(f)[0]]),i=t.map(f=>Va(f)[0]),o=new Set(i);let a=i.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const u={},h={};return Se(()=>{const f=new c6(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,x]=Va(y,f),w=[];w[x]=e[y],d[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const p=this.getFrozenTensorIds(d),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(const y of m){if(d[y.name])continue;const b=l6(y,d,f,this._resourceManager);if(ap(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,p,o,g.get(y.name))}return this.parent==null&&f.dispose(p),t.map(y=>ao(y,d,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,i,o,a){if(!(zm(t)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(zm(l))continue;const c=r6(l.name,r,s);if(c!=null)for(const u of c){if(!u||u.kept||i.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,i,o){function a(l){return zm(l)||i.has(l.name)}if(!(zm(e)||o==null))for(const l of o){if(a(l))continue;const c=r6(l.name,t,r);for(const u of c)!u||u.kept||s.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},i={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new c6(this.weightMap,s,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,r),l=t.map(f=>ao(f,a,o)),c=l.map(f=>f.id),u=Object.keys(e).map(f=>e[f].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,r){const s=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const i=Object.keys(e),o=i.map(w=>this.graph.nodes[Va(w)[0]]),a=r.map(w=>Va(w)[0]),l=new Set(a);let c=a.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:f,syncInputs:d}=u6(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[S,C]=Va(w),k=[];k[C]=e[w],m[S]=k});const g={},y=this.getFrozenTensorIds(m),b={};for(;p.length>0;){const w=this.processStack(o,p,t,m,b,y,l,g,u);await Promise.all(w)}f==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(w=>!zm(w)&&!ao(w.name,m,t)).map(w=>w.name);if(x.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(e,t,r,s,i,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&F("isConstant",h.node,s,r)&&([f]=vf(h.node.name,r)),s[h.node.name]==null){const d=l6(h.node,s,r,this._resourceManager);f||([f]=vf(h.node.name,r));const p=r.currentContext;ap(d)?u.push(d.then(m=>(s[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c),m))):(s[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c))}else this.processChildNodes(h.node,t,r,s,i,c)}return u}processChildNodes(e,t,r,s,i,o){e.children.forEach(a=>{const[l]=vf(a.name,r);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!ao(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!ao(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Va(t),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,c)=>o[c]===-1||o[c]===l);U(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&U(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const i in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[i];o!=null?s[o.name]=e[i]:s[i]=e[i]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Va(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const i=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=Va(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class pQe{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mQe="?tfjs-format=file",gQe="model.json";class o4{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=Qz){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new pQe}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return ap(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new eA(s6.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=s6.Instance.transformGraph(e.modelInitializer);this.initializer=new eA(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof jn?[e]:e,r={};return t.forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof jn)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?i[o]=this.resourceIdToCapturedInput[u]:i[o]=e[s++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const i=r[s],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Rl(n,e={},t=Qz){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=bQe(n));const r=new o4(n,e,t);return await r.load(),r}function yQe(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[r,s]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const i=GL(r.weightsManifest),o=UL(r,i,s);e=$I(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=$I(n);else throw new Error("Unknown model format");const t=new o4(e);return t.load(),t}function bQe(n){return n.endsWith("/")||(n=n+"/"),`${n}${gQe}${mQe}`}/** @license See the LICENSE file. */const vQe="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wQe=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:o4,deregisterOp:jZe,loadGraphModel:Rl,loadGraphModelSync:yQe,registerOp:HZe,version_converter:vQe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oh extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oh.prototype)}}class gc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,gc.prototype)}}class _e extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_e.prototype)}}class Fn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Fn.prototype)}}class a4 extends Error{constructor(e){super(e),Object.setPrototypeOf(this,a4.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ute{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wg(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ah(n,e){if(!n)throw new a4(e)}function h6(n,e){let t=0;for(const r of n)r===e&&t++;return t}function da(n){return n.length===1?n[0]:n}function Gr(n){return Array.isArray(n)?n:[n]}function xf(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Bm(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Ql={};function l4(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function jO(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>jO(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:jO(r))}}}function kC(n,e={},t={},r="object",s=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in Ql)o=Ql[i];else if(o=e[i],o==null)throw new _e(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new _e(`${r}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in Ql?[a,l]=Ql.className:o in e&&([a,l]=e[o]),a==null)throw new _e(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const d of Object.keys(Ql))c[d]=Ql[d];for(const d of Object.keys(t))c[d]=t[d];const u=i.config;u.customObjects=c;const h=Object.assign({},Ql);for(const d of Object.keys(t))Ql[d]=t[d];jO(i.config);const f=l(a,i.config,t,s);return Ql=Object.assign({},h),f}else{const c=Object.assign({},Ql);for(const h of Object.keys(t))Ql[h]=t[h];const u=new a(i.config);return Ql=Object.assign({},c),u}}}function xQe(n,e){return n<e?-1:n>e?1:0}function uT(n,e){return-1*xQe(n,e)}function Xd(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function _Qe(n){if(n==null)throw new _e(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Jy(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new _e(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function c4(n,e,t=0,r=1/0){return ah(t>=0),ah(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(s=>typeof s===e)}function Wi(n,e){Array.isArray(n)?(U(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Wi(t,`element ${r+1} of ${e}`))):U(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Wte(n)}.`)}function Wte(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Wte(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function SQe(n,e,t){let r=t!=null?t():so(),s;return(...o)=>{const a=t!=null?t():so();return a-r<e||(r=a,s=n(...o)),s}}function Gte(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let CQe=0;function Hte(){return CQe++}const hT={};function l$(n=""){return n in hT||(hT[n]=0),hT[n]+=1,n+hT[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const kQe=["channelsFirst","channelsLast"],TQe=["nearest","bilinear"],EQe=["valid","same","causal"],IQe=["max","avg"],AQe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const z0=new Map;function ti(n){Jy(kQe,"DataFormat",n)}function MQe(n){Jy(TQe,"InterpolationFormat",n)}function Bl(n){Jy(EQe,"PaddingMode",n)}function jte(n){Jy(IQe,"PoolMode",n)}const t_=[],f6="/";function Jm(n,e){t_.push(n);try{const t=e();return t_.pop(),t}catch(t){throw t_.pop(),t}}function NQe(){return t_.length===0?"":t_.join(f6)+f6}function qte(n){if(!Kte(n))throw new Error("Not a valid tensor name: '"+n+"'");return NQe()+n}function Xte(n){if(!Kte(n))throw new Error("Not a valid tensor name: '"+n+"'");z0.has(n)||z0.set(n,0);const e=z0.get(n);if(z0.set(n,z0.get(n)+1),e>0){const t=`${n}_${e}`;return z0.set(t,1),t}else return n}const $Qe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Kte(n){return!!n.match($Qe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function RQe(n){return n===parseInt(n.toString(),10)}function Kd(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let s=e;s<t;++s)r*=n[s];return r}function lv(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function pp(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Cu(n,e){if(e<n)throw new _e(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let N3;function ki(){return N3==null&&(N3=cg().epsilon()),N3}function ku(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gh(n,e){return wt(n,e)}function TC(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ve(n,t)}function PQe(n,e){return Se(()=>{if(n.shape.length!==2)throw new _e(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=TC(n,1);return qO(t,[1,e,1])})}function DQe(n){const e=[Kd(n.shape)];return ve(n,e)}function OQe(n){if(n.rank<=1)throw new _e(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Kd(n.shape,1)];return ve(n,e)}function Qm(n,e,t){return Se(()=>{switch(n.rank){case 1:return rC(n,e,t);case 2:return YM(n,[e,0],[t,n.shape[1]]);case 3:return sC(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return ev(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return dn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return dn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new _e(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function $3(n,e,t){return Se(()=>{switch(n.rank){case 1:return rC(n,e,t);case 2:return YM(n,[0,e],[n.shape[0],t]);case 3:return sC(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return ev(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function fT(n,e,t,r){return Se(()=>{switch(n.rank){case 1:return rC(n,e,t);case 2:switch(r){case 1:return Qm(n,e,t);case 2:return $3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Qm(n,e,t);case 2:return sC(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return $3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Qm(n,e,t);case 2:return ev(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return ev(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return $3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function u4(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),cs(n,e)}function d6(n,e){switch(n.rank){case 1:return nz([n,e]);case 2:return rz([n,e],0);case 3:return sz([n,e],0);case 4:return iz([n,e],0);default:throw new _e(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function qO(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new _e(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return pc(n,e)}function c$(n,e=0,t=1,r,s){return KM(n,e,t,r,s)}function yh(n,e,t,r){if(n.rank<2||e.rank<2)throw new Fn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(s!==i)throw new Fn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return MD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?XO(n.rank,r,ku()):null,activation:t});{const s=n.shape.slice(),i=s.pop();n=ve(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(p,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=ve(rr(e,u),[l,-1]);const h=[...s,...c];return ve(MD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?XO(n.rank,r,ku()):null,activation:t}),h)}}function Yte(n,e,t){return Se(()=>(Array.isArray(e)?e=Ks(e,"int32"):e=wt(e,"int32"),eC(n,e,t)))}function EC(n){return fe(n,n)}function XO(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new _e(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1,1]):ve(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1]):ve(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1]):ve(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,r[0]]):ve(e,[1].concat(r))}else if(n<3)return e;throw new _e(`Unsupported input rank by biasAdd: ${e.rank}`)}function Wu(n,e,t){return Se(()=>(t==null&&(t=ku()),ti(t),qe(n,XO(n.rank,e,t))))}function FQe(n,e=1){if(e!==1)throw new Fn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return J2(n)}function LQe(n){return Se(()=>Lt(n,qe(wi(n),1)))}function Zte(n,e,t,r){return Se(()=>Vz(n,e,t,r))}function zQe(n){return Se(()=>{const e=qe(.5,fe(.2,n));return xa(e,0,1)})}function IC(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const BQe=["fanIn","fanOut","fanAvg"],VQe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UQe(n){Jy(BQe,"FanMode",n)}function WQe(n){Jy(VQe,"Distribution",n)}class Dc extends By{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Jte extends Dc{apply(e,t){return ms(e,t)}}Jte.className="Zeros";ot(Jte);class h4 extends Dc{apply(e,t){return ma(e,t)}}h4.className="Ones";ot(h4);class Qte extends Dc{constructor(e){if(super(),typeof e!="object")throw new _e(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new _e(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Se(()=>fe(en(this.value),ma(e,t)))}getConfig(){return{value:this.value}}}Qte.className="Constant";ot(Qte);class ene extends Dc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Op(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ene.className="RandomUniform";ot(ene);class tne extends Dc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`randomNormal does not support dType ${t}.`);return c$(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}tne.className="RandomNormal";ot(tne);class nne extends Dc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`truncatedNormal does not support dType ${t}.`);return eN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}nne.className="TruncatedNormal";ot(nne);let rne=class extends Dc{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Se(()=>{if(e.length!==2||e[0]!==e[1])throw new _e("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,zM(e[0]))})}getConfig(){return{gain:this.gain}}};rne.className="Identity";ot(rne);function GQe(n,e="channelsLast"){let t,r;if(ti(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const s=Kd(n,2);t=n[1]*s,r=n[0]*s}else if(e==="channelsLast"){const s=Kd(n,0,n.length-2);t=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=Kd(n);t=Math.sqrt(s),r=Math.sqrt(s)}return[t,r]}class Za extends Dc{constructor(e){if(super(),e.scale<0)throw new _e(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,UQe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,WQe(this.distribution),this.seed=e.seed}apply(e,t){const r=GQe(e),s=r[0],i=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,s):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(s+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`${this.getClassName()} does not support dType ${t}.`);return eN(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Op(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Za.className="VarianceScaling";ot(Za);class f4 extends Za{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Za.className}}f4.className="GlorotUniform";ot(f4);class d4 extends Za{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Za.className}}d4.className="GlorotNormal";ot(d4);class p4 extends Za{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Za.className}}p4.className="HeNormal";ot(p4);class m4 extends Za{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Za.className}}m4.className="HeUniform";ot(m4);class g4 extends Za{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Za.className}}g4.className="LeCunNormal";ot(g4);class y4 extends Za{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Za.className}}y4.className="LeCunUniform";ot(y4);class sne extends Dc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Se(()=>{if(e.length<2)throw new Fn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=Te(e.slice(0,-1)),s=e[e.length-1],i=r*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(s,r),Math.min(s,r)],a=c$(o,0,1,t,this.seed),l=Hz.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return c=fe(c,h.sign()),r<s&&(c=c.transpose()),fe(en(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}sne.className="Orthogonal";ot(sne);const p6={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function m6(n,e={}){return kC(n,xl.getMap().classNameMap,e,"initializer")}function Cs(n){return l4(n)}function ys(n){if(typeof n=="string"){const e=n in p6?p6[n]:n;if(e==="GlorotNormal")return new d4;if(e==="GlorotUniform")return new f4;if(e==="HeNormal")return new p4;if(e==="HeUniform")return new m4;if(e==="LeCunNormal")return new g4;if(e==="LeCunUniform")return new y4;{const t={};return t.className=e,t.config={},m6(t)}}else return n instanceof Dc?n:m6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KO(n){return Array.isArray(n)&&Array.isArray(n[0])}function tA(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function vn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new _e(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function wr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new _e(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nA(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,s)=>r*s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const g6="Variable";class HQe{constructor(e,t="float32",r=g6,s=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Hte(),r=r??g6,this.originalName=qte(r),this.name=Xte(this.originalName),this.trainable_=s,this.constraint=i,this.val=zz(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),jQe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function jQe(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function YO(n){return n.map(e=>e.read())}function b4(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ti{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class kh{constructor(e,t,r,s,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=Hte(),o!=null&&(this.originalName=qte(o),this.name=Xte(this.originalName)),this.rank=t.length}}let qQe=0,u$=class{constructor(e,t){this.callArgs=t,this.id=qQe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},XQe=0;class Kn extends By{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=XQe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=xf(r)+"_"+l$(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),r=[i].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new gc(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new _e(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return da(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return da(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new oh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new oh(`Layer ${this.name} is not connected, no input to return.`);return da(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new oh(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new oh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return da(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Gr(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Gr(this.inputSpec);if(t.length!==r.length)throw new _e(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let s=0;s<t.length;s++){const i=t[s],o=r[s];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new _e(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],f=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(f)===-1)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=i.shape[l];if(c!=null&&u!=null&&c!==u)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Gr(e),s=ZQe(e),i=JQe(e);if(s===i)throw new _e("Arguments to apply() must be all SymbolicTensors or all Tensors");return Jm(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Gr(e))o.push(a.shape);this.build(da(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Gr(o),l=[];for(let c of a)r.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=da(l),this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=KQe(e),a=this.computeOutputShape(o);let l;const c=YQe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new kh(c,u,this,Gr(e),t,this.name,h)):l=new kh(c,a,this,Gr(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new oh(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new oh(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new gc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return nA(this.weights)}build(e){this.built=!0}getWeights(e=!1){return YO(e?this.trainableWeights:this.weights)}setWeights(e){Se(()=>{const t=this.weights;if(t.length!==e.length)throw new _e(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],s=YO(t);for(let i=0;i<s.length;++i){const o=s[i],a=t[i],l=e[i];if(!Rn(o.shape,l.shape))throw new _e(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}b4(r)})}addWeight(e,t,r,s,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new _e(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():ys("zeros"));const c=s.apply(t,r),u=new HQe(c,r,e,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Gr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r);if(t instanceof Array&&s instanceof Array){if(t.length!==s.length)throw new Error(`${this.name} outputs ${t.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<t.length;i++)t[i].kerasMask=s[i]}else{if(s instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${s.length} masks`);if(t instanceof Array)throw new Error(`{this.name} outputs ${t.length} tensors but only one mask`);t.kerasMask=s}}addInboundNode(e,t,r,s,i,o,a=null){const l=Gr(e);t=Gr(t),r=Gr(r),s=Gr(s),i=tA(i),o=tA(o);const c=[],u=[],h=[];for(const f of l)c.push(f.sourceLayer),u.push(f.nodeIndex),h.push(f.tensorIndex);new u$({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function KQe(n){n=Gr(n);const e=[];for(const t of n)e.push(t.shape);return da(e)}function YQe(n){return"float32"}function ine(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const o=r.inputTensors[i],a=r.inboundLayers[i],l=r.nodeIndices[i],c=ine(o,a,l);for(const u of c)s.indexOf(u)===-1&&s.push(u)}return s}}}function ZQe(n){let e=!0;for(const t of Gr(n))if(!(t instanceof kh)){e=!1;break}return e}function JQe(n){let e=!0;for(const t of Gr(n))if(t instanceof kh){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AC extends Kn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:l$("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new _e("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new _e("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new _e("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const s=new kh(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new u$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new _e(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}AC.className="InputLayer";ot(AC);function QQe(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new _e("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new AC({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eet(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return wt(e,n.dtype)}catch{throw new _e(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Ld{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ld)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=eet(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new _e(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&nn(this.id2Mask)}}const rA=new Ute,sA=new Ute;function tet(n){rA!=null&&rA.setMaxEntries(n),sA!=null&&sA.setMaxEntries(n)}function N1(n,e,t,r){const s=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=e.names();for(const p of a)c.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+e.names().sort().join(",");let h=rA.get(u),f;if(h==null){const p=net(o,e);h=p.sorted,f=p.recipientCounts,rA.put(u,h),sA.put(u,f)}f={},s||Object.assign(f,sA.get(u));const d=new Ld(e);for(let p=0;p<h.length;++p){if(r!=null){const M=II().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}const m=h[p],g=m.sourceLayer;if(g instanceof AC)continue;const y=[],b=[],x=[];let w=!1;for(const M of m.inputs){const E=d.getValue(M),N=d.getMask(M);y.push(E),b.push(N),N!=null&&(w=!0),s||(f[M.name]--,f[M.name]===0&&!e.hasKey(M)&&a.indexOf(M.name)===-1&&!E.isDisposed&&M.sourceLayer.stateful!==!0&&x.push(E))}w&&(t=t||{},t.mask=b[0]);const S=Gr(g.apply(y,t));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const k=set(m),A=Array.isArray(k)?k:[k];for(let M=0;M<A.length;++M){d.hasKey(A[M])||d.add(A[M],S[M],Array.isArray(C)?C[0]:C);const E=a.indexOf(A[M].name);E!==-1&&(l[E]=S[M])}s||nn(x)}return d.disposeMasks(),i?l:l[0]}function net(n,e){U(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const s=y6(n[0],e);t=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=y6(i,e);for(const l of o)s.has(l.name)||(t.push(l),s.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:t,recipientCounts:ret(r)}}function ret(n){const e={};for(const t in n)e[t]=n[t].size;return e}function y6(n,e){const t=new Set,r=[],s={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),r.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(a.name),!t.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function set(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet=Ee();iet.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,tet);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const one={kernelName:Mv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Pw(wt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oet={kernelName:Vg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Or(wt(t,"float32")),s=So(Dt(en(1),r));return us(Lt(n,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aet={kernelName:Ug,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=So(Dt(Or(wt(t,"float32")),1));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cet={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ui(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ui(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet={kernelName:Nv,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,s)=>{t[s]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het={kernelName:$v,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lr(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet={kernelName:Rv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lr(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const det={kernelName:Wg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,So(Dt(en(1),Or(wt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pet={kernelName:Gg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=So(qe(en(1),Or(wt(t,"float32"))));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const met={kernelName:qg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=qe(Or(t),Or(r));let l=fe(n,Lt(r,a));const c=ui(t.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,t.shape)},b:()=>{const a=qe(Or(t),Or(r));let l=us(fe(n,Lt(t,a)));const c=ui(r.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const get={kernelName:Hg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,qe(Or(wt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yet={kernelName:jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Dt(en(1),Or(wt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bet(n,e,t,r,s,i){const o=j(n,"dy","avgPool3dGrad"),a=j(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),U(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),na("avgPool3dGrad",s,i);const h={dy:l,input:c},f={filterSize:t,strides:r,pad:s,dimRoundingMode:i},d=ue.runKernel(YS,h,f);return u?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const vet=he({avgPool3dGrad_:bet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wet={kernelName:Dv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>vet(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xet(n,e,t,r,s){const i=j(n,"dy","avgPoolGrad"),o=j(e,"input","avgPoolGrad");U(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),U(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:r,pad:s},f=ue.runKernel(KS,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const _et=he({avgPoolGrad_:xet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cet={kernelName:Pv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=t;return{x:()=>_et(n,r,s,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ket={kernelName:Ov,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,s]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>Hn(n,s,!1,!0),b:()=>Hn(r,n,!0,!1)}:!i&&o?{a:()=>Hn(n,s,!1,!1),b:()=>Hn(n,r,!0,!1)}:i&&!o?{a:()=>Hn(s,n,!1,!0),b:()=>Hn(r,n,!1,!1)}:{a:()=>Hn(s,n,!0,!0),b:()=>Hn(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tet={kernelName:Fv,gradFunc:(n,e,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>qM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eet={kernelName:yX,gradFunc:(n,e,t)=>{const r=t,s=r.inputShape,i=r.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Yt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet={kernelName:Xg,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aet={kernelName:Kg,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Met={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=t;return{x:()=>_o(_h(Dp(r,s),Ly(r,i)),n,lr(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net={kernelName:Lv,inputsToSave:["x"],gradFunc:one.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $et={kernelName:zv,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(l=>l.shape),{axis:s}=t,i=An(s,e[0].shape)[0],o=r.map(l=>l[i]);return qa(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ret={kernelName:Bv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return U(lp(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>az(r.shape,n,s,o,a,l),filter:()=>Wz(r,n,s.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pet={kernelName:Vv,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>cp(n,s,i,o,a,1,l),filter:()=>Wz(n,r,s.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Det(n,e,t,r,s){let i=n;n.rank===4&&(i=ve(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),U(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),U(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),U(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),U(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),U(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:r,pad:s,filterShape:t};return ue.runKernel(n2,a,l)}const Oet=he({conv3DBackpropFilter_:Det});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fet={kernelName:Uv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i}=t;U(lp(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>aK(o.shape,n,a,s,i),filter:()=>Oet(o,n,a.shape,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Let={kernelName:Zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(us($z(wt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zet={kernelName:Jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Rz(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bet={kernelName:Wv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=t;return{x:()=>{const a=Lr([s],r.rank);let l=fz(n,s,i,!o);return a!=null&&(l=rr(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vet={kernelName:Gv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=t,a=r??[1,1];U(lp(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return U(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),U(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),U(Ri(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),na("depthwiseConv2d",i,o),{x:()=>xY(l.shape,n,c,s,i,a,o),filter:()=>wY(l,n,c.shape,s,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet={kernelName:Hv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>ue.runKernel(y_,i,t),filter:()=>ue.runKernel(b_,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wet={kernelName:ey,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>ue.runKernel(d2,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Get={kernelName:ty,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Yo(us(Or(t))),2/Math.sqrt(Math.PI));return{x:()=>fe(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Het={kernelName:ny,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jet={kernelName:qv,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qet={kernelName:ry,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Yo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xet={kernelName:sy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ket={kernelName:iy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,wt(t,"float32"));const l=ui(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Lt(a,wt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yet={kernelName:Xv,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[s,i,o,a]=e,l=a??en(1),c=ui(i.shape,s.shape),u=[];if(i.rank===1){for(let w=0;w<s.shape.length-1;++w)u.push(s.shape[w]);u.push(1)}const h=Dt(s,i),f=fe(n,l),d=Az(qe(o,en(r))),p=fe(fe(fe(d,d),d),en(-.5));return{x:()=>i.rank===1?ve(fe(fe(n,pc(ve(d,[1,1,1,i.shape[0]]),u)),l),s.shape):ve(fe(fe(n,d),l),s.shape),mean:()=>{let w=fe(fe(d,en(-1)),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},variance:()=>{let w=fe(fe(p,h),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},scale:()=>{const w=fe(h,d);let S=fe(n,w);return i.rank===1&&(S=Yt(S,c)),ve(S,i.shape)},offset:()=>{let w=n;return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet={kernelName:Kv,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,s]=e,{axis:i,batchDims:o}=t,a=An(i,r.shape)[0],l=(c,u,h)=>()=>{const f=c.shape,d=u.size,p=f.slice(0,a),m=p.length,g=f.slice(i,f.length).slice(1),y=g.length,b=b6(0,m),x=b6(m+1,m+1+y),w=v6([p,[d],g]),S=ve(h,w),C=ve(u,[d]),k=v6([[m],b,x]),A=rr(S,k);let M=Lz(A,C,c.shape[a]);const E=Oh(k);return M=rr(M,E),M};if(o===1){const c=r.shape[0],u=r.split(c,0);return{x:()=>_a(u.map((d,p)=>l(d,s.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,n),indices:()=>s}}};function b6(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function v6(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jet={kernelName:oy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>lr(t),b:()=>lr(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet={kernelName:ay,gradFunc:n=>({x:()=>wt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ett={kernelName:ly,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt={kernelName:cy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ntt={kernelName:uy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rtt={kernelName:Zv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:s}=t,i=rl(r,0);return{x:()=>_o(i,n,fe(n,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stt={kernelName:fy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,qe(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const itt={kernelName:hy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,wt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ott={kernelName:bX,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;return{logits:()=>{const o=Yo(r);return Dt(n,fe(Yt(n,s,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function att(n,e,t,r=5,s=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:r,bias:s,alpha:i,beta:o};return ue.runKernel(x2,a,l)}const ltt=he({localResponseNormalizationBackprop_:att});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ctt={kernelName:rw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>ltt(r,s,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ane(n,e,t,r){return e.rank<t.rank&&(e=ve(e,Ls(e.shape,r))),n.rank<t.rank&&(n=ve(n,Ls(n.shape,r))),{x:()=>fe(n,wt(vu(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w6={kernelName:sw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:s}=r,i=e[0],o=e[1],a=An(s,i.shape),l=ane(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const utt={kernelName:dy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,wt(Dp(t,r),"float32")),b:()=>fe(n,wt(I_(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function htt(n,e,t,r,s,i,o){const a=j(n,"dy","maxPool3dGrad"),l=j(e,"input","maxPool3dGrad"),c=j(t,"output","maxPool3dGrad");let u=a,h=l,f=c,d=!1;l.rank===4&&(d=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=ve(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),U(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),U(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),na("maxPool3dGrad",i,o);const p={dy:u,input:h,output:f},m={filterSize:r,strides:s,pad:i,dimRoundingMode:o},g=ue.runKernel(S2,p,m);return d?ve(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const ftt=he({maxPool3dGrad_:htt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dtt={kernelName:ow,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>ftt(n,r,s,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ptt(n,e,t,r,s,i,o){const a=j(n,"dy","maxPoolGrad"),l=j(e,"input","maxPoolGrad"),c=j(t,"output","maxPoolGrad");U(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),U(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),U(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),na("maxPoolGrad",i,o);const u={dy:a,input:l,output:c},h={filterSize:r,strides:s,pad:i,dimRoundingMode:o};return ue.runKernel(_2,u,h)}const mtt=he({maxPoolGrad_:ptt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gtt={kernelName:iw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>mtt(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt={kernelName:aw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t,i=An(s,r.shape),a=Qs(r.shape,i)[1],l=Te(a);return{x:()=>{const u=r.shape.slice();i.forEach(d=>{u[d]=1});const h=ve(n,u);return Lt(fe(h,ma(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const btt={kernelName:lw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:s}=r,[i,o]=e,a=An(s,i.shape),l=ane(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt={kernelName:py,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,wt(Ly(t,r),"float32")),b:()=>fe(n,wt(rl(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wtt={kernelName:cw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>dn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xtt={kernelName:my,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=ui(t.shape,s);return a.length>0?ve(Yt(n,a),t.shape):n},b:()=>{const a=fe(n,us(Q2(Lt(t,r)))),l=ui(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _tt={kernelName:gy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=fe(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{const a=fe(n,wt(t,"float32")),l=ui(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt={kernelName:uw,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ctt={kernelName:dw,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>ms(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ktt={kernelName:fw,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ttt={kernelName:pw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Ec(n,r).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6={kernelName:mw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>dn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ett={kernelName:yy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,s]=e,i=t,o=r,a=ln(i.shape,o.shape);return{a:()=>{const u=wt(o,"float32");let h=fe(n,fe(u,up(i,Dt(u,en(1)))));const f=ui(i.shape,a);return f.length>0&&(h=Yt(h,f)),ve(h,i.shape)},b:()=>{const u=rl(i,0),h=_o(u,Nl(i),lr(i));let f=fe(n,fe(s,h));const d=ui(o.shape,a);return d.length>0&&(f=Yt(f,d)),ve(f,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Itt={kernelName:gw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,s=rl(t,0);return{x:()=>_o(s,n,fe(n,r)),alpha:()=>{let i=_o(s,lr(n),fe(n,t));const o=ui(r.shape,n.shape);return o.length>0&&(i=Yt(i,o)),ve(i,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Att(n,e,t){const r=n.shape.slice();r[t]=1;const s=ve(e,r),i=MI(n,t,!0,!1),o=MI(n,t,!0,!0),a=fe(i,o);return fe(s,a)}function Mtt(n,e,t){const r=n.shape.length,s=r-t.length,i=Lr(t,r);let o=n;i!=null&&(o=rr(n,i));const a=o.shape.slice(),c=a.splice(r-t.length,t.length).reduce((f,d)=>f*d,1);a.push(c);const u=o.reshape(a);let h=Att(u,e,s);if(h=h.reshape(o.shape),i!=null){const f=Oh(i);h=rr(h,f)}return h}const Ntt={kernelName:yw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;let i=[];return s==null?i=r.shape.map((o,a)=>a):typeof s=="number"?i=[s]:i=s,{x:()=>Mtt(r,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $tt={kernelName:Qg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,wt(t,"float32"));const l=ui(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Lt(a,wt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt={kernelName:by,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,us(Or(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ptt={kernelName:wy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Ly(t,6),Pw(t));return{x:()=>fe(n,wt(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dtt={kernelName:vy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,wt(Pw(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ott={kernelName:bw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ftt={kernelName:ww,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ue.runKernel(N2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ltt={kernelName:vw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ue.runKernel(M2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ztt={kernelName:xw,gradFunc:(n,e,t)=>{const{dims:r}=t,s=An(r,n.shape);return{x:()=>Tc(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Btt={kernelName:xy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vtt={kernelName:_y,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>us(Lt(n,fe(up(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Utt={kernelName:_w,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>wt(lr(t),"float32"),t:()=>fe(n,wt(t,n.dtype)),e:()=>fe(n,wt(GM(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wtt={kernelName:Sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=rl(t,en(0)),s=en(fC),i=en(dC),o=fe(n,i),a=fe(fe(n,s),Yo(wt(t,"float32")));return _o(r,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gtt={kernelName:Ey,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(t,Dt(en(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Htt={kernelName:Ty,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jtt={kernelName:Cy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(LM(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qtt={kernelName:ky,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(hz(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xtt={kernelName:Sw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:s,size:i}=t,o=r.shape,[a,l]=hC(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>wu(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ktt={kernelName:Ew,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:s}=t,i=!0,o=fe(n,r);return{logits:()=>Dt(o,fe(Yt(o,[s],i),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ytt={kernelName:Iy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,El(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _6={kernelName:kw,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>FM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S6={kernelName:Tw,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>cs(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ztt={kernelName:Ay,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,fe(So(wt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jtt={kernelName:L2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(wt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qtt={kernelName:My,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=en(2);return{a:()=>fe(n,fe(s,Dt(t,r))),b:()=>fe(n,fe(s,Dt(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ent={kernelName:Dy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tnt={kernelName:Ny,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ui(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ui(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(us(a),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nnt={kernelName:Cw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,s=r.shape.slice(),{axis:i}=t;An(i,r.shape).forEach(c=>{s[c]=1});const a=ve(n,s),l=fe(a,ma(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rnt={kernelName:$y,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Or(LM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const snt={kernelName:Ry,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Dt(en(1),Or(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const int={kernelName:Py,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:s}=t;return{x:()=>{let o=lr(r);if(r.rank===1)for(let a=0;a<s[0];++a)o=qe(o,dn(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ont={kernelName:jd,gradFunc:(n,e,t)=>{const r=t,{perm:s}=r,i=Oh(s);return{x:()=>rr(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ant={kernelName:Iw,gradFunc:(n,e,t)=>{const r=t,{axis:s}=r;return{value:()=>_a(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lnt={kernelName:Aw,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>cnt(n,t)}}};function cnt(n,e){const t=jf(e,lr(e)),r=eC(n,t);let s=Dp(e,en(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=oi(s,a+1);s=_h(s,ma(r.shape,"bool"));const o=lr(r);return _o(s,r,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const unt={kernelName:Mw,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hnt=[one,oet,aet,cet,uet,het,fet,det,pet,met,get,yet,wet,Cet,ket,Tet,Eet,Iet,Aet,Met,Net,$et,Pet,Ret,Fet,Let,zet,Bet,Vet,Uet,$tt,Wet,Get,Het,jet,qet,Ket,Xet,Yet,Zet,Jet,Qet,ett,ttt,ntt,rtt,stt,itt,ott,ctt,w6,w6,utt,dtt,gtt,ytt,btt,vtt,wtt,xtt,_tt,Stt,Ctt,ktt,Ttt,x6,x6,Ett,Itt,Ntt,Rtt,Ptt,Dtt,Ott,Ftt,Ltt,ztt,Btt,Vtt,Utt,Wtt,Gtt,Htt,jtt,qtt,Xtt,Ktt,Ytt,_6,_6,S6,S6,Ztt,Qtt,Jtt,ent,tnt,nnt,rnt,snt,int,ont,ant,lnt,unt];for(const n of hnt)vX(n);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function v4(n,e){return Se(()=>So(Yt(fe(n,n),e,!0)))}class MC extends By{getConfig(){return{}}}class lne extends MC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=v4(e,this.axis),r=xa(t,0,this.maxValue);return fe(e,Lt(r,qe(ki(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}lne.className="MaxNorm";ot(lne);class cne extends MC{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>Lt(e,qe(ki(),v4(e,this.axis))))}getConfig(){return{axis:this.axis}}}cne.className="UnitNorm";ot(cne);class une extends MC{apply(e){return Fh(e)}}une.className="NonNeg";ot(une);class hne extends MC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=v4(e,this.axis),r=qe(fe(this.rate,xa(t,this.minValue,this.maxValue)),fe(1-this.rate,t));return fe(e,Lt(r,qe(ki(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}hne.className="MinMaxNorm";ot(hne);const C6={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ii(n){return l4(n)}function k6(n,e={}){return kC(n,xl.getMap().classNameMap,e,"constraint")}function Ai(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in C6?C6[n]:n,config:{}};return k6(t)}else return n instanceof MC?n:k6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function cm(n){if(n==null)return;const e=[],t=[],r=[];for(const s in n){const i=n[s];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(s),r.push(o)}}if(e.length>0){const s=await Promise.all(e);for(let i=0;i<s.length;++i)n[t[i]]=s[i][0];nn(r)}}function fne(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var T6;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(T6||(T6={}));const fnt=125;class Y_{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class dnt{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class pnt extends Y_{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const s in t){const i=t[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*r;else{let o;s in this.totals?o=this.totals[s]:this.totals[s]=0;const a=Se(()=>qe(this.totals[s],fe(i,r)));this.totals[s]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:Se(()=>{const s=fe(Lt(1,this.seen),this.totals[r]);t[r]=s,this.totals[r].dispose(),Xs(t[r])}))}}class mnt extends Y_{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),r.push(a)}}const s=await Promise.all(e);for(let i=0;i<s.length;++i)this.history[t[i]][r[i]].dispose(),this.history[t[i]][r[i]]=s[i][0]}}class gnt extends Y_{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||nB,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=fnt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");SI(this.yieldEvery)&&(this.maybeWait=SQe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const s=[];this.yield!=null&&(await cm(r),s.push(this.yield(e,t,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await cm(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await cm(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await cm(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await cm(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):SI(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await cm(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await cm(e),await this.trainEnd(e))}}function dne(n,e){return n==null&&(n={}),n instanceof Y_?[n]:Array.isArray(n)&&n[0]instanceof Y_?n:Gr(n).map(r=>new gnt(r,e))}class sc{constructor(){}static registerCallbackConstructor(e,t){U(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),sc.checkForDuplicate(t),sc.constructors[e]==null&&(sc.constructors[e]=[]),sc.constructors[e].push(t)}static checkForDuplicate(e){for(const t in sc.constructors)sc.constructors[+t].forEach(s=>{if(s===e)throw new _e("Duplicate callback constructor.")})}static clear(){sc.constructors={}}static createCallbacks(e){const t=[];for(const r in sc.constructors){const s=+r;e>=s&&t.push(...sc.constructors[s])}return t.map(r=>new r)}}sc.constructors={};function pne(n,e,t,r,s,i,o,a,l){const c=new mnt,u=[new pnt,...sc.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new dnt(u);return h.setParams({epochs:t,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bh(n,e={},t=!1){return kC(n,xl.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iA(n,e){return Se(()=>{n.dtype!=="float32"&&(n=wt(n,"float32"));const t=Yt(EC(n),e,!0),r=Fy(t.shape,ki()),s=So(jf(t,r));return Lt(n,s)})}function h$(n,e){return Se(()=>Ds(EC(Dt(e,n)),-1))}function w4(n,e){return Se(()=>Ds(wi(Dt(e,n)),-1))}function x4(n,e){return Se(()=>{const t=Dt(n,e),r=xa(wi(n),ki(),Number.MAX_VALUE),s=wi(Lt(t,r));return fe(100,Ds(s,-1))})}function ynt(n,e){return Se(()=>{const t=xa(e,ki(),Number.MAX_VALUE),r=Nl(qe(1,t)),s=xa(n,ki(),Number.MAX_VALUE),i=Nl(qe(1,s));return Ds(EC(Dt(r,i)),-1)})}function bnt(n,e){return Se(()=>{const t=jf(0,Dt(1,fe(n,e)));return Ds(EC(t),-1)})}function vnt(n,e){return Se(()=>{const t=jf(0,Dt(1,fe(n,e)));return Ds(t,-1)})}function wnt(n,e){return Se(()=>{const t=Yt(fe(n,e),-1),r=wc(fe(Dt(1,n),e),-1);return jf(0,qe(1,Dt(r,t)))})}function xnt(n,e){return Se(()=>{const t=Math.log(2),r=Dt(e,n),s=Dt(qe(r,$w(fe(-2,r))),t);return Ds(s,-1)})}function Z_(n,e,t=!1){return Se(()=>{if(t)e=iC(e);else{const r=Yt(e,e.shape.length-1,!0);e=Lt(e,r)}return e=xa(e,ki(),1-ki()),us(Yt(fe(wt(n,"float32"),Nl(e)),e.shape.length-1))})}function oA(n,e,t=!1){return Se(()=>{const r=wt(Q2(DQe(n)),"int32");e=xa(e,ki(),1-ki());const s=e.shape,i=ve(Jb(r,s[s.length-1]),s);return Z_(i,e,t)})}function _nt(n,e){if(!Rn(n.shape,e.shape))throw new _e(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return Se(()=>{const t=Fh(e),r=us(wi(e));return qe(Dt(t,fe(e,n)),VM(Yo(r)))})}function f$(n,e){return Se(()=>{let t;return t=xa(e,ki(),1-ki()),t=Nl(Lt(t,Dt(1,t))),Ds(_nt(n,t),-1)})}function Snt(n,e){return Se(()=>{const t=xa(n,ki(),1),r=xa(e,ki(),1);return Yt(fe(n,Nl(Lt(t,r))),-1)})}function Cnt(n,e){return Se(()=>{const t=Nl(qe(ki(),e));return Ds(Dt(e,fe(n,t)),-1)})}function mne(n,e){return Se(()=>{const t=iA(n,-1),r=iA(e,-1),s=fe(t,r);return us(Yt(s,-1))})}const aA={meanSquaredError:h$,meanAbsoluteError:w4,meanAbsolutePercentageError:x4,meanSquaredLogarithmicError:ynt,squaredHinge:bnt,hinge:vnt,categoricalHinge:wnt,logcosh:xnt,categoricalCrossentropy:Z_,sparseCategoricalCrossentropy:oA,binaryCrossentropy:f$,kullbackLeiblerDivergence:Snt,poisson:Cnt,cosineProximity:mne};function R3(n){if(typeof n=="string"){if(n in aA)return aA[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new _e(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gne(n,e){return Se(()=>{const t=fe(.5,$l(e)),r=gh(rl(e,t),n.dtype);return Ds(vu(n,r),-1)})}function yne(n,e){return Se(()=>gh(vu(ug(n,-1),ug(e,-1)),"float32"))}function knt(n,e){return Se(()=>wt(Yt(_h(vu(n,1),vu(e,1))),"float32"))}function Tnt(n,e){return Se(()=>wt(Yt(_h(vu(n,0),vu(e,1))),"float32"))}function Ent(n,e){return Se(()=>{const t=knt(n,e),r=Tnt(n,e),s=qe(t,r);return wt(_o(rl(s,0),Lt(t,s),0),"float32")})}function Int(n,e){return f$(n,e)}function Ant(n,e){return n.rank===e.rank&&(n=vr(n,[n.rank-1])),e=ug(e,-1),e.dtype!==n.dtype&&(e=wt(e,n.dtype)),wt(vu(n,e),"float32")}const Mnt=h$,Nnt=h$,$nt=w4,Rnt=w4,Pnt=x4,Dnt=x4,bne=Z_,Ont=mne,vne=oA,lA={binaryAccuracy:gne,categoricalAccuracy:yne,precision:Ent,categoricalCrossentropy:bne,sparseCategoricalCrossentropy:vne,mse:Mnt,MSE:Nnt,mae:$nt,MAE:Rnt,mape:Pnt,MAPE:Dnt,cosine:Ont};function Fnt(n){if(typeof n=="string"&&n in lA)return lA[n];if(typeof n!="string"&&n!=null)return n;throw new _e(`Unknown metric ${n}`)}function dT(n){if(ah(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(aA))if(aA[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(lA))if(lA[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lnt(n){const e={Adagrad:()=>Id.adagrad(.01),Adadelta:()=>Id.adadelta(1,.95,ki()),Adam:()=>Id.adam(.001,.9,.999,ki()),Adamax:()=>Id.adamax(.002,.9,.999,ki(),0),RMSProp:()=>Id.rmsprop(.001,.9,0,ki()),SGD:()=>Id.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new _e(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const E6=1*1024*1024;function I6(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ZO(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>E6&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${E6}.`)}}function ZO(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!ZO(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!ZO(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function znt(n,e,t,r=console.log){const s=Vnt(n),i=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(e)),cA(i,t,r),r("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)s?Unt(a[u],t,r):Wnt(a[u],t,o,r),r((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Bnt(n),c=nA(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(e))}function Bnt(n){let e;return n.collectedTrainableWeights!=null?e=nA(n.collectedTrainableWeights):e=nA(n.trainableWeights),e}function Vnt(n){let e=!0;const t=[],r=[];for(const s in n.nodesByDepth)t.push(n.nodesByDepth[s]);for(const s of t){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(r.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function cA(n,e,t=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);t(r)}function Unt(n,e,t){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,s,r,n.countParams().toString()];cA(a,e,t)}function Wnt(n,e,t,r){let s,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let f=0;f<h.inboundLayers.length;++f){const d=h.inboundLayers[f].name,p=h.nodeIndices[f],m=h.tensorIndices[f];o.push(`${d}[${p}][${m}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,i,s,n.countParams().toString(),c];cA(u,e,r);for(let h=1;h<o.length;++h)cA(["","","","",o[h]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wne(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function uA(n,e){if(n===null)return null;if(typeof n=="string")return Bm(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];wne(e,s,i)?t.push(i):t.push(uA(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r];if(r==="name"&&typeof s=="string")t[r]=s;else{const i=Bm(r);t[i]=uA(s,i)}}return t}}function JO(n,e){if(n==null)return null;if(typeof n=="string")return xf(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];wne(e,s,i)?t.push(i):t.push(JO(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r],i=xf(r);(r==="name"||r==="className")&&typeof s=="string"?t[i]=s:t[i]=JO(s,r)}return t}}/** @license See the LICENSE file. */const xne="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Gnt=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class nu extends Kn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=l$(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Xd(this.inputs).length!==this.inputs.length)throw new _e(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Xd(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(S)}for(const b of this.inputs){const x=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;ah(w===0,"input layer has >1 nodes"),ah(S===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof AC))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},r={},s={},i={},o={},a=[],l=(b,x,w,S,C,k)=>{(S==null||C==null||k==null)&&(S=b.sourceLayer,C=b.nodeIndex,k=b.tensorIndex);const A=S.inboundNodes[C];if(w.indexOf(A)!==-1)throw new gc(`The tensor ${b.name} at layer "${S.name}" is part of a cycle.`);if(x.indexOf(A)!==-1)return;this.containerNodes.add(nu.nodeKey(S,C)),S.id in o||(o[S.id]=Object.keys(o).length),w.indexOf(A)===-1&&w.push(A);const M=A.inboundLayers.length;for(let E=0;E<M;E++){const N=A.inputTensors[E],O=A.inboundLayers[E],R=A.nodeIndices[E],D=A.tensorIndices[E];l(N,x,w,O,R,D)}for(x.push(A);w.indexOf(A)>=0;)w.splice(w.indexOf(A),1);a.push(A)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=a.slice().reverse();for(const b of h){r[b.id]=b,b.id in t||(t[b.id]=0);let x=t[b.id];const w=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,w),s[b.outboundLayer.id]=x,i[b.outboundLayer.id]=b.outboundLayer,t[b.id]=x;for(let S=0;S<b.inboundLayers.length;S++){const C=b.inboundLayers[S],k=b.nodeIndices[S],A=C.inboundNodes[k],M=t[A.id]==null?0:t[A.id];t[A.id]=Math.max(x+1,M),r[A.id]=A}}const f={};for(const b in t){const x=t[b];x in f||(f[x]=[]),f[x].push(r[b])}const d={};for(const b in s){const x=s[b];x in d||(d[x]=[]),d[x].push(i[b])}let p=Object.keys(d).map(b=>parseInt(b,10)).sort(uT);this.layers=[];for(const b of p){const x=d[b];x.sort((w,S)=>{const C=o[w.id],k=o[S.id];return C<k?-1:C>k?1:0});for(const w of x)w instanceof nu&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,p=Object.keys(f).map(b=>parseInt(b,10)).sort(uT);const m=this.inputs.slice(),g=[];for(const b of p)for(const x of f[b]){const w=x.outboundLayer;if(w!=null){for(const S of x.inputTensors)if(m.indexOf(S)===-1)throw new gc(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const S of x.outputTensors)m.push(S);g.push(w.name)}}this.nodesByDepth=f;const y=this.layers.map(b=>b.name);for(const b of y){const x=y.filter(w=>w===b).length;if(x!==1)throw new gc(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new u$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new _e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let s=0;const i=Gnt(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new _e(`Duplicate weight name: ${u}`);r[u]=c,s++}const o=[];for(const a in e){let l=a;if(r[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(t)throw new _e(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new _e(`${a.length} of ${s} weights are not set: ${a}`)}b4(o)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),s=["vars","layer_checkpoint_dependencies"],i=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!s.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${xne}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=JO(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return Se(()=>{e=Gr(e);const r=new Ld;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return N1(this.outputs,r,t)})}computeMask(e,t){return Se(()=>{e=Gr(e);let r;return t==null?r=wg(null,e.length):r=Gr(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=tA(e);if(t.length!==this.inputLayers.length)throw new _e(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";r[u]=c}const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(uT);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;const h=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],x=`${g.name}_${y}_${b}`,w=r[x];h.push(w)}const f=u.computeOutputShape(da(h)),d=tA(f),p=u.inboundNodes.indexOf(c);for(let m=0;m<d.length;m++){const g=`${u.name}_${p}_${m}`;r[g]=d[m]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];ah(l in r),i.push(r[l])}return da(i)}runInternalGraph(e,t){t==null&&(t=wg(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];r[c.id]=[u,h]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(uT);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,f=u.inputTensors,d=u.outputTensors,p=new Array;for(const m of f)m.id in r&&p.push(r[m.id]);if(p.length===f.length){let m={},g,y,b,x;if(u.callArgs!=null&&(m=u.callArgs),p.length===1){const[w,S]=p[0];m.mask==null&&(m.mask=S),b=Gr(h.call(w,m)),x=Gr(h.computeMask(w,S)),g=[w],y=[S]}else g=p.map(w=>w[0]),y=p.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Gr(h.call(g,m)),x=Gr(h.computeMask(g,y));if(h.activityRegularizer)throw new Fn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){const S=d[w],C=b[w],k=x[w];r[S.id]=[C,k]}}}}const i=[],o=[],a=[];for(const l of this.outputs){ah(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(e){const t={};let r;for(const s of this.layers){r=s instanceof nu?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=nu.nodeKey(s,i);this.containerNodes.has(o)&&(t[o]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new _e("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new _e(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new _e(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Se(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=nu.nodeKey(t,r);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const f=o.inboundNodes[h],d=nu.nodeKey(o,h);let p={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),p=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(f.inboundLayers.length>0){const m=[];for(let g=0;g<f.inboundLayers.length;g++){const y=f.inboundLayers[g],b=f.nodeIndices[g],x=f.tensorIndices[g],w=nu.nodeKey(y,b);let S=t[w];S==null&&(S=0),m.push([y.name,S,x,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}e.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=nu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];s.push([a.name,u,h])}e.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=nu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,u,h])}return e.outputLayers=i,e}static fromConfig(e,t,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let x;for(const w of y){const S=w[0],C=w[1],k=w[2];if(x=w[3]==null?{}:w[3],!(S in i)){a(g,y);return}const A=i[S];if(A.inboundNodes.length<=C){a(g,y);return}const M=A.inboundNodes[C];b.push(M.outputTensors[k])}b.length>0&&g.apply(da(b),x)}function c(g){const y=g.name,b=bh(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new _e(`Corrupted configuration, expected array for nodeData: ${w}`);a(b,w)})}const u=t.name,h=t.layers;for(const g of h)c(g);for(;!_Qe(o);)for(const g of h){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const x of b)l(y,x)}}const f=[],d=[],p=t.inputLayers;for(const g of p){const y=g[0],b=g[1],x=g[2];ah(y in i);const S=i[y].inboundNodes[b].outputTensors;f.push(S[x])}const m=t.outputLayers;for(const g of m){const y=g[0],b=g[1],x=g[2];ah(y in i);const S=i[y].inboundNodes[b].outputTensors;d.push(S[x])}return new e({inputs:f,outputs:d,name:u})}get stateful(){if(this._stateful)throw new _e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hnt(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const s=[];return e.forEach(i=>{i in n?s.push(n[i]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function _ne(n,e){return Hnt(n,e,"classWeight")}async function Sne(n,e,t,r){if(e!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const s=Se(()=>{if(n.shape.length===1)return mh(n);if(n.shape.length===2){if(n.shape[1]>1)return ug(n,1);if(n.shape[1]===1)return ve(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await s.data());nn(s);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Ks(o,"float32")}else return null}function jnt(n,e){return fe(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const qnt=32;function Cne(n,e){let t,r;const s=e;t=s.xs,r=s.ys,U(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=A6("input",n.inputNames,t),o=A6("output",n.outputNames,r),a=i[0].shape[0];U(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),U(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)U(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)U(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function A6(n,e,t){if(t instanceof jn)return[t];if(Array.isArray(t))return U(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const s of e){if(t[s]==null)throw new _e(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(t[s])}return r}}function Xnt(n){if(n.length===3)throw new Fn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Knt(n,e,t){const r=t.batchesPerEpoch!=null;if(U(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),U(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),U(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=t.validationData!=null;let i,o;if(s)if(M6(t.validationData))U(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=Xnt(t.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;s?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();const u=dne(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:f,history:d}=pne(u,h,t.epochs,null,null,Ynt(e,t),null,s,c);f.setModel(n),n.history=d,await f.onTrainBegin(),n.stopTraining_=!1;let p=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;p<t.epochs;){const g={};await f.onEpochBegin(p);let y=0,b=0;for(r||(m=await e.iterator());!r||y<t.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:w,ys:S}=Cne(n,x.value),C={};C.batch=b,C.size=w[0].shape[0],await f.onBatchBegin(b,C);const k=[];if(t.classWeight!=null){const E=_ne(t.classWeight,n.outputNames);for(let N=0;N<E.length;++N)k.push(await Sne(S[N],null,E[N]))}const A=w.concat(S).concat(k),M=a(A);nn(A);for(let E=0;E<l.length;++E){const N=l[E],O=M[E];C[N]=O,Xs(O)}await f.onBatchEnd(b,C),fne(C),b++,y++}if(r?y>=t.batchesPerEpoch:x.done){if(s){let w;M6(t.validationData)?w=Gr(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):w=Gr(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?qnt:t.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)g[`val_${n.metricsNames[S]}`]=w[S]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(p,g),p++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Ynt(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function M6(n){return typeof n.iterator=="function"}function Znt(n){return typeof n.next=="function"}async function Jnt(n,e,t){t=t||{};const r=t.batches!=null,s=n.testFunction;let i=[];if(t.verbose>0)throw new Fn("Verbose mode is not implemented yet.");U(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=Znt(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<t.batches;){const c=await o.next();if(i=Se(()=>{if(c.value){const{xs:u,ys:h}=Cne(n,c.value),f=u.concat(h),d=Se(()=>s(f));if(nn(f),l===0)for(let m=0;m<d.length;++m)i.push(en(0));const p=f[0].shape[0];for(let m=0;m<d.length;++m){const g=d[m],y=i[m];i[m]=Se(()=>qe(i[m],fe(p,g))),l>0&&nn(y)}nn(d),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Lt(i[c],a),nn(u)}return da(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function P3(n){U(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Kx(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Qm(r,e,t-e)):Qm(n,e,t-e)}function QO(n,e){return Se(()=>n==null?null:Array.isArray(n)?n.map(t=>QO(t,e)):Yte(n,e.dtype==="int32"?e:wt(e,"int32")))}function D3(n,e){const t=[];let r=0,s=null;for(;r<n;)s=r+e,s>=n&&(s=n),t.push([r,s]),r=s;return t}function kne(n){const e=[];n instanceof jn&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(TC(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Xc(n,e){if(n==null)return;const t=[];if(e instanceof jn)t.push(e.id);else if(Array.isArray(e))e.forEach(s=>t.push(s.id));else if(e!=null)for(const s in e){const i=e[s];t.push(i.id)}const r=[];if(n instanceof jn)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{t.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(const s in n){const i=n[s];t.indexOf(i.id)===-1&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qnt(n){return n instanceof jn}function eF(n){return Array.isArray(n)}function N6(n){return!Qnt(n)&&!eF(n)}function $6(n,e,t,r=!0,s=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(eF(n)&&n.length>0)o=!0;else if(N6(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new _e(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(N6(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new _e(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(eF(n)){if(n=n,n.length!==e.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new _e(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=kne(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new _e(`${s} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function ert(n,e,t){const r=Xd(n.map(i=>i.shape[0]));r.sort();const s=Xd(e.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new _e(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new _e(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!Rn(r,s))throw new _e(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function trt(n,e,t){const r=[h$,f$,Z_];for(let s=0;s<n.length;++s){const i=n[s],o=e[s],a=t[s];if(o!=null){if(o===Z_&&i.shape[i.shape.length-1]===1)throw new _e(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],f=c[u];if(f!=null&&h!==f)throw new _e(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function R6(n,e,t,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new _e(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new _e(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function nrt(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const s of e){let i=t.hasOwnProperty(s)?t[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}const rrt="layers-model";class Yd extends nu{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new _e("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");znt(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Lnt(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Xf))throw new _e("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new _e(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(R3(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new _e(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>R3(a))}else{const o=R3(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Jm("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const s=nrt(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Jm("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=s[o];(c=>{const u="";let h,f,d;for(const p of c){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===f$?["accuracy","acc"].indexOf(p)!==-1?f=gne:["crossentropy","ce"].indexOf(p)!==-1&&(f=Int):this.lossFunctions[o]===oA?["accuracy","acc"].indexOf(p)!==-1?f=Ant:["crossentropy","ce"].indexOf(p)!==-1&&(f=vne):["accuracy","acc"].indexOf(p)!==-1?f=yne:["crossentropy","ce"].indexOf(p)!==-1&&(f=bne);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=f,h=u+y}else d=Fnt(p),h=u+dT(p);let m;Jm(h,()=>{m=d}),i(o,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const s=r.batchSize==null?32:r.batchSize;P3(s);const i=!0,o=this.standardizeUserDataXY(e,t,i,s);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,s,r.verbose,r.steps);return da(c)}finally{Xc(o[0],e),Xc(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Jnt(this,e,t)}checkNumSamples(e,t,r,s="steps"){let i;if(r!=null){if(i=null,t!=null)throw new _e(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new _e(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new _e("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),s=r?t:[t],i=this.retrieveSymbolicTensors(s),o=new Ld;if(e instanceof jn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new _e(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new _e(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=N1(i,o);return r?a:a[0]}retrieveSymbolicTensors(e){const t=wg(null,e.length);let r=e.length;for(const s of this.layers){const i=Array.isArray(s.output)?s.output:[s.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw t.forEach((i,o)=>{i==null&&s.push(e[o])}),new _e(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(e,t=32,r=!1){return Se(()=>{const s=this.checkNumSamples(e);if(r)throw new Fn("Verbose predictLoop() is not implemented yet.");const i=D3(s,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)Se(()=>{const c=i[a][0],u=i[a][1],h=Kx(e,c,u),f=[];if(Array.isArray(h))for(let p=0;p<h.length;++p)f.push({key:this.inputs[p],value:h[p]});else f.push({key:this.inputs[0],value:h});const d=new Ld(f);return N1(this.outputs,d)}).forEach((c,u)=>o[u].push(c));return da(o.map(a=>cs(a,0)))})}predict(e,t={}){const r=kne(e);R6(r,this.inputNames,this.feedInputShapes,!1);try{const s=t.batchSize==null?32:t.batchSize;return P3(s),this.predictLoop(r,s)}finally{Xc(r,e)}}predictOnBatch(e){R6(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,s){if(this.optimizer_==null)throw new gc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===oA?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=$6(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=$6(t,this.feedOutputNames,i,!1,"target"),ert(e,t),trt(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new _e(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,s,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(r!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){const u=_ne(s,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await Sne(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,r,s=0,i){return Se(()=>{const o=this.checkNumSamples(t,r,i,"steps"),a=[];if(s>0)throw new Fn("Verbose mode is not implemented yet.");if(i!=null)throw new Fn("steps mode in testLoop() is not implemented yet");{const l=D3(o,r),c=Ks(Cu(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],f=l[u][1],d=Qm(c,h,f-h),p=QO(t,d),m=e(p);if(u===0)for(let g=0;g<m.length;++g)a.push(en(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=qe(a[g],fe(f-h,y))}}for(let u=0;u<a.length;++u)a[u]=Lt(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const s=e[r];let i=s;if(h6(e,s)>1){const o=h6(e.slice(0,r),s);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const f=new Ld(h),d=N1(this.outputs,f,{training:!0});let p;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(s[m],d[m]);i[m]!=null&&(y=jnt(y,i[m]));const b=Ds(y);t.push(b),m===0?p=y:p=qe(p,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Ds(y(s[b],d[b]))}Xs(g),o.push(g)}return p=Ds(p),this.calculateLosses().forEach(m=>{p=qe(p,m)}),p},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>Se(()=>{const t=[];let r;const s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:s[c]});const a=new Ld(o),l=N1(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=Ds(u(i[c],l[c]));c===0?r=h:r=qe(r,h),t.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],f=Ds(u(i[h],l[h]));t.push(f)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,o,a,l,c,u,h,f;try{const d=r.batchSize==null?32:r.batchSize;P3(d);const p=!1,m=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,p,d);s=m[0],i=m[1],f=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],c=r.validationData[1];else throw r.validationData.length===3?new Fn("validationData including sample weights is not supported yet."):new _e(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const M=!0,E=await this.standardizeUserData(l,c,null,null,M,d);u=E[0],h=E[1],y=u.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const M=Math.floor(s[0].shape[0]*(1-r.validationSplit)),E=s[0].shape[0];u=Kx(s,M,E),o=s,s=Kx(s,0,M),h=Kx(i,M,E),a=i,i=Kx(i,0,M),y=u.concat(h)}else r.validationSteps!=null&&(g=!0);const b=s.concat(i).concat(f);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let S,C;g?(this.makeTestFunction(),S=this.testFunction,C=w.slice().concat(w.map(M=>"val_"+M))):(S=null,y=[],C=w.slice());const k=dne(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,w,d,r.epochs,r.verbose,k,S,y,r.shuffle,C,r.initialEpoch,null,null)}finally{this.isTraining=!1,Xc(s,e),Xc(i,t),Xc(o,e),Xc(a,t),Xc(u,l),Xc(h,c),f!=null&&nn(f)}}async fitLoop(e,t,r,s,i,o,a,l,c,u,h,f,d,p){s==null&&(s=32),i==null&&(i=1),u==null&&(u=!0),f==null&&(f=0);let m=!1;if(l!=null&&c!=null&&(m=!0),p!=null&&(m=!0,d==null))throw new _e("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,s,d,"steps_per_epoch");let y;g!=null&&(y=Cu(0,g)),o==null&&(o=1);const{callbackList:b,history:x}=pne(a,o,i,f,g,d,s,m,h);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=f;w<i;++w){await b.onEpochBegin(w);const S={};if(d!=null)throw new Fn("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Fn("batch shuffling is not implemneted yet");u&&AL(y);const C=Ks(y),k=D3(g,s);for(let A=0;A<k.length;++A){const M={};if(await b.onBatchBegin(A,M),Se(()=>{const E=k[A][0],N=k[A][1],O=Qm(C,E,N-E);M.batch=A,M.size=N-E;const R=QO(t,O),D=e(R);for(let z=0;z<r.length;++z){const B=r[z],X=D[z];M[B]=X,Xs(X)}if(A===k.length-1&&m){const z=this.testLoop(l,c,s);for(let B=0;B<r.length;++B){const X=r[B],G=z[B];Xs(G),S["val_"+X]=G}}}),await b.onBatchEnd(A,M),fne(M),this.stopTraining_)break}C.dispose()}if(await b.onEpochEnd(w,S),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Knt(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),s=r[0],i=r[1],a=this.makeTrainFunction()(s.concat(i)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return nn(a),Xc(r[0],e),Xc(r[1],t),da(l)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<s.length;++o)r&&!s[o].trainable||t.push({name:s[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=II().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-II().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=xf(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>xf(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const s of t)if(typeof r[s]=="string")e[s]=xf(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[xf(dT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>xf(dT(e)));{const e={};for(const t in this.metrics)e[t]=xf(dT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=uA(e.optimizer_config),r=bh(t);let s;if(typeof e.loss=="string")s=Bm(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>Bm(o));else if(e.loss!=null){s={};for(const o in e.loss)s[o]=Bm(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Bm(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Bm(e.metrics[o])}this.compile({loss:s,metrics:i,optimizer:r})}async save(e,t){if(typeof e=="string"){const c=zX(e);if(c.length===0)throw new _e(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new _e(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new _e("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await CD(this.getNamedWeights(t)),s=!1,i=null,a={modelTopology:this.toJSON(i,s),format:rrt,generatedBy:`TensorFlow.js tfjs-layers v${xne}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await CD(await this.optimizer.getWeights(),c);r.specs.push(...h),r.data=FX([r.data,u])}return this.userDefinedMetadata!=null&&(I6(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){I6(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yd.className="Model";ot(Yd);class Tne extends Yd{}Tne.className="Functional";ot(Tne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function J_(n,e){if(e==null&&(e={}),typeof n=="string"){const t=BX(n,e);if(t.length===0)t.push(PY(n,e));else if(t.length>1)throw new _e(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return srt(n,void 0,e)}async function srt(n,e,t){if(t==null&&(t={}),n.load==null)throw new _e("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await n.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const i=t.strict==null?!0:t.strict,o=r.weightData!=null&&r.weightSpecs!=null&&i,a=bh(uA(s),e,o),l=r.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),r.userDefinedMetadata!=null&&a.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new _e("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=irt(r.weightData,r.weightSpecs);a.loadWeights(c,i),a.optimizer!=null&&u.length>0&&await a.optimizer.setWeights(u),nn(c),nn(u.map(h=>h.tensor))}return a}function irt(n,e){const t=BL(n,e),r={},s=[];return e.forEach(i=>{i.group==="optimizer"?s.push({name:i.name,tensor:t[i.name]}):r[i.name]=t[i.name]}),{modelWeights:r,optimizerWeights:s}}class cv extends Yd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:l$("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new _e(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof cv||e instanceof Yd;let r;if(t){if(r=e,r.outputs.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new _e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new _e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=QQe({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new _e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=ine(this.outputs[0])}this.inboundNodes=[],new u$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:wg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(wr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new gc("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new gc("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new gc("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new gc("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},s=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new _e("Legacy serialization format not supported yet.");i=t}else U(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof cv))throw new Fn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const u=bh(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new _e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new _e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}cv.className="Sequential";ot(cv);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function art(n){return new cv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ia=class extends By{getConfig(){return{}}};class Ene extends Ia{apply(e,t=1){return FQe(e,t)}}Ene.className="elu";ot(Ene);class Ine extends Ia{apply(e){return Mz(e)}}Ine.className="selu";ot(Ine);class Ane extends Ia{apply(e){return Fh(e)}}Ane.className="relu";ot(Ane);class Mne extends Ia{apply(e){return Se(()=>hp(6,Fh(e)))}}Mne.className="relu6";ot(Mne);class Nne extends Ia{apply(e){return e}}Nne.className="linear";ot(Nne);class $ne extends Ia{apply(e){return El(e)}}$ne.className="sigmoid";ot($ne);class Rne extends Ia{apply(e){return zQe(e)}}Rne.className="hardSigmoid";ot(Rne);class Pne extends Ia{apply(e){return $w(e)}}Pne.className="softplus";ot(Pne);class Dne extends Ia{apply(e){return LQe(e)}}Dne.className="softsign";ot(Dne);class One extends Ia{apply(e){return Yb(e)}}One.className="tanh";ot(One);let _4=class extends Ia{apply(e,t=-1){return iC(e,t)}};_4.className="softmax";ot(_4);class Fne extends Ia{apply(e,t=-1){return pz(e,t)}}Fne.className="logSoftmax";ot(Fne);class Lne extends Ia{apply(e,t=1){return Se(()=>fe(El(fe(e,t)),e))}}Lne.className="swish";ot(Lne);class zne extends Ia{apply(e){return Se(()=>fe(e,Yb($w(e))))}}zne.className="mish";ot(zne);function mp(n){return n.getClassName()}function O3(n,e={}){return kC(n,xl.getMap().classNameMap,e,"activation")}function gp(n){if(n==null){const e={};return e.className="linear",e.config={},O3(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},O3(e)}else return n instanceof Ia?n:O3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lrt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Bne extends By{}class Vne extends Bne{constructor(e){super(),lrt(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Se(()=>{let t=ms([1]);return this.hasL1&&(t=qe(t,Yt(fe(this.l1,wi(e))))),this.hasL2&&(t=qe(t,Yt(fe(this.l2,EC(e))))),ve(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Vne.className="L1L2";ot(Vne);const P6={l1l2:"L1L2"};function jr(n){return l4(n)}function D6(n,e={}){return kC(n,xl.getMap().classNameMap,e,"regularizer")}function vs(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in P6?P6[n]:n,config:{}};return D6(t)}else return n instanceof Bne?n:D6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Une extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=vn(e);let r=Fh(e);return this.maxValue!=null&&(r=xa(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Une.className="ReLU";ot(Une);class Wne extends Kn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=vn(e);return BM(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Wne.className="LeakyReLU";ot(Wne);class Gne extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ys(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vs(e.alphaRegularizer),this.alphaConstraint=Ai(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new _e(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=wr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Ti({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=vn(e),XM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Cs(this.alphaInitializer),alphaRegularizer:jr(this.alphaRegularizer),alphaConstraint:Ii(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Gne.className="PReLU";ot(Gne);class Hne extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Fn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=vn(e);return J2(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Hne.className="ELU";ot(Hne);class jne extends Kn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=vn(e);return fe(r,wt(rl(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}jne.className="ThresholdedReLU";ot(jne);class qne extends Kn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new _4().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return Se(()=>{let r=vn(e);const s=t.mask;if(s!=null){const i=fe(Dt(ma(r.shape),wt(s,r.dtype)),en(-1e9));r=qe(r,i)}return this.axis instanceof Array?this.axis.length>1?Yo(Dt(r,WM(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}qne.className="Softmax";ot(qne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Db(n,e,t){if(typeof n=="number")return wg(n,e);if(n.length!==e)throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const s=n[r];if(!RQe(s))throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function bu(n,e,t,r,s=1){if(n==null)return n;const i=e+(e-1)*(s-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+r-1)/r)}function lh(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+pp([t-e,0]);else if(r==="same")n=n*e;else throw new _e(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function S4(n,e){return Se(()=>(ti(e),e==="channelsFirst"?rr(n,[0,2,3,1]):n))}function Xne(n,e){return Se(()=>(ti(e),e==="channelsFirst"?rr(n,[0,2,3,4,1]):n))}function crt(n,e,t,r=1,s="valid",i,o=1){return Se(()=>{if(i==null&&(i=ku()),ti(i),n.shape.length!==3)throw new _e(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new _e(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new _e(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=rr(n,[0,2,1])),s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=oz(n,e,r,s==="same"?"same":"valid","NWC",o);return t!=null&&(a=Wu(a,t)),a})}function O6(n,e,t,r=[1,1],s="valid",i,o,a=null){return Se(()=>{if(i==null&&(i=ku()),ti(i),n.rank!==3&&n.rank!==4)throw new _e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new _e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=S4(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=vY({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=rr(l,[0,3,1,2])),l})}function urt(n,e,t,r=[1,1,1],s="valid",i,o){return Se(()=>{if(i==null&&(i=ku()),ti(i),n.rank!==4&&n.rank!==5)throw new _e(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new _e(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Xne(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=cz(a,e,r,s==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Wu(a,t)),i==="channelsFirst"&&(a=rr(a,[0,4,1,2,3])),a})}class d$ extends Kn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",d$.verifyArgs(t),this.rank=e,Wi(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Fn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Db(t.kernelSize,e,"kernelSize"),this.strides=Db(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Bl(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ti(this.dataFormat),this.activation=gp(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=ys(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ai(t.biasConstraint),this.biasRegularizer=vs(t.biasRegularizer),this.activityRegularizer=vs(t.activityRegularizer),this.dilationRate=Db(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new _e(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new _e(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new _e(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ah("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!c4(e.kernelSize,"number",1,3))throw new _e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mp(this.activation),useBias:this.useBias,biasInitializer:Cs(this.biasInitializer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),biasConstraint:Ii(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class ex extends d${constructor(e,t){super(e,t),this.kernel=null,ex.verifyArgs(t),this.filters=t.filters,Wi(this.filters,"filters"),this.kernelInitializer=ys(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ai(t.kernelConstraint),this.kernelRegularizer=vs(t.kernelRegularizer)}build(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r;const s=this.bias==null?null:this.bias.read(),i=Gte(this.activation.getClassName());if(i!=null&&this.rank===2)r=O6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)r=crt(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=O6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=urt(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Fn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=wr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<r.length;++i){const o=bu(r[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:Cs(this.kernelInitializer),kernelRegularizer:jr(this.kernelRegularizer),kernelConstraint:Ii(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new _e(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class NC extends ex{constructor(e){super(2,e),NC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!c4(e.kernelSize,"number",1,2))throw new _e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}NC.className="Conv2D";ot(NC);class $C extends ex{constructor(e){super(3,e),$C.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new _e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}$C.className="Conv3D";ot($C);class Kne extends NC{constructor(e){if(super(e),this.inputSpec=[new Ti({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==4)throw new _e("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ti({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=vn(e);if(r.shape.length!==4)throw new _e(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=s[o],c=s[a],u=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],d=this.strides[1],p=lh(l,f,u,this.padding),m=lh(c,d,h,this.padding),g=[i,p,m,this.filters];this.dataFormat!=="channelsLast"&&(r=rr(r,[0,2,3,1]));let y=lz(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=rr(y,[0,3,1,2])),this.bias!=null&&(y=Wu(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,s,i;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3):(r=3,s=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[r]=this.filters,t[s]=lh(t[s],l,o,this.padding),t[i]=lh(t[i],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Kne.className="Conv2DTranspose";ot(Kne);class Yne extends $C{constructor(e){if(super(e),this.inputSpec=[new Ti({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==5)throw new _e("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ti({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=vn(e);if(r.shape.length!==5)throw new _e(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=s[l],u=s[o],h=s[a],f=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=lh(c,m,f,this.padding),x=lh(u,g,d,this.padding),w=lh(h,y,p,this.padding),S=[i,b,x,w,this.filters];this.dataFormat!=="channelsLast"&&(r=rr(r,[0,2,3,4,1]));let C=uz(r,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=rr(C,[0,4,1,2,3])),this.bias!==null&&(C=Wu(C,this.bias.read(),this.dataFormat)),this.activation!==null&&(C=this.activation.apply(C)),C})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,s,i,o;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3,o=4):(r=4,s=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],f=this.strides[2];return t[r]=this.filters,t[s]=lh(t[s],u,a,this.padding),t[i]=lh(t[i],h,l,this.padding),t[o]=lh(t[o],f,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Yne.className="Conv3DTranspose";ot(Yne);class Zne extends ex{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new _e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new _e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new _e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vs(t.depthwiseRegularizer),this.depthwiseConstraint=Ai(t.depthwiseConstraint),this.pointwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vs(t.pointwiseRegularizer),this.pointwiseConstraint=Ai(t.pointwiseConstraint)}build(e){if(e=wr(e),e.length<this.rank+2)throw new _e(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],s=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Ti({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r;if(this.rank===1)throw new Fn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=rr(e,[0,2,3,1])),r=Nz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Wu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=rr(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Cs(this.depthwiseInitializer),e.pointwiseInitializer=Cs(this.pointwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.pointwiseRegularizer=jr(this.pointwiseRegularizer),e.depthwiseConstraint=Ii(this.depthwiseConstraint),e.pointwiseConstraint=Ii(this.pointwiseConstraint),e}}Zne.className="SeparableConv";class Jne extends Zne{constructor(e){super(2,e)}}Jne.className="SeparableConv2D";ot(Jne);class p$ extends ex{constructor(e){super(1,e),p$.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!c4(e.kernelSize,"number",1,1))throw new _e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}p$.className="Conv1D";ot(p$);class Qne extends Kn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Se(()=>{if(e=vn(e),this.dataFormat==="channelsLast"){const r=fT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return fT(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=fT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return fT(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Qne.className="Cropping2D";ot(Qne);class ere extends Kn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,MQe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return Se(()=>{let r=vn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=rr(r,[0,2,3,1]);const i=this.size[0]*s[2],o=this.size[1]*s[3],a=this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o]);return rr(a,[0,3,1,2])}else{const i=this.size[0]*s[1],o=this.size[1]*s[2];return this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}ere.className="UpSampling2D";ot(ere);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hrt(n,e,t=[1,1],r="valid",s,i){return Se(()=>{s==null&&(s=ku()),ti(s);let o=S4(n,s);if(n.rank!==4)throw new _e(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new _e(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Z2(o,e,t,r==="same"?"same":"valid","NHWC",i),s==="channelsFirst"&&(o=rr(o,[0,3,1,2])),o})}class tre extends d${constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ys(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ai(e.depthwiseConstraint),this.depthwiseRegularizer=vs(e.depthwiseRegularizer)}build(e){if(e=wr(e),e.length<4)throw new _e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r=hrt(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Wu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=bu(t,this.kernelSize[0],this.padding,this.strides[0]),o=bu(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,o]:[e[0],i,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Cs(this.depthwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.depthwiseConstraint=Ii(this.depthwiseRegularizer),e}}tre.className="DepthwiseConv2D";ot(tre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nre(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new _e("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function s(i){return i==null||Array.isArray(i)?i:[i]}return e=s(e),t=s(t),{inputs:n,initialState:e,constants:t}}function rre(n,e,t,r=!1,s,i,o=!1,a=!1){return Se(()=>{const l=e.shape.length;if(l<3)throw new _e(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Cu(2,l));if(e=rr(e,c),i!=null)throw new Fn("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=wt(wt(s,"bool"),"float32"),s.rank===l-1&&(s=oi(s,-1)),s=rr(s,c)),r&&(e=Tc(e,0),s!=null&&(s=Tc(s,0)));const u=[];let h,f=t;const d=e.shape[0],p=Ec(e);let m;s!=null&&(m=Ec(s));for(let y=0;y<d;++y){const b=p[y],x=Se(()=>n(b,f));if(s==null)h=x[0],f=x[1];else{const w=Se(()=>{const S=m[y],C=Dt($l(S),S),k=qe(fe(x[0],S),fe(f[0],C)),A=f.map((M,E)=>qe(fe(x[1][E],S),fe(M,C)));return{output:k,newStates:A}});h=w.output,f=w.newStates}a&&u.push(h)}let g;return a&&(g=_a(u,1)),[h,g,f]})}class Up extends Kn{constructor(e){super(e);let t;if(e.cell==null)throw new _e("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new T4({cells:e.cell}):t=e.cell,t.stateSize==null)throw new _e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ti({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Cu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){KO(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[s].concat(i)}else return s}computeMask(e,t){return Se(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const s=this.states.map(i=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Fn("Constants support is not implemented in RNN yet.");KO(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Ti({shape:[t,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Rn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new _e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Ti({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new oh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_=[ms([r,this.cell.stateSize])];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_[0]=ms([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,a=[r,o];if(!Rn(i.shape,a))throw new _e(`State ${s} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Xs(s.clone()))})}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=nre(e,r,s,this.numConstants);e=i.inputs,r=i.initialState,s=i.constants;let o=[],a=[];if(r!=null){t.initialState=r,o=o.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new Ti({shape:c.shape}));a=a.concat(this.stateSpec)}if(s!=null&&(t.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof kh){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t==null?null:t.mask,s=t==null?null:t.training;let i=t==null?null:t.initialState;e=vn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new _e(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},c=rre((p,m)=>{const g=this.cell.call([p].concat(m),a);return[g[0],g.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),u=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,s);const d=this.returnSequences?h:u;return this.returnState?[d].concat(f):d})}getInitialState(e){return Se(()=>{let t=ms(e.shape);return t=Yt(t,[1,2]),t=TC(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?qO(t,[1,r]):t):this.cell.stateSize>1?[qO(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Up.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const s=t.cell,i=bh(s,r);return new e(Object.assign(t,{cell:i}))}}Up.className="RNN";ot(Up);class m$ extends Kn{}class C4 extends m${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Wi(this.units,"units"),this.activation=gp(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=lv([1,pp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=lv([1,pp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yp({ones:()=>$l(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yp({ones:()=>$l(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=yh(fe(e,o),this.kernel.read()):i=yh(e,this.kernel.read()),this.bias!=null&&(i=Wu(i,this.bias.read())),a!=null&&(r=fe(r,a));let l=qe(i,yh(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mp(this.activation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}C4.className="SimpleRNNCell";ot(C4);class sre extends Up{constructor(e){e.cell=new C4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return new e(t)}}sre.className="SimpleRNN";ot(sre);class k4 extends m${constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new _e("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Wi(this.units,"units"),this.activation=gp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=lv([1,pp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=lv([1,pp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yp({ones:()=>$l(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yp({ones:()=>$l(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=fe(e,i[0]));let u=yh(e,this.kernel.read());this.useBias&&(u=Wu(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,o[0]));const h=this.recurrentKernel.read(),[f,d]=qa(h,[2*this.units,this.units],h.rank-1),p=yh(s,f),[m,g,y]=qa(u,3,u.rank-1),[b,x]=qa(p,2,p.rank-1);a=this.recurrentActivation.apply(qe(m,b)),l=this.recurrentActivation.apply(qe(g,x));const w=yh(fe(l,s),d);c=this.activation.apply(qe(y,w));const S=qe(fe(a,s),fe(qe(1,us(a)),c));return[S,S]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mp(this.activation),recurrentActivation:mp(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}k4.className="GRUCell";ot(k4);class ire extends Up{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new k4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}ire.className="GRU";ot(ire);class g$ extends m${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Wi(this.units,"units"),this.activation=gp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=lv([1,pp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=lv([1,pp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=wr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;s=new(t=class extends Dc{apply(l,c){const u=i.apply([o]),h=new h4().apply([o]),f=i.apply([o*2]);return d6(d6(u,h),f)}},t.className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new _e(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yp({ones:()=>$l(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yp({ones:()=>$l(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=fe(e,o[0]));let f=yh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,a[0])),f=qe(f,yh(s,this.recurrentKernel.read())),this.useBias&&(f=Wu(f,this.bias.read()));const[d,p,m,g]=qa(f,4,f.rank-1);l=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),u=qe(fe(c,i),fe(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=fe(h,this.activation.apply(u));return[y,y,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mp(this.activation),recurrentActivation:mp(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}g$.className="LSTMCell";ot(g$);class ore extends Up{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new g$(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}ore.className="LSTM";ot(ore);class T4 extends m${constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Se(()=>{e=e;let r=e.slice(1);const s=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?s.push(r.splice(0,a.stateSize.length)):s.push(r.splice(0,1));s.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=s[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,t),i.push(o.slice(1))}r=[];for(const a of i.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){KO(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,s)=>{Jm(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,t,r={}){const s=[];for(const i of t.cells)s.push(bh(i,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return YO(e)}setWeights(e){const t=[];for(const r of this.cells){const s=r.weights.length,i=e.splice(s);for(let o=0;o<r.weights.length;++o)t.push([r.weights[o],i[o]])}b4(t)}}T4.className="StackedRNNCells";ot(T4);function yp(n){const{ones:e,rate:t,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):Zte(e(),t),a=()=>IC(o,e,r);return!s||s<=1?Xs(a().clone()):Array(s).fill(void 0).map(a).map(c=>Xs(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var frt=globalThis&&globalThis.__rest||function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(n);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(t[r[s]]=n[r[s]]);return t};class are extends Up{constructor(e){if(e.unroll)throw new Fn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Fn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ti({ndim:5})]}call(e,t){return Se(()=>{if(this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new _e("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Se(()=>{const{stateSize:t}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)],o=ms(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new oh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)];if(r[0]==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_=[ms(i)];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_[0]=ms(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=i;if(!Rn(l.shape,c))throw new _e(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Xs(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:s,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=bu(c,s[0],i,o[0],a[0]),f=bu(u,s[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[r,h,f]:[h,f,r]]}}are.className="ConvRNN2D";class E4 extends g${constructor(e){const{filters:t,kernelSize:r,strides:s,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Wi(this.filters,"filters"),this.kernelSize=Db(r,2,"kernelSize"),this.kernelSize.forEach(l=>Wi(l,"kernelSize")),this.strides=Db(s||1,2,"strides"),this.strides.forEach(l=>Wi(l,"strides")),this.padding=i||"valid",Bl(this.padding),this.dataFormat=o||"channelsLast",ti(this.dataFormat),this.dilationRate=Db(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Wi(l,"dilationRate"))}build(e){var t;e=wr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],i=4,o=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends Dc{apply(f,d){const p=c.apply([u]),m=ma([u]),g=c.apply([u*2]);return u4([p,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Se(()=>{if(e.length!==3)throw new _e(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,s=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yp({ones:()=>$l(s),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(ge,ae,Ne)=>!ae||!ae[Ne]?ge:fe(ae[Ne],ge);let u=c(s,l,0),h=c(s,l,1),f=c(s,l,2),d=c(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yp({ones:()=>$l(i),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let m=c(i,p,0),g=c(i,p,1),y=c(i,p,2),b=c(i,p,3);const x=3,[w,S,C,k]=qa(this.kernel.read(),a,x),[A,M,E,N]=this.useBias?qa(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,w,A,this.padding),h=this.inputConv(h,S,M,this.padding),f=this.inputConv(f,C,E,this.padding),d=this.inputConv(d,k,N,this.padding);const[O,R,D,z]=qa(this.recurrentKernel.read(),a,x);m=this.recurrentConv(m,O),g=this.recurrentConv(g,R),y=this.recurrentConv(y,D),b=this.recurrentConv(b,z);const B=this.recurrentActivation.apply(qe(u,m)),X=this.recurrentActivation.apply(qe(h,g)),G=qe(fe(X,o),fe(B,this.activation.apply(qe(f,y)))),te=fe(this.recurrentActivation.apply(qe(d,b)),this.activation.apply(G));return[te,te,G]})}getConfig(){const e=super.getConfig(),t=frt(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),r)}inputConv(e,t,r,s){const i=cp(e,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Wu(i,r,this.dataFormat):i}recurrentConv(e,t){return cp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}E4.className="ConvLSTM2DCell";ot(E4);class lre extends are{constructor(e){const t=new E4(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}lre.className="ConvLSTM2D";ot(lre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class I4 extends Kn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return r}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);if(0<this.rate&&this.rate<1){const s=t.training==null?!1:t.training,i=this.getNoiseShape(r);return IC(()=>Zte(r,this.rate,i,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}I4.className="Dropout";ot(I4);class cre extends I4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}cre.className="SpatialDropout1D";ot(cre);class A4 extends Kn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Wi(this.units,"units"),this.activation=gp(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ai(e.kernelConstraint),this.biasConstraint=Ai(e.biasConstraint),this.kernelRegularizer=vs(e.kernelRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.activityRegularizer=vs(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=wr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=wr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=Gte(this.activation.getClassName());let i;return s!=null?i=yh(r,this.kernel.read(),s,this.bias?this.bias.read():null):(i=yh(r,this.kernel.read()),this.bias!=null&&(i=Wu(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:mp(this.activation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),biasConstraint:Ii(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}A4.className="Dense";ot(A4);class ure extends Kn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=wr(e);for(const t of e.slice(1))if(t==null)throw new _e(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Kd(e,1)]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=vn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let i=2;i<r.rank;++i)s.push(i);s.push(1),r=rr(r,s)}return OQe(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}ure.className="Flatten";ot(ure);class hre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.activation=gp(e.activation)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return this.activation.apply(r)})}getConfig(){const e={activation:mp(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}hre.className="Activation";ot(hre);class fre extends Kn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Se(()=>(e=vn(e),PQe(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}fre.className="RepeatVector";ot(fre);let dre=class extends Kn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",s=t.slice();let i=1,o=null;for(let l=0;l<s.length;++l){const c=s[l];if(this.isUnknown(c))if(o===null)o=l;else throw new _e("Can only specifiy one unknown dimension.");else i*=c}const a=Kd(e);if(o!==null){if(i===0||a%i!==0)throw new _e(r);s[o]=a/i}else if(a!==i)throw new _e(r);return s}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=r.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return ve(r,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};dre.className="Reshape";ot(dre);class pre extends Kn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Cu(1,e.dims.length+1);if(!Rn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ti({ndim:this.dims.length+1})]}computeOutputShape(e){e=wr(e);const t=e.slice();return this.dims.forEach((r,s)=>{t[s+1]=e[r]}),t}call(e,t){return rr(vn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}pre.className="Permute";ot(pre);class mre extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=vn(e),s=-1;return AI(Zb(r,this.maskValue),s)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=-1,i=!0,o=AI(Zb(r,this.maskValue),s,i);return fe(r,wt(o,r.dtype))})}}mre.className="Masking";ot(mre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gre extends Kn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Gr(e.inputLength))}this.inputDim=e.inputDim,Wi(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Wi(this.outputDim,"outputDim"),this.embeddingsInitializer=ys(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vs(e.embeddingsRegularizer),this.activityRegularizer=vs(e.activityRegularizer),this.embeddingsConstraint=Ai(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Se(()=>this.maskZero?(e=vn(e),Zb(e,lr(e))):null)}computeOutputShape(e){if(e=wr(e),this.inputLength==null)return[...e,this.outputDim];const t=Gr(this.inputLength);if(t.length!==e.length-1)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<t.length;++s){const i=t[s],o=e[s+1];if(i!=null&&o!=null&&i!==o)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[r]=o),r++}}return[e[0],...t,this.outputDim]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=vn(e);r.dtype!=="int32"&&(r=gh(r,"int32"));const s=Yte(this.embeddings.read(),ve(r,[r.size]));return ve(s,wr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Cs(this.embeddingsInitializer),embeddingsRegularizer:jr(this.embeddingsRegularizer),activityRegularizer:jr(this.activityRegularizer),embeddingsConstraint:Ii(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}gre.className="Embedding";ot(gre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Qy extends Kn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Fn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const i=e[e.length-t.length+s],o=t[s];if(i==null||o==null||i<0||o<0)r.push(null);else if(i===1)r.push(o);else if(o===1)r.push(i);else{if(i!==o)throw new _e("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(i)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[wr(e)]),e=e,e.length<2)throw new _e(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Xd(t),t.length>1)throw new _e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=e.map(i=>i.length);e.indexOf(null)===-1&&Xd(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Se(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(i=>i.rank);if(s.indexOf(null)===-1){const i=pp(s);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=TC(o,1);r.push(o)}return this.mergeFunction(r)}else{let i=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],f=u.slice(1).concat([h]);let d=ve(l,[h].concat(Kd(u.slice(1))));d=rr(d,[1,0]),d=ve(d,f),r.push(d),i=!0}else if(c>1){const u=Cu(1,c).concat([0]);r.push(rr(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ve(rr(ve(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Cu(0,a-1));o=rr(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let s=1;s<e.length;++s){const i=e[s]==null?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=Xd(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return Se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an Array");if(!Array.isArray(e))throw new _e("`inputs` should be an Array");if(t.length!==e.length)throw new _e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(s=>s==null))return null;t=t.map(s=>s==null?s:oi(s,0));let r=t[0];for(let s=1;s<t.length-1;++s)r=_h(r,t[s]);return r})}}let yre=class extends Qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return t})}};yre.className="Add";ot(yre);let bre=class extends Qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=fe(t,e[r]);return t})}};bre.className="Multiply";ot(bre);class vre extends Qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return fe(1/e.length,t)})}}vre.className="Average";ot(vre);class wre extends Qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=jf(t,e[r]);return t})}}wre.className="Maximum";ot(wre);class xre extends Qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=hp(t,e[r]);return t})}}xre.className="Minimum";ot(xre);class _re extends Qy{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new _e("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(s!=null){t=!1;break}if(t)return;const r=[];for(let s=0;s<e.length;++s){const i=e[s].slice();i.splice(this.axis,1);let o=!1;for(const a of r)if(Rn(a,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new _e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Se(()=>u4(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new _e("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const i of t.slice(1)){if(r[s]==null||i[s]==null){r[s]=null;break}r[s]+=i[s]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new _e("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new _e(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Se(()=>{let r=!0;if(t.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const s=[];for(let o=0;o<e.length;++o)t[o]==null?s.push(wt($l(e[o]),"bool")):t[o].rank<e[o].rank?s.push(oi(t[o],-1)):s.push(t[o]);const i=cs(s,this.axis);return KL(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}_re.className="Concatenate";ot(_re);function Yx(n,e){for(;n<0;)n+=e;return n}function drt(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Fn("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),U(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Fn("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=e.shape.length;t==null&&(t=[r-1,s-2]);const i=t;return Se(()=>{let o;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);e=ve(e,e.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=ve(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=Yt(fe(n,e),i[0]):a=Yt(fe(rr(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;a=Hn(n,e,l,c)}if(o>0){let l;r>s?l=r+s-3:l=r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=vr(a,c)}return a.shape.length===1&&(a=oi(a,1)),a})}class Sre extends Qy{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);if(t[s[0]]!==r[s[1]])throw new _e(`Dimension incompatibility: ${t[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new _e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,o)=>Yx(i,e[o].shape.length)):s=[Yx(this.axes,t.shape.length),Yx(this.axes,r.shape.length)],this.normalize&&(t=iA(t,s[0]),r=iA(r,s[1])),drt(t,r,s)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[Yx(this.axes,e.length),Yx(this.axes,t.length)],r}computeOutputShape(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);t.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const i=t.concat(r);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Sre.className="Dot";ot(Sre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Cre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return IC(()=>qe(c$(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}Cre.className="GaussianNoise";ot(Cre);class kre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return this.rate>0&&this.rate<1?IC(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return fe(r,c$(r.shape,1,i))},()=>r,t.training||!1):r})}}kre.className="GaussianDropout";ot(kre);class Tre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||vn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return IC(()=>{const i=vn(e),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=Dp(Op(r),this.rate);c=gh(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate,f=qe(fe(i,c),fe(qe(c,-1),l));return qe(fe(f,u),h)},()=>vn(e),t.training||!1)}return e})}}Tre.className="AlphaDropout";ot(Tre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Q_(n,e,t,r,s,i=.001){let o;if(n.rank===2)o=JL(n,e,t,r,s,i);else if(n.rank===3)o=QL(n,e,t,r,s,i);else if(n.rank===4)o=ez(n,e,t,r,s,i);else throw new Fn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function prt(n,e,t,r,s=.001){return Se(()=>{const i=nC(n,r),o=i.mean,a=i.variance;return[Q_(n,o,a,t,e,s),o,a]})}function mrt(n,e,t,r,s=.001){return Se(()=>{const i=nC(n,r),o=i.mean,a=i.variance,l=[];for(const p of Cu(0,n.rank))r.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const c=ve(o,l),u=ve(a,l),h=e==null?null:ve(e,l),f=t==null?null:ve(t,l);return[Q_(n,c,u,f,h,s),o,a]})}function grt(n,e,t,r,s=.001){return Rn(r.slice().sort(),Cu(0,n.rank-1))?prt(n,e,t,r,s):mrt(n,e,t,r,s)}class Ere extends Kn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.movingMeanInitializer=ys(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ys(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ai(e.betaConstraint),this.gammaConstraint=Ai(e.gammaConstraint),this.betaRegularizer=vs(e.betaRegularizer),this.gammaRegularizer=vs(e.gammaRegularizer)}build(e){e=wr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new _e(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ti({ndim:e.length,axes:{[t]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training,s=vn(e),i=s.shape,o=i.length,a=Cu(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=wg(1,o);c[l]=i[l];const u=a.slice();u.sort();const h=!Rn(u,Cu(0,o).slice(0,o-1)),f=()=>{if(h){const b=ve(this.movingMean.read(),c),x=ve(this.movingVariance.read(),c),w=this.center?ve(this.beta.read(),c):null,S=this.scale?ve(this.gamma.read(),c):null;return Q_(s,b,x,w,S,this.epsilon)}else return Q_(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[d,p,m]=grt(s,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,x,w)=>{Se(()=>{const S=1-w,C=b.read(),k=fe(Dt(C,x),S);b.write(Dt(C,k))})};return(()=>{g(this.movingMean,p,this.momentum),g(this.movingVariance,m,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cs(this.betaInitializer),gammaInitializer:Cs(this.gammaInitializer),movingMeanInitializer:Cs(this.movingMeanInitializer),movingVarianceInitializer:Cs(this.movingVarianceInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer),betaConstraint:Ii(this.betaConstraint),gammaConstraint:Ii(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ere.className="BatchNormalization";ot(Ere);class Ire extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.betaRegularizer=vs(e.betaRegularizer),this.gammaRegularizer=vs(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=wr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Xd(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const r=vn(e),s=r.shape,i=s.length;return Se(()=>{let{mean:a,variance:l}=nC(r,this.axis,!0);const c=wg(1,i);for(const m of this.axis)c[m]=s[m];const u=m=>m!=null&&m.shape.length!==i?ve(m,c):m;let h=this.scale?u(this.gamma.read()):null,f=this.center?u(this.beta.read()):null;const d=[],p=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(d.push(s[m]),p.push(1)):(d.push(1),p.push(s[m]));return a=pc(a,d),l=pc(l,d),h!=null&&(h=pc(h,p)),f!=null&&(f=pc(f,p)),Q_(r,a,l,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cs(this.betaInitializer),gammaInitializer:Cs(this.gammaInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Ire.className="LayerNormalization";ot(Ire);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yrt(n,e,t){return Se(()=>{if(n.rank!==4)throw new _e(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new _e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=ku()),t!=="channelsLast"&&t!=="channelsFirst")throw new _e(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],wu(n,r)})}class Are extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ku():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new _e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new _e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new _e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){e=wr(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return Se(()=>yrt(vn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Are.className="ZeroPadding2D";ot(Are);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function y$(n,e,t,r,s,i){return Se(()=>{ti(s),jte(i),Bl(r),t==null&&(t=[1,1]),r==null&&(r="valid"),s==null&&(s=ku()),i==null&&(i="max"),n=S4(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=jM(n,e,t,a):o=OM(n,e,t,a),s==="channelsFirst"&&(o=rr(o,[0,3,1,2])),o})}function Mre(n,e,t,r,s,i){return Se(()=>{ti(s),jte(i),Bl(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ku()),i==null&&(i="max"),n=Xne(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=gz(n,e,t,a):o=ZL(n,e,t,a),s==="channelsFirst"&&(o=rr(o,[0,4,1,2,3])),o})}class Nre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new _e(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Wi(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new _e(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Bl(this.padding),this.inputSpec=[new Ti({ndim:3})]}computeOutputShape(e){e=wr(e);const t=bu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Se(()=>{this.invokeCallHook(e,t),e=TC(vn(e),2);const r=this.poolingFunction(vn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return vr(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class $re extends Nre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),y$(e,t,r,s,i,"max")}}$re.className="MaxPooling1D";ot($re);class Rre extends Nre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),y$(e,t,r,s,i,"avg")}}Rre.className="AveragePooling1D";ot(Rre);class Pre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new _e(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Wi(this.poolSize,"poolSize"),Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),Bl(this.padding),this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=bu(t,this.poolSize[0],this.padding,this.strides[0]),r=bu(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(vn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Dre extends Pre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),y$(e,t,r,s,i,"max")}}Dre.className="MaxPooling2D";ot(Dre);class Ore extends Pre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),y$(e,t,r,s,i,"avg")}}Ore.className="AveragePooling2D";ot(Ore);class Fre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new _e(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Wi(this.poolSize,"poolSize"),Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),Bl(this.padding),this.inputSpec=[new Ti({ndim:5})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=bu(t,this.poolSize[0],this.padding,this.strides[0]),r=bu(r,this.poolSize[1],this.padding,this.strides[1]),s=bu(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,s]:[e[0],t,r,s,e[4]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(vn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Lre extends Fre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),Mre(e,t,r,s,i,"max")}}Lre.className="MaxPooling3D";ot(Lre);class zre extends Fre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Bl(s),Mre(e,t,r,s,i,"avg")}}zre.className="AveragePooling3D";ot(zre);class Bre extends Kn{constructor(e){super(e),this.inputSpec=[new Ti({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Fn}}class Vre extends Bre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=vn(e);return Ds(r,1)})}}Vre.className="GlobalAveragePooling1D";ot(Vre);class Ure extends Bre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=vn(e);return wc(r,1)})}}Ure.className="GlobalMaxPooling1D";ot(Ure);class Wre extends Kn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Fn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Gre extends Wre{call(e,t){return Se(()=>{const r=vn(e);return this.dataFormat==="channelsLast"?Ds(r,[1,2]):Ds(r,[2,3])})}}Gre.className="GlobalAveragePooling2D";ot(Gre);class Hre extends Wre{call(e,t){return Se(()=>{const r=vn(e);return this.dataFormat==="channelsLast"?wc(r,[1,2]):wc(r,[2,3])})}}Hre.className="GlobalMaxPooling2D";ot(Hre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jre extends Kn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const s=t.layer,i=bh(s,r);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class qre extends jre{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=wr(e),e.length<3)throw new _e(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=wr(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,t){return Se(()=>(e=vn(e),rre((o,a)=>[vn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}qre.className="TimeDistributed";ot(qre);function brt(n){Jy(AQe,"BidirectionalMergeMode",n)}const vrt="concat";class Xre extends jre{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=bh(r),t.goBackwards=t.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=bh(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?vrt:e.mergeMode,brt(this.mergeMode),e.weights)throw new Fn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,s,i;return this.returnState&&(i=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):da(s)}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=nre(e,r,s,this.numConstants);if(e=i.inputs,r=i.initialState,s=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,t);const o=[],a=[];if(r!=null){const c=r.length;if(c%2>0)throw new _e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,o.push(...r);const u=r.map(h=>new Ti({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(s!=null)throw new Fn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof kh;for(const c of o)if(c instanceof kh!==l)throw new _e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t.initialState;let s,i;if(r==null)s=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=r.slice(0,r.length/2),c=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=Tc(i,1));let a;return this.mergeMode==="concat"?a=u4([s,i]):this.mergeMode==="sum"?a=qe(s,i):this.mergeMode==="ave"?a=fe(.5,qe(s,i)):this.mergeMode==="mul"?a=fe(s,i):this.mergeMode==null&&(a=[s,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Jm(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Jm(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=bh(t.layer);if(delete t.layer,t.numConstants!=null)throw new Fn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=r,new e(s)}}Xre.className="Bidirectional";ot(Xre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Kre extends Kn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>(e=vn(e),e.dtype!=="float32"&&(e=gh(e,"float32")),qe(fe(e,this.scale),this.offset)))}}Kre.className="Rescaling";ot(Kre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:wrt,cropAndResize:xrt}=Ci;class Yre extends Kn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,s,i,o,a,l){return Se(()=>{let c,u=!1;const h=t/o,f=r/a,d=(s+t)/o,p=(i+r)/a,m=[h,f,d,p],g=[];e.rank===3?(u=!0,c=_a([e])):c=e;for(let S=0;S<c.shape[0];S++)g.push(m);const y=Ei(g,[g.length,4]),b=fg(0,g.length,1,"int32"),w=xrt(c,y,b,[s,i],"nearest");return gh(u?vn(Ec(w)):w,l)})}upsize(e,t,r,s){return Se(()=>{const i=wrt(e,[t,r]);return gh(i,s)})}call(e,t){return Se(()=>{const r=vn(e),s=r.dtype,i=r.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(r,l,c,this.height,this.width,o,a,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}Yre.className="CenterCrop";ot(Yre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _rt(n,e,t,r){let s=vn(n);if(s.dtype!=="int32"&&(s=gh(s,"int32")),e==="int")return s;const i=s.shape;if(s.rank===0&&(s=oi(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=oi(s,-1)),s.rank>2)throw new _e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(e),a=s;let l;if(typeof r<"u"&&e==="count"?l=NI(a,r,t,o):l=NI(a,[],t,o),e!=="tfIdf")return l;if(r)return fe(l,r);throw new _e("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Zre extends Kn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=wr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Se(()=>{e=vn(e),e.dtype!=="int32"&&(e=gh(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new _e(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=vn(t.countWeights)}const s=wc(e),i=E_(e),o=rl(this.numTokens,s).bufferSync().get(0),a=Dp(i,0).bufferSync().get(0);if(!(o&&a))throw new _e(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return _rt(e,this.outputMode,this.numTokens,r)})}}Zre.className="CategoryEncoding";ot(Zre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Srt=["bilinear","nearest"],F6=new Set(Srt);class Jre extends Kn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(F6.has(e.interpolation))this.interpolation=e.interpolation;else throw new _e(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=wr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Ci.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ci.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...F6]} are supported`)})}}Jre.className="Resizing";ot(Jre);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Qre{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}Qre.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ese extends Kn{constructor(e){super(e),this.randomGenerator=new Qre(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}ese.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Crt=["bilinear","nearest"],L6=new Set(Crt);class tse extends ese{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new _e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new _e(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new _e(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(L6.has(r))this.interpolation=r;else throw new _e(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Se(()=>{const r=vn(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Op([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ci.resizeBilinear(e,o);case"nearest":return Ci.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...L6]} are supported`)}})}}tse.className="RandomWidth";ot(tse);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function z6(n){return new A4(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function krt(n,e){return nse(n,e)}function nse(n,e,t=new Map,r=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(b$(n)){const i=Array.isArray(n)?[]:{};r.add(n);for(const o in n){const a=n[o],l=nse(a,e,t,r);i[o]=l}return r.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,s.value),s.value}function Trt(n,e=sse){return rse(n,e)}function rse(n,e,t=new Set){const r=n[0];if(t.has(r))throw new Error("Circular references are not supported.");const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(b$(r)){const i=Array.isArray(r)?[]:{};t.add(r);for(const o in r){const a=n.map(c=>c[o]),l=rse(a,e,t);i[o]=l}return t.delete(r),i}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function sse(n){return n===null?null:b$(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function b$(n){let e=!1;if(Ee().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof jn)&&!(n instanceof Promise)&&!e)}function Ert(n){return n==null||Irt(n)||Array.isArray(n)||typeof n=="object"&&n instanceof jn||_i(n)}function Irt(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Art(n){return krt(n,Mrt)}function Mrt(n){return n instanceof jn?{value:n.clone(),recurse:!1}:b$(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ise{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class v$ extends ise{constructor(){super(v$.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),r=this.length();for(let s=0;s<r;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}v$.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Nrt(n){return new Rrt(n)}function ose(n){return new Prt(n)}function $rt(n,e){return new ase(n,e)}class Vl{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)t=await this.next(),r=e(t.value)}handleErrors(e){return new Vrt(this,e)}filter(e){return new zrt(this,e)}map(e){return new Brt(this,e)}mapAsync(e){return new B6(this,e)}serialMapAsync(e){return new B6(this,e).serial()}flatmap(e){return new Wrt(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new Lrt(this,e,t)}columnMajorBatch(e,t=!0,r=sse){return this.rowMajorBatch(e,t).map(i=>Trt(i,r))}concatenate(e,t){return new ase(Nrt([this,e]),t)}take(e){return e<0||e==null?this:new Frt(this,e)}skip(e){return e<0||e==null?this:new Ort(this,e)}prefetch(e){return new lse(this,e)}shuffle(e,t){return new Grt(this,e,t)}serial(){return new Drt(this)}}class Rrt extends Vl{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Art(e),done:!1}}}class Prt extends Vl{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class Drt extends Vl{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Ort extends Vl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;nn(e.value)}return this.upstream.next()}}class Frt extends Vl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Lrt extends Vl{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class zrt extends Vl{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nn(e.value)}}}class Brt extends Vl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Df(e.value),r=this.transform(e.value),s=Df(r);for(const i of t)PM(i,s)||i.dispose();return{value:r,done:!1}}}class Vrt extends Vl{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class B6 extends Vl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Df(e.value),r=await this.transform(e.value),s=Df(r);for(const i of t)PM(i,s)||i.dispose();return{value:r,done:!1}}}class Urt extends Vl{constructor(){super(),this.outputQueue=new v$,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Wrt extends Urt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Df(e.value),r=this.transform(e.value),s=Df(r);this.outputQueue.pushAll(r);for(const i of t)PM(i,s)||i.dispose();return!0}}class ase extends Vl{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var V6;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(V6||(V6={}));class lse extends Vl{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new ise(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Grt extends lse{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Rw.alea(r||so().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let cse=class{constructor(){this.size=null}batch(e,t=!0){const r=this;U(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let s;return this.size===1/0||this.size==null?s=this.size:t?s=Math.ceil(this.size/e):s=Math.floor(this.size/e),tu(async()=>(await r.iterator()).columnMajorBatch(e,t,Hrt),s)}concatenate(e){const t=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,tu(async()=>(await t.iterator()).concatenate(await e.iterator()),r)}filter(e){const t=this;let r;return this.size===1/0?r=1/0:r=null,tu(async()=>(await t.iterator()).filter(s=>Se(()=>e(s))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return tu(async()=>(await t.iterator()).map(r=>Se(()=>e(r))),this.size)}mapAsync(e){const t=this;return tu(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return tu(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,tu(async()=>{const s=ose(async()=>({value:await t.iterator(),done:!1}));return $rt(s.take(e))},r)}skip(e){const t=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,tu(async()=>(await t.iterator()).skip(e),r)}shuffle(e,t,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=Rw.alea(t||so().toString());return tu(async()=>{let o=i.int32();return r&&(o+=i.int32()),(await s.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,tu(async()=>(await t.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};cse.MAX_BUFFER_SIZE=1e4;function tu(n,e=null){return new class extends cse{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function Hrt(n){if(n===null)return null;const e=n[0];return Ert(e)?{value:jrt(n),recurse:!1}:{value:null,recurse:!0}}function jrt(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof jn?_a(n):Ei(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function qrt(n){return tu(async()=>{const e=await n();return ose(()=>e.next())})}var tF={exports:{}};const Xrt=Gf(wQe),Krt=Gf(vZ);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(n,e){(function(t,r){r(e,Xrt,Krt)})(pt,function(t,r,s){const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(l,c){this.modelPath=c||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const l=s.zeros([1,300,300,3],"int32"),c=await this.model.executeAsync(l);await Promise.all(c.map(u=>u.data())),c.map(u=>u.dispose()),l.dispose()}async infer(l,c,u){const h=s.tidy(()=>(l instanceof s.Tensor||(l=s.browser.fromPixels(l)),s.expandDims(l))),f=h.shape[1],d=h.shape[2],p=await this.model.executeAsync(h),m=p[0].dataSync(),g=p[1].dataSync();h.dispose(),s.dispose(p);const[y,b]=this.calculateMaxScores(m,p[0].shape[1],p[0].shape[2]),x=s.getBackend();s.getBackend()==="webgl"&&s.setBackend("cpu");const w=s.tidy(()=>{const C=s.tensor2d(g,[p[1].shape[1],p[1].shape[3]]);return s.image.nonMaxSuppression(C,y,c,u,u)}),S=w.dataSync();return w.dispose(),x!==s.getBackend()&&s.setBackend(x),this.buildDetectedObjects(d,f,g,y,S,b)}buildDetectedObjects(l,c,u,h,f,d){const p=f.length,m=[];for(let g=0;g<p;g++){const y=[];for(let C=0;C<4;C++)y[C]=u[4*f[g]+C];const b=y[0]*c,x=y[1]*l,w=y[2]*c,S=y[3]*l;y[0]=x,y[1]=b,y[2]=S-x,y[3]=w-b,m.push({bbox:y,class:i[d[f[g]]+1].displayName,score:h[f[g]]})}return m}calculateMaxScores(l,c,u){const h=[],f=[];for(let d=0;d<c;d++){let p=Number.MIN_VALUE,m=-1;for(let g=0;g<u;g++)l[d*u+g]>p&&(p=l[d*u+g],m=g);h[d]=p,f[d]=m}return[h,f]}async detect(l,c=20,u=.5){return this.infer(l,c,u)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=o,t.load=async function(a={}){if(s==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=a.base||"lite_mobilenet_v2",c=a.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new o(l,c);return await u.load(),u},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})})(tF,tF.exports);var U6=tF.exports;/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function RC(n){return n+.5|0}const zd=(n,e,t)=>Math.max(Math.min(n,t),e);function $1(n){return zd(RC(n*2.55),0,255)}function Zd(n){return zd(RC(n*255),0,255)}function _f(n){return zd(RC(n/2.55)/100,0,1)}function W6(n){return zd(RC(n*100),0,100)}const ec={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},nF=[..."0123456789ABCDEF"],Yrt=n=>nF[n&15],Zrt=n=>nF[(n&240)>>4]+nF[n&15],pT=n=>(n&240)>>4===(n&15),Jrt=n=>pT(n.r)&&pT(n.g)&&pT(n.b)&&pT(n.a);function Qrt(n){var e=n.length,t;return n[0]==="#"&&(e===4||e===5?t={r:255&ec[n[1]]*17,g:255&ec[n[2]]*17,b:255&ec[n[3]]*17,a:e===5?ec[n[4]]*17:255}:(e===7||e===9)&&(t={r:ec[n[1]]<<4|ec[n[2]],g:ec[n[3]]<<4|ec[n[4]],b:ec[n[5]]<<4|ec[n[6]],a:e===9?ec[n[7]]<<4|ec[n[8]]:255})),t}const est=(n,e)=>n<255?e(n):"";function tst(n){var e=Jrt(n)?Yrt:Zrt;return n?"#"+e(n.r)+e(n.g)+e(n.b)+est(n.a,e):void 0}const nst=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function use(n,e,t){const r=e*Math.min(t,1-t),s=(i,o=(i+n/30)%12)=>t-r*Math.max(Math.min(o-3,9-o,1),-1);return[s(0),s(8),s(4)]}function rst(n,e,t){const r=(s,i=(s+n/60)%6)=>t-t*e*Math.max(Math.min(i,4-i,1),0);return[r(5),r(3),r(1)]}function sst(n,e,t){const r=use(n,1,.5);let s;for(e+t>1&&(s=1/(e+t),e*=s,t*=s),s=0;s<3;s++)r[s]*=1-e-t,r[s]+=e;return r}function ist(n,e,t,r,s){return n===s?(e-t)/r+(e<t?6:0):e===s?(t-n)/r+2:(n-e)/r+4}function M4(n){const t=n.r/255,r=n.g/255,s=n.b/255,i=Math.max(t,r,s),o=Math.min(t,r,s),a=(i+o)/2;let l,c,u;return i!==o&&(u=i-o,c=a>.5?u/(2-i-o):u/(i+o),l=ist(t,r,s,u,i),l=l*60+.5),[l|0,c||0,a]}function N4(n,e,t,r){return(Array.isArray(e)?n(e[0],e[1],e[2]):n(e,t,r)).map(Zd)}function $4(n,e,t){return N4(use,n,e,t)}function ost(n,e,t){return N4(sst,n,e,t)}function ast(n,e,t){return N4(rst,n,e,t)}function hse(n){return(n%360+360)%360}function lst(n){const e=nst.exec(n);let t=255,r;if(!e)return;e[5]!==r&&(t=e[6]?$1(+e[5]):Zd(+e[5]));const s=hse(+e[2]),i=+e[3]/100,o=+e[4]/100;return e[1]==="hwb"?r=ost(s,i,o):e[1]==="hsv"?r=ast(s,i,o):r=$4(s,i,o),{r:r[0],g:r[1],b:r[2],a:t}}function cst(n,e){var t=M4(n);t[0]=hse(t[0]+e),t=$4(t),n.r=t[0],n.g=t[1],n.b=t[2]}function ust(n){if(!n)return;const e=M4(n),t=e[0],r=W6(e[1]),s=W6(e[2]);return n.a<255?`hsla(${t}, ${r}%, ${s}%, ${_f(n.a)})`:`hsl(${t}, ${r}%, ${s}%)`}const G6={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},H6={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function hst(){const n={},e=Object.keys(H6),t=Object.keys(G6);let r,s,i,o,a;for(r=0;r<e.length;r++){for(o=a=e[r],s=0;s<t.length;s++)i=t[s],a=a.replace(i,G6[i]);i=parseInt(H6[o],16),n[a]=[i>>16&255,i>>8&255,i&255]}return n}let mT;function fst(n){mT||(mT=hst(),mT.transparent=[0,0,0,0]);const e=mT[n.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:e.length===4?e[3]:255}}const dst=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function pst(n){const e=dst.exec(n);let t=255,r,s,i;if(e){if(e[7]!==r){const o=+e[7];t=e[8]?$1(o):zd(o*255,0,255)}return r=+e[1],s=+e[3],i=+e[5],r=255&(e[2]?$1(r):zd(r,0,255)),s=255&(e[4]?$1(s):zd(s,0,255)),i=255&(e[6]?$1(i):zd(i,0,255)),{r,g:s,b:i,a:t}}}function mst(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${_f(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const F3=n=>n<=.0031308?n*12.92:Math.pow(n,1/2.4)*1.055-.055,B0=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function gst(n,e,t){const r=B0(_f(n.r)),s=B0(_f(n.g)),i=B0(_f(n.b));return{r:Zd(F3(r+t*(B0(_f(e.r))-r))),g:Zd(F3(s+t*(B0(_f(e.g))-s))),b:Zd(F3(i+t*(B0(_f(e.b))-i))),a:n.a+t*(e.a-n.a)}}function gT(n,e,t){if(n){let r=M4(n);r[e]=Math.max(0,Math.min(r[e]+r[e]*t,e===0?360:1)),r=$4(r),n.r=r[0],n.g=r[1],n.b=r[2]}}function fse(n,e){return n&&Object.assign(e||{},n)}function j6(n){var e={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(e={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(e.a=Zd(n[3]))):(e=fse(n,{r:0,g:0,b:0,a:1}),e.a=Zd(e.a)),e}function yst(n){return n.charAt(0)==="r"?pst(n):lst(n)}let dse=class rF{constructor(e){if(e instanceof rF)return e;const t=typeof e;let r;t==="object"?r=j6(e):t==="string"&&(r=Qrt(e)||fst(e)||yst(e)),this._rgb=r,this._valid=!!r}get valid(){return this._valid}get rgb(){var e=fse(this._rgb);return e&&(e.a=_f(e.a)),e}set rgb(e){this._rgb=j6(e)}rgbString(){return this._valid?mst(this._rgb):void 0}hexString(){return this._valid?tst(this._rgb):void 0}hslString(){return this._valid?ust(this._rgb):void 0}mix(e,t){if(e){const r=this.rgb,s=e.rgb;let i;const o=t===i?.5:t,a=2*o-1,l=r.a-s.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;i=1-c,r.r=255&c*r.r+i*s.r+.5,r.g=255&c*r.g+i*s.g+.5,r.b=255&c*r.b+i*s.b+.5,r.a=o*r.a+(1-o)*s.a,this.rgb=r}return this}interpolate(e,t){return e&&(this._rgb=gst(this._rgb,e._rgb,t)),this}clone(){return new rF(this.rgb)}alpha(e){return this._rgb.a=Zd(e),this}clearer(e){const t=this._rgb;return t.a*=1-e,this}greyscale(){const e=this._rgb,t=RC(e.r*.3+e.g*.59+e.b*.11);return e.r=e.g=e.b=t,this}opaquer(e){const t=this._rgb;return t.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return gT(this._rgb,2,e),this}darken(e){return gT(this._rgb,2,-e),this}saturate(e){return gT(this._rgb,1,e),this}desaturate(e){return gT(this._rgb,1,-e),this}rotate(e){return cst(this._rgb,e),this}};/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function af(){}const bst=(()=>{let n=0;return()=>n++})();function Nr(n){return n===null||typeof n>"u"}function gs(n){if(Array.isArray&&Array.isArray(n))return!0;const e=Object.prototype.toString.call(n);return e.slice(0,7)==="[object"&&e.slice(-6)==="Array]"}function nr(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}function Zs(n){return(typeof n=="number"||n instanceof Number)&&isFinite(+n)}function gl(n,e){return Zs(n)?n:e}function Un(n,e){return typeof n>"u"?e:n}const vst=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100:+n/e,pse=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*e:+n;function is(n,e,t){if(n&&typeof n.call=="function")return n.apply(t,e)}function Dr(n,e,t,r){let s,i,o;if(gs(n))if(i=n.length,r)for(s=i-1;s>=0;s--)e.call(t,n[s],s);else for(s=0;s<i;s++)e.call(t,n[s],s);else if(nr(n))for(o=Object.keys(n),i=o.length,s=0;s<i;s++)e.call(t,n[o[s]],o[s])}function hA(n,e){let t,r,s,i;if(!n||!e||n.length!==e.length)return!1;for(t=0,r=n.length;t<r;++t)if(s=n[t],i=e[t],s.datasetIndex!==i.datasetIndex||s.index!==i.index)return!1;return!0}function fA(n){if(gs(n))return n.map(fA);if(nr(n)){const e=Object.create(null),t=Object.keys(n),r=t.length;let s=0;for(;s<r;++s)e[t[s]]=fA(n[t[s]]);return e}return n}function mse(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function wst(n,e,t,r){if(!mse(n))return;const s=e[n],i=t[n];nr(s)&&nr(i)?eS(s,i,r):e[n]=fA(i)}function eS(n,e,t){const r=gs(e)?e:[e],s=r.length;if(!nr(n))return n;t=t||{};const i=t.merger||wst;let o;for(let a=0;a<s;++a){if(o=r[a],!nr(o))continue;const l=Object.keys(o);for(let c=0,u=l.length;c<u;++c)i(l[c],n,o,t)}return n}function n_(n,e){return eS(n,e,{merger:xst})}function xst(n,e,t){if(!mse(n))return;const r=e[n],s=t[n];nr(r)&&nr(s)?n_(r,s):Object.prototype.hasOwnProperty.call(e,n)||(e[n]=fA(s))}const q6={"":n=>n,x:n=>n.x,y:n=>n.y};function _st(n){const e=n.split("."),t=[];let r="";for(const s of e)r+=s,r.endsWith("\\")?r=r.slice(0,-1)+".":(t.push(r),r="");return t}function Sst(n){const e=_st(n);return t=>{for(const r of e){if(r==="")break;t=t&&t[r]}return t}}function bp(n,e){return(q6[e]||(q6[e]=Sst(e)))(n)}function R4(n){return n.charAt(0).toUpperCase()+n.slice(1)}const Ac=n=>typeof n<"u",vp=n=>typeof n=="function",X6=(n,e)=>{if(n.size!==e.size)return!1;for(const t of n)if(!e.has(t))return!1;return!0};function Cst(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const Ts=Math.PI,bs=2*Ts,kst=bs+Ts,dA=Number.POSITIVE_INFINITY,Tst=Ts/180,Js=Ts/2,um=Ts/4,K6=Ts*2/3,Bd=Math.log10,vh=Math.sign;function r_(n,e,t){return Math.abs(n-e)<t}function Y6(n){const e=Math.round(n);n=r_(n,e,n/1e3)?e:n;const t=Math.pow(10,Math.floor(Bd(n))),r=n/t;return(r<=1?1:r<=2?2:r<=5?5:10)*t}function Est(n){const e=[],t=Math.sqrt(n);let r;for(r=1;r<t;r++)n%r===0&&(e.push(r),e.push(n/r));return t===(t|0)&&e.push(t),e.sort((s,i)=>s-i).pop(),e}function uv(n){return!isNaN(parseFloat(n))&&isFinite(n)}function Ist(n,e){const t=Math.round(n);return t-e<=n&&t+e>=n}function gse(n,e,t){let r,s,i;for(r=0,s=n.length;r<s;r++)i=n[r][t],isNaN(i)||(e.min=Math.min(e.min,i),e.max=Math.max(e.max,i))}function fu(n){return n*(Ts/180)}function P4(n){return n*(180/Ts)}function Z6(n){if(!Zs(n))return;let e=1,t=0;for(;Math.round(n*e)/e!==n;)e*=10,t++;return t}function yse(n,e){const t=e.x-n.x,r=e.y-n.y,s=Math.sqrt(t*t+r*r);let i=Math.atan2(r,t);return i<-.5*Ts&&(i+=bs),{angle:i,distance:s}}function sF(n,e){return Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2))}function Ast(n,e){return(n-e+kst)%bs-Ts}function yl(n){return(n%bs+bs)%bs}function tS(n,e,t,r){const s=yl(n),i=yl(e),o=yl(t),a=yl(i-s),l=yl(o-s),c=yl(s-i),u=yl(s-o);return s===i||s===o||r&&i===o||a>l&&c<u}function Xo(n,e,t){return Math.max(e,Math.min(t,n))}function Mst(n){return Xo(n,-32768,32767)}function Af(n,e,t,r=1e-6){return n>=Math.min(e,t)-r&&n<=Math.max(e,t)+r}function D4(n,e,t){t=t||(o=>n[o]<e);let r=n.length-1,s=0,i;for(;r-s>1;)i=s+r>>1,t(i)?s=i:r=i;return{lo:s,hi:r}}const Hm=(n,e,t,r)=>D4(n,t,r?s=>{const i=n[s][e];return i<t||i===t&&n[s+1][e]===t}:s=>n[s][e]<t),Nst=(n,e,t)=>D4(n,t,r=>n[r][e]>=t);function $st(n,e,t){let r=0,s=n.length;for(;r<s&&n[r]<e;)r++;for(;s>r&&n[s-1]>t;)s--;return r>0||s<n.length?n.slice(r,s):n}const bse=["push","pop","shift","splice","unshift"];function Rst(n,e){if(n._chartjs){n._chartjs.listeners.push(e);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),bse.forEach(t=>{const r="_onData"+R4(t),s=n[t];Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value(...i){const o=s.apply(this,i);return n._chartjs.listeners.forEach(a=>{typeof a[r]=="function"&&a[r](...i)}),o}})})}function J6(n,e){const t=n._chartjs;if(!t)return;const r=t.listeners,s=r.indexOf(e);s!==-1&&r.splice(s,1),!(r.length>0)&&(bse.forEach(i=>{delete n[i]}),delete n._chartjs)}function vse(n){const e=new Set;let t,r;for(t=0,r=n.length;t<r;++t)e.add(n[t]);return e.size===r?n:Array.from(e)}const wse=function(){return typeof window>"u"?function(n){return n()}:window.requestAnimationFrame}();function xse(n,e){let t=[],r=!1;return function(...s){t=s,r||(r=!0,wse.call(window,()=>{r=!1,n.apply(e,t)}))}}function Pst(n,e){let t;return function(...r){return e?(clearTimeout(t),t=setTimeout(n,e,r)):n.apply(this,r),e}}const O4=n=>n==="start"?"left":n==="end"?"right":"center",Lo=(n,e,t)=>n==="start"?e:n==="end"?t:(e+t)/2,Dst=(n,e,t,r)=>n===(r?"left":"right")?t:n==="center"?(e+t)/2:e;function _se(n,e,t){const r=e.length;let s=0,i=r;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:u,minDefined:h,maxDefined:f}=o.getUserBounds();h&&(s=Xo(Math.min(Hm(a,o.axis,c).lo,t?r:Hm(e,l,o.getPixelForValue(c)).lo),0,r-1)),f?i=Xo(Math.max(Hm(a,o.axis,u,!0).hi+1,t?0:Hm(e,l,o.getPixelForValue(u),!0).hi+1),s,r)-s:i=r-s}return{start:s,count:i}}function Sse(n){const{xScale:e,yScale:t,_scaleRanges:r}=n,s={xmin:e.min,xmax:e.max,ymin:t.min,ymax:t.max};if(!r)return n._scaleRanges=s,!0;const i=r.xmin!==e.min||r.xmax!==e.max||r.ymin!==t.min||r.ymax!==t.max;return Object.assign(r,s),i}const yT=n=>n===0||n===1,Q6=(n,e,t)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-e)*bs/t)),e5=(n,e,t)=>Math.pow(2,-10*n)*Math.sin((n-e)*bs/t)+1,s_={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*Js)+1,easeOutSine:n=>Math.sin(n*Js),easeInOutSine:n=>-.5*(Math.cos(Ts*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>yT(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>yT(n)?n:Q6(n,.075,.3),easeOutElastic:n=>yT(n)?n:e5(n,.075,.3),easeInOutElastic(n){return yT(n)?n:n<.5?.5*Q6(n*2,.1125,.45):.5+.5*e5(n*2-1,.1125,.45)},easeInBack(n){return n*n*((1.70158+1)*n-1.70158)},easeOutBack(n){return(n-=1)*n*((1.70158+1)*n+1.70158)+1},easeInOutBack(n){let e=1.70158;return(n/=.5)<1?.5*(n*n*(((e*=1.525)+1)*n-e)):.5*((n-=2)*n*(((e*=1.525)+1)*n+e)+2)},easeInBounce:n=>1-s_.easeOutBounce(1-n),easeOutBounce(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},easeInOutBounce:n=>n<.5?s_.easeInBounce(n*2)*.5:s_.easeOutBounce(n*2-1)*.5+.5};function Cse(n){if(n&&typeof n=="object"){const e=n.toString();return e==="[object CanvasPattern]"||e==="[object CanvasGradient]"}return!1}function t5(n){return Cse(n)?n:new dse(n)}function L3(n){return Cse(n)?n:new dse(n).saturate(.5).darken(.1).hexString()}const Ost=["x","y","borderWidth","radius","tension"],Fst=["color","borderColor","backgroundColor"];function Lst(n){n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),n.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>e!=="onProgress"&&e!=="onComplete"&&e!=="fn"}),n.set("animations",{colors:{type:"color",properties:Fst},numbers:{type:"number",properties:Ost}}),n.describe("animations",{_fallback:"animation"}),n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>e|0}}}})}function zst(n){n.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const n5=new Map;function Bst(n,e){e=e||{};const t=n+JSON.stringify(e);let r=n5.get(t);return r||(r=new Intl.NumberFormat(n,e),n5.set(t,r)),r}function PC(n,e,t){return Bst(e,t).format(n)}const kse={values(n){return gs(n)?n:""+n},numeric(n,e,t){if(n===0)return"0";const r=this.chart.options.locale;let s,i=n;if(t.length>1){const c=Math.max(Math.abs(t[0].value),Math.abs(t[t.length-1].value));(c<1e-4||c>1e15)&&(s="scientific"),i=Vst(n,t)}const o=Bd(Math.abs(i)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:s,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),PC(n,r,l)},logarithmic(n,e,t){if(n===0)return"0";const r=t[e].significand||n/Math.pow(10,Math.floor(Bd(n)));return[1,2,3,5,10,15].includes(r)||e>.8*t.length?kse.numeric.call(this,n,e,t):""}};function Vst(n,e){let t=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;return Math.abs(t)>=1&&n!==Math.floor(n)&&(t=n-Math.floor(n)),t}var w$={formatters:kse};function Ust(n){n.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:w$.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),n.route("scale.ticks","color","","color"),n.route("scale.grid","color","","borderColor"),n.route("scale.border","color","","borderColor"),n.route("scale.title","color","","color"),n.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&e!=="callback"&&e!=="parser",_indexable:e=>e!=="borderDash"&&e!=="tickBorderDash"&&e!=="dash"}),n.describe("scales",{_fallback:"scale"}),n.describe("scale.ticks",{_scriptable:e=>e!=="backdropPadding"&&e!=="callback",_indexable:e=>e!=="backdropPadding"})}const xg=Object.create(null),iF=Object.create(null);function i_(n,e){if(!e)return n;const t=e.split(".");for(let r=0,s=t.length;r<s;++r){const i=t[r];n=n[i]||(n[i]=Object.create(null))}return n}function z3(n,e,t){return typeof e=="string"?eS(i_(n,e),t):eS(i_(n,""),e)}class Wst{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=r=>r.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(r,s)=>L3(s.backgroundColor),this.hoverBorderColor=(r,s)=>L3(s.borderColor),this.hoverColor=(r,s)=>L3(s.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return z3(this,e,t)}get(e){return i_(this,e)}describe(e,t){return z3(iF,e,t)}override(e,t){return z3(xg,e,t)}route(e,t,r,s){const i=i_(this,e),o=i_(this,r),a="_"+t;Object.defineProperties(i,{[a]:{value:i[t],writable:!0},[t]:{enumerable:!0,get(){const l=this[a],c=o[s];return nr(l)?Object.assign({},c,l):Un(l,c)},set(l){this[a]=l}}})}apply(e){e.forEach(t=>t(this))}}var ai=new Wst({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[Lst,zst,Ust]);function Gst(n){return!n||Nr(n.size)||Nr(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function pA(n,e,t,r,s){let i=e[s];return i||(i=e[s]=n.measureText(s).width,t.push(s)),i>r&&(r=i),r}function Hst(n,e,t,r){r=r||{};let s=r.data=r.data||{},i=r.garbageCollect=r.garbageCollect||[];r.font!==e&&(s=r.data={},i=r.garbageCollect=[],r.font=e),n.save(),n.font=e;let o=0;const a=t.length;let l,c,u,h,f;for(l=0;l<a;l++)if(h=t[l],h!=null&&gs(h)!==!0)o=pA(n,s,i,o,h);else if(gs(h))for(c=0,u=h.length;c<u;c++)f=h[c],f!=null&&!gs(f)&&(o=pA(n,s,i,o,f));n.restore();const d=i.length/2;if(d>t.length){for(l=0;l<d;l++)delete s[i[l]];i.splice(0,d)}return o}function hm(n,e,t){const r=n.currentDevicePixelRatio,s=t!==0?Math.max(t/2,.5):0;return Math.round((e-s)*r)/r+s}function r5(n,e){e=e||n.getContext("2d"),e.save(),e.resetTransform(),e.clearRect(0,0,n.width,n.height),e.restore()}function oF(n,e,t,r){Tse(n,e,t,r,null)}function Tse(n,e,t,r,s){let i,o,a,l,c,u,h,f;const d=e.pointStyle,p=e.rotation,m=e.radius;let g=(p||0)*Tst;if(d&&typeof d=="object"&&(i=d.toString(),i==="[object HTMLImageElement]"||i==="[object HTMLCanvasElement]")){n.save(),n.translate(t,r),n.rotate(g),n.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),n.restore();return}if(!(isNaN(m)||m<=0)){switch(n.beginPath(),d){default:s?n.ellipse(t,r,s/2,m,0,0,bs):n.arc(t,r,m,0,bs),n.closePath();break;case"triangle":u=s?s/2:m,n.moveTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=K6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=K6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),n.closePath();break;case"rectRounded":c=m*.516,l=m-c,o=Math.cos(g+um)*l,h=Math.cos(g+um)*(s?s/2-c:l),a=Math.sin(g+um)*l,f=Math.sin(g+um)*(s?s/2-c:l),n.arc(t-h,r-a,c,g-Ts,g-Js),n.arc(t+f,r-o,c,g-Js,g),n.arc(t+h,r+a,c,g,g+Js),n.arc(t-f,r+o,c,g+Js,g+Ts),n.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*m,u=s?s/2:l,n.rect(t-u,r-l,2*u,2*l);break}g+=um;case"rectRot":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+f,r-o),n.lineTo(t+h,r+a),n.lineTo(t-f,r+o),n.closePath();break;case"crossRot":g+=um;case"cross":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"star":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o),g+=um,h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"line":o=s?s/2:Math.cos(g)*m,a=Math.sin(g)*m,n.moveTo(t-o,r-a),n.lineTo(t+o,r+a);break;case"dash":n.moveTo(t,r),n.lineTo(t+Math.cos(g)*(s?s/2:m),r+Math.sin(g)*m);break;case!1:n.closePath();break}n.fill(),e.borderWidth>0&&n.stroke()}}function nS(n,e,t){return t=t||.5,!e||n&&n.x>e.left-t&&n.x<e.right+t&&n.y>e.top-t&&n.y<e.bottom+t}function x$(n,e){n.save(),n.beginPath(),n.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),n.clip()}function _$(n){n.restore()}function jst(n,e,t,r,s){if(!e)return n.lineTo(t.x,t.y);if(s==="middle"){const i=(e.x+t.x)/2;n.lineTo(i,e.y),n.lineTo(i,t.y)}else s==="after"!=!!r?n.lineTo(e.x,t.y):n.lineTo(t.x,e.y);n.lineTo(t.x,t.y)}function qst(n,e,t,r){if(!e)return n.lineTo(t.x,t.y);n.bezierCurveTo(r?e.cp1x:e.cp2x,r?e.cp1y:e.cp2y,r?t.cp2x:t.cp1x,r?t.cp2y:t.cp1y,t.x,t.y)}function _g(n,e,t,r,s,i={}){const o=gs(e)?e:[e],a=i.strokeWidth>0&&i.strokeColor!=="";let l,c;for(n.save(),n.font=s.string,Xst(n,i),l=0;l<o.length;++l)c=o[l],i.backdrop&&Yst(n,i.backdrop),a&&(i.strokeColor&&(n.strokeStyle=i.strokeColor),Nr(i.strokeWidth)||(n.lineWidth=i.strokeWidth),n.strokeText(c,t,r,i.maxWidth)),n.fillText(c,t,r,i.maxWidth),Kst(n,t,r,c,i),r+=s.lineHeight;n.restore()}function Xst(n,e){e.translation&&n.translate(e.translation[0],e.translation[1]),Nr(e.rotation)||n.rotate(e.rotation),e.color&&(n.fillStyle=e.color),e.textAlign&&(n.textAlign=e.textAlign),e.textBaseline&&(n.textBaseline=e.textBaseline)}function Kst(n,e,t,r,s){if(s.strikethrough||s.underline){const i=n.measureText(r),o=e-i.actualBoundingBoxLeft,a=e+i.actualBoundingBoxRight,l=t-i.actualBoundingBoxAscent,c=t+i.actualBoundingBoxDescent,u=s.strikethrough?(l+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=s.decorationWidth||2,n.moveTo(o,u),n.lineTo(a,u),n.stroke()}}function Yst(n,e){const t=n.fillStyle;n.fillStyle=e.color,n.fillRect(e.left,e.top,e.width,e.height),n.fillStyle=t}function Jd(n,e){const{x:t,y:r,w:s,h:i,radius:o}=e;n.arc(t+o.topLeft,r+o.topLeft,o.topLeft,-Js,Ts,!0),n.lineTo(t,r+i-o.bottomLeft),n.arc(t+o.bottomLeft,r+i-o.bottomLeft,o.bottomLeft,Ts,Js,!0),n.lineTo(t+s-o.bottomRight,r+i),n.arc(t+s-o.bottomRight,r+i-o.bottomRight,o.bottomRight,Js,0,!0),n.lineTo(t+s,r+o.topRight),n.arc(t+s-o.topRight,r+o.topRight,o.topRight,0,-Js,!0),n.lineTo(t+o.topLeft,r)}const Zst=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,Jst=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function Qst(n,e){const t=(""+n).match(Zst);if(!t||t[1]==="normal")return e*1.2;switch(n=+t[2],t[3]){case"px":return n;case"%":n/=100;break}return e*n}const eit=n=>+n||0;function F4(n,e){const t={},r=nr(e),s=r?Object.keys(e):e,i=nr(n)?r?o=>Un(n[o],n[e[o]]):o=>n[o]:()=>n;for(const o of s)t[o]=eit(i(o));return t}function Ese(n){return F4(n,{top:"y",right:"x",bottom:"y",left:"x"})}function Qd(n){return F4(n,["topLeft","topRight","bottomLeft","bottomRight"])}function Jo(n){const e=Ese(n);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Gi(n,e){n=n||{},e=e||ai.font;let t=Un(n.size,e.size);typeof t=="string"&&(t=parseInt(t,10));let r=Un(n.style,e.style);r&&!(""+r).match(Jst)&&(console.warn('Invalid font style specified: "'+r+'"'),r=void 0);const s={family:Un(n.family,e.family),lineHeight:Qst(Un(n.lineHeight,e.lineHeight),t),size:t,style:r,weight:Un(n.weight,e.weight),string:""};return s.string=Gst(s),s}function bT(n,e,t,r){let s=!0,i,o,a;for(i=0,o=n.length;i<o;++i)if(a=n[i],a!==void 0&&(e!==void 0&&typeof a=="function"&&(a=a(e),s=!1),t!==void 0&&gs(a)&&(a=a[t%a.length],s=!1),a!==void 0))return r&&!s&&(r.cacheable=!1),a}function tit(n,e,t){const{min:r,max:s}=n,i=pse(e,(s-r)/2),o=(a,l)=>t&&a===0?0:a+l;return{min:o(r,-Math.abs(i)),max:o(s,i)}}function Wp(n,e){return Object.assign(Object.create(n),e)}function L4(n,e=[""],t=n,r,s=()=>n[0]){Ac(r)||(r=Nse("_fallback",n));const i={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:t,_fallback:r,_getTarget:s,override:o=>L4([o,...n],e,t,r)};return new Proxy(i,{deleteProperty(o,a){return delete o[a],delete o._keys,delete n[0][a],!0},get(o,a){return Ase(o,a,()=>cit(a,e,n,o))},getOwnPropertyDescriptor(o,a){return Reflect.getOwnPropertyDescriptor(o._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,a){return i5(o).includes(a)},ownKeys(o){return i5(o)},set(o,a,l){const c=o._storage||(o._storage=s());return o[a]=c[a]=l,delete o._keys,!0}})}function hv(n,e,t,r){const s={_cacheable:!1,_proxy:n,_context:e,_subProxy:t,_stack:new Set,_descriptors:Ise(n,r),setContext:i=>hv(n,i,t,r),override:i=>hv(n.override(i),e,t,r)};return new Proxy(s,{deleteProperty(i,o){return delete i[o],delete n[o],!0},get(i,o,a){return Ase(i,o,()=>rit(i,o,a))},getOwnPropertyDescriptor(i,o){return i._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(i,o){return Reflect.has(n,o)},ownKeys(){return Reflect.ownKeys(n)},set(i,o,a){return n[o]=a,delete i[o],!0}})}function Ise(n,e={scriptable:!0,indexable:!0}){const{_scriptable:t=e.scriptable,_indexable:r=e.indexable,_allKeys:s=e.allKeys}=n;return{allKeys:s,scriptable:t,indexable:r,isScriptable:vp(t)?t:()=>t,isIndexable:vp(r)?r:()=>r}}const nit=(n,e)=>n?n+R4(e):e,z4=(n,e)=>nr(e)&&n!=="adapters"&&(Object.getPrototypeOf(e)===null||e.constructor===Object);function Ase(n,e,t){if(Object.prototype.hasOwnProperty.call(n,e))return n[e];const r=t();return n[e]=r,r}function rit(n,e,t){const{_proxy:r,_context:s,_subProxy:i,_descriptors:o}=n;let a=r[e];return vp(a)&&o.isScriptable(e)&&(a=sit(e,a,n,t)),gs(a)&&a.length&&(a=iit(e,a,n,o.isIndexable)),z4(e,a)&&(a=hv(a,s,i&&i[e],o)),a}function sit(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_stack:a}=t;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),e=e(i,o||r),a.delete(n),z4(n,e)&&(e=B4(s._scopes,s,n,e)),e}function iit(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_descriptors:a}=t;if(Ac(i.index)&&r(n))e=e[i.index%e.length];else if(nr(e[0])){const l=e,c=s._scopes.filter(u=>u!==l);e=[];for(const u of l){const h=B4(c,s,n,u);e.push(hv(h,i,o&&o[n],a))}}return e}function Mse(n,e,t){return vp(n)?n(e,t):n}const oit=(n,e)=>n===!0?e:typeof n=="string"?bp(e,n):void 0;function ait(n,e,t,r,s){for(const i of e){const o=oit(t,i);if(o){n.add(o);const a=Mse(o._fallback,t,s);if(Ac(a)&&a!==t&&a!==r)return a}else if(o===!1&&Ac(r)&&t!==r)return null}return!1}function B4(n,e,t,r){const s=e._rootScopes,i=Mse(e._fallback,t,r),o=[...n,...s],a=new Set;a.add(r);let l=s5(a,o,t,i||t,r);return l===null||Ac(i)&&i!==t&&(l=s5(a,o,i,l,r),l===null)?!1:L4(Array.from(a),[""],s,i,()=>lit(e,t,r))}function s5(n,e,t,r,s){for(;t;)t=ait(n,e,t,r,s);return t}function lit(n,e,t){const r=n._getTarget();e in r||(r[e]={});const s=r[e];return gs(s)&&nr(t)?t:s||{}}function cit(n,e,t,r){let s;for(const i of e)if(s=Nse(nit(i,n),t),Ac(s))return z4(n,s)?B4(t,r,n,s):s}function Nse(n,e){for(const t of e){if(!t)continue;const r=t[n];if(Ac(r))return r}}function i5(n){let e=n._keys;return e||(e=n._keys=uit(n._scopes)),e}function uit(n){const e=new Set;for(const t of n)for(const r of Object.keys(t).filter(s=>!s.startsWith("_")))e.add(r);return Array.from(e)}function $se(n,e,t,r){const{iScale:s}=n,{key:i="r"}=this._parsing,o=new Array(r);let a,l,c,u;for(a=0,l=r;a<l;++a)c=a+t,u=e[c],o[a]={r:s.parse(bp(u,i),c)};return o}const hit=Number.EPSILON||1e-14,fv=(n,e)=>e<n.length&&!n[e].skip&&n[e],Rse=n=>n==="x"?"y":"x";function fit(n,e,t,r){const s=n.skip?e:n,i=e,o=t.skip?e:t,a=sF(i,s),l=sF(o,i);let c=a/(a+l),u=l/(a+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const h=r*c,f=r*u;return{previous:{x:i.x-h*(o.x-s.x),y:i.y-h*(o.y-s.y)},next:{x:i.x+f*(o.x-s.x),y:i.y+f*(o.y-s.y)}}}function dit(n,e,t){const r=n.length;let s,i,o,a,l,c=fv(n,0);for(let u=0;u<r-1;++u)if(l=c,c=fv(n,u+1),!(!l||!c)){if(r_(e[u],0,hit)){t[u]=t[u+1]=0;continue}s=t[u]/e[u],i=t[u+1]/e[u],a=Math.pow(s,2)+Math.pow(i,2),!(a<=9)&&(o=3/Math.sqrt(a),t[u]=s*o*e[u],t[u+1]=i*o*e[u])}}function pit(n,e,t="x"){const r=Rse(t),s=n.length;let i,o,a,l=fv(n,0);for(let c=0;c<s;++c){if(o=a,a=l,l=fv(n,c+1),!a)continue;const u=a[t],h=a[r];o&&(i=(u-o[t])/3,a[`cp1${t}`]=u-i,a[`cp1${r}`]=h-i*e[c]),l&&(i=(l[t]-u)/3,a[`cp2${t}`]=u+i,a[`cp2${r}`]=h+i*e[c])}}function mit(n,e="x"){const t=Rse(e),r=n.length,s=Array(r).fill(0),i=Array(r);let o,a,l,c=fv(n,0);for(o=0;o<r;++o)if(a=l,l=c,c=fv(n,o+1),!!l){if(c){const u=c[e]-l[e];s[o]=u!==0?(c[t]-l[t])/u:0}i[o]=a?c?vh(s[o-1])!==vh(s[o])?0:(s[o-1]+s[o])/2:s[o-1]:s[o]}dit(n,s,i),pit(n,i,e)}function vT(n,e,t){return Math.max(Math.min(n,t),e)}function git(n,e){let t,r,s,i,o,a=nS(n[0],e);for(t=0,r=n.length;t<r;++t)o=i,i=a,a=t<r-1&&nS(n[t+1],e),i&&(s=n[t],o&&(s.cp1x=vT(s.cp1x,e.left,e.right),s.cp1y=vT(s.cp1y,e.top,e.bottom)),a&&(s.cp2x=vT(s.cp2x,e.left,e.right),s.cp2y=vT(s.cp2y,e.top,e.bottom)))}function yit(n,e,t,r,s){let i,o,a,l;if(e.spanGaps&&(n=n.filter(c=>!c.skip)),e.cubicInterpolationMode==="monotone")mit(n,s);else{let c=r?n[n.length-1]:n[0];for(i=0,o=n.length;i<o;++i)a=n[i],l=fit(c,a,n[Math.min(i+1,o-(r?0:1))%o],e.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}e.capBezierPoints&&git(n,t)}function Pse(){return typeof window<"u"&&typeof document<"u"}function V4(n){let e=n.parentNode;return e&&e.toString()==="[object ShadowRoot]"&&(e=e.host),e}function mA(n,e,t){let r;return typeof n=="string"?(r=parseInt(n,10),n.indexOf("%")!==-1&&(r=r/100*e.parentNode[t])):r=n,r}const S$=n=>n.ownerDocument.defaultView.getComputedStyle(n,null);function bit(n,e){return S$(n).getPropertyValue(e)}const vit=["top","right","bottom","left"];function eg(n,e,t){const r={};t=t?"-"+t:"";for(let s=0;s<4;s++){const i=vit[s];r[i]=parseFloat(n[e+"-"+i+t])||0}return r.width=r.left+r.right,r.height=r.top+r.bottom,r}const wit=(n,e,t)=>(n>0||e>0)&&(!t||!t.shadowRoot);function xit(n,e){const t=n.touches,r=t&&t.length?t[0]:n,{offsetX:s,offsetY:i}=r;let o=!1,a,l;if(wit(s,i,n.target))a=s,l=i;else{const c=e.getBoundingClientRect();a=r.clientX-c.left,l=r.clientY-c.top,o=!0}return{x:a,y:l,box:o}}function Em(n,e){if("native"in n)return n;const{canvas:t,currentDevicePixelRatio:r}=e,s=S$(t),i=s.boxSizing==="border-box",o=eg(s,"padding"),a=eg(s,"border","width"),{x:l,y:c,box:u}=xit(n,t),h=o.left+(u&&a.left),f=o.top+(u&&a.top);let{width:d,height:p}=e;return i&&(d-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-h)/d*t.width/r),y:Math.round((c-f)/p*t.height/r)}}function _it(n,e,t){let r,s;if(e===void 0||t===void 0){const i=V4(n);if(!i)e=n.clientWidth,t=n.clientHeight;else{const o=i.getBoundingClientRect(),a=S$(i),l=eg(a,"border","width"),c=eg(a,"padding");e=o.width-c.width-l.width,t=o.height-c.height-l.height,r=mA(a.maxWidth,i,"clientWidth"),s=mA(a.maxHeight,i,"clientHeight")}}return{width:e,height:t,maxWidth:r||dA,maxHeight:s||dA}}const wT=n=>Math.round(n*10)/10;function Sit(n,e,t,r){const s=S$(n),i=eg(s,"margin"),o=mA(s.maxWidth,n,"clientWidth")||dA,a=mA(s.maxHeight,n,"clientHeight")||dA,l=_it(n,e,t);let{width:c,height:u}=l;if(s.boxSizing==="content-box"){const f=eg(s,"border","width"),d=eg(s,"padding");c-=d.width+f.width,u-=d.height+f.height}return c=Math.max(0,c-i.width),u=Math.max(0,r?c/r:u-i.height),c=wT(Math.min(c,o,l.maxWidth)),u=wT(Math.min(u,a,l.maxHeight)),c&&!u&&(u=wT(c/2)),(e!==void 0||t!==void 0)&&r&&l.height&&u>l.height&&(u=l.height,c=wT(Math.floor(u*r))),{width:c,height:u}}function o5(n,e,t){const r=e||1,s=Math.floor(n.height*r),i=Math.floor(n.width*r);n.height=Math.floor(n.height),n.width=Math.floor(n.width);const o=n.canvas;return o.style&&(t||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),n.currentDevicePixelRatio!==r||o.height!==s||o.width!==i?(n.currentDevicePixelRatio=r,o.height=s,o.width=i,n.ctx.setTransform(r,0,0,r,0,0),!0):!1}const Cit=function(){let n=!1;try{const e={get passive(){return n=!0,!1}};window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}catch{}return n}();function a5(n,e){const t=bit(n,e),r=t&&t.match(/^(\d+)(\.\d+)?px$/);return r?+r[1]:void 0}function Im(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:n.y+t*(e.y-n.y)}}function kit(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:r==="middle"?t<.5?n.y:e.y:r==="after"?t<1?n.y:e.y:t>0?e.y:n.y}}function Tit(n,e,t,r){const s={x:n.cp2x,y:n.cp2y},i={x:e.cp1x,y:e.cp1y},o=Im(n,s,t),a=Im(s,i,t),l=Im(i,e,t),c=Im(o,a,t),u=Im(a,l,t);return Im(c,u,t)}const Eit=function(n,e){return{x(t){return n+n+e-t},setWidth(t){e=t},textAlign(t){return t==="center"?t:t==="right"?"left":"right"},xPlus(t,r){return t-r},leftForLtr(t,r){return t-r}}},Iit=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,e){return n+e},leftForLtr(n,e){return n}}};function Ob(n,e,t){return n?Eit(e,t):Iit()}function Dse(n,e){let t,r;(e==="ltr"||e==="rtl")&&(t=n.canvas.style,r=[t.getPropertyValue("direction"),t.getPropertyPriority("direction")],t.setProperty("direction",e,"important"),n.prevTextDirection=r)}function Ose(n,e){e!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",e[0],e[1]))}function Fse(n){return n==="angle"?{between:tS,compare:Ast,normalize:yl}:{between:Af,compare:(e,t)=>e-t,normalize:e=>e}}function l5({start:n,end:e,count:t,loop:r,style:s}){return{start:n%t,end:e%t,loop:r&&(e-n+1)%t===0,style:s}}function Ait(n,e,t){const{property:r,start:s,end:i}=t,{between:o,normalize:a}=Fse(r),l=e.length;let{start:c,end:u,loop:h}=n,f,d;if(h){for(c+=l,u+=l,f=0,d=l;f<d&&o(a(e[c%l][r]),s,i);++f)c--,u--;c%=l,u%=l}return u<c&&(u+=l),{start:c,end:u,loop:h,style:n.style}}function Lse(n,e,t){if(!t)return[n];const{property:r,start:s,end:i}=t,o=e.length,{compare:a,between:l,normalize:c}=Fse(r),{start:u,end:h,loop:f,style:d}=Ait(n,e,t),p=[];let m=!1,g=null,y,b,x;const w=()=>l(s,x,y)&&a(s,x)!==0,S=()=>a(i,y)===0||l(i,x,y),C=()=>m||w(),k=()=>!m||S();for(let A=u,M=u;A<=h;++A)b=e[A%o],!b.skip&&(y=c(b[r]),y!==x&&(m=l(y,s,i),g===null&&C()&&(g=a(y,s)===0?A:M),g!==null&&k()&&(p.push(l5({start:g,end:A,loop:f,count:o,style:d})),g=null),M=A,x=y));return g!==null&&p.push(l5({start:g,end:h,loop:f,count:o,style:d})),p}function zse(n,e){const t=[],r=n.segments;for(let s=0;s<r.length;s++){const i=Lse(r[s],n.points,e);i.length&&t.push(...i)}return t}function Mit(n,e,t,r){let s=0,i=e-1;if(t&&!r)for(;s<e&&!n[s].skip;)s++;for(;s<e&&n[s].skip;)s++;for(s%=e,t&&(i+=s);i>s&&n[i%e].skip;)i--;return i%=e,{start:s,end:i}}function Nit(n,e,t,r){const s=n.length,i=[];let o=e,a=n[e],l;for(l=e+1;l<=t;++l){const c=n[l%s];c.skip||c.stop?a.skip||(r=!1,i.push({start:e%s,end:(l-1)%s,loop:r}),e=o=c.stop?l:null):(o=l,a.skip&&(e=l)),a=c}return o!==null&&i.push({start:e%s,end:o%s,loop:r}),i}function $it(n,e){const t=n.points,r=n.options.spanGaps,s=t.length;if(!s)return[];const i=!!n._loop,{start:o,end:a}=Mit(t,s,i,r);if(r===!0)return c5(n,[{start:o,end:a,loop:i}],t,e);const l=a<o?a+s:a,c=!!n._fullLoop&&o===0&&a===s-1;return c5(n,Nit(t,o,l,c),t,e)}function c5(n,e,t,r){return!r||!r.setContext||!t?e:Rit(n,e,t,r)}function Rit(n,e,t,r){const s=n._chart.getContext(),i=u5(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=t.length,c=[];let u=i,h=e[0].start,f=h;function d(p,m,g,y){const b=a?-1:1;if(p!==m){for(p+=l;t[p%l].skip;)p-=b;for(;t[m%l].skip;)m+=b;p%l!==m%l&&(c.push({start:p%l,end:m%l,loop:g,style:y}),u=y,h=m%l)}}for(const p of e){h=a?h:p.start;let m=t[h%l],g;for(f=h+1;f<=p.end;f++){const y=t[f%l];g=u5(r.setContext(Wp(s,{type:"segment",p0:m,p1:y,p0DataIndex:(f-1)%l,p1DataIndex:f%l,datasetIndex:o}))),Pit(g,u)&&d(h,f-1,p.loop,u),m=y,u=g}h<f-1&&d(h,f-1,p.loop,u)}return c}function u5(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function Pit(n,e){return e&&JSON.stringify(n)!==JSON.stringify(e)}/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class Dit{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,r,s){const i=t.listeners[s],o=t.duration;i.forEach(a=>a({chart:e,initial:t.initial,numSteps:o,currentStep:Math.min(r-t.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=wse.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(e=Date.now()){let t=0;this._charts.forEach((r,s)=>{if(!r.running||!r.items.length)return;const i=r.items;let o=i.length-1,a=!1,l;for(;o>=0;--o)l=i[o],l._active?(l._total>r.duration&&(r.duration=l._total),l.tick(e),a=!0):(i[o]=i[i.length-1],i.pop());a&&(s.draw(),this._notify(s,r,e,"progress")),i.length||(r.running=!1,this._notify(s,r,e,"complete"),r.initial=!1),t+=i.length}),this._lastDate=e,t===0&&(this._running=!1)}_getAnims(e){const t=this._charts;let r=t.get(e);return r||(r={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,r)),r}listen(e,t,r){this._getAnims(e).listeners[t].push(r)}add(e,t){!t||!t.length||this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((r,s)=>Math.max(r,s._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!(!t||!t.running||!t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const r=t.items;let s=r.length-1;for(;s>=0;--s)r[s].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var pf=new Dit;const h5="transparent",Oit={boolean(n,e,t){return t>.5?e:n},color(n,e,t){const r=t5(n||h5),s=r.valid&&t5(e||h5);return s&&s.valid?s.mix(r,t).hexString():e},number(n,e,t){return n+(e-n)*t}};class Fit{constructor(e,t,r,s){const i=t[r];s=bT([e.to,s,i,e.from]);const o=bT([e.from,i,s]);this._active=!0,this._fn=e.fn||Oit[e.type||typeof o],this._easing=s_[e.easing]||s_.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=r,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(e,t,r){if(this._active){this._notify(!1);const s=this._target[this._prop],i=r-this._start,o=this._duration-i;this._start=r,this._duration=Math.floor(Math.max(o,e.duration)),this._total+=i,this._loop=!!e.loop,this._to=bT([e.to,t,s,e.from]),this._from=bT([e.from,s,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,r=this._duration,s=this._prop,i=this._from,o=this._loop,a=this._to;let l;if(this._active=i!==a&&(o||t<r),!this._active){this._target[s]=a,this._notify(!0);return}if(t<0){this._target[s]=i;return}l=t/r%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[s]=this._fn(i,a,l)}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,r)=>{e.push({res:t,rej:r})})}_notify(e){const t=e?"res":"rej",r=this._promises||[];for(let s=0;s<r.length;s++)r[s][t]()}}class Bse{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!nr(e))return;const t=Object.keys(ai.animation),r=this._properties;Object.getOwnPropertyNames(e).forEach(s=>{const i=e[s];if(!nr(i))return;const o={};for(const a of t)o[a]=i[a];(gs(i.properties)&&i.properties||[s]).forEach(a=>{(a===s||!r.has(a))&&r.set(a,o)})})}_animateOptions(e,t){const r=t.options,s=zit(e,r);if(!s)return[];const i=this._createAnimations(s,r);return r.$shared&&Lit(e.options.$animations,r).then(()=>{e.options=r},()=>{}),i}_createAnimations(e,t){const r=this._properties,s=[],i=e.$animations||(e.$animations={}),o=Object.keys(t),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){s.push(...this._animateOptions(e,t));continue}const u=t[c];let h=i[c];const f=r.get(c);if(h)if(f&&h.active()){h.update(f,u,a);continue}else h.cancel();if(!f||!f.duration){e[c]=u;continue}i[c]=h=new Fit(f,e,c,u),s.push(h)}return s}update(e,t){if(this._properties.size===0){Object.assign(e,t);return}const r=this._createAnimations(e,t);if(r.length)return pf.add(this._chart,r),!0}}function Lit(n,e){const t=[],r=Object.keys(e);for(let s=0;s<r.length;s++){const i=n[r[s]];i&&i.active()&&t.push(i.wait())}return Promise.all(t)}function zit(n,e){if(!e)return;let t=n.options;if(!t){n.options=e;return}return t.$shared&&(n.options=t=Object.assign({},t,{$shared:!1,$animations:{}})),t}function f5(n,e){const t=n&&n.options||{},r=t.reverse,s=t.min===void 0?e:0,i=t.max===void 0?e:0;return{start:r?i:s,end:r?s:i}}function Bit(n,e,t){if(t===!1)return!1;const r=f5(n,t),s=f5(e,t);return{top:s.end,right:r.end,bottom:s.start,left:r.start}}function Vit(n){let e,t,r,s;return nr(n)?(e=n.top,t=n.right,r=n.bottom,s=n.left):e=t=r=s=n,{top:e,right:t,bottom:r,left:s,disabled:n===!1}}function Vse(n,e){const t=[],r=n._getSortedDatasetMetas(e);let s,i;for(s=0,i=r.length;s<i;++s)t.push(r[s].index);return t}function d5(n,e,t,r={}){const s=n.keys,i=r.mode==="single";let o,a,l,c;if(e!==null){for(o=0,a=s.length;o<a;++o){if(l=+s[o],l===t){if(r.all)continue;break}c=n.values[l],Zs(c)&&(i||e===0||vh(e)===vh(c))&&(e+=c)}return e}}function Uit(n){const e=Object.keys(n),t=new Array(e.length);let r,s,i;for(r=0,s=e.length;r<s;++r)i=e[r],t[r]={x:i,y:n[i]};return t}function p5(n,e){const t=n&&n.options.stacked;return t||t===void 0&&e.stack!==void 0}function Wit(n,e,t){return`${n.id}.${e.id}.${t.stack||t.type}`}function Git(n){const{min:e,max:t,minDefined:r,maxDefined:s}=n.getUserBounds();return{min:r?e:Number.NEGATIVE_INFINITY,max:s?t:Number.POSITIVE_INFINITY}}function Hit(n,e,t){const r=n[e]||(n[e]={});return r[t]||(r[t]={})}function m5(n,e,t,r){for(const s of e.getMatchingVisibleMetas(r).reverse()){const i=n[s.index];if(t&&i>0||!t&&i<0)return s.index}return null}function g5(n,e){const{chart:t,_cachedMeta:r}=n,s=t._stacks||(t._stacks={}),{iScale:i,vScale:o,index:a}=r,l=i.axis,c=o.axis,u=Wit(i,o,r),h=e.length;let f;for(let d=0;d<h;++d){const p=e[d],{[l]:m,[c]:g}=p,y=p._stacks||(p._stacks={});f=y[c]=Hit(s,u,m),f[a]=g,f._top=m5(f,o,!0,r.type),f._bottom=m5(f,o,!1,r.type);const b=f._visualValues||(f._visualValues={});b[a]=g}}function B3(n,e){const t=n.scales;return Object.keys(t).filter(r=>t[r].axis===e).shift()}function jit(n,e){return Wp(n,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}function qit(n,e,t){return Wp(n,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:t,index:e,mode:"default",type:"data"})}function Zx(n,e){const t=n.controller.index,r=n.vScale&&n.vScale.axis;if(r){e=e||n._parsed;for(const s of e){const i=s._stacks;if(!i||i[r]===void 0||i[r][t]===void 0)return;delete i[r][t],i[r]._visualValues!==void 0&&i[r]._visualValues[t]!==void 0&&delete i[r]._visualValues[t]}}}const V3=n=>n==="reset"||n==="none",y5=(n,e)=>e?n:Object.assign({},n),Xit=(n,e,t)=>n&&!e.hidden&&e._stacked&&{keys:Vse(t,!0),values:null};class _c{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=p5(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Zx(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,r=this.getDataset(),s=(h,f,d,p)=>h==="x"?f:h==="r"?p:d,i=t.xAxisID=Un(r.xAxisID,B3(e,"x")),o=t.yAxisID=Un(r.yAxisID,B3(e,"y")),a=t.rAxisID=Un(r.rAxisID,B3(e,"r")),l=t.indexAxis,c=t.iAxisID=s(l,i,o,a),u=t.vAxisID=s(l,o,i,a);t.xScale=this.getScaleForId(i),t.yScale=this.getScaleForId(o),t.rScale=this.getScaleForId(a),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&J6(this._data,this),e._stacked&&Zx(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),r=this._data;if(nr(t))this._data=Uit(t);else if(r!==t){if(r){J6(r,this);const s=this._cachedMeta;Zx(s),s._parsed=[]}t&&Object.isExtensible(t)&&Rst(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,r=this.getDataset();let s=!1;this._dataCheck();const i=t._stacked;t._stacked=p5(t.vScale,t),t.stack!==r.stack&&(s=!0,Zx(t),t.stack=r.stack),this._resyncElements(e),(s||i!==t._stacked)&&g5(this,t._parsed)}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),r=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(r,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:r,_data:s}=this,{iScale:i,_stacked:o}=r,a=i.axis;let l=e===0&&t===s.length?!0:r._sorted,c=e>0&&r._parsed[e-1],u,h,f;if(this._parsing===!1)r._parsed=s,r._sorted=!0,f=s;else{gs(s[e])?f=this.parseArrayData(r,s,e,t):nr(s[e])?f=this.parseObjectData(r,s,e,t):f=this.parsePrimitiveData(r,s,e,t);const d=()=>h[a]===null||c&&h[a]<c[a];for(u=0;u<t;++u)r._parsed[u+e]=h=f[u],l&&(d()&&(l=!1),c=h);r._sorted=l}o&&g5(this,f)}parsePrimitiveData(e,t,r,s){const{iScale:i,vScale:o}=e,a=i.axis,l=o.axis,c=i.getLabels(),u=i===o,h=new Array(s);let f,d,p;for(f=0,d=s;f<d;++f)p=f+r,h[f]={[a]:u||i.parse(c[p],p),[l]:o.parse(t[p],p)};return h}parseArrayData(e,t,r,s){const{xScale:i,yScale:o}=e,a=new Array(s);let l,c,u,h;for(l=0,c=s;l<c;++l)u=l+r,h=t[u],a[l]={x:i.parse(h[0],u),y:o.parse(h[1],u)};return a}parseObjectData(e,t,r,s){const{xScale:i,yScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(s);let u,h,f,d;for(u=0,h=s;u<h;++u)f=u+r,d=t[f],c[u]={x:i.parse(bp(d,a),f),y:o.parse(bp(d,l),f)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,r){const s=this.chart,i=this._cachedMeta,o=t[e.axis],a={keys:Vse(s,!0),values:t._stacks[e.axis]._visualValues};return d5(a,o,i.index,{mode:r})}updateRangeFromParsed(e,t,r,s){const i=r[t.axis];let o=i===null?NaN:i;const a=s&&r._stacks[t.axis];s&&a&&(s.values=a,o=d5(s,i,this._cachedMeta.index)),e.min=Math.min(e.min,o),e.max=Math.max(e.max,o)}getMinMax(e,t){const r=this._cachedMeta,s=r._parsed,i=r._sorted&&e===r.iScale,o=s.length,a=this._getOtherScale(e),l=Xit(t,r,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:h}=Git(a);let f,d;function p(){d=s[f];const m=d[a.axis];return!Zs(d[e.axis])||u>m||h<m}for(f=0;f<o&&!(!p()&&(this.updateRangeFromParsed(c,e,d,l),i));++f);if(i){for(f=o-1;f>=0;--f)if(!p()){this.updateRangeFromParsed(c,e,d,l);break}}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,r=[];let s,i,o;for(s=0,i=t.length;s<i;++s)o=t[s][e.axis],Zs(o)&&r.push(o);return r}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,r=t.iScale,s=t.vScale,i=this.getParsed(e);return{label:r?""+r.getLabelForValue(i[r.axis]):"",value:s?""+s.getLabelForValue(i[s.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=Vit(Un(this.options.clip,Bit(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,r=this._cachedMeta,s=r.data||[],i=t.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||s.length-a,c=this.options.drawActiveElementsOnTop;let u;for(r.dataset&&r.dataset.draw(e,i,a,l),u=a;u<a+l;++u){const h=s[u];h.hidden||(h.active&&c?o.push(h):h.draw(e,i))}for(u=0;u<o.length;++u)o[u].draw(e,i)}getStyle(e,t){const r=t?"active":"default";return e===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(r):this.resolveDataElementOptions(e||0,r)}getContext(e,t,r){const s=this.getDataset();let i;if(e>=0&&e<this._cachedMeta.data.length){const o=this._cachedMeta.data[e];i=o.$context||(o.$context=qit(this.getContext(),e,o)),i.parsed=this.getParsed(e),i.raw=s.data[e],i.index=i.dataIndex=e}else i=this.$context||(this.$context=jit(this.chart.getContext(),this.index)),i.dataset=s,i.index=i.datasetIndex=this.index;return i.active=!!t,i.mode=r,i}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e,t="default",r){const s=t==="active",i=this._cachedDataOpts,o=e+"-"+t,a=i[o],l=this.enableOptionSharing&&Ac(r);if(a)return y5(a,l);const c=this.chart.config,u=c.datasetElementScopeKeys(this._type,e),h=s?[`${e}Hover`,"hover",e,""]:[e,""],f=c.getOptionScopes(this.getDataset(),u),d=Object.keys(ai.elements[e]),p=()=>this.getContext(r,s,t),m=c.resolveNamedOptions(f,d,p,h);return m.$shared&&(m.$shared=l,i[o]=Object.freeze(y5(m,l))),m}_resolveAnimations(e,t,r){const s=this.chart,i=this._cachedDataOpts,o=`animation-${t}`,a=i[o];if(a)return a;let l;if(s.options.animation!==!1){const u=this.chart.config,h=u.datasetAnimationScopeKeys(this._type,t),f=u.getOptionScopes(this.getDataset(),h);l=u.createResolver(f,this.getContext(e,r,t))}const c=new Bse(s,l&&l.animations);return l&&l._cacheable&&(i[o]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||V3(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const r=this.resolveDataElementOptions(e,t),s=this._sharedOptions,i=this.getSharedOptions(r),o=this.includeOptions(t,i)||i!==s;return this.updateSharedOptions(i,t,r),{sharedOptions:i,includeOptions:o}}updateElement(e,t,r,s){V3(s)?Object.assign(e,r):this._resolveAnimations(t,s).update(e,r)}updateSharedOptions(e,t,r){e&&!V3(t)&&this._resolveAnimations(void 0,t).update(e,r)}_setStyle(e,t,r,s){e.active=s;const i=this.getStyle(t,s);this._resolveAnimations(t,r,s).update(e,{options:!s&&this.getSharedOptions(i)||i})}removeHoverStyle(e,t,r){this._setStyle(e,r,"active",!1)}setHoverStyle(e,t,r){this._setStyle(e,r,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,r=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const s=r.length,i=t.length,o=Math.min(i,s);o&&this.parse(0,o),i>s?this._insertElements(s,i-s,e):i<s&&this._removeElements(i,s-i)}_insertElements(e,t,r=!0){const s=this._cachedMeta,i=s.data,o=e+t;let a;const l=c=>{for(c.length+=t,a=c.length-1;a>=o;a--)c[a]=c[a-t]};for(l(i),a=e;a<o;++a)i[a]=new this.dataElementType;this._parsing&&l(s._parsed),this.parse(e,t),r&&this.updateElements(i,e,t,"reset")}updateElements(e,t,r,s){}_removeElements(e,t){const r=this._cachedMeta;if(this._parsing){const s=r._parsed.splice(e,t);r._stacked&&Zx(r,s)}r.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,r,s]=e;this[t](r,s)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const r=arguments.length-2;r&&this._sync(["_insertElements",e,r])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}Mt(_c,"defaults",{}),Mt(_c,"datasetElementType",null),Mt(_c,"dataElementType",null);function Kit(n,e){if(!n._cache.$bar){const t=n.getMatchingVisibleMetas(e);let r=[];for(let s=0,i=t.length;s<i;s++)r=r.concat(t[s].controller.getAllParsedValues(n));n._cache.$bar=vse(r.sort((s,i)=>s-i))}return n._cache.$bar}function Yit(n){const e=n.iScale,t=Kit(e,n.type);let r=e._length,s,i,o,a;const l=()=>{o===32767||o===-32768||(Ac(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,i=t.length;s<i;++s)o=e.getPixelForValue(t[s]),l();for(a=void 0,s=0,i=e.ticks.length;s<i;++s)o=e.getPixelForTick(s),l();return r}function Zit(n,e,t,r){const s=t.barThickness;let i,o;return Nr(s)?(i=e.min*t.categoryPercentage,o=t.barPercentage):(i=s*r,o=1),{chunk:i/r,ratio:o,start:e.pixels[n]-i/2}}function Jit(n,e,t,r){const s=e.pixels,i=s[n];let o=n>0?s[n-1]:null,a=n<s.length-1?s[n+1]:null;const l=t.categoryPercentage;o===null&&(o=i-(a===null?e.end-e.start:a-i)),a===null&&(a=i+i-o);const c=i-(i-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/r,ratio:t.barPercentage,start:c}}function Qit(n,e,t,r){const s=t.parse(n[0],r),i=t.parse(n[1],r),o=Math.min(s,i),a=Math.max(s,i);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),e[t.axis]=c,e._custom={barStart:l,barEnd:c,start:s,end:i,min:o,max:a}}function Use(n,e,t,r){return gs(n)?Qit(n,e,t,r):e[t.axis]=t.parse(n,r),e}function b5(n,e,t,r){const s=n.iScale,i=n.vScale,o=s.getLabels(),a=s===i,l=[];let c,u,h,f;for(c=t,u=t+r;c<u;++c)f=e[c],h={},h[s.axis]=a||s.parse(o[c],c),l.push(Use(f,h,i,c));return l}function U3(n){return n&&n.barStart!==void 0&&n.barEnd!==void 0}function eot(n,e,t){return n!==0?vh(n):(e.isHorizontal()?1:-1)*(e.min>=t?1:-1)}function tot(n){let e,t,r,s,i;return n.horizontal?(e=n.base>n.x,t="left",r="right"):(e=n.base<n.y,t="bottom",r="top"),e?(s="end",i="start"):(s="start",i="end"),{start:t,end:r,reverse:e,top:s,bottom:i}}function not(n,e,t,r){let s=e.borderSkipped;const i={};if(!s){n.borderSkipped=i;return}if(s===!0){n.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:o,end:a,reverse:l,top:c,bottom:u}=tot(n);s==="middle"&&t&&(n.enableBorderRadius=!0,(t._top||0)===r?s=c:(t._bottom||0)===r?s=u:(i[v5(u,o,a,l)]=!0,s=c)),i[v5(s,o,a,l)]=!0,n.borderSkipped=i}function v5(n,e,t,r){return r?(n=rot(n,e,t),n=w5(n,t,e)):n=w5(n,e,t),n}function rot(n,e,t){return n===e?t:n===t?e:n}function w5(n,e,t){return n==="start"?e:n==="end"?t:n}function sot(n,{inflateAmount:e},t){n.inflateAmount=e==="auto"?t===1?.33:0:e}class GE extends _c{parsePrimitiveData(e,t,r,s){return b5(e,t,r,s)}parseArrayData(e,t,r,s){return b5(e,t,r,s)}parseObjectData(e,t,r,s){const{iScale:i,vScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=i.axis==="x"?a:l,u=o.axis==="x"?a:l,h=[];let f,d,p,m;for(f=r,d=r+s;f<d;++f)m=t[f],p={},p[i.axis]=i.parse(bp(m,c),f),h.push(Use(bp(m,u),p,o,f));return h}updateRangeFromParsed(e,t,r,s){super.updateRangeFromParsed(e,t,r,s);const i=r._custom;i&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,i.min),e.max=Math.max(e.max,i.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:r,vScale:s}=t,i=this.getParsed(e),o=i._custom,a=U3(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(i[s.axis]);return{label:""+r.getLabelForValue(i[r.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const e=this._cachedMeta;e.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,r,s){const i=s==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),u=this._getRuler(),{sharedOptions:h,includeOptions:f}=this._getSharedOptions(t,s);for(let d=t;d<t+r;d++){const p=this.getParsed(d),m=i||Nr(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(d),g=this._calculateBarIndexPixels(d,u),y=(p._stacks||{})[a.axis],b={horizontal:c,base:m.base,enableBorderRadius:!y||U3(p._custom)||o===y._top||o===y._bottom,x:c?m.head:g.center,y:c?g.center:m.head,height:c?g.size:Math.abs(m.size),width:c?Math.abs(m.size):g.size};f&&(b.options=h||this.resolveDataElementOptions(d,e[d].active?"active":s));const x=b.options||e[d].options;not(b,x,y,o),sot(b,x,u.ratio),this.updateElement(e[d],d,b,s)}}_getStacks(e,t){const{iScale:r}=this._cachedMeta,s=r.getMatchingVisibleMetas(this._type).filter(l=>l.controller.options.grouped),i=r.options.stacked,o=[],a=l=>{const c=l.controller.getParsed(t),u=c&&c[l.vScale.axis];if(Nr(u)||isNaN(u))return!0};for(const l of s)if(!(t!==void 0&&a(l))&&((i===!1||o.indexOf(l.stack)===-1||i===void 0&&l.stack===void 0)&&o.push(l.stack),l.index===e))break;return o.length||o.push(void 0),o}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,t,r){const s=this._getStacks(e,r),i=t!==void 0?s.indexOf(t):-1;return i===-1?s.length-1:i}_getRuler(){const e=this.options,t=this._cachedMeta,r=t.iScale,s=[];let i,o;for(i=0,o=t.data.length;i<o;++i)s.push(r.getPixelForValue(this.getParsed(i)[r.axis],i));const a=e.barThickness;return{min:a||Yit(t),pixels:s,start:r._startPixel,end:r._endPixel,stackCount:this._getStackCount(),scale:r,grouped:e.grouped,ratio:a?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:r,index:s},options:{base:i,minBarLength:o}}=this,a=i||0,l=this.getParsed(e),c=l._custom,u=U3(c);let h=l[t.axis],f=0,d=r?this.applyStack(t,l,r):h,p,m;d!==h&&(f=d-h,d=h),u&&(h=c.barStart,d=c.barEnd-c.barStart,h!==0&&vh(h)!==vh(c.barEnd)&&(f=0),f+=h);const g=!Nr(i)&&!u?i:f;let y=t.getPixelForValue(g);if(this.chart.getDataVisibility(e)?p=t.getPixelForValue(f+d):p=y,m=p-y,Math.abs(m)<o){m=eot(m,t,a)*o,h===a&&(y-=m/2);const b=t.getPixelForDecimal(0),x=t.getPixelForDecimal(1),w=Math.min(b,x),S=Math.max(b,x);y=Math.max(Math.min(y,S),w),p=y+m,r&&!u&&(l._stacks[t.axis]._visualValues[s]=t.getValueForPixel(p)-t.getValueForPixel(y))}if(y===t.getPixelForValue(a)){const b=vh(m)*t.getLineWidthForValue(a)/2;y+=b,m-=b}return{size:m,base:y,head:p,center:p+m/2}}_calculateBarIndexPixels(e,t){const r=t.scale,s=this.options,i=s.skipNull,o=Un(s.maxBarThickness,1/0);let a,l;if(t.grouped){const c=i?this._getStackCount(e):t.stackCount,u=s.barThickness==="flex"?Jit(e,t,s,c):Zit(e,t,s,c),h=this._getStackIndex(this.index,this._cachedMeta.stack,i?e:void 0);a=u.start+u.chunk*h+u.chunk/2,l=Math.min(o,u.chunk*u.ratio)}else a=r.getPixelForValue(this.getParsed(e)[r.axis],e),l=Math.min(o,t.min*t.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const e=this._cachedMeta,t=e.vScale,r=e.data,s=r.length;let i=0;for(;i<s;++i)this.getParsed(i)[t.axis]!==null&&r[i].draw(this._ctx)}}Mt(GE,"id","bar"),Mt(GE,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),Mt(GE,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class HE extends _c{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,r,s){const i=super.parsePrimitiveData(e,t,r,s);for(let o=0;o<i.length;o++)i[o]._custom=this.resolveDataElementOptions(o+r).radius;return i}parseArrayData(e,t,r,s){const i=super.parseArrayData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Un(a[2],this.resolveDataElementOptions(o+r).radius)}return i}parseObjectData(e,t,r,s){const i=super.parseObjectData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Un(a&&a.r&&+a.r,this.resolveDataElementOptions(o+r).radius)}return i}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let r=e.length-1;r>=0;--r)t=Math.max(t,e[r].size(this.resolveDataElementOptions(r))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y),c=o._custom;return{label:r[e]||"",value:"("+a+", "+l+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:l,includeOptions:c}=this._getSharedOptions(t,s),u=o.axis,h=a.axis;for(let f=t;f<t+r;f++){const d=e[f],p=!i&&this.getParsed(f),m={},g=m[u]=i?o.getPixelForDecimal(.5):o.getPixelForValue(p[u]),y=m[h]=i?a.getBasePixel():a.getPixelForValue(p[h]);m.skip=isNaN(g)||isNaN(y),c&&(m.options=l||this.resolveDataElementOptions(f,d.active?"active":s),i&&(m.options.radius=0)),this.updateElement(d,f,m,s)}}resolveDataElementOptions(e,t){const r=this.getParsed(e);let s=super.resolveDataElementOptions(e,t);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const i=s.radius;return t!=="active"&&(s.radius=0),s.radius+=Un(r&&r._custom,i),s}}Mt(HE,"id","bubble"),Mt(HE,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),Mt(HE,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});function iot(n,e,t){let r=1,s=1,i=0,o=0;if(e<bs){const a=n,l=a+e,c=Math.cos(a),u=Math.sin(a),h=Math.cos(l),f=Math.sin(l),d=(x,w,S)=>tS(x,a,l,!0)?1:Math.max(w,w*t,S,S*t),p=(x,w,S)=>tS(x,a,l,!0)?-1:Math.min(w,w*t,S,S*t),m=d(0,c,h),g=d(Js,u,f),y=p(Ts,c,h),b=p(Ts+Js,u,f);r=(m-y)/2,s=(g-b)/2,i=-(m+y)/2,o=-(g+b)/2}return{ratioX:r,ratioY:s,offsetX:i,offsetY:o}}class kb extends _c{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const r=this.getDataset().data,s=this._cachedMeta;if(this._parsing===!1)s._parsed=r;else{let i=l=>+r[l];if(nr(r[e])){const{key:l="value"}=this._parsing;i=c=>+bp(r[c],l)}let o,a;for(o=e,a=e+t;o<a;++o)s._parsed[o]=i(o)}}_getRotation(){return fu(this.options.rotation-90)}_getCircumference(){return fu(this.options.circumference)}_getRotationExtents(){let e=bs,t=-bs;for(let r=0;r<this.chart.data.datasets.length;++r)if(this.chart.isDatasetVisible(r)&&this.chart.getDatasetMeta(r).type===this._type){const s=this.chart.getDatasetMeta(r).controller,i=s._getRotation(),o=s._getCircumference();e=Math.min(e,i),t=Math.max(t,i+o)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:r}=t,s=this._cachedMeta,i=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(i)+this.options.spacing,a=Math.max((Math.min(r.width,r.height)-o)/2,0),l=Math.min(vst(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:u,rotation:h}=this._getRotationExtents(),{ratioX:f,ratioY:d,offsetX:p,offsetY:m}=iot(h,u,l),g=(r.width-o)/f,y=(r.height-o)/d,b=Math.max(Math.min(g,y)/2,0),x=pse(this.options.radius,b),w=Math.max(x*l,0),S=(x-w)/this._getVisibleDatasetWeightTotal();this.offsetX=p*x,this.offsetY=m*x,s.total=this.calculateTotal(),this.outerRadius=x-S*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-S*c,0),this.updateElements(i,0,i.length,e)}_circumference(e,t){const r=this.options,s=this._cachedMeta,i=this._getCircumference();return t&&r.animation.animateRotate||!this.chart.getDataVisibility(e)||s._parsed[e]===null||s.data[e].hidden?0:this.calculateCircumference(s._parsed[e]*i/bs)}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,u=(a.left+a.right)/2,h=(a.top+a.bottom)/2,f=i&&c.animateScale,d=f?0:this.innerRadius,p=f?0:this.outerRadius,{sharedOptions:m,includeOptions:g}=this._getSharedOptions(t,s);let y=this._getRotation(),b;for(b=0;b<t;++b)y+=this._circumference(b,i);for(b=t;b<t+r;++b){const x=this._circumference(b,i),w=e[b],S={x:u+this.offsetX,y:h+this.offsetY,startAngle:y,endAngle:y+x,circumference:x,outerRadius:p,innerRadius:d};g&&(S.options=m||this.resolveDataElementOptions(b,w.active?"active":s)),y+=x,this.updateElement(w,b,S,s)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let r=0,s;for(s=0;s<t.length;s++){const i=e._parsed[s];i!==null&&!isNaN(i)&&this.chart.getDataVisibility(s)&&!t[s].hidden&&(r+=Math.abs(i))}return r}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?bs*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=PC(t._parsed[e],r.options.locale);return{label:s[e]||"",value:i}}getMaxBorderWidth(e){let t=0;const r=this.chart;let s,i,o,a,l;if(!e){for(s=0,i=r.data.datasets.length;s<i;++s)if(r.isDatasetVisible(s)){o=r.getDatasetMeta(s),e=o.data,a=o.controller;break}}if(!e)return 0;for(s=0,i=e.length;s<i;++s)l=a.resolveDataElementOptions(s),l.borderAlign!=="inner"&&(t=Math.max(t,l.borderWidth||0,l.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let r=0,s=e.length;r<s;++r){const i=this.resolveDataElementOptions(r);t=Math.max(t,i.offset||0,i.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let r=0;r<e;++r)this.chart.isDatasetVisible(r)&&(t+=this._getRingWeight(r));return t}_getRingWeight(e){return Math.max(Un(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}Mt(kb,"id","doughnut"),Mt(kb,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),Mt(kb,"descriptors",{_scriptable:e=>e!=="spacing",_indexable:e=>e!=="spacing"}),Mt(kb,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}}});class jE extends _c{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:r,data:s=[],_dataset:i}=t,o=this.chart._animationsDisabled;let{start:a,count:l}=_se(t,s,o);this._drawStart=a,this._drawCount=l,Sse(t)&&(a=0,l=s.length),r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!i._decimated,r.points=s;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(r,void 0,{animated:!o,options:c},e),this.updateElements(s,a,l,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,s),f=o.axis,d=a.axis,{spanGaps:p,segment:m}=this.options,g=uv(p)?p:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||i||s==="none",b=t+r,x=e.length;let w=t>0&&this.getParsed(t-1);for(let S=0;S<x;++S){const C=e[S],k=y?C:{};if(S<t||S>=b){k.skip=!0;continue}const A=this.getParsed(S),M=Nr(A[d]),E=k[f]=o.getPixelForValue(A[f],S),N=k[d]=i||M?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,A,l):A[d],S);k.skip=isNaN(E)||isNaN(N)||M,k.stop=S>0&&Math.abs(A[f]-w[f])>g,m&&(k.parsed=A,k.raw=c.data[S]),h&&(k.options=u||this.resolveDataElementOptions(S,C.active?"active":s)),y||this.updateElement(C,S,k,s),w=A}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,r=t.options&&t.options.borderWidth||0,s=e.data||[];if(!s.length)return r;const i=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(r,i,o)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}Mt(jE,"id","line"),Mt(jE,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),Mt(jE,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class qE extends _c{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=PC(t._parsed[e].r,r.options.locale);return{label:s[e]||"",value:i}}parseObjectData(e,t,r,s){return $se.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((r,s)=>{const i=this.getParsed(s).r;!isNaN(i)&&this.chart.getDataVisibility(s)&&(i<t.min&&(t.min=i),i>t.max&&(t.max=i))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,r=e.options,s=Math.min(t.right-t.left,t.bottom-t.top),i=Math.max(s/2,0),o=Math.max(r.cutoutPercentage?i/100*r.cutoutPercentage:1,0),a=(i-o)/e.getVisibleDatasetCount();this.outerRadius=i-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,l=o.options.animation,c=this._cachedMeta.rScale,u=c.xCenter,h=c.yCenter,f=c.getIndexAngle(0)-.5*Ts;let d=f,p;const m=360/this.countVisibleElements();for(p=0;p<t;++p)d+=this._computeAngle(p,s,m);for(p=t;p<t+r;p++){const g=e[p];let y=d,b=d+this._computeAngle(p,s,m),x=o.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;d=b,i&&(l.animateScale&&(x=0),l.animateRotate&&(y=b=f));const w={x:u,y:h,innerRadius:0,outerRadius:x,startAngle:y,endAngle:b,options:this.resolveDataElementOptions(p,g.active?"active":s)};this.updateElement(g,p,w,s)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((r,s)=>{!isNaN(this.getParsed(s).r)&&this.chart.getDataVisibility(s)&&t++}),t}_computeAngle(e,t,r){return this.chart.getDataVisibility(e)?fu(this.resolveDataElementOptions(e,t).angle||r):0}}Mt(qE,"id","polarArea"),Mt(qE,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),Mt(qE,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class aF extends kb{}Mt(aF,"id","pie"),Mt(aF,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class XE extends _c{getLabelAndValue(e){const t=this._cachedMeta.vScale,r=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(r[t.axis])}}parseObjectData(e,t,r,s){return $se.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta,r=t.dataset,s=t.data||[],i=t.iScale.getLabels();if(r.points=s,e!=="resize"){const o=this.resolveDatasetElementOptions(e);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:i.length===s.length,options:o};this.updateElement(r,void 0,a,e)}this.updateElements(s,0,s.length,e)}updateElements(e,t,r,s){const i=this._cachedMeta.rScale,o=s==="reset";for(let a=t;a<t+r;a++){const l=e[a],c=this.resolveDataElementOptions(a,l.active?"active":s),u=i.getPointPositionForValue(a,this.getParsed(a).r),h=o?i.xCenter:u.x,f=o?i.yCenter:u.y,d={x:h,y:f,angle:u.angle,skip:isNaN(h)||isNaN(f),options:c};this.updateElement(l,a,d,s)}}}Mt(XE,"id","radar"),Mt(XE,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),Mt(XE,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class KE extends _c{getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y);return{label:r[e]||"",value:"("+a+", "+l+")"}}update(e){const t=this._cachedMeta,{data:r=[]}=t,s=this.chart._animationsDisabled;let{start:i,count:o}=_se(t,r,s);if(this._drawStart=i,this._drawCount=o,Sse(t)&&(i=0,o=r.length),this.options.showLine){const{dataset:a,_dataset:l}=t;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=r;const c=this.resolveDatasetElementOptions(e);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!s,options:c},e)}this.updateElements(r,i,o,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,u=this.resolveDataElementOptions(t,s),h=this.getSharedOptions(u),f=this.includeOptions(s,h),d=o.axis,p=a.axis,{spanGaps:m,segment:g}=this.options,y=uv(m)?m:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||i||s==="none";let x=t>0&&this.getParsed(t-1);for(let w=t;w<t+r;++w){const S=e[w],C=this.getParsed(w),k=b?S:{},A=Nr(C[p]),M=k[d]=o.getPixelForValue(C[d],w),E=k[p]=i||A?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,C,l):C[p],w);k.skip=isNaN(M)||isNaN(E)||A,k.stop=w>0&&Math.abs(C[d]-x[d])>y,g&&(k.parsed=C,k.raw=c.data[w]),f&&(k.options=h||this.resolveDataElementOptions(w,S.active?"active":s)),b||this.updateElement(S,w,k,s),x=C}this.updateSharedOptions(h,s,u)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let a=0;for(let l=t.length-1;l>=0;--l)a=Math.max(a,t[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const r=e.dataset,s=r.options&&r.options.borderWidth||0;if(!t.length)return s;const i=t[0].size(this.resolveDataElementOptions(0)),o=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(s,i,o)/2}}Mt(KE,"id","scatter"),Mt(KE,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),Mt(KE,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function fm(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class U4{static override(e){Object.assign(U4.prototype,e)}constructor(e){this.options=e||{}}init(){}formats(){return fm()}parse(){return fm()}format(){return fm()}add(){return fm()}diff(){return fm()}startOf(){return fm()}endOf(){return fm()}}var Wse={_date:U4};function oot(n,e,t,r){const{controller:s,data:i,_sorted:o}=n,a=s._cachedMeta.iScale;if(a&&e===a.axis&&e!=="r"&&o&&i.length){const l=a._reversePixels?Nst:Hm;if(r){if(s._sharedOptions){const c=i[0],u=typeof c.getRange=="function"&&c.getRange(e);if(u){const h=l(i,e,t-u),f=l(i,e,t+u);return{lo:h.lo,hi:f.hi}}}}else return l(i,e,t)}return{lo:0,hi:i.length-1}}function DC(n,e,t,r,s){const i=n.getSortedVisibleDatasetMetas(),o=t[e];for(let a=0,l=i.length;a<l;++a){const{index:c,data:u}=i[a],{lo:h,hi:f}=oot(i[a],e,o,s);for(let d=h;d<=f;++d){const p=u[d];p.skip||r(p,c,d)}}}function aot(n){const e=n.indexOf("x")!==-1,t=n.indexOf("y")!==-1;return function(r,s){const i=e?Math.abs(r.x-s.x):0,o=t?Math.abs(r.y-s.y):0;return Math.sqrt(Math.pow(i,2)+Math.pow(o,2))}}function W3(n,e,t,r,s){const i=[];return!s&&!n.isPointInArea(e)||DC(n,t,e,function(a,l,c){!s&&!nS(a,n.chartArea,0)||a.inRange(e.x,e.y,r)&&i.push({element:a,datasetIndex:l,index:c})},!0),i}function lot(n,e,t,r){let s=[];function i(o,a,l){const{startAngle:c,endAngle:u}=o.getProps(["startAngle","endAngle"],r),{angle:h}=yse(o,{x:e.x,y:e.y});tS(h,c,u)&&s.push({element:o,datasetIndex:a,index:l})}return DC(n,t,e,i),s}function cot(n,e,t,r,s,i){let o=[];const a=aot(t);let l=Number.POSITIVE_INFINITY;function c(u,h,f){const d=u.inRange(e.x,e.y,s);if(r&&!d)return;const p=u.getCenterPoint(s);if(!(!!i||n.isPointInArea(p))&&!d)return;const g=a(e,p);g<l?(o=[{element:u,datasetIndex:h,index:f}],l=g):g===l&&o.push({element:u,datasetIndex:h,index:f})}return DC(n,t,e,c),o}function G3(n,e,t,r,s,i){return!i&&!n.isPointInArea(e)?[]:t==="r"&&!r?lot(n,e,t,s):cot(n,e,t,r,s,i)}function x5(n,e,t,r,s){const i=[],o=t==="x"?"inXRange":"inYRange";let a=!1;return DC(n,t,e,(l,c,u)=>{l[o](e[t],s)&&(i.push({element:l,datasetIndex:c,index:u}),a=a||l.inRange(e.x,e.y,s))}),r&&!a?[]:i}var uot={evaluateInteractionItems:DC,modes:{index(n,e,t,r){const s=Em(e,n),i=t.axis||"x",o=t.includeInvisible||!1,a=t.intersect?W3(n,s,i,r,o):G3(n,s,i,!1,r,o),l=[];return a.length?(n.getSortedVisibleDatasetMetas().forEach(c=>{const u=a[0].index,h=c.data[u];h&&!h.skip&&l.push({element:h,datasetIndex:c.index,index:u})}),l):[]},dataset(n,e,t,r){const s=Em(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;let a=t.intersect?W3(n,s,i,r,o):G3(n,s,i,!1,r,o);if(a.length>0){const l=a[0].datasetIndex,c=n.getDatasetMeta(l).data;a=[];for(let u=0;u<c.length;++u)a.push({element:c[u],datasetIndex:l,index:u})}return a},point(n,e,t,r){const s=Em(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return W3(n,s,i,r,o)},nearest(n,e,t,r){const s=Em(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return G3(n,s,i,t.intersect,r,o)},x(n,e,t,r){const s=Em(e,n);return x5(n,s,"x",t.intersect,r)},y(n,e,t,r){const s=Em(e,n);return x5(n,s,"y",t.intersect,r)}}};const Gse=["left","top","right","bottom"];function Jx(n,e){return n.filter(t=>t.pos===e)}function _5(n,e){return n.filter(t=>Gse.indexOf(t.pos)===-1&&t.box.axis===e)}function Qx(n,e){return n.sort((t,r)=>{const s=e?r:t,i=e?t:r;return s.weight===i.weight?s.index-i.index:s.weight-i.weight})}function hot(n){const e=[];let t,r,s,i,o,a;for(t=0,r=(n||[]).length;t<r;++t)s=n[t],{position:i,options:{stack:o,stackWeight:a=1}}=s,e.push({index:t,box:s,pos:i,horizontal:s.isHorizontal(),weight:s.weight,stack:o&&i+o,stackWeight:a});return e}function fot(n){const e={};for(const t of n){const{stack:r,pos:s,stackWeight:i}=t;if(!r||!Gse.includes(s))continue;const o=e[r]||(e[r]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=i}return e}function dot(n,e){const t=fot(n),{vBoxMaxWidth:r,hBoxMaxHeight:s}=e;let i,o,a;for(i=0,o=n.length;i<o;++i){a=n[i];const{fullSize:l}=a.box,c=t[a.stack],u=c&&a.stackWeight/c.weight;a.horizontal?(a.width=u?u*r:l&&e.availableWidth,a.height=s):(a.width=r,a.height=u?u*s:l&&e.availableHeight)}return t}function pot(n){const e=hot(n),t=Qx(e.filter(c=>c.box.fullSize),!0),r=Qx(Jx(e,"left"),!0),s=Qx(Jx(e,"right")),i=Qx(Jx(e,"top"),!0),o=Qx(Jx(e,"bottom")),a=_5(e,"x"),l=_5(e,"y");return{fullSize:t,leftAndTop:r.concat(i),rightAndBottom:s.concat(l).concat(o).concat(a),chartArea:Jx(e,"chartArea"),vertical:r.concat(s).concat(l),horizontal:i.concat(o).concat(a)}}function S5(n,e,t,r){return Math.max(n[t],e[t])+Math.max(n[r],e[r])}function Hse(n,e){n.top=Math.max(n.top,e.top),n.left=Math.max(n.left,e.left),n.bottom=Math.max(n.bottom,e.bottom),n.right=Math.max(n.right,e.right)}function mot(n,e,t,r){const{pos:s,box:i}=t,o=n.maxPadding;if(!nr(s)){t.size&&(n[s]-=t.size);const h=r[t.stack]||{size:0,count:1};h.size=Math.max(h.size,t.horizontal?i.height:i.width),t.size=h.size/h.count,n[s]+=t.size}i.getPadding&&Hse(o,i.getPadding());const a=Math.max(0,e.outerWidth-S5(o,n,"left","right")),l=Math.max(0,e.outerHeight-S5(o,n,"top","bottom")),c=a!==n.w,u=l!==n.h;return n.w=a,n.h=l,t.horizontal?{same:c,other:u}:{same:u,other:c}}function got(n){const e=n.maxPadding;function t(r){const s=Math.max(e[r]-n[r],0);return n[r]+=s,s}n.y+=t("top"),n.x+=t("left"),t("right"),t("bottom")}function yot(n,e){const t=e.maxPadding;function r(s){const i={left:0,top:0,right:0,bottom:0};return s.forEach(o=>{i[o]=Math.max(e[o],t[o])}),i}return r(n?["left","right"]:["top","bottom"])}function R1(n,e,t,r){const s=[];let i,o,a,l,c,u;for(i=0,o=n.length,c=0;i<o;++i){a=n[i],l=a.box,l.update(a.width||e.w,a.height||e.h,yot(a.horizontal,e));const{same:h,other:f}=mot(e,t,a,r);c|=h&&s.length,u=u||f,l.fullSize||s.push(a)}return c&&R1(s,e,t,r)||u}function xT(n,e,t,r,s){n.top=t,n.left=e,n.right=e+r,n.bottom=t+s,n.width=r,n.height=s}function C5(n,e,t,r){const s=t.padding;let{x:i,y:o}=e;for(const a of n){const l=a.box,c=r[a.stack]||{count:1,placed:0,weight:1},u=a.stackWeight/c.weight||1;if(a.horizontal){const h=e.w*u,f=c.size||l.height;Ac(c.start)&&(o=c.start),l.fullSize?xT(l,s.left,o,t.outerWidth-s.right-s.left,f):xT(l,e.left+c.placed,o,h,f),c.start=o,c.placed+=h,o=l.bottom}else{const h=e.h*u,f=c.size||l.width;Ac(c.start)&&(i=c.start),l.fullSize?xT(l,i,s.top,f,t.outerHeight-s.bottom-s.top):xT(l,i,e.top+c.placed,f,h),c.start=i,c.placed+=h,i=l.right}}e.x=i,e.y=o}var yc={addBox(n,e){n.boxes||(n.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},n.boxes.push(e)},removeBox(n,e){const t=n.boxes?n.boxes.indexOf(e):-1;t!==-1&&n.boxes.splice(t,1)},configure(n,e,t){e.fullSize=t.fullSize,e.position=t.position,e.weight=t.weight},update(n,e,t,r){if(!n)return;const s=Jo(n.options.layout.padding),i=Math.max(e-s.width,0),o=Math.max(t-s.height,0),a=pot(n.boxes),l=a.vertical,c=a.horizontal;Dr(n.boxes,m=>{typeof m.beforeLayout=="function"&&m.beforeLayout()});const u=l.reduce((m,g)=>g.box.options&&g.box.options.display===!1?m:m+1,0)||1,h=Object.freeze({outerWidth:e,outerHeight:t,padding:s,availableWidth:i,availableHeight:o,vBoxMaxWidth:i/2/u,hBoxMaxHeight:o/2}),f=Object.assign({},s);Hse(f,Jo(r));const d=Object.assign({maxPadding:f,w:i,h:o,x:s.left,y:s.top},s),p=dot(l.concat(c),h);R1(a.fullSize,d,h,p),R1(l,d,h,p),R1(c,d,h,p)&&R1(l,d,h,p),got(d),C5(a.leftAndTop,d,h,p),d.x+=d.w,d.y+=d.h,C5(a.rightAndBottom,d,h,p),n.chartArea={left:d.left,top:d.top,right:d.left+d.w,bottom:d.top+d.h,height:d.h,width:d.w},Dr(a.chartArea,m=>{const g=m.box;Object.assign(g,n.chartArea),g.update(d.w,d.h,{left:0,top:0,right:0,bottom:0})})}};class jse{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,r){}removeEventListener(e,t,r){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,r,s){return t=Math.max(0,t||e.width),r=r||e.height,{width:t,height:Math.max(0,s?Math.floor(t/s):r)}}isAttached(e){return!0}updateConfig(e){}}class bot extends jse{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const YE="$chartjs",vot={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},k5=n=>n===null||n==="";function wot(n,e){const t=n.style,r=n.getAttribute("height"),s=n.getAttribute("width");if(n[YE]={initial:{height:r,width:s,style:{display:t.display,height:t.height,width:t.width}}},t.display=t.display||"block",t.boxSizing=t.boxSizing||"border-box",k5(s)){const i=a5(n,"width");i!==void 0&&(n.width=i)}if(k5(r))if(n.style.height==="")n.height=n.width/(e||2);else{const i=a5(n,"height");i!==void 0&&(n.height=i)}return n}const qse=Cit?{passive:!0}:!1;function xot(n,e,t){n.addEventListener(e,t,qse)}function _ot(n,e,t){n.canvas.removeEventListener(e,t,qse)}function Sot(n,e){const t=vot[n.type]||n.type,{x:r,y:s}=Em(n,e);return{type:t,chart:e,native:n,x:r!==void 0?r:null,y:s!==void 0?s:null}}function gA(n,e){for(const t of n)if(t===e||t.contains(e))return!0}function Cot(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||gA(a.addedNodes,r),o=o&&!gA(a.removedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}function kot(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||gA(a.removedNodes,r),o=o&&!gA(a.addedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}const rS=new Map;let T5=0;function Xse(){const n=window.devicePixelRatio;n!==T5&&(T5=n,rS.forEach((e,t)=>{t.currentDevicePixelRatio!==n&&e()}))}function Tot(n,e){rS.size||window.addEventListener("resize",Xse),rS.set(n,e)}function Eot(n){rS.delete(n),rS.size||window.removeEventListener("resize",Xse)}function Iot(n,e,t){const r=n.canvas,s=r&&V4(r);if(!s)return;const i=xse((a,l)=>{const c=s.clientWidth;t(a,l),c<s.clientWidth&&t()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,u=l.contentRect.height;c===0&&u===0||i(c,u)});return o.observe(s),Tot(n,i),o}function H3(n,e,t){t&&t.disconnect(),e==="resize"&&Eot(n)}function Aot(n,e,t){const r=n.canvas,s=xse(i=>{n.ctx!==null&&t(Sot(i,n))},n);return xot(r,e,s),s}class Mot extends jse{acquireContext(e,t){const r=e&&e.getContext&&e.getContext("2d");return r&&r.canvas===e?(wot(e,t),r):null}releaseContext(e){const t=e.canvas;if(!t[YE])return!1;const r=t[YE].initial;["height","width"].forEach(i=>{const o=r[i];Nr(o)?t.removeAttribute(i):t.setAttribute(i,o)});const s=r.style||{};return Object.keys(s).forEach(i=>{t.style[i]=s[i]}),t.width=t.width,delete t[YE],!0}addEventListener(e,t,r){this.removeEventListener(e,t);const s=e.$proxies||(e.$proxies={}),o={attach:Cot,detach:kot,resize:Iot}[t]||Aot;s[t]=o(e,t,r)}removeEventListener(e,t){const r=e.$proxies||(e.$proxies={}),s=r[t];if(!s)return;({attach:H3,detach:H3,resize:H3}[t]||_ot)(e,t,s),r[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,r,s){return Sit(e,t,r,s)}isAttached(e){const t=V4(e);return!!(t&&t.isConnected)}}function Not(n){return!Pse()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?bot:Mot}class Mc{constructor(){Mt(this,"active",!1)}tooltipPosition(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}hasValue(){return uv(this.x)&&uv(this.y)}getProps(e,t){const r=this.$animations;if(!t||!r)return this;const s={};return e.forEach(i=>{s[i]=r[i]&&r[i].active()?r[i]._to:this[i]}),s}}Mt(Mc,"defaults",{}),Mt(Mc,"defaultRoutes");function $ot(n,e){const t=n.options.ticks,r=Rot(n),s=Math.min(t.maxTicksLimit||r,r),i=t.major.enabled?Dot(e):[],o=i.length,a=i[0],l=i[o-1],c=[];if(o>s)return Oot(e,c,i,o/s),c;const u=Pot(i,e,s);if(o>0){let h,f;const d=o>1?Math.round((l-a)/(o-1)):null;for(_T(e,c,u,Nr(d)?0:a-d,a),h=0,f=o-1;h<f;h++)_T(e,c,u,i[h],i[h+1]);return _T(e,c,u,l,Nr(d)?e.length:l+d),c}return _T(e,c,u),c}function Rot(n){const e=n.options.offset,t=n._tickSize(),r=n._length/t+(e?0:1),s=n._maxLength/t;return Math.floor(Math.min(r,s))}function Pot(n,e,t){const r=Fot(n),s=e.length/t;if(!r)return Math.max(s,1);const i=Est(r);for(let o=0,a=i.length-1;o<a;o++){const l=i[o];if(l>s)return l}return Math.max(s,1)}function Dot(n){const e=[];let t,r;for(t=0,r=n.length;t<r;t++)n[t].major&&e.push(t);return e}function Oot(n,e,t,r){let s=0,i=t[0],o;for(r=Math.ceil(r),o=0;o<n.length;o++)o===i&&(e.push(n[o]),s++,i=t[s*r])}function _T(n,e,t,r,s){const i=Un(r,0),o=Math.min(Un(s,n.length),n.length);let a=0,l,c,u;for(t=Math.ceil(t),s&&(l=s-r,t=l/Math.floor(l/t)),u=i;u<0;)a++,u=Math.round(i+a*t);for(c=Math.max(i,0);c<o;c++)c===u&&(e.push(n[c]),a++,u=Math.round(i+a*t))}function Fot(n){const e=n.length;let t,r;if(e<2)return!1;for(r=n[0],t=1;t<e;++t)if(n[t]-n[t-1]!==r)return!1;return r}const Lot=n=>n==="left"?"right":n==="right"?"left":n,E5=(n,e,t)=>e==="top"||e==="left"?n[e]+t:n[e]-t,I5=(n,e)=>Math.min(e||n,n);function A5(n,e){const t=[],r=n.length/e,s=n.length;let i=0;for(;i<s;i+=r)t.push(n[Math.floor(i)]);return t}function zot(n,e,t){const r=n.ticks.length,s=Math.min(e,r-1),i=n._startPixel,o=n._endPixel,a=1e-6;let l=n.getPixelForTick(s),c;if(!(t&&(r===1?c=Math.max(l-i,o-l):e===0?c=(n.getPixelForTick(1)-l)/2:c=(l-n.getPixelForTick(s-1))/2,l+=s<e?c:-c,l<i-a||l>o+a)))return l}function Bot(n,e){Dr(n,t=>{const r=t.gc,s=r.length/2;let i;if(s>e){for(i=0;i<s;++i)delete t.data[r[i]];r.splice(0,s)}})}function e1(n){return n.drawTicks?n.tickLength:0}function M5(n,e){if(!n.display)return 0;const t=Gi(n.font,e),r=Jo(n.padding);return(gs(n.text)?n.text.length:1)*t.lineHeight+r.height}function Vot(n,e){return Wp(n,{scale:e,type:"scale"})}function Uot(n,e,t){return Wp(n,{tick:t,index:e,type:"tick"})}function Wot(n,e,t){let r=O4(n);return(t&&e!=="right"||!t&&e==="right")&&(r=Lot(r)),r}function Got(n,e,t,r){const{top:s,left:i,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:u}=l;let h=0,f,d,p;const m=o-s,g=a-i;if(n.isHorizontal()){if(d=Lo(r,i,a),nr(t)){const y=Object.keys(t)[0],b=t[y];p=u[y].getPixelForValue(b)+m-e}else t==="center"?p=(c.bottom+c.top)/2+m-e:p=E5(n,t,e);f=a-i}else{if(nr(t)){const y=Object.keys(t)[0],b=t[y];d=u[y].getPixelForValue(b)-g+e}else t==="center"?d=(c.left+c.right)/2-g+e:d=E5(n,t,e);p=Lo(r,o,s),h=t==="left"?-Js:Js}return{titleX:d,titleY:p,maxWidth:f,rotation:h}}class e0 extends Mc{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:r,_suggestedMax:s}=this;return e=gl(e,Number.POSITIVE_INFINITY),t=gl(t,Number.NEGATIVE_INFINITY),r=gl(r,Number.POSITIVE_INFINITY),s=gl(s,Number.NEGATIVE_INFINITY),{min:gl(e,r),max:gl(t,s),minDefined:Zs(e),maxDefined:Zs(t)}}getMinMax(e){let{min:t,max:r,minDefined:s,maxDefined:i}=this.getUserBounds(),o;if(s&&i)return{min:t,max:r};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,e),s||(t=Math.min(t,o.min)),i||(r=Math.max(r,o.max));return t=i&&t>r?r:t,r=s&&t>r?t:r,{min:gl(t,gl(r,t)),max:gl(r,gl(t,r))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(e=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){is(this.options.beforeUpdate,[this])}update(e,t,r){const{beginAtZero:s,grace:i,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=r=Object.assign({left:0,right:0,top:0,bottom:0},r),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+r.left+r.right:this.height+r.top+r.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=tit(this,i,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?A5(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=$ot(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e=this.options.reverse,t,r;this.isHorizontal()?(t=this.left,r=this.right):(t=this.top,r=this.bottom,e=!e),this._startPixel=t,this._endPixel=r,this._reversePixels=e,this._length=r-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){is(this.options.afterUpdate,[this])}beforeSetDimensions(){is(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){is(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),is(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){is(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let r,s,i;for(r=0,s=e.length;r<s;r++)i=e[r],i.label=is(t.callback,[i.value,r,e],this)}afterTickToLabelConversion(){is(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){is(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,r=I5(this.ticks.length,e.ticks.maxTicksLimit),s=t.minRotation||0,i=t.maxRotation;let o=s,a,l,c;if(!this._isVisible()||!t.display||s>=i||r<=1||!this.isHorizontal()){this.labelRotation=s;return}const u=this._getLabelSizes(),h=u.widest.width,f=u.highest.height,d=Xo(this.chart.width-h,0,this.maxWidth);a=e.offset?this.maxWidth/r:d/(r-1),h+6>a&&(a=d/(r-(e.offset?.5:1)),l=this.maxHeight-e1(e.grid)-t.padding-M5(e.title,this.chart.options.font),c=Math.sqrt(h*h+f*f),o=P4(Math.min(Math.asin(Xo((u.highest.height+6)/a,-1,1)),Math.asin(Xo(l/c,-1,1))-Math.asin(Xo(f/c,-1,1)))),o=Math.max(s,Math.min(i,o))),this.labelRotation=o}afterCalculateLabelRotation(){is(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){is(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:r,title:s,grid:i}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=M5(s,t.options.font);if(a?(e.width=this.maxWidth,e.height=e1(i)+l):(e.height=this.maxHeight,e.width=e1(i)+l),r.display&&this.ticks.length){const{first:c,last:u,widest:h,highest:f}=this._getLabelSizes(),d=r.padding*2,p=fu(this.labelRotation),m=Math.cos(p),g=Math.sin(p);if(a){const y=r.mirror?0:g*h.width+m*f.height;e.height=Math.min(this.maxHeight,e.height+y+d)}else{const y=r.mirror?0:m*h.width+g*f.height;e.width=Math.min(this.maxWidth,e.width+y+d)}this._calculatePadding(c,u,g,m)}}this._handleMargins(),a?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,r,s){const{ticks:{align:i,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const u=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let f=0,d=0;l?c?(f=s*e.width,d=r*t.height):(f=r*e.height,d=s*t.width):i==="start"?d=t.width:i==="end"?f=e.width:i!=="inner"&&(f=e.width/2,d=t.width/2),this.paddingLeft=Math.max((f-u+o)*this.width/(this.width-u),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let u=t.height/2,h=e.height/2;i==="start"?(u=0,h=e.height):i==="end"&&(u=t.height,h=0),this.paddingTop=u+o,this.paddingBottom=h+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){is(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return t==="top"||t==="bottom"||e==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){this.beforeTickToLabelConversion(),this.generateTickLabels(e);let t,r;for(t=0,r=e.length;t<r;t++)Nr(e[t].label)&&(e.splice(t,1),r--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let r=this.ticks;t<r.length&&(r=A5(r,t)),this._labelSizes=e=this._computeLabelSizes(r,r.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,r){const{ctx:s,_longestTextCache:i}=this,o=[],a=[],l=Math.floor(t/I5(t,r));let c=0,u=0,h,f,d,p,m,g,y,b,x,w,S;for(h=0;h<t;h+=l){if(p=e[h].label,m=this._resolveTickFontOptions(h),s.font=g=m.string,y=i[g]=i[g]||{data:{},gc:[]},b=m.lineHeight,x=w=0,!Nr(p)&&!gs(p))x=pA(s,y.data,y.gc,x,p),w=b;else if(gs(p))for(f=0,d=p.length;f<d;++f)S=p[f],!Nr(S)&&!gs(S)&&(x=pA(s,y.data,y.gc,x,S),w+=b);o.push(x),a.push(w),c=Math.max(x,c),u=Math.max(w,u)}Bot(i,t);const C=o.indexOf(c),k=a.indexOf(u),A=M=>({width:o[M]||0,height:a[M]||0});return{first:A(0),last:A(t-1),widest:A(C),highest:A(k),widths:o,heights:a}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return Mst(this._alignToPixels?hm(this.chart,t,0):t)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const r=t[e];return r.$context||(r.$context=Uot(this.getContext(),e,r))}return this.$context||(this.$context=Vot(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=fu(this.labelRotation),r=Math.abs(Math.cos(t)),s=Math.abs(Math.sin(t)),i=this._getLabelSizes(),o=e.autoSkipPadding||0,a=i?i.widest.width+o:0,l=i?i.highest.height+o:0;return this.isHorizontal()?l*r>a*s?a/r:l/s:l*s<a*r?l/r:a/s}_isVisible(){const e=this.options.display;return e!=="auto"?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,r=this.chart,s=this.options,{grid:i,position:o,border:a}=s,l=i.offset,c=this.isHorizontal(),h=this.ticks.length+(l?1:0),f=e1(i),d=[],p=a.setContext(this.getContext()),m=p.display?p.width:0,g=m/2,y=function(B){return hm(r,B,m)};let b,x,w,S,C,k,A,M,E,N,O,R;if(o==="top")b=y(this.bottom),k=this.bottom-f,M=b-g,N=y(e.top)+g,R=e.bottom;else if(o==="bottom")b=y(this.top),N=e.top,R=y(e.bottom)-g,k=b+g,M=this.top+f;else if(o==="left")b=y(this.right),C=this.right-f,A=b-g,E=y(e.left)+g,O=e.right;else if(o==="right")b=y(this.left),E=e.left,O=y(e.right)-g,C=b+g,A=this.left+f;else if(t==="x"){if(o==="center")b=y((e.top+e.bottom)/2+.5);else if(nr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}N=e.top,R=e.bottom,k=b+g,M=k+f}else if(t==="y"){if(o==="center")b=y((e.left+e.right)/2);else if(nr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}C=b-g,A=C-f,E=e.left,O=e.right}const D=Un(s.ticks.maxTicksLimit,h),z=Math.max(1,Math.ceil(h/D));for(x=0;x<h;x+=z){const B=this.getContext(x),X=i.setContext(B),G=a.setContext(B),te=X.lineWidth,ge=X.color,ae=G.dash||[],Ne=G.dashOffset,ke=X.tickWidth,De=X.tickColor,be=X.tickBorderDash||[],Xe=X.tickBorderDashOffset;w=zot(this,x,l),w!==void 0&&(S=hm(r,w,te),c?C=A=E=O=S:k=M=N=R=S,d.push({tx1:C,ty1:k,tx2:A,ty2:M,x1:E,y1:N,x2:O,y2:R,width:te,color:ge,borderDash:ae,borderDashOffset:Ne,tickWidth:ke,tickColor:De,tickBorderDash:be,tickBorderDashOffset:Xe}))}return this._ticksLength=h,this._borderValue=b,d}_computeLabelItems(e){const t=this.axis,r=this.options,{position:s,ticks:i}=r,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:u,mirror:h}=i,f=e1(r.grid),d=f+u,p=h?-u:d,m=-fu(this.labelRotation),g=[];let y,b,x,w,S,C,k,A,M,E,N,O,R="middle";if(s==="top")C=this.bottom-p,k=this._getXAxisLabelAlignment();else if(s==="bottom")C=this.top+p,k=this._getXAxisLabelAlignment();else if(s==="left"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(s==="right"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(t==="x"){if(s==="center")C=(e.top+e.bottom)/2+d;else if(nr(s)){const z=Object.keys(s)[0],B=s[z];C=this.chart.scales[z].getPixelForValue(B)+d}k=this._getXAxisLabelAlignment()}else if(t==="y"){if(s==="center")S=(e.left+e.right)/2-d;else if(nr(s)){const z=Object.keys(s)[0],B=s[z];S=this.chart.scales[z].getPixelForValue(B)}k=this._getYAxisLabelAlignment(f).textAlign}t==="y"&&(l==="start"?R="top":l==="end"&&(R="bottom"));const D=this._getLabelSizes();for(y=0,b=a.length;y<b;++y){x=a[y],w=x.label;const z=i.setContext(this.getContext(y));A=this.getPixelForTick(y)+i.labelOffset,M=this._resolveTickFontOptions(y),E=M.lineHeight,N=gs(w)?w.length:1;const B=N/2,X=z.color,G=z.textStrokeColor,te=z.textStrokeWidth;let ge=k;o?(S=A,k==="inner"&&(y===b-1?ge=this.options.reverse?"left":"right":y===0?ge=this.options.reverse?"right":"left":ge="center"),s==="top"?c==="near"||m!==0?O=-N*E+E/2:c==="center"?O=-D.highest.height/2-B*E+E:O=-D.highest.height+E/2:c==="near"||m!==0?O=E/2:c==="center"?O=D.highest.height/2-B*E:O=D.highest.height-N*E,h&&(O*=-1),m!==0&&!z.showLabelBackdrop&&(S+=E/2*Math.sin(m))):(C=A,O=(1-N)*E/2);let ae;if(z.showLabelBackdrop){const Ne=Jo(z.backdropPadding),ke=D.heights[y],De=D.widths[y];let be=O-Ne.top,Xe=0-Ne.left;switch(R){case"middle":be-=ke/2;break;case"bottom":be-=ke;break}switch(k){case"center":Xe-=De/2;break;case"right":Xe-=De;break}ae={left:Xe,top:be,width:De+Ne.width,height:ke+Ne.height,color:z.backdropColor}}g.push({label:w,font:M,textOffset:O,options:{rotation:m,color:X,strokeColor:G,strokeWidth:te,textAlign:ge,textBaseline:R,translation:[S,C],backdrop:ae}})}return g}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-fu(this.labelRotation))return e==="top"?"left":"right";let s="center";return t.align==="start"?s="left":t.align==="end"?s="right":t.align==="inner"&&(s="inner"),s}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:r,mirror:s,padding:i}}=this.options,o=this._getLabelSizes(),a=e+i,l=o.widest.width;let c,u;return t==="left"?s?(u=this.right+i,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u+=l)):(u=this.right-a,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u=this.left)):t==="right"?s?(u=this.left+i,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u-=l)):(u=this.left+a,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u=this.right)):c="right",{textAlign:c,x:u}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;if(t==="left"||t==="right")return{top:0,left:this.left,bottom:e.height,right:this.right};if(t==="top"||t==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:e.width}}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:r,top:s,width:i,height:o}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(r,s,i,o),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const s=this.ticks.findIndex(i=>i.value===e);return s>=0?t.setContext(this.getContext(s)).lineWidth:0}drawGrid(e){const t=this.options.grid,r=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let i,o;const a=(l,c,u)=>{!u.width||!u.color||(r.save(),r.lineWidth=u.width,r.strokeStyle=u.color,r.setLineDash(u.borderDash||[]),r.lineDashOffset=u.borderDashOffset,r.beginPath(),r.moveTo(l.x,l.y),r.lineTo(c.x,c.y),r.stroke(),r.restore())};if(t.display)for(i=0,o=s.length;i<o;++i){const l=s[i];t.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),t.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:r,grid:s}}=this,i=r.setContext(this.getContext()),o=r.display?i.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,l=this._borderValue;let c,u,h,f;this.isHorizontal()?(c=hm(e,this.left,o)-o/2,u=hm(e,this.right,a)+a/2,h=f=l):(h=hm(e,this.top,o)-o/2,f=hm(e,this.bottom,a)+a/2,c=u=l),t.save(),t.lineWidth=i.width,t.strokeStyle=i.color,t.beginPath(),t.moveTo(c,h),t.lineTo(u,f),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const r=this.ctx,s=this._computeLabelArea();s&&x$(r,s);const i=this.getLabelItems(e);for(const o of i){const a=o.options,l=o.font,c=o.label,u=o.textOffset;_g(r,c,0,u,l,a)}s&&_$(r)}drawTitle(){const{ctx:e,options:{position:t,title:r,reverse:s}}=this;if(!r.display)return;const i=Gi(r.font),o=Jo(r.padding),a=r.align;let l=i.lineHeight/2;t==="bottom"||t==="center"||nr(t)?(l+=o.bottom,gs(r.text)&&(l+=i.lineHeight*(r.text.length-1))):l+=o.top;const{titleX:c,titleY:u,maxWidth:h,rotation:f}=Got(this,l,t,a);_g(e,r.text,0,0,i,{color:r.color,maxWidth:h,rotation:f,textAlign:Wot(a,t,s),textBaseline:"middle",translation:[c,u]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,r=Un(e.grid&&e.grid.z,-1),s=Un(e.border&&e.border.z,0);return!this._isVisible()||this.draw!==e0.prototype.draw?[{z:t,draw:i=>{this.draw(i)}}]:[{z:r,draw:i=>{this.drawBackground(),this.drawGrid(i),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:t,draw:i=>{this.drawLabels(i)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),r=this.axis+"AxisID",s=[];let i,o;for(i=0,o=t.length;i<o;++i){const a=t[i];a[r]===this.id&&(!e||a.type===e)&&s.push(a)}return s}_resolveTickFontOptions(e){const t=this.options.ticks.setContext(this.getContext(e));return Gi(t.font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class ST{constructor(e,t,r){this.type=e,this.scope=t,this.override=r,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let r;qot(t)&&(r=this.register(t));const s=this.items,i=e.id,o=this.scope+"."+i;if(!i)throw new Error("class does not have id: "+e);return i in s||(s[i]=e,Hot(e,o,r),this.override&&ai.override(e.id,e.overrides)),o}get(e){return this.items[e]}unregister(e){const t=this.items,r=e.id,s=this.scope;r in t&&delete t[r],s&&r in ai[s]&&(delete ai[s][r],this.override&&delete xg[r])}}function Hot(n,e,t){const r=eS(Object.create(null),[t?ai.get(t):{},ai.get(e),n.defaults]);ai.set(e,r),n.defaultRoutes&&jot(e,n.defaultRoutes),n.descriptors&&ai.describe(e,n.descriptors)}function jot(n,e){Object.keys(e).forEach(t=>{const r=t.split("."),s=r.pop(),i=[n].concat(r).join("."),o=e[t].split("."),a=o.pop(),l=o.join(".");ai.route(i,s,l,a)})}function qot(n){return"id"in n&&"defaults"in n}class Xot{constructor(){this.controllers=new ST(_c,"datasets",!0),this.elements=new ST(Mc,"elements"),this.plugins=new ST(Object,"plugins"),this.scales=new ST(e0,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...e){this._each("register",e)}remove(...e){this._each("unregister",e)}addControllers(...e){this._each("register",e,this.controllers)}addElements(...e){this._each("register",e,this.elements)}addPlugins(...e){this._each("register",e,this.plugins)}addScales(...e){this._each("register",e,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(...e){this._each("unregister",e,this.controllers)}removeElements(...e){this._each("unregister",e,this.elements)}removePlugins(...e){this._each("unregister",e,this.plugins)}removeScales(...e){this._each("unregister",e,this.scales)}_each(e,t,r){[...t].forEach(s=>{const i=r||this._getRegistryForType(s);r||i.isForType(s)||i===this.plugins&&s.id?this._exec(e,i,s):Dr(s,o=>{const a=r||this._getRegistryForType(o);this._exec(e,a,o)})})}_exec(e,t,r){const s=R4(e);is(r["before"+s],[],r),t[e](r),is(r["after"+s],[],r)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const r=this._typedRegistries[t];if(r.isForType(e))return r}return this.plugins}_get(e,t,r){const s=t.get(e);if(s===void 0)throw new Error('"'+e+'" is not a registered '+r+".");return s}}var sh=new Xot;class Kot{constructor(){this._init=[]}notify(e,t,r,s){t==="beforeInit"&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install"));const i=s?this._descriptors(e).filter(s):this._descriptors(e),o=this._notify(i,e,t,r);return t==="afterDestroy"&&(this._notify(i,e,"stop"),this._notify(this._init,e,"uninstall")),o}_notify(e,t,r,s){s=s||{};for(const i of e){const o=i.plugin,a=o[r],l=[t,s,i.options];if(is(a,l,o)===!1&&s.cancelable)return!1}return!0}invalidate(){Nr(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const r=e&&e.config,s=Un(r.options&&r.options.plugins,{}),i=Yot(r);return s===!1&&!t?[]:Jot(e,i,s,t)}_notifyStateChanges(e){const t=this._oldCache||[],r=this._cache,s=(i,o)=>i.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(s(t,r),e,"stop"),this._notify(s(r,t),e,"start")}}function Yot(n){const e={},t=[],r=Object.keys(sh.plugins.items);for(let i=0;i<r.length;i++)t.push(sh.getPlugin(r[i]));const s=n.plugins||[];for(let i=0;i<s.length;i++){const o=s[i];t.indexOf(o)===-1&&(t.push(o),e[o.id]=!0)}return{plugins:t,localIds:e}}function Zot(n,e){return!e&&n===!1?null:n===!0?{}:n}function Jot(n,{plugins:e,localIds:t},r,s){const i=[],o=n.getContext();for(const a of e){const l=a.id,c=Zot(r[l],s);c!==null&&i.push({plugin:a,options:Qot(n.config,{plugin:a,local:t[l]},c,o)})}return i}function Qot(n,{plugin:e,local:t},r,s){const i=n.pluginScopeKeys(e),o=n.getOptionScopes(r,i);return t&&e.defaults&&o.push(e.defaults),n.createResolver(o,s,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function lF(n,e){const t=ai.datasets[n]||{};return((e.datasets||{})[n]||{}).indexAxis||e.indexAxis||t.indexAxis||"x"}function eat(n,e){let t=n;return n==="_index_"?t=e:n==="_value_"&&(t=e==="x"?"y":"x"),t}function tat(n,e){return n===e?"_index_":"_value_"}function nat(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function yA(n,e){if(n==="x"||n==="y"||n==="r"||(n=e.axis||nat(e.position)||n.length>1&&yA(n[0].toLowerCase(),e),n))return n;throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`)}function rat(n,e){const t=xg[n.type]||{scales:{}},r=e.scales||{},s=lF(n.type,e),i=Object.create(null);return Object.keys(r).forEach(o=>{const a=r[o];if(!nr(a))return console.error(`Invalid scale configuration for scale: ${o}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${o}`);const l=yA(o,a),c=tat(l,s),u=t.scales||{};i[o]=n_(Object.create(null),[{axis:l},a,u[l],u[c]])}),n.data.datasets.forEach(o=>{const a=o.type||n.type,l=o.indexAxis||lF(a,e),u=(xg[a]||{}).scales||{};Object.keys(u).forEach(h=>{const f=eat(h,l),d=o[f+"AxisID"]||f;i[d]=i[d]||Object.create(null),n_(i[d],[{axis:f},r[d],u[h]])})}),Object.keys(i).forEach(o=>{const a=i[o];n_(a,[ai.scales[a.type],ai.scale])}),i}function Kse(n){const e=n.options||(n.options={});e.plugins=Un(e.plugins,{}),e.scales=rat(n,e)}function Yse(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function sat(n){return n=n||{},n.data=Yse(n.data),Kse(n),n}const N5=new Map,Zse=new Set;function CT(n,e){let t=N5.get(n);return t||(t=e(),N5.set(n,t),Zse.add(t)),t}const t1=(n,e,t)=>{const r=bp(e,t);r!==void 0&&n.add(r)};class iat{constructor(e){this._config=sat(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=Yse(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),Kse(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return CT(e,()=>[[`datasets.${e}`,""]])}datasetAnimationScopeKeys(e,t){return CT(`${e}.transition.${t}`,()=>[[`datasets.${e}.transitions.${t}`,`transitions.${t}`],[`datasets.${e}`,""]])}datasetElementScopeKeys(e,t){return CT(`${e}-${t}`,()=>[[`datasets.${e}.elements.${t}`,`datasets.${e}`,`elements.${t}`,""]])}pluginScopeKeys(e){const t=e.id,r=this.type;return CT(`${r}-plugin-${t}`,()=>[[`plugins.${t}`,...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const r=this._scopeCache;let s=r.get(e);return(!s||t)&&(s=new Map,r.set(e,s)),s}getOptionScopes(e,t,r){const{options:s,type:i}=this,o=this._cachedScopes(e,r),a=o.get(t);if(a)return a;const l=new Set;t.forEach(u=>{e&&(l.add(e),u.forEach(h=>t1(l,e,h))),u.forEach(h=>t1(l,s,h)),u.forEach(h=>t1(l,xg[i]||{},h)),u.forEach(h=>t1(l,ai,h)),u.forEach(h=>t1(l,iF,h))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Zse.has(t)&&o.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,xg[t]||{},ai.datasets[t]||{},{type:t},ai,iF]}resolveNamedOptions(e,t,r,s=[""]){const i={$shared:!0},{resolver:o,subPrefixes:a}=$5(this._resolverCache,e,s);let l=o;if(aat(o,t)){i.$shared=!1,r=vp(r)?r():r;const c=this.createResolver(e,r,a);l=hv(o,r,c)}for(const c of t)i[c]=l[c];return i}createResolver(e,t,r=[""],s){const{resolver:i}=$5(this._resolverCache,e,r);return nr(t)?hv(i,t,void 0,s):i}}function $5(n,e,t){let r=n.get(e);r||(r=new Map,n.set(e,r));const s=t.join();let i=r.get(s);return i||(i={resolver:L4(e,t),subPrefixes:t.filter(a=>!a.toLowerCase().includes("hover"))},r.set(s,i)),i}const oat=n=>nr(n)&&Object.getOwnPropertyNames(n).reduce((e,t)=>e||vp(n[t]),!1);function aat(n,e){const{isScriptable:t,isIndexable:r}=Ise(n);for(const s of e){const i=t(s),o=r(s),a=(o||i)&&n[s];if(i&&(vp(a)||oat(a))||o&&gs(a))return!0}return!1}var lat="4.2.1";const cat=["top","bottom","left","right","chartArea"];function R5(n,e){return n==="top"||n==="bottom"||cat.indexOf(n)===-1&&e==="x"}function P5(n,e){return function(t,r){return t[n]===r[n]?t[e]-r[e]:t[n]-r[n]}}function D5(n){const e=n.chart,t=e.options.animation;e.notifyPlugins("afterRender"),is(t&&t.onComplete,[n],e)}function uat(n){const e=n.chart,t=e.options.animation;is(t&&t.onProgress,[n],e)}function Jse(n){return Pse()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const ZE={},O5=n=>{const e=Jse(n);return Object.values(ZE).filter(t=>t.canvas===e).pop()};function hat(n,e,t){const r=Object.keys(n);for(const s of r){const i=+s;if(i>=e){const o=n[s];delete n[s],(t>0||i>e)&&(n[i+t]=o)}}}function fat(n,e,t,r){return!t||n.type==="mouseout"?null:r?e:n}function dat(n){const{xScale:e,yScale:t}=n;if(e&&t)return{left:e.left,right:e.right,top:t.top,bottom:t.bottom}}class iu{static register(...e){sh.add(...e),F5()}static unregister(...e){sh.remove(...e),F5()}constructor(e,t){const r=this.config=new iat(t),s=Jse(e),i=O5(s);if(i)throw new Error("Canvas is already in use. Chart with ID '"+i.id+"' must be destroyed before the canvas with ID '"+i.canvas.id+"' can be reused.");const o=r.createResolver(r.chartOptionScopes(),this.getContext());this.platform=new(r.platform||Not(s)),this.platform.updateConfig(r);const a=this.platform.acquireContext(s,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,u=l&&l.width;if(this.id=bst(),this.ctx=a,this.canvas=l,this.width=u,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Kot,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=Pst(h=>this.update(h),o.resizeDelay||0),this._dataChanges=[],ZE[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}pf.listen(this,"complete",D5),pf.listen(this,"progress",uat),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:r,height:s,_aspectRatio:i}=this;return Nr(e)?t&&i?i:s?r/s:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return sh}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():o5(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return r5(this.canvas,this.ctx),this}stop(){return pf.stop(this),this}resize(e,t){pf.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const r=this.options,s=this.canvas,i=r.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,e,t,i),a=r.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,o5(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),is(r.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const t=this.options.scales||{};Dr(t,(r,s)=>{r.id=s})}buildOrUpdateScales(){const e=this.options,t=e.scales,r=this.scales,s=Object.keys(r).reduce((o,a)=>(o[a]=!1,o),{});let i=[];t&&(i=i.concat(Object.keys(t).map(o=>{const a=t[o],l=yA(o,a),c=l==="r",u=l==="x";return{options:a,dposition:c?"chartArea":u?"bottom":"left",dtype:c?"radialLinear":u?"category":"linear"}}))),Dr(i,o=>{const a=o.options,l=a.id,c=yA(l,a),u=Un(a.type,o.dtype);(a.position===void 0||R5(a.position,c)!==R5(o.dposition))&&(a.position=o.dposition),s[l]=!0;let h=null;if(l in r&&r[l].type===u)h=r[l];else{const f=sh.getScale(u);h=new f({id:l,type:u,ctx:this.ctx,chart:this}),r[h.id]=h}h.init(a,e)}),Dr(s,(o,a)=>{o||delete r[a]}),Dr(r,o=>{yc.configure(this,o,o.options),yc.addBox(this,o)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,r=e.length;if(e.sort((s,i)=>s.index-i.index),r>t){for(let s=t;s<r;++s)this._destroyDatasetMeta(s);e.splice(t,r-t)}this._sortedMetasets=e.slice(0).sort(P5("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((r,s)=>{t.filter(i=>i===r._dataset).length===0&&this._destroyDatasetMeta(s)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let r,s;for(this._removeUnreferencedMetasets(),r=0,s=t.length;r<s;r++){const i=t[r];let o=this.getDatasetMeta(r);const a=i.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(r),o=this.getDatasetMeta(r)),o.type=a,o.indexAxis=i.indexAxis||lF(a,this.options),o.order=i.order||0,o.index=r,o.label=""+i.label,o.visible=this.isDatasetVisible(r),o.controller)o.controller.updateIndex(r),o.controller.linkScales();else{const l=sh.getController(a),{datasetElementType:c,dataElementType:u}=ai.datasets[a];Object.assign(l,{dataElementType:sh.getElement(u),datasetElementType:c&&sh.getElement(c)}),o.controller=new l(this,r),e.push(o.controller)}}return this._updateMetasets(),e}_resetElements(){Dr(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const r=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!r.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0})===!1)return;const i=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,u=this.data.datasets.length;c<u;c++){const{controller:h}=this.getDatasetMeta(c),f=!s&&i.indexOf(h)===-1;h.buildOrUpdateElements(f),o=Math.max(+h.getMaxOverflow(),o)}o=this._minPadding=r.layout.autoPadding?o:0,this._updateLayout(o),s||Dr(i,c=>{c.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(P5("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Dr(this.scales,e=>{yc.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),r=new Set(e.events);(!X6(t,r)||!!this._responsiveListeners!==e.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:r,start:s,count:i}of t){const o=r==="_removeElements"?-i:i;hat(e,s,o)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,r=i=>new Set(e.filter(o=>o[0]===i).map((o,a)=>a+","+o.splice(1).join(","))),s=r(0);for(let i=1;i<t;i++)if(!X6(s,r(i)))return;return Array.from(s).map(i=>i.split(",")).map(i=>({method:i[1],start:+i[2],count:+i[3]}))}_updateLayout(e){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;yc.update(this,this.width,this.height,e);const t=this.chartArea,r=t.width<=0||t.height<=0;this._layers=[],Dr(this.boxes,s=>{r&&s.position==="chartArea"||(s.configure&&s.configure(),this._layers.push(...s._layers()))},this),this._layers.forEach((s,i)=>{s._idx=i}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})!==!1){for(let t=0,r=this.data.datasets.length;t<r;++t)this.getDatasetMeta(t).controller.configure();for(let t=0,r=this.data.datasets.length;t<r;++t)this._updateDataset(t,vp(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const r=this.getDatasetMeta(e),s={meta:r,index:e,mode:t,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",s)!==!1&&(r.controller._update(t),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(pf.has(this)?this.attached&&!pf.running(this)&&pf.start(this):(this.draw(),D5({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:r,height:s}=this._resizeBeforeDraw;this._resize(r,s),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,r=[];let s,i;for(s=0,i=t.length;s<i;++s){const o=t[s];(!e||o.visible)&&r.push(o)}return r}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,r=e._clip,s=!r.disabled,i=dat(e)||this.chartArea,o={meta:e,index:e.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",o)!==!1&&(s&&x$(t,{left:r.left===!1?0:i.left-r.left,right:r.right===!1?this.width:i.right+r.right,top:r.top===!1?0:i.top-r.top,bottom:r.bottom===!1?this.height:i.bottom+r.bottom}),e.controller.draw(),s&&_$(t),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}isPointInArea(e){return nS(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,r,s){const i=uot.modes[t];return typeof i=="function"?i(this,e,r,s):[]}getDatasetMeta(e){const t=this.data.datasets[e],r=this._metasets;let s=r.filter(i=>i&&i._dataset===t).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},r.push(s)),s}getContext(){return this.$context||(this.$context=Wp(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const r=this.getDatasetMeta(e);return typeof r.hidden=="boolean"?!r.hidden:!t.hidden}setDatasetVisibility(e,t){const r=this.getDatasetMeta(e);r.hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,r){const s=r?"show":"hide",i=this.getDatasetMeta(e),o=i.controller._resolveAnimations(void 0,s);Ac(t)?(i.data[t].hidden=!r,this.update()):(this.setDatasetVisibility(e,r),o.update(i,{visible:r}),this.update(a=>a.datasetIndex===e?s:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),pf.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),r5(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete ZE[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...e){return this.canvas.toDataURL(...e)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,r=(i,o)=>{t.addEventListener(this,i,o),e[i]=o},s=(i,o,a)=>{i.offsetX=o,i.offsetY=a,this._eventHandler(i)};Dr(this.options.events,i=>r(i,s))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,r=(l,c)=>{t.addEventListener(this,l,c),e[l]=c},s=(l,c)=>{e[l]&&(t.removeEventListener(this,l,c),delete e[l])},i=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{s("attach",a),this.attached=!0,this.resize(),r("resize",i),r("detach",o)};o=()=>{this.attached=!1,s("resize",i),this._stop(),this._resize(0,0),r("attach",a)},t.isAttached(this.canvas)?a():o()}unbindEvents(){Dr(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Dr(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,r){const s=r?"set":"remove";let i,o,a,l;for(t==="dataset"&&(i=this.getDatasetMeta(e[0].datasetIndex),i.controller["_"+s+"DatasetHoverStyle"]()),a=0,l=e.length;a<l;++a){o=e[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],r=e.map(({datasetIndex:i,index:o})=>{const a=this.getDatasetMeta(i);if(!a)throw new Error("No dataset found at index "+i);return{datasetIndex:i,element:a.data[o],index:o}});!hA(r,t)&&(this._active=r,this._lastEvent=null,this._updateHoverStyles(r,t))}notifyPlugins(e,t,r){return this._plugins.notify(this,e,t,r)}isPluginEnabled(e){return this._plugins._cache.filter(t=>t.plugin.id===e).length===1}_updateHoverStyles(e,t,r){const s=this.options.hover,i=(l,c)=>l.filter(u=>!c.some(h=>u.datasetIndex===h.datasetIndex&&u.index===h.index)),o=i(t,e),a=r?e:i(e,t);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(e,t){const r={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},s=o=>(o.options.events||this.options.events).includes(e.native.type);if(this.notifyPlugins("beforeEvent",r,s)===!1)return;const i=this._handleEvent(e,t,r.inChartArea);return r.cancelable=!1,this.notifyPlugins("afterEvent",r,s),(i||r.changed)&&this.render(),this}_handleEvent(e,t,r){const{_active:s=[],options:i}=this,o=t,a=this._getActiveElements(e,s,r,o),l=Cst(e),c=fat(e,this._lastEvent,r,l);r&&(this._lastEvent=null,is(i.onHover,[e,a,this],this),l&&is(i.onClick,[e,a,this],this));const u=!hA(a,s);return(u||t)&&(this._active=a,this._updateHoverStyles(a,s,t)),this._lastEvent=c,u}_getActiveElements(e,t,r,s){if(e.type==="mouseout")return[];if(!r)return t;const i=this.options.hover;return this.getElementsAtEventForMode(e,i.mode,i,s)}}Mt(iu,"defaults",ai),Mt(iu,"instances",ZE),Mt(iu,"overrides",xg),Mt(iu,"registry",sh),Mt(iu,"version",lat),Mt(iu,"getChart",O5);function F5(){return Dr(iu.instances,n=>n._plugins.invalidate())}function pat(n,e,t){const{startAngle:r,pixelMargin:s,x:i,y:o,outerRadius:a,innerRadius:l}=e;let c=s/a;n.beginPath(),n.arc(i,o,a,r-c,t+c),l>s?(c=s/l,n.arc(i,o,l,t+c,r-c,!0)):n.arc(i,o,s,t+Js,r-Js),n.closePath(),n.clip()}function mat(n){return F4(n,["outerStart","outerEnd","innerStart","innerEnd"])}function gat(n,e,t,r){const s=mat(n.options.borderRadius),i=(t-e)/2,o=Math.min(i,r*e/2),a=l=>{const c=(t-Math.min(i,l))*r/2;return Xo(l,0,Math.min(i,c))};return{outerStart:a(s.outerStart),outerEnd:a(s.outerEnd),innerStart:Xo(s.innerStart,0,o),innerEnd:Xo(s.innerEnd,0,o)}}function V0(n,e,t,r){return{x:t+n*Math.cos(e),y:r+n*Math.sin(e)}}function bA(n,e,t,r,s,i){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:u}=e,h=Math.max(e.outerRadius+r+t-c,0),f=u>0?u+r+t+c:0;let d=0;const p=s-l;if(r){const z=u>0?u-r:0,B=h>0?h-r:0,X=(z+B)/2,G=X!==0?p*X/(X+r):p;d=(p-G)/2}const m=Math.max(.001,p*h-t/Ts)/h,g=(p-m)/2,y=l+g+d,b=s-g-d,{outerStart:x,outerEnd:w,innerStart:S,innerEnd:C}=gat(e,f,h,b-y),k=h-x,A=h-w,M=y+x/k,E=b-w/A,N=f+S,O=f+C,R=y+S/N,D=b-C/O;if(n.beginPath(),i){const z=(M+E)/2;if(n.arc(o,a,h,M,z),n.arc(o,a,h,z,E),w>0){const te=V0(A,E,o,a);n.arc(te.x,te.y,w,E,b+Js)}const B=V0(O,b,o,a);if(n.lineTo(B.x,B.y),C>0){const te=V0(O,D,o,a);n.arc(te.x,te.y,C,b+Js,D+Math.PI)}const X=(b-C/f+(y+S/f))/2;if(n.arc(o,a,f,b-C/f,X,!0),n.arc(o,a,f,X,y+S/f,!0),S>0){const te=V0(N,R,o,a);n.arc(te.x,te.y,S,R+Math.PI,y-Js)}const G=V0(k,y,o,a);if(n.lineTo(G.x,G.y),x>0){const te=V0(k,M,o,a);n.arc(te.x,te.y,x,y-Js,M)}}else{n.moveTo(o,a);const z=Math.cos(M)*h+o,B=Math.sin(M)*h+a;n.lineTo(z,B);const X=Math.cos(E)*h+o,G=Math.sin(E)*h+a;n.lineTo(X,G)}n.closePath()}function yat(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a}=e;let l=e.endAngle;if(i){bA(n,e,t,r,l,s);for(let c=0;c<i;++c)n.fill();isNaN(a)||(l=o+(a%bs||bs))}return bA(n,e,t,r,l,s),n.fill(),l}function bat(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a,options:l}=e,{borderWidth:c,borderJoinStyle:u}=l,h=l.borderAlign==="inner";if(!c)return;h?(n.lineWidth=c*2,n.lineJoin=u||"round"):(n.lineWidth=c,n.lineJoin=u||"bevel");let f=e.endAngle;if(i){bA(n,e,t,r,f,s);for(let d=0;d<i;++d)n.stroke();isNaN(a)||(f=o+(a%bs||bs))}h&&pat(n,e,f),i||(bA(n,e,t,r,f,s),n.stroke())}class JE extends Mc{constructor(e){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.getProps(["x","y"],r),{angle:i,distance:o}=yse(s,{x:e,y:t}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:u,circumference:h}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],r),f=this.options.spacing/2,p=Un(h,l-a)>=bs||tS(i,a,l),m=Af(o,c+f,u+f);return p&&m}getCenterPoint(e){const{x:t,y:r,startAngle:s,endAngle:i,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:l,spacing:c}=this.options,u=(s+i)/2,h=(o+a+c+l)/2;return{x:t+Math.cos(u)*h,y:r+Math.sin(u)*h}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:r}=this,s=(t.offset||0)/4,i=(t.spacing||0)/2,o=t.circular;if(this.pixelMargin=t.borderAlign==="inner"?.33:0,this.fullCircles=r>bs?Math.floor(r/bs):0,r===0||this.innerRadius<0||this.outerRadius<0)return;e.save();const a=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(a)*s,Math.sin(a)*s);const l=1-Math.sin(Math.min(Ts,r||0)),c=s*l;e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,yat(e,this,c,i,o),bat(e,this,c,i,o),e.restore()}}Mt(JE,"id","arc"),Mt(JE,"defaults",{borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0}),Mt(JE,"defaultRoutes",{backgroundColor:"backgroundColor"});function Qse(n,e,t=e){n.lineCap=Un(t.borderCapStyle,e.borderCapStyle),n.setLineDash(Un(t.borderDash,e.borderDash)),n.lineDashOffset=Un(t.borderDashOffset,e.borderDashOffset),n.lineJoin=Un(t.borderJoinStyle,e.borderJoinStyle),n.lineWidth=Un(t.borderWidth,e.borderWidth),n.strokeStyle=Un(t.borderColor,e.borderColor)}function vat(n,e,t){n.lineTo(t.x,t.y)}function wat(n){return n.stepped?jst:n.tension||n.cubicInterpolationMode==="monotone"?qst:vat}function eie(n,e,t={}){const r=n.length,{start:s=0,end:i=r-1}=t,{start:o,end:a}=e,l=Math.max(s,o),c=Math.min(i,a),u=s<o&&i<o||s>a&&i>a;return{count:r,start:l,loop:e.loop,ilen:c<l&&!u?r+c-l:c-l}}function xat(n,e,t,r){const{points:s,options:i}=e,{count:o,start:a,loop:l,ilen:c}=eie(s,t,r),u=wat(i);let{move:h=!0,reverse:f}=r||{},d,p,m;for(d=0;d<=c;++d)p=s[(a+(f?c-d:d))%o],!p.skip&&(h?(n.moveTo(p.x,p.y),h=!1):u(n,m,p,f,i.stepped),m=p);return l&&(p=s[(a+(f?c:0))%o],u(n,m,p,f,i.stepped)),!!l}function _at(n,e,t,r){const s=e.points,{count:i,start:o,ilen:a}=eie(s,t,r),{move:l=!0,reverse:c}=r||{};let u=0,h=0,f,d,p,m,g,y;const b=w=>(o+(c?a-w:w))%i,x=()=>{m!==g&&(n.lineTo(u,g),n.lineTo(u,m),n.lineTo(u,y))};for(l&&(d=s[b(0)],n.moveTo(d.x,d.y)),f=0;f<=a;++f){if(d=s[b(f)],d.skip)continue;const w=d.x,S=d.y,C=w|0;C===p?(S<m?m=S:S>g&&(g=S),u=(h*u+w)/++h):(x(),n.lineTo(w,S),p=C,h=0,m=g=S),y=S}x()}function cF(n){const e=n.options,t=e.borderDash&&e.borderDash.length;return!n._decimated&&!n._loop&&!e.tension&&e.cubicInterpolationMode!=="monotone"&&!e.stepped&&!t?_at:xat}function Sat(n){return n.stepped?kit:n.tension||n.cubicInterpolationMode==="monotone"?Tit:Im}function Cat(n,e,t,r){let s=e._path;s||(s=e._path=new Path2D,e.path(s,t,r)&&s.closePath()),Qse(n,e.options),n.stroke(s)}function kat(n,e,t,r){const{segments:s,options:i}=e,o=cF(e);for(const a of s)Qse(n,i,a.style),n.beginPath(),o(n,e,a,{start:t,end:t+r-1})&&n.closePath(),n.stroke()}const Tat=typeof Path2D=="function";function Eat(n,e,t,r){Tat&&!e.options.segment?Cat(n,e,t,r):kat(n,e,t,r)}class Vd extends Mc{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const r=this.options;if((r.tension||r.cubicInterpolationMode==="monotone")&&!r.stepped&&!this._pointsUpdated){const s=r.spanGaps?this._loop:this._fullLoop;yit(this._points,r,e,s,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=$it(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,r=e.length;return r&&t[e[r-1].end]}interpolate(e,t){const r=this.options,s=e[t],i=this.points,o=zse(this,{property:t,start:s,end:s});if(!o.length)return;const a=[],l=Sat(r);let c,u;for(c=0,u=o.length;c<u;++c){const{start:h,end:f}=o[c],d=i[h],p=i[f];if(d===p){a.push(d);continue}const m=Math.abs((s-d[t])/(p[t]-d[t])),g=l(d,p,m,r.stepped);g[t]=e[t],a.push(g)}return a.length===1?a[0]:a}pathSegment(e,t,r){return cF(this)(e,this,t,r)}path(e,t,r){const s=this.segments,i=cF(this);let o=this._loop;t=t||0,r=r||this.points.length-t;for(const a of s)o&=i(e,this,a,{start:t,end:t+r-1});return!!o}draw(e,t,r,s){const i=this.options||{};(this.points||[]).length&&i.borderWidth&&(e.save(),Eat(e,this,r,s),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}Mt(Vd,"id","line"),Mt(Vd,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),Mt(Vd,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),Mt(Vd,"descriptors",{_scriptable:!0,_indexable:e=>e!=="borderDash"&&e!=="fill"});function L5(n,e,t,r){const s=n.options,{[t]:i}=n.getProps([t],r);return Math.abs(e-i)<s.radius+s.hitRadius}class QE extends Mc{constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.options,{x:i,y:o}=this.getProps(["x","y"],r);return Math.pow(e-i,2)+Math.pow(t-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(e,t){return L5(this,e,"x",t)}inYRange(e,t){return L5(this,e,"y",t)}getCenterPoint(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}size(e){e=e||this.options||{};let t=e.radius||0;t=Math.max(t,t&&e.hoverRadius||0);const r=t&&e.borderWidth||0;return(t+r)*2}draw(e,t){const r=this.options;this.skip||r.radius<.1||!nS(this,t,this.size(r)/2)||(e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.fillStyle=r.backgroundColor,oF(e,r,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}Mt(QE,"id","point"),Mt(QE,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),Mt(QE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function tie(n,e){const{x:t,y:r,base:s,width:i,height:o}=n.getProps(["x","y","base","width","height"],e);let a,l,c,u,h;return n.horizontal?(h=o/2,a=Math.min(t,s),l=Math.max(t,s),c=r-h,u=r+h):(h=i/2,a=t-h,l=t+h,c=Math.min(r,s),u=Math.max(r,s)),{left:a,top:c,right:l,bottom:u}}function Ud(n,e,t,r){return n?0:Xo(e,t,r)}function Iat(n,e,t){const r=n.options.borderWidth,s=n.borderSkipped,i=Ese(r);return{t:Ud(s.top,i.top,0,t),r:Ud(s.right,i.right,0,e),b:Ud(s.bottom,i.bottom,0,t),l:Ud(s.left,i.left,0,e)}}function Aat(n,e,t){const{enableBorderRadius:r}=n.getProps(["enableBorderRadius"]),s=n.options.borderRadius,i=Qd(s),o=Math.min(e,t),a=n.borderSkipped,l=r||nr(s);return{topLeft:Ud(!l||a.top||a.left,i.topLeft,0,o),topRight:Ud(!l||a.top||a.right,i.topRight,0,o),bottomLeft:Ud(!l||a.bottom||a.left,i.bottomLeft,0,o),bottomRight:Ud(!l||a.bottom||a.right,i.bottomRight,0,o)}}function Mat(n){const e=tie(n),t=e.right-e.left,r=e.bottom-e.top,s=Iat(n,t/2,r/2),i=Aat(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r,radius:i},inner:{x:e.left+s.l,y:e.top+s.t,w:t-s.l-s.r,h:r-s.t-s.b,radius:{topLeft:Math.max(0,i.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,i.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,i.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,i.bottomRight-Math.max(s.b,s.r))}}}}function j3(n,e,t,r){const s=e===null,i=t===null,a=n&&!(s&&i)&&tie(n,r);return a&&(s||Af(e,a.left,a.right))&&(i||Af(t,a.top,a.bottom))}function Nat(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}function $at(n,e){n.rect(e.x,e.y,e.w,e.h)}function q3(n,e,t={}){const r=n.x!==t.x?-e:0,s=n.y!==t.y?-e:0,i=(n.x+n.w!==t.x+t.w?e:0)-r,o=(n.y+n.h!==t.y+t.h?e:0)-s;return{x:n.x+r,y:n.y+s,w:n.w+i,h:n.h+o,radius:n.radius}}class eI extends Mc{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:r,backgroundColor:s}}=this,{inner:i,outer:o}=Mat(this),a=Nat(o.radius)?Jd:$at;e.save(),(o.w!==i.w||o.h!==i.h)&&(e.beginPath(),a(e,q3(o,t,i)),e.clip(),a(e,q3(i,-t,o)),e.fillStyle=r,e.fill("evenodd")),e.beginPath(),a(e,q3(i,t)),e.fillStyle=s,e.fill(),e.restore()}inRange(e,t,r){return j3(this,e,t,r)}inXRange(e,t){return j3(this,e,null,t)}inYRange(e,t){return j3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,base:s,horizontal:i}=this.getProps(["x","y","base","horizontal"],e);return{x:i?(t+s)/2:t,y:i?r:(r+s)/2}}getRange(e){return e==="x"?this.width/2:this.height/2}}Mt(eI,"id","bar"),Mt(eI,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),Mt(eI,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function Rat(n,e,t){const r=n.segments,s=n.points,i=e.points,o=[];for(const a of r){let{start:l,end:c}=a;c=W4(l,c,s);const u=uF(t,s[l],s[c],a.loop);if(!e.segments){o.push({source:a,target:u,start:s[l],end:s[c]});continue}const h=zse(e,u);for(const f of h){const d=uF(t,i[f.start],i[f.end],f.loop),p=Lse(a,s,d);for(const m of p)o.push({source:m,target:f,start:{[t]:z5(u,d,"start",Math.max)},end:{[t]:z5(u,d,"end",Math.min)}})}}return o}function uF(n,e,t,r){if(r)return;let s=e[n],i=t[n];return n==="angle"&&(s=yl(s),i=yl(i)),{property:n,start:s,end:i}}function Pat(n,e){const{x:t=null,y:r=null}=n||{},s=e.points,i=[];return e.segments.forEach(({start:o,end:a})=>{a=W4(o,a,s);const l=s[o],c=s[a];r!==null?(i.push({x:l.x,y:r}),i.push({x:c.x,y:r})):t!==null&&(i.push({x:t,y:l.y}),i.push({x:t,y:c.y}))}),i}function W4(n,e,t){for(;e>n;e--){const r=t[e];if(!isNaN(r.x)&&!isNaN(r.y))break}return e}function z5(n,e,t,r){return n&&e?r(n[t],e[t]):n?n[t]:e?e[t]:0}function nie(n,e){let t=[],r=!1;return gs(n)?(r=!0,t=n):t=Pat(n,e),t.length?new Vd({points:t,options:{tension:0},_loop:r,_fullLoop:r}):null}function B5(n){return n&&n.fill!==!1}function Dat(n,e,t){let s=n[e].fill;const i=[e];let o;if(!t)return s;for(;s!==!1&&i.indexOf(s)===-1;){if(!Zs(s))return s;if(o=n[s],!o)return!1;if(o.visible)return s;i.push(s),s=o.fill}return!1}function Oat(n,e,t){const r=Bat(n);if(nr(r))return isNaN(r.value)?!1:r;let s=parseFloat(r);return Zs(s)&&Math.floor(s)===s?Fat(r[0],e,s,t):["origin","start","end","stack","shape"].indexOf(r)>=0&&r}function Fat(n,e,t,r){return(n==="-"||n==="+")&&(t=e+t),t===e||t<0||t>=r?!1:t}function Lat(n,e){let t=null;return n==="start"?t=e.bottom:n==="end"?t=e.top:nr(n)?t=e.getPixelForValue(n.value):e.getBasePixel&&(t=e.getBasePixel()),t}function zat(n,e,t){let r;return n==="start"?r=t:n==="end"?r=e.options.reverse?e.min:e.max:nr(n)?r=n.value:r=e.getBaseValue(),r}function Bat(n){const e=n.options,t=e.fill;let r=Un(t&&t.target,t);return r===void 0&&(r=!!e.backgroundColor),r===!1||r===null?!1:r===!0?"origin":r}function Vat(n){const{scale:e,index:t,line:r}=n,s=[],i=r.segments,o=r.points,a=Uat(e,t);a.push(nie({x:null,y:e.bottom},r));for(let l=0;l<i.length;l++){const c=i[l];for(let u=c.start;u<=c.end;u++)Wat(s,o[u],a)}return new Vd({points:s,options:{}})}function Uat(n,e){const t=[],r=n.getMatchingVisibleMetas("line");for(let s=0;s<r.length;s++){const i=r[s];if(i.index===e)break;i.hidden||t.unshift(i.dataset)}return t}function Wat(n,e,t){const r=[];for(let s=0;s<t.length;s++){const i=t[s],{first:o,last:a,point:l}=Gat(i,e,"x");if(!(!l||o&&a)){if(o)r.unshift(l);else if(n.push(l),!a)break}}n.push(...r)}function Gat(n,e,t){const r=n.interpolate(e,t);if(!r)return{};const s=r[t],i=n.segments,o=n.points;let a=!1,l=!1;for(let c=0;c<i.length;c++){const u=i[c],h=o[u.start][t],f=o[u.end][t];if(Af(s,h,f)){a=s===h,l=s===f;break}}return{first:a,last:l,point:r}}class rie{constructor(e){this.x=e.x,this.y=e.y,this.radius=e.radius}pathSegment(e,t,r){const{x:s,y:i,radius:o}=this;return t=t||{start:0,end:bs},e.arc(s,i,o,t.end,t.start,!0),!r.bounds}interpolate(e){const{x:t,y:r,radius:s}=this,i=e.angle;return{x:t+Math.cos(i)*s,y:r+Math.sin(i)*s,angle:i}}}function Hat(n){const{chart:e,fill:t,line:r}=n;if(Zs(t))return jat(e,t);if(t==="stack")return Vat(n);if(t==="shape")return!0;const s=qat(n);return s instanceof rie?s:nie(s,r)}function jat(n,e){const t=n.getDatasetMeta(e);return t&&n.isDatasetVisible(e)?t.dataset:null}function qat(n){return(n.scale||{}).getPointPositionForValue?Kat(n):Xat(n)}function Xat(n){const{scale:e={},fill:t}=n,r=Lat(t,e);if(Zs(r)){const s=e.isHorizontal();return{x:s?r:null,y:s?null:r}}return null}function Kat(n){const{scale:e,fill:t}=n,r=e.options,s=e.getLabels().length,i=r.reverse?e.max:e.min,o=zat(t,e,i),a=[];if(r.grid.circular){const l=e.getPointPositionForValue(0,i);return new rie({x:l.x,y:l.y,radius:e.getDistanceFromCenterForValue(o)})}for(let l=0;l<s;++l)a.push(e.getPointPositionForValue(l,o));return a}function X3(n,e,t){const r=Hat(e),{line:s,scale:i,axis:o}=e,a=s.options,l=a.fill,c=a.backgroundColor,{above:u=c,below:h=c}=l||{};r&&s.points.length&&(x$(n,t),Yat(n,{line:s,target:r,above:u,below:h,area:t,scale:i,axis:o}),_$(n))}function Yat(n,e){const{line:t,target:r,above:s,below:i,area:o,scale:a}=e,l=t._loop?"angle":e.axis;n.save(),l==="x"&&i!==s&&(V5(n,r,o.top),U5(n,{line:t,target:r,color:s,scale:a,property:l}),n.restore(),n.save(),V5(n,r,o.bottom)),U5(n,{line:t,target:r,color:i,scale:a,property:l}),n.restore()}function V5(n,e,t){const{segments:r,points:s}=e;let i=!0,o=!1;n.beginPath();for(const a of r){const{start:l,end:c}=a,u=s[l],h=s[W4(l,c,s)];i?(n.moveTo(u.x,u.y),i=!1):(n.lineTo(u.x,t),n.lineTo(u.x,u.y)),o=!!e.pathSegment(n,a,{move:o}),o?n.closePath():n.lineTo(h.x,t)}n.lineTo(e.first().x,t),n.closePath(),n.clip()}function U5(n,e){const{line:t,target:r,property:s,color:i,scale:o}=e,a=Rat(t,r,s);for(const{source:l,target:c,start:u,end:h}of a){const{style:{backgroundColor:f=i}={}}=l,d=r!==!0;n.save(),n.fillStyle=f,Zat(n,o,d&&uF(s,u,h)),n.beginPath();const p=!!t.pathSegment(n,l);let m;if(d){p?n.closePath():W5(n,r,h,s);const g=!!r.pathSegment(n,c,{move:p,reverse:!0});m=p&&g,m||W5(n,r,u,s)}n.closePath(),n.fill(m?"evenodd":"nonzero"),n.restore()}}function Zat(n,e,t){const{top:r,bottom:s}=e.chart.chartArea,{property:i,start:o,end:a}=t||{};i==="x"&&(n.beginPath(),n.rect(o,r,a-o,s-r),n.clip())}function W5(n,e,t,r){const s=e.interpolate(t,r);s&&n.lineTo(s.x,s.y)}var Jat={id:"filler",afterDatasetsUpdate(n,e,t){const r=(n.data.datasets||[]).length,s=[];let i,o,a,l;for(o=0;o<r;++o)i=n.getDatasetMeta(o),a=i.dataset,l=null,a&&a.options&&a instanceof Vd&&(l={visible:n.isDatasetVisible(o),index:o,fill:Oat(a,o,r),chart:n,axis:i.controller.options.indexAxis,scale:i.vScale,line:a}),i.$filler=l,s.push(l);for(o=0;o<r;++o)l=s[o],!(!l||l.fill===!1)&&(l.fill=Dat(s,o,t.propagate))},beforeDraw(n,e,t){const r=t.drawTime==="beforeDraw",s=n.getSortedVisibleDatasetMetas(),i=n.chartArea;for(let o=s.length-1;o>=0;--o){const a=s[o].$filler;a&&(a.line.updateControlPoints(i,a.axis),r&&a.fill&&X3(n.ctx,a,i))}},beforeDatasetsDraw(n,e,t){if(t.drawTime!=="beforeDatasetsDraw")return;const r=n.getSortedVisibleDatasetMetas();for(let s=r.length-1;s>=0;--s){const i=r[s].$filler;B5(i)&&X3(n.ctx,i,n.chartArea)}},beforeDatasetDraw(n,e,t){const r=e.meta.$filler;!B5(r)||t.drawTime!=="beforeDatasetDraw"||X3(n.ctx,r,n.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const G5=(n,e)=>{let{boxHeight:t=e,boxWidth:r=e}=n;return n.usePointStyle&&(t=Math.min(t,e),r=n.pointStyleWidth||Math.min(r,e)),{boxWidth:r,boxHeight:t,itemHeight:Math.max(e,t)}},Qat=(n,e)=>n!==null&&e!==null&&n.datasetIndex===e.datasetIndex&&n.index===e.index;class H5 extends Mc{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,r){this.maxWidth=e,this.maxHeight=t,this._margins=r,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=is(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(r=>e.filter(r,this.chart.data))),e.sort&&(t=t.sort((r,s)=>e.sort(r,s,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display){this.width=this.height=0;return}const r=e.labels,s=Gi(r.font),i=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=G5(r,i);let c,u;t.font=s.string,this.isHorizontal()?(c=this.maxWidth,u=this._fitRows(o,i,a,l)+10):(u=this.maxHeight,c=this._fitCols(o,s,a,l)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(u,e.maxHeight||this.maxHeight)}_fitRows(e,t,r,s){const{ctx:i,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],u=s+a;let h=e;i.textAlign="left",i.textBaseline="middle";let f=-1,d=-u;return this.legendItems.forEach((p,m)=>{const g=r+t/2+i.measureText(p.text).width;(m===0||c[c.length-1]+g+2*a>o)&&(h+=u,c[c.length-(m>0?0:1)]=0,d+=u,f++),l[m]={left:0,top:d,row:f,width:g,height:s},c[c.length-1]+=g+a}),h}_fitCols(e,t,r,s){const{ctx:i,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],u=o-e;let h=a,f=0,d=0,p=0,m=0;return this.legendItems.forEach((g,y)=>{const{itemWidth:b,itemHeight:x}=elt(r,t,i,g,s);y>0&&d+x+2*a>u&&(h+=f+a,c.push({width:f,height:d}),p+=f+a,m++,f=d=0),l[y]={left:p,top:d,col:m,width:b,height:x},f=Math.max(f,b),d+=x+a}),h+=f,c.push({width:f,height:d}),h}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:r,labels:{padding:s},rtl:i}}=this,o=Ob(i,this.left,this.width);if(this.isHorizontal()){let a=0,l=Lo(r,this.left+s,this.right-this.lineWidths[a]);for(const c of t)a!==c.row&&(a=c.row,l=Lo(r,this.left+s,this.right-this.lineWidths[a])),c.top+=this.top+e+s,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+s}else{let a=0,l=Lo(r,this.top+e+s,this.bottom-this.columnSizes[a].height);for(const c of t)c.col!==a&&(a=c.col,l=Lo(r,this.top+e+s,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+s,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+s}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const e=this.ctx;x$(e,this),this._draw(),_$(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:r,ctx:s}=this,{align:i,labels:o}=e,a=ai.color,l=Ob(e.rtl,this.left,this.width),c=Gi(o.font),{padding:u}=o,h=c.size,f=h/2;let d;this.drawTitle(),s.textAlign=l.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:g}=G5(o,h),y=function(C,k,A){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;s.save();const M=Un(A.lineWidth,1);if(s.fillStyle=Un(A.fillStyle,a),s.lineCap=Un(A.lineCap,"butt"),s.lineDashOffset=Un(A.lineDashOffset,0),s.lineJoin=Un(A.lineJoin,"miter"),s.lineWidth=M,s.strokeStyle=Un(A.strokeStyle,a),s.setLineDash(Un(A.lineDash,[])),o.usePointStyle){const E={radius:m*Math.SQRT2/2,pointStyle:A.pointStyle,rotation:A.rotation,borderWidth:M},N=l.xPlus(C,p/2),O=k+f;Tse(s,E,N,O,o.pointStyleWidth&&p)}else{const E=k+Math.max((h-m)/2,0),N=l.leftForLtr(C,p),O=Qd(A.borderRadius);s.beginPath(),Object.values(O).some(R=>R!==0)?Jd(s,{x:N,y:E,w:p,h:m,radius:O}):s.rect(N,E,p,m),s.fill(),M!==0&&s.stroke()}s.restore()},b=function(C,k,A){_g(s,A.text,C,k+g/2,c,{strikethrough:A.hidden,textAlign:l.textAlign(A.textAlign)})},x=this.isHorizontal(),w=this._computeTitleHeight();x?d={x:Lo(i,this.left+u,this.right-r[0]),y:this.top+u+w,line:0}:d={x:this.left+u,y:Lo(i,this.top+w+u,this.bottom-t[0].height),line:0},Dse(this.ctx,e.textDirection);const S=g+u;this.legendItems.forEach((C,k)=>{s.strokeStyle=C.fontColor,s.fillStyle=C.fontColor;const A=s.measureText(C.text).width,M=l.textAlign(C.textAlign||(C.textAlign=o.textAlign)),E=p+f+A;let N=d.x,O=d.y;l.setWidth(this.width),x?k>0&&N+E+u>this.right&&(O=d.y+=S,d.line++,N=d.x=Lo(i,this.left+u,this.right-r[d.line])):k>0&&O+S>this.bottom&&(N=d.x=N+t[d.line].width+u,d.line++,O=d.y=Lo(i,this.top+w+u,this.bottom-t[d.line].height));const R=l.x(N);if(y(R,O,C),N=Dst(M,N+p+f,x?N+E:this.right,e.rtl),b(l.x(N),O,C),x)d.x+=E+u;else if(typeof C.text!="string"){const D=c.lineHeight;d.y+=sie(C,D)}else d.y+=S}),Ose(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,r=Gi(t.font),s=Jo(t.padding);if(!t.display)return;const i=Ob(e.rtl,this.left,this.width),o=this.ctx,a=t.position,l=r.size/2,c=s.top+l;let u,h=this.left,f=this.width;if(this.isHorizontal())f=Math.max(...this.lineWidths),u=this.top+c,h=Lo(e.align,h,this.right-f);else{const p=this.columnSizes.reduce((m,g)=>Math.max(m,g.height),0);u=c+Lo(e.align,this.top,this.bottom-p-e.labels.padding-this._computeTitleHeight())}const d=Lo(a,h,h+f);o.textAlign=i.textAlign(O4(a)),o.textBaseline="middle",o.strokeStyle=t.color,o.fillStyle=t.color,o.font=r.string,_g(o,t.text,d,u,r)}_computeTitleHeight(){const e=this.options.title,t=Gi(e.font),r=Jo(e.padding);return e.display?t.lineHeight+r.height:0}_getLegendItemAt(e,t){let r,s,i;if(Af(e,this.left,this.right)&&Af(t,this.top,this.bottom)){for(i=this.legendHitBoxes,r=0;r<i.length;++r)if(s=i[r],Af(e,s.left,s.left+s.width)&&Af(t,s.top,s.top+s.height))return this.legendItems[r]}return null}handleEvent(e){const t=this.options;if(!rlt(e.type,t))return;const r=this._getLegendItemAt(e.x,e.y);if(e.type==="mousemove"||e.type==="mouseout"){const s=this._hoveredItem,i=Qat(s,r);s&&!i&&is(t.onLeave,[e,s,this],this),this._hoveredItem=r,r&&!i&&is(t.onHover,[e,r,this],this)}else r&&is(t.onClick,[e,r,this],this)}}function elt(n,e,t,r,s){const i=tlt(r,n,e,t),o=nlt(s,r,e.lineHeight);return{itemWidth:i,itemHeight:o}}function tlt(n,e,t,r){let s=n.text;return s&&typeof s!="string"&&(s=s.reduce((i,o)=>i.length>o.length?i:o)),e+t.size/2+r.measureText(s).width}function nlt(n,e,t){let r=n;return typeof e.text!="string"&&(r=sie(e,t)),r}function sie(n,e){const t=n.text?n.text.length+.5:0;return e*t}function rlt(n,e){return!!((n==="mousemove"||n==="mouseout")&&(e.onHover||e.onLeave)||e.onClick&&(n==="click"||n==="mouseup"))}var slt={id:"legend",_element:H5,start(n,e,t){const r=n.legend=new H5({ctx:n.ctx,options:t,chart:n});yc.configure(n,r,t),yc.addBox(n,r)},stop(n){yc.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,e,t){const r=n.legend;yc.configure(n,r,t),r.options=t},afterUpdate(n){const e=n.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(n,e){e.replay||n.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,e,t){const r=e.datasetIndex,s=t.chart;s.isDatasetVisible(r)?(s.hide(r),e.hidden=!0):(s.show(r),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const e=n.data.datasets,{labels:{usePointStyle:t,pointStyle:r,textAlign:s,color:i,useBorderRadius:o,borderRadius:a}}=n.legend.options;return n._getSortedDatasetMetas().map(l=>{const c=l.controller.getStyle(t?0:void 0),u=Jo(c.borderWidth);return{text:e[l.index].label,fillStyle:c.backgroundColor,fontColor:i,hidden:!l.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(u.width+u.height)/4,strokeStyle:c.borderColor,pointStyle:r||c.pointStyle,rotation:c.rotation,textAlign:s||c.textAlign,borderRadius:o&&(a||c.borderRadius),datasetIndex:l.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class iie extends Mc{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const r=this.options;if(this.left=0,this.top=0,!r.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=e,this.height=this.bottom=t;const s=gs(r.text)?r.text.length:1;this._padding=Jo(r.padding);const i=s*Gi(r.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=i:this.width=i}isHorizontal(){const e=this.options.position;return e==="top"||e==="bottom"}_drawArgs(e){const{top:t,left:r,bottom:s,right:i,options:o}=this,a=o.align;let l=0,c,u,h;return this.isHorizontal()?(u=Lo(a,r,i),h=t+e,c=i-r):(o.position==="left"?(u=r+e,h=Lo(a,s,t),l=Ts*-.5):(u=i-e,h=Lo(a,t,s),l=Ts*.5),c=s-t),{titleX:u,titleY:h,maxWidth:c,rotation:l}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const r=Gi(t.font),i=r.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(i);_g(e,t.text,0,0,r,{color:t.color,maxWidth:l,rotation:c,textAlign:O4(t.align),textBaseline:"middle",translation:[o,a]})}}function ilt(n,e){const t=new iie({ctx:n.ctx,options:e,chart:n});yc.configure(n,t,e),yc.addBox(n,t),n.titleBlock=t}var oie={id:"title",_element:iie,start(n,e,t){ilt(n,t)},stop(n){const e=n.titleBlock;yc.removeBox(n,e),delete n.titleBlock},beforeUpdate(n,e,t){const r=n.titleBlock;yc.configure(n,r,t),r.options=t},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const P1={average(n){if(!n.length)return!1;let e,t,r=0,s=0,i=0;for(e=0,t=n.length;e<t;++e){const o=n[e].element;if(o&&o.hasValue()){const a=o.tooltipPosition();r+=a.x,s+=a.y,++i}}return{x:r/i,y:s/i}},nearest(n,e){if(!n.length)return!1;let t=e.x,r=e.y,s=Number.POSITIVE_INFINITY,i,o,a;for(i=0,o=n.length;i<o;++i){const l=n[i].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),u=sF(e,c);u<s&&(s=u,a=l)}}if(a){const l=a.tooltipPosition();t=l.x,r=l.y}return{x:t,y:r}}};function th(n,e){return e&&(gs(e)?Array.prototype.push.apply(n,e):n.push(e)),n}function mf(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function olt(n,e){const{element:t,datasetIndex:r,index:s}=e,i=n.getDatasetMeta(r).controller,{label:o,value:a}=i.getLabelAndValue(s);return{chart:n,label:o,parsed:i.getParsed(s),raw:n.data.datasets[r].data[s],formattedValue:a,dataset:i.getDataset(),dataIndex:s,datasetIndex:r,element:t}}function j5(n,e){const t=n.chart.ctx,{body:r,footer:s,title:i}=n,{boxWidth:o,boxHeight:a}=e,l=Gi(e.bodyFont),c=Gi(e.titleFont),u=Gi(e.footerFont),h=i.length,f=s.length,d=r.length,p=Jo(e.padding);let m=p.height,g=0,y=r.reduce((w,S)=>w+S.before.length+S.lines.length+S.after.length,0);if(y+=n.beforeBody.length+n.afterBody.length,h&&(m+=h*c.lineHeight+(h-1)*e.titleSpacing+e.titleMarginBottom),y){const w=e.displayColors?Math.max(a,l.lineHeight):l.lineHeight;m+=d*w+(y-d)*l.lineHeight+(y-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*u.lineHeight+(f-1)*e.footerSpacing);let b=0;const x=function(w){g=Math.max(g,t.measureText(w).width+b)};return t.save(),t.font=c.string,Dr(n.title,x),t.font=l.string,Dr(n.beforeBody.concat(n.afterBody),x),b=e.displayColors?o+2+e.boxPadding:0,Dr(r,w=>{Dr(w.before,x),Dr(w.lines,x),Dr(w.after,x)}),b=0,t.font=u.string,Dr(n.footer,x),t.restore(),g+=p.width,{width:g,height:m}}function alt(n,e){const{y:t,height:r}=e;return t<r/2?"top":t>n.height-r/2?"bottom":"center"}function llt(n,e,t,r){const{x:s,width:i}=r,o=t.caretSize+t.caretPadding;if(n==="left"&&s+i+o>e.width||n==="right"&&s-i-o<0)return!0}function clt(n,e,t,r){const{x:s,width:i}=t,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return r==="center"?c=s<=(a+l)/2?"left":"right":s<=i/2?c="left":s>=o-i/2&&(c="right"),llt(c,n,e,t)&&(c="center"),c}function q5(n,e,t){const r=t.yAlign||e.yAlign||alt(n,t);return{xAlign:t.xAlign||e.xAlign||clt(n,e,t,r),yAlign:r}}function ult(n,e){let{x:t,width:r}=n;return e==="right"?t-=r:e==="center"&&(t-=r/2),t}function hlt(n,e,t){let{y:r,height:s}=n;return e==="top"?r+=t:e==="bottom"?r-=s+t:r-=s/2,r}function X5(n,e,t,r){const{caretSize:s,caretPadding:i,cornerRadius:o}=n,{xAlign:a,yAlign:l}=t,c=s+i,{topLeft:u,topRight:h,bottomLeft:f,bottomRight:d}=Qd(o);let p=ult(e,a);const m=hlt(e,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(u,f)+s:a==="right"&&(p+=Math.max(h,d)+s),{x:Xo(p,0,r.width-e.width),y:Xo(m,0,r.height-e.height)}}function kT(n,e,t){const r=Jo(t.padding);return e==="center"?n.x+n.width/2:e==="right"?n.x+n.width-r.right:n.x+r.left}function K5(n){return th([],mf(n))}function flt(n,e,t){return Wp(n,{tooltip:e,tooltipItems:t,type:"tooltip"})}function Y5(n,e){const t=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return t?n.override(t):n}const aie={beforeTitle:af,title(n){if(n.length>0){const e=n[0],t=e.chart.data.labels,r=t?t.length:0;if(this&&this.options&&this.options.mode==="dataset")return e.dataset.label||"";if(e.label)return e.label;if(r>0&&e.dataIndex<r)return t[e.dataIndex]}return""},afterTitle:af,beforeBody:af,beforeLabel:af,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let e=n.dataset.label||"";e&&(e+=": ");const t=n.formattedValue;return Nr(t)||(e+=t),e},labelColor(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:af,afterBody:af,beforeFooter:af,footer:af,afterFooter:af};function za(n,e,t,r){const s=n[e].call(t,r);return typeof s>"u"?aie[e].call(t,r):s}class hF extends Mc{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,r=this.options.setContext(this.getContext()),s=r.enabled&&t.options.animation&&r.animations,i=new Bse(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(i)),i}getContext(){return this.$context||(this.$context=flt(this.chart.getContext(),this,this._tooltipItems))}getTitle(e,t){const{callbacks:r}=t,s=za(r,"beforeTitle",this,e),i=za(r,"title",this,e),o=za(r,"afterTitle",this,e);let a=[];return a=th(a,mf(s)),a=th(a,mf(i)),a=th(a,mf(o)),a}getBeforeBody(e,t){return K5(za(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:r}=t,s=[];return Dr(e,i=>{const o={before:[],lines:[],after:[]},a=Y5(r,i);th(o.before,mf(za(a,"beforeLabel",this,i))),th(o.lines,za(a,"label",this,i)),th(o.after,mf(za(a,"afterLabel",this,i))),s.push(o)}),s}getAfterBody(e,t){return K5(za(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:r}=t,s=za(r,"beforeFooter",this,e),i=za(r,"footer",this,e),o=za(r,"afterFooter",this,e);let a=[];return a=th(a,mf(s)),a=th(a,mf(i)),a=th(a,mf(o)),a}_createItems(e){const t=this._active,r=this.chart.data,s=[],i=[],o=[];let a=[],l,c;for(l=0,c=t.length;l<c;++l)a.push(olt(this.chart,t[l]));return e.filter&&(a=a.filter((u,h,f)=>e.filter(u,h,f,r))),e.itemSort&&(a=a.sort((u,h)=>e.itemSort(u,h,r))),Dr(a,u=>{const h=Y5(e.callbacks,u);s.push(za(h,"labelColor",this,u)),i.push(za(h,"labelPointStyle",this,u)),o.push(za(h,"labelTextColor",this,u))}),this.labelColors=s,this.labelPointStyles=i,this.labelTextColors=o,this.dataPoints=a,a}update(e,t){const r=this.options.setContext(this.getContext()),s=this._active;let i,o=[];if(!s.length)this.opacity!==0&&(i={opacity:0});else{const a=P1[r.position].call(this,s,this._eventPosition);o=this._createItems(r),this.title=this.getTitle(o,r),this.beforeBody=this.getBeforeBody(o,r),this.body=this.getBody(o,r),this.afterBody=this.getAfterBody(o,r),this.footer=this.getFooter(o,r);const l=this._size=j5(this,r),c=Object.assign({},a,l),u=q5(this.chart,r,c),h=X5(r,c,u,this.chart);this.xAlign=u.xAlign,this.yAlign=u.yAlign,i={opacity:1,x:h.x,y:h.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,i&&this._resolveAnimations().update(this,i),e&&r.external&&r.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,r,s){const i=this.getCaretPosition(e,r,s);t.lineTo(i.x1,i.y1),t.lineTo(i.x2,i.y2),t.lineTo(i.x3,i.y3)}getCaretPosition(e,t,r){const{xAlign:s,yAlign:i}=this,{caretSize:o,cornerRadius:a}=r,{topLeft:l,topRight:c,bottomLeft:u,bottomRight:h}=Qd(a),{x:f,y:d}=e,{width:p,height:m}=t;let g,y,b,x,w,S;return i==="center"?(w=d+m/2,s==="left"?(g=f,y=g-o,x=w+o,S=w-o):(g=f+p,y=g+o,x=w-o,S=w+o),b=g):(s==="left"?y=f+Math.max(l,u)+o:s==="right"?y=f+p-Math.max(c,h)-o:y=this.caretX,i==="top"?(x=d,w=x-o,g=y-o,b=y+o):(x=d+m,w=x+o,g=y+o,b=y-o),S=x),{x1:g,x2:y,x3:b,y1:x,y2:w,y3:S}}drawTitle(e,t,r){const s=this.title,i=s.length;let o,a,l;if(i){const c=Ob(r.rtl,this.x,this.width);for(e.x=kT(this,r.titleAlign,r),t.textAlign=c.textAlign(r.titleAlign),t.textBaseline="middle",o=Gi(r.titleFont),a=r.titleSpacing,t.fillStyle=r.titleColor,t.font=o.string,l=0;l<i;++l)t.fillText(s[l],c.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+a,l+1===i&&(e.y+=r.titleMarginBottom-a)}}_drawColorBox(e,t,r,s,i){const o=this.labelColors[r],a=this.labelPointStyles[r],{boxHeight:l,boxWidth:c,boxPadding:u}=i,h=Gi(i.bodyFont),f=kT(this,"left",i),d=s.x(f),p=l<h.lineHeight?(h.lineHeight-l)/2:0,m=t.y+p;if(i.usePointStyle){const g={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=s.leftForLtr(d,c)+c/2,b=m+l/2;e.strokeStyle=i.multiKeyBackground,e.fillStyle=i.multiKeyBackground,oF(e,g,y,b),e.strokeStyle=o.borderColor,e.fillStyle=o.backgroundColor,oF(e,g,y,b)}else{e.lineWidth=nr(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,e.strokeStyle=o.borderColor,e.setLineDash(o.borderDash||[]),e.lineDashOffset=o.borderDashOffset||0;const g=s.leftForLtr(d,c-u),y=s.leftForLtr(s.xPlus(d,1),c-u-2),b=Qd(o.borderRadius);Object.values(b).some(x=>x!==0)?(e.beginPath(),e.fillStyle=i.multiKeyBackground,Jd(e,{x:g,y:m,w:c,h:l,radius:b}),e.fill(),e.stroke(),e.fillStyle=o.backgroundColor,e.beginPath(),Jd(e,{x:y,y:m+1,w:c-2,h:l-2,radius:b}),e.fill()):(e.fillStyle=i.multiKeyBackground,e.fillRect(g,m,c,l),e.strokeRect(g,m,c,l),e.fillStyle=o.backgroundColor,e.fillRect(y,m+1,c-2,l-2))}e.fillStyle=this.labelTextColors[r]}drawBody(e,t,r){const{body:s}=this,{bodySpacing:i,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:u}=r,h=Gi(r.bodyFont);let f=h.lineHeight,d=0;const p=Ob(r.rtl,this.x,this.width),m=function(A){t.fillText(A,p.x(e.x+d),e.y+f/2),e.y+=f+i},g=p.textAlign(o);let y,b,x,w,S,C,k;for(t.textAlign=o,t.textBaseline="middle",t.font=h.string,e.x=kT(this,g,r),t.fillStyle=r.bodyColor,Dr(this.beforeBody,m),d=a&&g!=="right"?o==="center"?c/2+u:c+2+u:0,w=0,C=s.length;w<C;++w){for(y=s[w],b=this.labelTextColors[w],t.fillStyle=b,Dr(y.before,m),x=y.lines,a&&x.length&&(this._drawColorBox(t,e,w,p,r),f=Math.max(h.lineHeight,l)),S=0,k=x.length;S<k;++S)m(x[S]),f=h.lineHeight;Dr(y.after,m)}d=0,f=h.lineHeight,Dr(this.afterBody,m),e.y-=i}drawFooter(e,t,r){const s=this.footer,i=s.length;let o,a;if(i){const l=Ob(r.rtl,this.x,this.width);for(e.x=kT(this,r.footerAlign,r),e.y+=r.footerMarginTop,t.textAlign=l.textAlign(r.footerAlign),t.textBaseline="middle",o=Gi(r.footerFont),t.fillStyle=r.footerColor,t.font=o.string,a=0;a<i;++a)t.fillText(s[a],l.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+r.footerSpacing}}drawBackground(e,t,r,s){const{xAlign:i,yAlign:o}=this,{x:a,y:l}=e,{width:c,height:u}=r,{topLeft:h,topRight:f,bottomLeft:d,bottomRight:p}=Qd(s.cornerRadius);t.fillStyle=s.backgroundColor,t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.beginPath(),t.moveTo(a+h,l),o==="top"&&this.drawCaret(e,t,r,s),t.lineTo(a+c-f,l),t.quadraticCurveTo(a+c,l,a+c,l+f),o==="center"&&i==="right"&&this.drawCaret(e,t,r,s),t.lineTo(a+c,l+u-p),t.quadraticCurveTo(a+c,l+u,a+c-p,l+u),o==="bottom"&&this.drawCaret(e,t,r,s),t.lineTo(a+d,l+u),t.quadraticCurveTo(a,l+u,a,l+u-d),o==="center"&&i==="left"&&this.drawCaret(e,t,r,s),t.lineTo(a,l+h),t.quadraticCurveTo(a,l,a+h,l),t.closePath(),t.fill(),s.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,r=this.$animations,s=r&&r.x,i=r&&r.y;if(s||i){const o=P1[e.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=j5(this,e),l=Object.assign({},o,this._size),c=q5(t,e,l),u=X5(e,l,c,t);(s._to!==u.x||i._to!==u.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,u))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let r=this.opacity;if(!r)return;this._updateAnimationTarget(t);const s={width:this.width,height:this.height},i={x:this.x,y:this.y};r=Math.abs(r)<.001?0:r;const o=Jo(t.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&a&&(e.save(),e.globalAlpha=r,this.drawBackground(i,e,s,t),Dse(e,t.textDirection),i.y+=o.top,this.drawTitle(i,e,t),this.drawBody(i,e,t),this.drawFooter(i,e,t),Ose(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const r=this._active,s=e.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),i=!hA(r,s),o=this._positionChanged(s,t);(i||o)&&(this._active=s,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t,r=!0){if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,i=this._active||[],o=this._getActiveElements(e,i,t,r),a=this._positionChanged(o,e),l=t||!hA(o,i)||a;return l&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),l}_getActiveElements(e,t,r,s){const i=this.options;if(e.type==="mouseout")return[];if(!s)return t;const o=this.chart.getElementsAtEventForMode(e,i.mode,i,r);return i.reverse&&o.reverse(),o}_positionChanged(e,t){const{caretX:r,caretY:s,options:i}=this,o=P1[i.position].call(this,e,t);return o!==!1&&(r!==o.x||s!==o.y)}}Mt(hF,"positioners",P1);var lie={id:"tooltip",_element:hF,positioners:P1,afterInit(n,e,t){t&&(n.tooltip=new hF({chart:n,options:t}))},beforeUpdate(n,e,t){n.tooltip&&n.tooltip.initialize(t)},reset(n,e,t){n.tooltip&&n.tooltip.initialize(t)},afterDraw(n){const e=n.tooltip;if(e&&e._willRender()){const t={tooltip:e};if(n.notifyPlugins("beforeTooltipDraw",{...t,cancelable:!0})===!1)return;e.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",t)}},afterEvent(n,e){if(n.tooltip){const t=e.replay;n.tooltip.handleEvent(e.event,t,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,e)=>e.bodyFont.size,boxWidth:(n,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:aie},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const dlt=(n,e,t,r)=>(typeof e=="string"?(t=n.push(e)-1,r.unshift({index:t,label:e})):isNaN(e)&&(t=null),t);function plt(n,e,t,r){const s=n.indexOf(e);if(s===-1)return dlt(n,e,t,r);const i=n.lastIndexOf(e);return s!==i?t:s}const mlt=(n,e)=>n===null?null:Xo(Math.round(n),0,e);function Z5(n){const e=this.getLabels();return n>=0&&n<e.length?e[n]:n}class vA extends e0{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const r=this.getLabels();for(const{index:s,label:i}of t)r[s]===i&&r.splice(s,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(Nr(e))return null;const r=this.getLabels();return t=isFinite(t)&&r[t]===e?t:plt(r,e,Un(t,e),this._addedLabels),mlt(t,r.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:r,max:s}=this.getMinMax(!0);this.options.bounds==="ticks"&&(e||(r=0),t||(s=this.getLabels().length-1)),this.min=r,this.max=s}buildTicks(){const e=this.min,t=this.max,r=this.options.offset,s=[];let i=this.getLabels();i=e===0&&t===i.length-1?i:i.slice(e,t+1),this._valueRange=Math.max(i.length-(r?0:1),1),this._startValue=this.min-(r?.5:0);for(let o=e;o<=t;o++)s.push({value:o});return s}getLabelForValue(e){return Z5.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return typeof e!="number"&&(e=this.parse(e)),e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}Mt(vA,"id","category"),Mt(vA,"defaults",{ticks:{callback:Z5}});function glt(n,e){const t=[],{bounds:s,step:i,min:o,max:a,precision:l,count:c,maxTicks:u,maxDigits:h,includeBounds:f}=n,d=i||1,p=u-1,{min:m,max:g}=e,y=!Nr(o),b=!Nr(a),x=!Nr(c),w=(g-m)/(h+1);let S=Y6((g-m)/p/d)*d,C,k,A,M;if(S<1e-14&&!y&&!b)return[{value:m},{value:g}];M=Math.ceil(g/S)-Math.floor(m/S),M>p&&(S=Y6(M*S/p/d)*d),Nr(l)||(C=Math.pow(10,l),S=Math.ceil(S*C)/C),s==="ticks"?(k=Math.floor(m/S)*S,A=Math.ceil(g/S)*S):(k=m,A=g),y&&b&&i&&Ist((a-o)/i,S/1e3)?(M=Math.round(Math.min((a-o)/S,u)),S=(a-o)/M,k=o,A=a):x?(k=y?o:k,A=b?a:A,M=c-1,S=(A-k)/M):(M=(A-k)/S,r_(M,Math.round(M),S/1e3)?M=Math.round(M):M=Math.ceil(M));const E=Math.max(Z6(S),Z6(k));C=Math.pow(10,Nr(l)?E:l),k=Math.round(k*C)/C,A=Math.round(A*C)/C;let N=0;for(y&&(f&&k!==o?(t.push({value:o}),k<o&&N++,r_(Math.round((k+N*S)*C)/C,o,J5(o,w,n))&&N++):k<o&&N++);N<M;++N)t.push({value:Math.round((k+N*S)*C)/C});return b&&f&&A!==a?t.length&&r_(t[t.length-1].value,a,J5(a,w,n))?t[t.length-1].value=a:t.push({value:a}):(!b||A===a)&&t.push({value:A}),t}function J5(n,e,{horizontal:t,minRotation:r}){const s=fu(r),i=(t?Math.sin(s):Math.cos(s))||.001,o=.75*e*(""+n).length;return Math.min(e/i,o)}class wA extends e0{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return Nr(e)||(typeof e=="number"||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:r}=this.getUserBounds();let{min:s,max:i}=this;const o=l=>s=t?s:l,a=l=>i=r?i:l;if(e){const l=vh(s),c=vh(i);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(s===i){let l=i===0?1:Math.abs(i*.05);a(i+l),e||o(s-l)}this.min=s,this.max=i}getTickLimit(){const e=this.options.ticks;let{maxTicksLimit:t,stepSize:r}=e,s;return r?(s=Math.ceil(this.max/r)-Math.floor(this.min/r)+1,s>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${s} ticks. Limiting to 1000.`),s=1e3)):(s=this.computeTickLimit(),t=t||11),t&&(s=Math.min(t,s)),s}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let r=this.getTickLimit();r=Math.max(2,r);const s={maxTicks:r,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:t.includeBounds!==!1},i=this._range||this,o=glt(s,i);return e.bounds==="ticks"&&gse(o,this,"value"),e.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const e=this.ticks;let t=this.min,r=this.max;if(super.configure(),this.options.offset&&e.length){const s=(r-t)/Math.max(e.length-1,1)/2;t-=s,r+=s}this._startValue=t,this._endValue=r,this._valueRange=r-t}getLabelForValue(e){return PC(e,this.chart.options.locale,this.options.ticks.format)}}class fF extends wA{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Zs(e)?e:0,this.max=Zs(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,r=fu(this.options.ticks.minRotation),s=(e?Math.sin(r):Math.cos(r))||.001,i=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,i.lineHeight/s))}getPixelForValue(e){return e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}Mt(fF,"id","linear"),Mt(fF,"defaults",{ticks:{callback:w$.formatters.numeric}});const sS=n=>Math.floor(Bd(n)),dm=(n,e)=>Math.pow(10,sS(n)+e);function Q5(n){return n/Math.pow(10,sS(n))===1}function ej(n,e,t){const r=Math.pow(10,t),s=Math.floor(n/r);return Math.ceil(e/r)-s}function ylt(n,e){const t=e-n;let r=sS(t);for(;ej(n,e,r)>10;)r++;for(;ej(n,e,r)<10;)r--;return Math.min(r,sS(n))}function blt(n,{min:e,max:t}){e=gl(n.min,e);const r=[],s=sS(e);let i=ylt(e,t),o=i<0?Math.pow(10,Math.abs(i)):1;const a=Math.pow(10,i),l=s>i?Math.pow(10,s):0,c=Math.round((e-l)*o)/o,u=Math.floor((e-l)/a/10)*a*10;let h=Math.floor((c-u)/Math.pow(10,i)),f=gl(n.min,Math.round((l+u+h*Math.pow(10,i))*o)/o);for(;f<t;)r.push({value:f,major:Q5(f),significand:h}),h>=10?h=h<15?15:20:h++,h>=20&&(i++,h=2,o=i>=0?1:o),f=Math.round((l+u+h*Math.pow(10,i))*o)/o;const d=gl(n.max,f);return r.push({value:d,major:Q5(d),significand:h}),r}class dF extends e0{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const r=wA.prototype.parse.apply(this,[e,t]);if(r===0){this._zero=!0;return}return Zs(r)&&r>0?r:null}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Zs(e)?Math.max(0,e):null,this.max=Zs(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Zs(this._userMin)&&(this.min=e===dm(this.min,0)?dm(this.min,-1):dm(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let r=this.min,s=this.max;const i=a=>r=e?r:a,o=a=>s=t?s:a;r===s&&(r<=0?(i(1),o(10)):(i(dm(r,-1)),o(dm(s,1)))),r<=0&&i(dm(s,-1)),s<=0&&o(dm(r,1)),this.min=r,this.max=s}buildTicks(){const e=this.options,t={min:this._userMin,max:this._userMax},r=blt(t,this);return e.bounds==="ticks"&&gse(r,this,"value"),e.reverse?(r.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),r}getLabelForValue(e){return e===void 0?"0":PC(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=Bd(e),this._valueRange=Bd(this.max)-Bd(e)}getPixelForValue(e){return(e===void 0||e===0)&&(e=this.min),e===null||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(Bd(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}Mt(dF,"id","logarithmic"),Mt(dF,"defaults",{ticks:{callback:w$.formatters.logarithmic,major:{enabled:!0}}});function pF(n){const e=n.ticks;if(e.display&&n.display){const t=Jo(e.backdropPadding);return Un(e.font&&e.font.size,ai.font.size)+t.height}return 0}function vlt(n,e,t){return t=gs(t)?t:[t],{w:Hst(n,e.string,t),h:t.length*e.lineHeight}}function tj(n,e,t,r,s){return n===r||n===s?{start:e-t/2,end:e+t/2}:n<r||n>s?{start:e-t,end:e}:{start:e,end:e+t}}function wlt(n){const e={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},t=Object.assign({},e),r=[],s=[],i=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?Ts/i:0;for(let l=0;l<i;l++){const c=o.setContext(n.getPointLabelContext(l));s[l]=c.padding;const u=n.getPointPosition(l,n.drawingArea+s[l],a),h=Gi(c.font),f=vlt(n.ctx,h,n._pointLabels[l]);r[l]=f;const d=yl(n.getIndexAngle(l)+a),p=Math.round(P4(d)),m=tj(p,u.x,f.w,0,180),g=tj(p,u.y,f.h,90,270);xlt(t,e,d,m,g)}n.setCenterPoint(e.l-t.l,t.r-e.r,e.t-t.t,t.b-e.b),n._pointLabelItems=_lt(n,r,s)}function xlt(n,e,t,r,s){const i=Math.abs(Math.sin(t)),o=Math.abs(Math.cos(t));let a=0,l=0;r.start<e.l?(a=(e.l-r.start)/i,n.l=Math.min(n.l,e.l-a)):r.end>e.r&&(a=(r.end-e.r)/i,n.r=Math.max(n.r,e.r+a)),s.start<e.t?(l=(e.t-s.start)/o,n.t=Math.min(n.t,e.t-l)):s.end>e.b&&(l=(s.end-e.b)/o,n.b=Math.max(n.b,e.b+l))}function _lt(n,e,t){const r=[],s=n._pointLabels.length,i=n.options,o=pF(i)/2,a=n.drawingArea,l=i.pointLabels.centerPointLabels?Ts/s:0;for(let c=0;c<s;c++){const u=n.getPointPosition(c,a+o+t[c],l),h=Math.round(P4(yl(u.angle+Js))),f=e[c],d=klt(u.y,f.h,h),p=Slt(h),m=Clt(u.x,f.w,p);r.push({x:u.x,y:d,textAlign:p,left:m,top:d,right:m+f.w,bottom:d+f.h})}return r}function Slt(n){return n===0||n===180?"center":n<180?"left":"right"}function Clt(n,e,t){return t==="right"?n-=e:t==="center"&&(n-=e/2),n}function klt(n,e,t){return t===90||t===270?n-=e/2:(t>270||t<90)&&(n-=e),n}function Tlt(n,e){const{ctx:t,options:{pointLabels:r}}=n;for(let s=e-1;s>=0;s--){const i=r.setContext(n.getPointLabelContext(s)),o=Gi(i.font),{x:a,y:l,textAlign:c,left:u,top:h,right:f,bottom:d}=n._pointLabelItems[s],{backdropColor:p}=i;if(!Nr(p)){const m=Qd(i.borderRadius),g=Jo(i.backdropPadding);t.fillStyle=p;const y=u-g.left,b=h-g.top,x=f-u+g.width,w=d-h+g.height;Object.values(m).some(S=>S!==0)?(t.beginPath(),Jd(t,{x:y,y:b,w:x,h:w,radius:m}),t.fill()):t.fillRect(y,b,x,w)}_g(t,n._pointLabels[s],a,l+o.lineHeight/2,o,{color:i.color,textAlign:c,textBaseline:"middle"})}}function cie(n,e,t,r){const{ctx:s}=n;if(t)s.arc(n.xCenter,n.yCenter,e,0,bs);else{let i=n.getPointPosition(0,e);s.moveTo(i.x,i.y);for(let o=1;o<r;o++)i=n.getPointPosition(o,e),s.lineTo(i.x,i.y)}}function Elt(n,e,t,r,s){const i=n.ctx,o=e.circular,{color:a,lineWidth:l}=e;!o&&!r||!a||!l||t<0||(i.save(),i.strokeStyle=a,i.lineWidth=l,i.setLineDash(s.dash),i.lineDashOffset=s.dashOffset,i.beginPath(),cie(n,t,o,r),i.closePath(),i.stroke(),i.restore())}function Ilt(n,e,t){return Wp(n,{label:t,index:e,type:"pointLabel"})}class D1 extends wA{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=Jo(pF(this.options)/2),t=this.width=this.maxWidth-e.width,r=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+r/2+e.top),this.drawingArea=Math.floor(Math.min(t,r)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=Zs(e)&&!isNaN(e)?e:0,this.max=Zs(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/pF(this.options))}generateTickLabels(e){wA.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((t,r)=>{const s=is(this.options.pointLabels.callback,[t,r],this);return s||s===0?s:""}).filter((t,r)=>this.chart.getDataVisibility(r))}fit(){const e=this.options;e.display&&e.pointLabels.display?wlt(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,r,s){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((r-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,r,s))}getIndexAngle(e){const t=bs/(this._pointLabels.length||1),r=this.options.startAngle||0;return yl(e*t+fu(r))}getDistanceFromCenterForValue(e){if(Nr(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(Nr(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const r=t[e];return Ilt(this.getContext(),e,r)}}getPointPosition(e,t,r=0){const s=this.getIndexAngle(e)-Js+r;return{x:Math.cos(s)*t+this.xCenter,y:Math.sin(s)*t+this.yCenter,angle:s}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:r,right:s,bottom:i}=this._pointLabelItems[e];return{left:t,top:r,right:s,bottom:i}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const r=this.ctx;r.save(),r.beginPath(),cie(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),r.closePath(),r.fillStyle=e,r.fill(),r.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:r,grid:s,border:i}=t,o=this._pointLabels.length;let a,l,c;if(t.pointLabels.display&&Tlt(this,o),s.display&&this.ticks.forEach((u,h)=>{if(h!==0){l=this.getDistanceFromCenterForValue(u.value);const f=this.getContext(h),d=s.setContext(f),p=i.setContext(f);Elt(this,d,l,o,p)}}),r.display){for(e.save(),a=o-1;a>=0;a--){const u=r.setContext(this.getPointLabelContext(a)),{color:h,lineWidth:f}=u;!f||!h||(e.lineWidth=f,e.strokeStyle=h,e.setLineDash(u.borderDash),e.lineDashOffset=u.borderDashOffset,l=this.getDistanceFromCenterForValue(t.ticks.reverse?this.min:this.max),c=this.getPointPosition(a,l),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,r=t.ticks;if(!r.display)return;const s=this.getIndexAngle(0);let i,o;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(s),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!t.reverse)return;const c=r.setContext(this.getContext(l)),u=Gi(c.font);if(i=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){e.font=u.string,o=e.measureText(a.label).width,e.fillStyle=c.backdropColor;const h=Jo(c.backdropPadding);e.fillRect(-o/2-h.left,-i-u.size/2-h.top,o+h.width,u.size+h.height)}_g(e,a.label,0,-i,u,{color:c.color})}),e.restore()}drawTitle(){}}Mt(D1,"id","radialLinear"),Mt(D1,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:w$.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(e){return e},padding:5,centerPointLabels:!1}}),Mt(D1,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),Mt(D1,"descriptors",{angleLines:{_fallback:"grid"}});const C$={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ga=Object.keys(C$);function Alt(n,e){return n-e}function nj(n,e){if(Nr(e))return null;const t=n._adapter,{parser:r,round:s,isoWeekday:i}=n._parseOpts;let o=e;return typeof r=="function"&&(o=r(o)),Zs(o)||(o=typeof r=="string"?t.parse(o,r):t.parse(o)),o===null?null:(s&&(o=s==="week"&&(uv(i)||i===!0)?t.startOf(o,"isoWeek",i):t.startOf(o,s)),+o)}function rj(n,e,t,r){const s=Ga.length;for(let i=Ga.indexOf(n);i<s-1;++i){const o=C$[Ga[i]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((t-e)/(a*o.size))<=r)return Ga[i]}return Ga[s-1]}function Mlt(n,e,t,r,s){for(let i=Ga.length-1;i>=Ga.indexOf(t);i--){const o=Ga[i];if(C$[o].common&&n._adapter.diff(s,r,o)>=e-1)return o}return Ga[t?Ga.indexOf(t):0]}function Nlt(n){for(let e=Ga.indexOf(n)+1,t=Ga.length;e<t;++e)if(C$[Ga[e]].common)return Ga[e]}function sj(n,e,t){if(!t)n[e]=!0;else if(t.length){const{lo:r,hi:s}=D4(t,e),i=t[r]>=e?t[r]:t[s];n[i]=!0}}function $lt(n,e,t,r){const s=n._adapter,i=+s.startOf(e[0].value,r),o=e[e.length-1].value;let a,l;for(a=i;a<=o;a=+s.add(a,1,r))l=t[a],l>=0&&(e[l].major=!0);return e}function ij(n,e,t){const r=[],s={},i=e.length;let o,a;for(o=0;o<i;++o)a=e[o],s[a]=o,r.push({value:a,major:!1});return i===0||!t?r:$lt(n,r,s,t)}class iS extends e0{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e,t={}){const r=e.time||(e.time={}),s=this._adapter=new Wse._date(e.adapters.date);s.init(t),n_(r.displayFormats,s.formats()),this._parseOpts={parser:r.parser,round:r.round,isoWeekday:r.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return e===void 0?null:nj(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,r=e.time.unit||"day";let{min:s,max:i,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(s=Math.min(s,c.min)),!a&&!isNaN(c.max)&&(i=Math.max(i,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(e.bounds!=="ticks"||e.ticks.source!=="labels")&&l(this.getMinMax(!1))),s=Zs(s)&&!isNaN(s)?s:+t.startOf(Date.now(),r),i=Zs(i)&&!isNaN(i)?i:+t.endOf(Date.now(),r)+1,this.min=Math.min(s,i-1),this.max=Math.max(s+1,i)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],r=e[e.length-1]),{min:t,max:r}}buildTicks(){const e=this.options,t=e.time,r=e.ticks,s=r.source==="labels"?this.getLabelTimestamps():this._generate();e.bounds==="ticks"&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const i=this.min,o=this.max,a=$st(s,i,o);return this._unit=t.unit||(r.autoSkip?rj(t.minUnit,this.min,this.max,this._getLabelCapacity(i)):Mlt(this,a.length,t.minUnit,this.min,this.max)),this._majorUnit=!r.major.enabled||this._unit==="year"?void 0:Nlt(this._unit),this.initOffsets(s),e.reverse&&a.reverse(),ij(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(e=[]){let t=0,r=0,s,i;this.options.offset&&e.length&&(s=this.getDecimalForValue(e[0]),e.length===1?t=1-s:t=(this.getDecimalForValue(e[1])-s)/2,i=this.getDecimalForValue(e[e.length-1]),e.length===1?r=i:r=(i-this.getDecimalForValue(e[e.length-2]))/2);const o=e.length<3?.5:.25;t=Xo(t,0,o),r=Xo(r,0,o),this._offsets={start:t,end:r,factor:1/(t+1+r)}}_generate(){const e=this._adapter,t=this.min,r=this.max,s=this.options,i=s.time,o=i.unit||rj(i.minUnit,t,r,this._getLabelCapacity(t)),a=Un(s.ticks.stepSize,1),l=o==="week"?i.isoWeekday:!1,c=uv(l)||l===!0,u={};let h=t,f,d;if(c&&(h=+e.startOf(h,"isoWeek",l)),h=+e.startOf(h,c?"day":o),e.diff(r,t,o)>1e5*a)throw new Error(t+" and "+r+" are too far apart with stepSize of "+a+" "+o);const p=s.ticks.source==="data"&&this.getDataTimestamps();for(f=h,d=0;f<r;f=+e.add(f,a,o),d++)sj(u,f,p);return(f===r||s.bounds==="ticks"||d===1)&&sj(u,f,p),Object.keys(u).sort((m,g)=>m-g).map(m=>+m)}getLabelForValue(e){const t=this._adapter,r=this.options.time;return r.tooltipFormat?t.format(e,r.tooltipFormat):t.format(e,r.displayFormats.datetime)}format(e,t){const s=this.options.time.displayFormats,i=this._unit,o=t||s[i];return this._adapter.format(e,o)}_tickFormatFunction(e,t,r,s){const i=this.options,o=i.ticks.callback;if(o)return is(o,[e,t,r],this);const a=i.time.displayFormats,l=this._unit,c=this._majorUnit,u=l&&a[l],h=c&&a[c],f=r[t],d=c&&h&&f&&f.major;return this._adapter.format(e,s||(d?h:u))}generateTickLabels(e){let t,r,s;for(t=0,r=e.length;t<r;++t)s=e[t],s.label=this._tickFormatFunction(s.value,t,e)}getDecimalForValue(e){return e===null?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,r=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+r)*t.factor)}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+r*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,r=this.ctx.measureText(e).width,s=fu(this.isHorizontal()?t.maxRotation:t.minRotation),i=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:r*i+a*o,h:r*o+a*i}}_getLabelCapacity(e){const t=this.options.time,r=t.displayFormats,s=r[t.unit]||r.millisecond,i=this._tickFormatFunction(e,0,ij(this,[e],this._majorUnit),s),o=this._getLabelSize(i),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let e=this._cache.data||[],t,r;if(e.length)return e;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,r=s.length;t<r;++t)e=e.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(e)}getLabelTimestamps(){const e=this._cache.labels||[];let t,r;if(e.length)return e;const s=this.getLabels();for(t=0,r=s.length;t<r;++t)e.push(nj(this,s[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return vse(e.sort(Alt))}}Mt(iS,"id","time"),Mt(iS,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});function TT(n,e,t){let r=0,s=n.length-1,i,o,a,l;t?(e>=n[r].pos&&e<=n[s].pos&&({lo:r,hi:s}=Hm(n,"pos",e)),{pos:i,time:a}=n[r],{pos:o,time:l}=n[s]):(e>=n[r].time&&e<=n[s].time&&({lo:r,hi:s}=Hm(n,"time",e)),{time:i,pos:a}=n[r],{time:o,pos:l}=n[s]);const c=o-i;return c?a+(l-a)*(e-i)/c:a}class mF extends iS{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=TT(t,this.min),this._tableRange=TT(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:r}=this,s=[],i=[];let o,a,l,c,u;for(o=0,a=e.length;o<a;++o)c=e[o],c>=t&&c<=r&&s.push(c);if(s.length<2)return[{time:t,pos:0},{time:r,pos:1}];for(o=0,a=s.length;o<a;++o)u=s[o+1],l=s[o-1],c=s[o],Math.round((u+l)/2)!==c&&i.push({time:c,pos:o/(a-1)});return i}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),r=this.getLabelTimestamps();return t.length&&r.length?e=this.normalize(t.concat(r)):e=t.length?t:r,e=this._cache.all=e,e}getDecimalForValue(e){return(TT(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return TT(this._table,r*this._tableRange+this._minPos,!0)}}Mt(mF,"id","timeseries"),Mt(mF,"defaults",iS.defaults);class t0 extends Error{}class Rlt extends t0{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class Plt extends t0{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class Dlt extends t0{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class O1 extends t0{}class uie extends t0{constructor(e){super(`Invalid unit ${e}`)}}class cc extends t0{}class md extends t0{constructor(){super("Zone is an abstract class")}}const zt="numeric",Tu="short",Il="long",xA={year:zt,month:zt,day:zt},hie={year:zt,month:Tu,day:zt},Olt={year:zt,month:Tu,day:zt,weekday:Tu},fie={year:zt,month:Il,day:zt},die={year:zt,month:Il,day:zt,weekday:Il},pie={hour:zt,minute:zt},mie={hour:zt,minute:zt,second:zt},gie={hour:zt,minute:zt,second:zt,timeZoneName:Tu},yie={hour:zt,minute:zt,second:zt,timeZoneName:Il},bie={hour:zt,minute:zt,hourCycle:"h23"},vie={hour:zt,minute:zt,second:zt,hourCycle:"h23"},wie={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:Tu},xie={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:Il},_ie={year:zt,month:zt,day:zt,hour:zt,minute:zt},Sie={year:zt,month:zt,day:zt,hour:zt,minute:zt,second:zt},Cie={year:zt,month:Tu,day:zt,hour:zt,minute:zt},kie={year:zt,month:Tu,day:zt,hour:zt,minute:zt,second:zt},Flt={year:zt,month:Tu,day:zt,weekday:Tu,hour:zt,minute:zt},Tie={year:zt,month:Il,day:zt,hour:zt,minute:zt,timeZoneName:Tu},Eie={year:zt,month:Il,day:zt,hour:zt,minute:zt,second:zt,timeZoneName:Tu},Iie={year:zt,month:Il,day:zt,weekday:Il,hour:zt,minute:zt,timeZoneName:Il},Aie={year:zt,month:Il,day:zt,weekday:Il,hour:zt,minute:zt,second:zt,timeZoneName:Il};class OC{get type(){throw new md}get name(){throw new md}get ianaName(){return this.name}get isUniversal(){throw new md}offsetName(e,t){throw new md}formatOffset(e,t){throw new md}offset(e){throw new md}equals(e){throw new md}get isValid(){throw new md}}let K3=null;class k$ extends OC{static get instance(){return K3===null&&(K3=new k$),K3}get type(){return"system"}get name(){return new Intl.DateTimeFormat().resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Nie(e,t,r)}formatOffset(e,t){return a_(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return e.type==="system"}get isValid(){return!0}}let tI={};function Llt(n){return tI[n]||(tI[n]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:n,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),tI[n]}const zlt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function Blt(n,e){const t=n.format(e).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t),[,s,i,o,a,l,c,u]=r;return[o,s,i,a,l,c,u]}function Vlt(n,e){const t=n.formatToParts(e),r=[];for(let s=0;s<t.length;s++){const{type:i,value:o}=t[s],a=zlt[i];i==="era"?r[a]=o:fr(a)||(r[a]=parseInt(o,10))}return r}let ET={};class Lf extends OC{static create(e){return ET[e]||(ET[e]=new Lf(e)),ET[e]}static resetCache(){ET={},tI={}}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch{return!1}}constructor(e){super(),this.zoneName=e,this.valid=Lf.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Nie(e,t,r,this.name)}formatOffset(e,t){return a_(this.offset(e),t)}offset(e){const t=new Date(e);if(isNaN(t))return NaN;const r=Llt(this.name);let[s,i,o,a,l,c,u]=r.formatToParts?Vlt(r,t):Blt(r,t);a==="BC"&&(s=-Math.abs(s)+1);const f=E$({year:s,month:i,day:o,hour:l===24?0:l,minute:c,second:u,millisecond:0});let d=+t;const p=d%1e3;return d-=p>=0?p:1e3+p,(f-d)/(60*1e3)}equals(e){return e.type==="iana"&&e.name===this.name}get isValid(){return this.valid}}let oj={};function Ult(n,e={}){const t=JSON.stringify([n,e]);let r=oj[t];return r||(r=new Intl.ListFormat(n,e),oj[t]=r),r}let gF={};function yF(n,e={}){const t=JSON.stringify([n,e]);let r=gF[t];return r||(r=new Intl.DateTimeFormat(n,e),gF[t]=r),r}let bF={};function Wlt(n,e={}){const t=JSON.stringify([n,e]);let r=bF[t];return r||(r=new Intl.NumberFormat(n,e),bF[t]=r),r}let vF={};function Glt(n,e={}){const{base:t,...r}=e,s=JSON.stringify([n,r]);let i=vF[s];return i||(i=new Intl.RelativeTimeFormat(n,e),vF[s]=i),i}let F1=null;function Hlt(){return F1||(F1=new Intl.DateTimeFormat().resolvedOptions().locale,F1)}function jlt(n){const e=n.indexOf("-x-");e!==-1&&(n=n.substring(0,e));const t=n.indexOf("-u-");if(t===-1)return[n];{let r,s;try{r=yF(n).resolvedOptions(),s=n}catch{const l=n.substring(0,t);r=yF(l).resolvedOptions(),s=l}const{numberingSystem:i,calendar:o}=r;return[s,i,o]}}function qlt(n,e,t){return(t||e)&&(n.includes("-u-")||(n+="-u"),t&&(n+=`-ca-${t}`),e&&(n+=`-nu-${e}`)),n}function Xlt(n){const e=[];for(let t=1;t<=12;t++){const r=bn.utc(2009,t,1);e.push(n(r))}return e}function Klt(n){const e=[];for(let t=1;t<=7;t++){const r=bn.utc(2016,11,13+t);e.push(n(r))}return e}function IT(n,e,t,r){const s=n.listingMode();return s==="error"?null:s==="en"?t(e):r(e)}function Ylt(n){return n.numberingSystem&&n.numberingSystem!=="latn"?!1:n.numberingSystem==="latn"||!n.locale||n.locale.startsWith("en")||new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem==="latn"}class Zlt{constructor(e,t,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:s,floor:i,...o}=r;if(!t||Object.keys(o).length>0){const a={useGrouping:!1,...r};r.padTo>0&&(a.minimumIntegerDigits=r.padTo),this.inf=Wlt(e,a)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}else{const t=this.floor?Math.floor(e):H4(e,3);return vi(t,this.padTo)}}}class Jlt{constructor(e,t,r){this.opts=r,this.originalZone=void 0;let s;if(this.opts.timeZone)this.dt=e;else if(e.zone.type==="fixed"){const o=-1*(e.offset/60),a=o>=0?`Etc/GMT+${o}`:`Etc/GMT${o}`;e.offset!==0&&Lf.create(a).valid?(s=a,this.dt=e):(s="UTC",this.dt=e.offset===0?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else e.zone.type==="system"?this.dt=e:e.zone.type==="iana"?(this.dt=e,s=e.zone.name):(s="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const i={...this.opts};i.timeZone=i.timeZone||s,this.dtf=yF(t,i)}format(){return this.originalZone?this.formatToParts().map(({value:e})=>e).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map(t=>{if(t.type==="timeZoneName"){const r=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...t,value:r}}else return t}):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class Qlt{constructor(e,t,r){this.opts={style:"long",...r},!t&&Mie()&&(this.rtf=Glt(e,r))}format(e,t){return this.rtf?this.rtf.format(e,t):gct(t,e,this.opts.numeric,this.opts.style!=="long")}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}class ds{static fromOpts(e){return ds.create(e.locale,e.numberingSystem,e.outputCalendar,e.defaultToEN)}static create(e,t,r,s=!1){const i=e||yi.defaultLocale,o=i||(s?"en-US":Hlt()),a=t||yi.defaultNumberingSystem,l=r||yi.defaultOutputCalendar;return new ds(o,a,l,i)}static resetCache(){F1=null,gF={},bF={},vF={}}static fromObject({locale:e,numberingSystem:t,outputCalendar:r}={}){return ds.create(e,t,r)}constructor(e,t,r,s){const[i,o,a]=jlt(e);this.locale=i,this.numberingSystem=t||o||null,this.outputCalendar=r||a||null,this.intl=qlt(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=s,this.fastNumbersCached=null}get fastNumbers(){return this.fastNumbersCached==null&&(this.fastNumbersCached=Ylt(this)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=(this.numberingSystem===null||this.numberingSystem==="latn")&&(this.outputCalendar===null||this.outputCalendar==="gregory");return e&&t?"en":"intl"}clone(e){return!e||Object.getOwnPropertyNames(e).length===0?this:ds.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,e.defaultToEN||!1)}redefaultToEN(e={}){return this.clone({...e,defaultToEN:!0})}redefaultToSystem(e={}){return this.clone({...e,defaultToEN:!1})}months(e,t=!1){return IT(this,e,Pie,()=>{const r=t?{month:e,day:"numeric"}:{month:e},s=t?"format":"standalone";return this.monthsCache[s][e]||(this.monthsCache[s][e]=Xlt(i=>this.extract(i,r,"month"))),this.monthsCache[s][e]})}weekdays(e,t=!1){return IT(this,e,Fie,()=>{const r=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},s=t?"format":"standalone";return this.weekdaysCache[s][e]||(this.weekdaysCache[s][e]=Klt(i=>this.extract(i,r,"weekday"))),this.weekdaysCache[s][e]})}meridiems(){return IT(this,void 0,()=>Lie,()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[bn.utc(2016,11,13,9),bn.utc(2016,11,13,19)].map(t=>this.extract(t,e,"dayperiod"))}return this.meridiemCache})}eras(e){return IT(this,e,zie,()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[bn.utc(-40,1,1),bn.utc(2017,1,1)].map(r=>this.extract(r,t,"era"))),this.eraCache[e]})}extract(e,t,r){const s=this.dtFormatter(e,t),i=s.formatToParts(),o=i.find(a=>a.type.toLowerCase()===r);return o?o.value:null}numberFormatter(e={}){return new Zlt(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new Jlt(e,this.intl,t)}relFormatter(e={}){return new Qlt(this.intl,this.isEnglish(),e)}listFormatter(e={}){return Ult(this.intl,e)}isEnglish(){return this.locale==="en"||this.locale.toLowerCase()==="en-us"||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}}let Y3=null;class ga extends OC{static get utcInstance(){return Y3===null&&(Y3=new ga(0)),Y3}static instance(e){return e===0?ga.utcInstance:new ga(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new ga(I$(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return this.fixed===0?"UTC":`UTC${a_(this.fixed,"narrow")}`}get ianaName(){return this.fixed===0?"Etc/UTC":`Etc/GMT${a_(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return a_(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return e.type==="fixed"&&e.fixed===this.fixed}get isValid(){return!0}}class ect extends OC{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function Rd(n,e){if(fr(n)||n===null)return e;if(n instanceof OC)return n;if(tct(n)){const t=n.toLowerCase();return t==="default"?e:t==="local"||t==="system"?k$.instance:t==="utc"||t==="gmt"?ga.utcInstance:ga.parseSpecifier(t)||Lf.create(n)}else return tg(n)?ga.instance(n):typeof n=="object"&&"offset"in n&&typeof n.offset=="function"?n:new ect(n)}let aj=()=>Date.now(),lj="system",cj=null,uj=null,hj=null,fj=60,dj;class yi{static get now(){return aj}static set now(e){aj=e}static set defaultZone(e){lj=e}static get defaultZone(){return Rd(lj,k$.instance)}static get defaultLocale(){return cj}static set defaultLocale(e){cj=e}static get defaultNumberingSystem(){return uj}static set defaultNumberingSystem(e){uj=e}static get defaultOutputCalendar(){return hj}static set defaultOutputCalendar(e){hj=e}static get twoDigitCutoffYear(){return fj}static set twoDigitCutoffYear(e){fj=e%100}static get throwOnInvalid(){return dj}static set throwOnInvalid(e){dj=e}static resetCaches(){ds.resetCache(),Lf.resetCache()}}function fr(n){return typeof n>"u"}function tg(n){return typeof n=="number"}function T$(n){return typeof n=="number"&&n%1===0}function tct(n){return typeof n=="string"}function nct(n){return Object.prototype.toString.call(n)==="[object Date]"}function Mie(){try{return typeof Intl<"u"&&!!Intl.RelativeTimeFormat}catch{return!1}}function rct(n){return Array.isArray(n)?n:[n]}function pj(n,e,t){if(n.length!==0)return n.reduce((r,s)=>{const i=[e(s),s];return r&&t(r[0],i[0])===r[0]?r:i},null)[1]}function sct(n,e){return e.reduce((t,r)=>(t[r]=n[r],t),{})}function dv(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function Mf(n,e,t){return T$(n)&&n>=e&&n<=t}function ict(n,e){return n-e*Math.floor(n/e)}function vi(n,e=2){const t=n<0;let r;return t?r="-"+(""+-n).padStart(e,"0"):r=(""+n).padStart(e,"0"),r}function Nd(n){if(!(fr(n)||n===null||n===""))return parseInt(n,10)}function pm(n){if(!(fr(n)||n===null||n===""))return parseFloat(n)}function G4(n){if(!(fr(n)||n===null||n==="")){const e=parseFloat("0."+n)*1e3;return Math.floor(e)}}function H4(n,e,t=!1){const r=10**e;return(t?Math.trunc:Math.round)(n*r)/r}function FC(n){return n%4===0&&(n%100!==0||n%400===0)}function o_(n){return FC(n)?366:365}function _A(n,e){const t=ict(e-1,12)+1,r=n+(e-t)/12;return t===2?FC(r)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][t-1]}function E$(n){let e=Date.UTC(n.year,n.month-1,n.day,n.hour,n.minute,n.second,n.millisecond);return n.year<100&&n.year>=0&&(e=new Date(e),e.setUTCFullYear(n.year,n.month-1,n.day)),+e}function SA(n){const e=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7,t=n-1,r=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return e===4||r===3?53:52}function wF(n){return n>99?n:n>yi.twoDigitCutoffYear?1900+n:2e3+n}function Nie(n,e,t,r=null){const s=new Date(n),i={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(i.timeZone=r);const o={timeZoneName:e,...i},a=new Intl.DateTimeFormat(t,o).formatToParts(s).find(l=>l.type.toLowerCase()==="timezonename");return a?a.value:null}function I$(n,e){let t=parseInt(n,10);Number.isNaN(t)&&(t=0);const r=parseInt(e,10)||0,s=t<0||Object.is(t,-0)?-r:r;return t*60+s}function $ie(n){const e=Number(n);if(typeof n=="boolean"||n===""||Number.isNaN(e))throw new cc(`Invalid unit value ${n}`);return e}function CA(n,e){const t={};for(const r in n)if(dv(n,r)){const s=n[r];if(s==null)continue;t[e(r)]=$ie(s)}return t}function a_(n,e){const t=Math.trunc(Math.abs(n/60)),r=Math.trunc(Math.abs(n%60)),s=n>=0?"+":"-";switch(e){case"short":return`${s}${vi(t,2)}:${vi(r,2)}`;case"narrow":return`${s}${t}${r>0?`:${r}`:""}`;case"techie":return`${s}${vi(t,2)}${vi(r,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function A$(n){return sct(n,["hour","minute","second","millisecond"])}const oct=["January","February","March","April","May","June","July","August","September","October","November","December"],Rie=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],act=["J","F","M","A","M","J","J","A","S","O","N","D"];function Pie(n){switch(n){case"narrow":return[...act];case"short":return[...Rie];case"long":return[...oct];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const Die=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],Oie=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],lct=["M","T","W","T","F","S","S"];function Fie(n){switch(n){case"narrow":return[...lct];case"short":return[...Oie];case"long":return[...Die];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const Lie=["AM","PM"],cct=["Before Christ","Anno Domini"],uct=["BC","AD"],hct=["B","A"];function zie(n){switch(n){case"narrow":return[...hct];case"short":return[...uct];case"long":return[...cct];default:return null}}function fct(n){return Lie[n.hour<12?0:1]}function dct(n,e){return Fie(e)[n.weekday-1]}function pct(n,e){return Pie(e)[n.month-1]}function mct(n,e){return zie(e)[n.year<0?0:1]}function gct(n,e,t="always",r=!1){const s={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},i=["hours","minutes","seconds"].indexOf(n)===-1;if(t==="auto"&&i){const h=n==="days";switch(e){case 1:return h?"tomorrow":`next ${s[n][0]}`;case-1:return h?"yesterday":`last ${s[n][0]}`;case 0:return h?"today":`this ${s[n][0]}`}}const o=Object.is(e,-0)||e<0,a=Math.abs(e),l=a===1,c=s[n],u=r?l?c[1]:c[2]||c[1]:l?s[n][0]:n;return o?`${a} ${u} ago`:`in ${a} ${u}`}function mj(n,e){let t="";for(const r of n)r.literal?t+=r.val:t+=e(r.val);return t}const yct={D:xA,DD:hie,DDD:fie,DDDD:die,t:pie,tt:mie,ttt:gie,tttt:yie,T:bie,TT:vie,TTT:wie,TTTT:xie,f:_ie,ff:Cie,fff:Tie,ffff:Iie,F:Sie,FF:kie,FFF:Eie,FFFF:Aie};class Ho{static create(e,t={}){return new Ho(e,t)}static parseFormat(e){let t=null,r="",s=!1;const i=[];for(let o=0;o<e.length;o++){const a=e.charAt(o);a==="'"?(r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),t=null,r="",s=!s):s||a===t?r+=a:(r.length>0&&i.push({literal:/^\s+$/.test(r),val:r}),r=a,t=a)}return r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),i}static macroTokenToFormatOpts(e){return yct[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){return this.systemLoc===null&&(this.systemLoc=this.loc.redefaultToSystem()),this.systemLoc.dtFormatter(e,{...this.opts,...t}).format()}dtFormatter(e,t={}){return this.loc.dtFormatter(e,{...this.opts,...t})}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return vi(e,t);const r={...this.opts};return t>0&&(r.padTo=t),this.loc.numberFormatter(r).format(e)}formatDateTimeFromString(e,t){const r=this.loc.listingMode()==="en",s=this.loc.outputCalendar&&this.loc.outputCalendar!=="gregory",i=(d,p)=>this.loc.extract(e,d,p),o=d=>e.isOffsetFixed&&e.offset===0&&d.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,d.format):"",a=()=>r?fct(e):i({hour:"numeric",hourCycle:"h12"},"dayperiod"),l=(d,p)=>r?pct(e,d):i(p?{month:d}:{month:d,day:"numeric"},"month"),c=(d,p)=>r?dct(e,d):i(p?{weekday:d}:{weekday:d,month:"long",day:"numeric"},"weekday"),u=d=>{const p=Ho.macroTokenToFormatOpts(d);return p?this.formatWithSystemDefault(e,p):d},h=d=>r?mct(e,d):i({era:d},"era"),f=d=>{switch(d){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return o({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return o({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return o({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return a();case"d":return s?i({day:"numeric"},"day"):this.num(e.day);case"dd":return s?i({day:"2-digit"},"day"):this.num(e.day,2);case"c":return this.num(e.weekday);case"ccc":return c("short",!0);case"cccc":return c("long",!0);case"ccccc":return c("narrow",!0);case"E":return this.num(e.weekday);case"EEE":return c("short",!1);case"EEEE":return c("long",!1);case"EEEEE":return c("narrow",!1);case"L":return s?i({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return s?i({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return l("short",!0);case"LLLL":return l("long",!0);case"LLLLL":return l("narrow",!0);case"M":return s?i({month:"numeric"},"month"):this.num(e.month);case"MM":return s?i({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return l("short",!1);case"MMMM":return l("long",!1);case"MMMMM":return l("narrow",!1);case"y":return s?i({year:"numeric"},"year"):this.num(e.year);case"yy":return s?i({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return s?i({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return s?i({year:"numeric"},"year"):this.num(e.year,6);case"G":return h("short");case"GG":return h("long");case"GGGGG":return h("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return u(d)}};return mj(Ho.parseFormat(t),f)}formatDurationFromString(e,t){const r=l=>{switch(l[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},s=l=>c=>{const u=r(c);return u?this.num(l.get(u),c.length):c},i=Ho.parseFormat(t),o=i.reduce((l,{literal:c,val:u})=>c?l:l.concat(u),[]),a=e.shiftTo(...o.map(r).filter(l=>l));return mj(i,s(a))}}class du{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const Bie=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function tx(...n){const e=n.reduce((t,r)=>t+r.source,"");return RegExp(`^${e}$`)}function nx(...n){return e=>n.reduce(([t,r,s],i)=>{const[o,a,l]=i(e,s);return[{...t,...o},a||r,l]},[{},null,1]).slice(0,2)}function rx(n,...e){if(n==null)return[null,null];for(const[t,r]of e){const s=t.exec(n);if(s)return r(s)}return[null,null]}function Vie(...n){return(e,t)=>{const r={};let s;for(s=0;s<n.length;s++)r[n[s]]=Nd(e[t+s]);return[r,null,t+s]}}const Uie=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,bct=`(?:${Uie.source}?(?:\\[(${Bie.source})\\])?)?`,j4=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,Wie=RegExp(`${j4.source}${bct}`),q4=RegExp(`(?:T${Wie.source})?`),vct=/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,wct=/(\d{4})-?W(\d\d)(?:-?(\d))?/,xct=/(\d{4})-?(\d{3})/,_ct=Vie("weekYear","weekNumber","weekDay"),Sct=Vie("year","ordinal"),Cct=/(\d{4})-(\d\d)-(\d\d)/,Gie=RegExp(`${j4.source} ?(?:${Uie.source}|(${Bie.source}))?`),kct=RegExp(`(?: ${Gie.source})?`);function Fb(n,e,t){const r=n[e];return fr(r)?t:Nd(r)}function Tct(n,e){return[{year:Fb(n,e),month:Fb(n,e+1,1),day:Fb(n,e+2,1)},null,e+3]}function sx(n,e){return[{hours:Fb(n,e,0),minutes:Fb(n,e+1,0),seconds:Fb(n,e+2,0),milliseconds:G4(n[e+3])},null,e+4]}function LC(n,e){const t=!n[e]&&!n[e+1],r=I$(n[e+1],n[e+2]),s=t?null:ga.instance(r);return[{},s,e+3]}function zC(n,e){const t=n[e]?Lf.create(n[e]):null;return[{},t,e+1]}const Ect=RegExp(`^T?${j4.source}$`),Ict=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function Act(n){const[e,t,r,s,i,o,a,l,c]=n,u=e[0]==="-",h=l&&l[0]==="-",f=(d,p=!1)=>d!==void 0&&(p||d&&u)?-d:d;return[{years:f(pm(t)),months:f(pm(r)),weeks:f(pm(s)),days:f(pm(i)),hours:f(pm(o)),minutes:f(pm(a)),seconds:f(pm(l),l==="-0"),milliseconds:f(G4(c),h)}]}const Mct={GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function X4(n,e,t,r,s,i,o){const a={year:e.length===2?wF(Nd(e)):Nd(e),month:Rie.indexOf(t)+1,day:Nd(r),hour:Nd(s),minute:Nd(i)};return o&&(a.second=Nd(o)),n&&(a.weekday=n.length>3?Die.indexOf(n)+1:Oie.indexOf(n)+1),a}const Nct=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function $ct(n){const[,e,t,r,s,i,o,a,l,c,u,h]=n,f=X4(e,s,r,t,i,o,a);let d;return l?d=Mct[l]:c?d=0:d=I$(u,h),[f,new ga(d)]}function Rct(n){return n.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}const Pct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,Dct=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,Oct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function gj(n){const[,e,t,r,s,i,o,a]=n;return[X4(e,s,r,t,i,o,a),ga.utcInstance]}function Fct(n){const[,e,t,r,s,i,o,a]=n;return[X4(e,a,t,r,s,i,o),ga.utcInstance]}const Lct=tx(vct,q4),zct=tx(wct,q4),Bct=tx(xct,q4),Vct=tx(Wie),Hie=nx(Tct,sx,LC,zC),Uct=nx(_ct,sx,LC,zC),Wct=nx(Sct,sx,LC,zC),Gct=nx(sx,LC,zC);function Hct(n){return rx(n,[Lct,Hie],[zct,Uct],[Bct,Wct],[Vct,Gct])}function jct(n){return rx(Rct(n),[Nct,$ct])}function qct(n){return rx(n,[Pct,gj],[Dct,gj],[Oct,Fct])}function Xct(n){return rx(n,[Ict,Act])}const Kct=nx(sx);function Yct(n){return rx(n,[Ect,Kct])}const Zct=tx(Cct,kct),Jct=tx(Gie),Qct=nx(sx,LC,zC);function eut(n){return rx(n,[Zct,Hie],[Jct,Qct])}const yj="Invalid Duration",jie={weeks:{days:7,hours:7*24,minutes:7*24*60,seconds:7*24*60*60,milliseconds:7*24*60*60*1e3},days:{hours:24,minutes:24*60,seconds:24*60*60,milliseconds:24*60*60*1e3},hours:{minutes:60,seconds:60*60,milliseconds:60*60*1e3},minutes:{seconds:60,milliseconds:60*1e3},seconds:{milliseconds:1e3}},tut={years:{quarters:4,months:12,weeks:52,days:365,hours:365*24,minutes:365*24*60,seconds:365*24*60*60,milliseconds:365*24*60*60*1e3},quarters:{months:3,weeks:13,days:91,hours:91*24,minutes:91*24*60,seconds:91*24*60*60,milliseconds:91*24*60*60*1e3},months:{weeks:4,days:30,hours:30*24,minutes:30*24*60,seconds:30*24*60*60,milliseconds:30*24*60*60*1e3},...jie},tc=146097/400,U0=146097/4800,nut={years:{quarters:4,months:12,weeks:tc/7,days:tc,hours:tc*24,minutes:tc*24*60,seconds:tc*24*60*60,milliseconds:tc*24*60*60*1e3},quarters:{months:3,weeks:tc/28,days:tc/4,hours:tc*24/4,minutes:tc*24*60/4,seconds:tc*24*60*60/4,milliseconds:tc*24*60*60*1e3/4},months:{weeks:U0/7,days:U0,hours:U0*24,minutes:U0*24*60,seconds:U0*24*60*60,milliseconds:U0*24*60*60*1e3},...jie},jm=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],rut=jm.slice(0).reverse();function gd(n,e,t=!1){const r={values:t?e.values:{...n.values,...e.values||{}},loc:n.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||n.conversionAccuracy,matrix:e.matrix||n.matrix};return new Sr(r)}function qie(n,e){let t=e.milliseconds??0;for(const r of rut.slice(1))e[r]&&(t+=e[r]*n[r].milliseconds);return t}function bj(n,e){const t=qie(n,e)<0?-1:1;jm.reduceRight((r,s)=>{if(fr(e[s]))return r;if(r){const i=e[r]*t,o=n[s][r],a=Math.floor(i/o);e[s]+=a*t,e[r]-=a*o*t}return s},null),jm.reduce((r,s)=>{if(fr(e[s]))return r;if(r){const i=e[r]%1;e[r]-=i,e[s]+=i*n[r][s]}return s},null)}function sut(n){const e={};for(const[t,r]of Object.entries(n))r!==0&&(e[t]=r);return e}class Sr{constructor(e){const t=e.conversionAccuracy==="longterm"||!1;let r=t?nut:tut;e.matrix&&(r=e.matrix),this.values=e.values,this.loc=e.loc||ds.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(e,t){return Sr.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(e==null||typeof e!="object")throw new cc(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);return new Sr({values:CA(e,Sr.normalizeUnit),loc:ds.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(tg(e))return Sr.fromMillis(e);if(Sr.isDuration(e))return e;if(typeof e=="object")return Sr.fromObject(e);throw new cc(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[r]=Xct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[r]=Yct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new cc("need to specify a reason the Duration is invalid");const r=e instanceof du?e:new du(e,t);if(yi.throwOnInvalid)throw new Dlt(r);return new Sr({invalid:r})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e&&e.toLowerCase()];if(!t)throw new uie(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){const r={...t,floor:t.round!==!1&&t.floor!==!1};return this.isValid?Ho.create(this.loc,r).formatDurationFromString(this,e):yj}toHuman(e={}){if(!this.isValid)return yj;const t=jm.map(r=>{const s=this.values[r];return fr(s)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...e,unit:r.slice(0,-1)}).format(s)}).filter(r=>r);return this.loc.listFormatter({type:"conjunction",style:e.listStyle||"narrow",...e}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let e="P";return this.years!==0&&(e+=this.years+"Y"),(this.months!==0||this.quarters!==0)&&(e+=this.months+this.quarters*3+"M"),this.weeks!==0&&(e+=this.weeks+"W"),this.days!==0&&(e+=this.days+"D"),(this.hours!==0||this.minutes!==0||this.seconds!==0||this.milliseconds!==0)&&(e+="T"),this.hours!==0&&(e+=this.hours+"H"),this.minutes!==0&&(e+=this.minutes+"M"),(this.seconds!==0||this.milliseconds!==0)&&(e+=H4(this.seconds+this.milliseconds/1e3,3)+"S"),e==="P"&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;const t=this.toMillis();return t<0||t>=864e5?null:(e={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...e,includeOffset:!1},bn.fromMillis(t,{zone:"UTC"}).toISOTime(e))}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.isValid?qie(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e),r={};for(const s of jm)(dv(t.values,s)||dv(this.values,s))&&(r[s]=t.get(s)+this.get(s));return gd(this,{values:r},!0)}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const r of Object.keys(this.values))t[r]=$ie(e(this.values[r],r));return gd(this,{values:t},!0)}get(e){return this[Sr.normalizeUnit(e)]}set(e){if(!this.isValid)return this;const t={...this.values,...CA(e,Sr.normalizeUnit)};return gd(this,{values:t})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:r,matrix:s}={}){const o={loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:s,conversionAccuracy:r};return gd(this,o)}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return bj(this.matrix,e),gd(this,{values:e},!0)}rescale(){if(!this.isValid)return this;const e=sut(this.normalize().shiftToAll().toObject());return gd(this,{values:e},!0)}shiftTo(...e){if(!this.isValid)return this;if(e.length===0)return this;e=e.map(o=>Sr.normalizeUnit(o));const t={},r={},s=this.toObject();let i;for(const o of jm)if(e.indexOf(o)>=0){i=o;let a=0;for(const c in r)a+=this.matrix[c][o]*r[c],r[c]=0;tg(s[o])&&(a+=s[o]);const l=Math.trunc(a);t[o]=l,r[o]=(a*1e3-l*1e3)/1e3}else tg(s[o])&&(r[o]=s[o]);for(const o in r)r[o]!==0&&(t[i]+=o===i?r[o]:r[o]/this.matrix[i][o]);return bj(this.matrix,t),gd(this,{values:t},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=this.values[t]===0?0:-this.values[t];return gd(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid||!this.loc.equals(e.loc))return!1;function t(r,s){return r===void 0||r===0?s===void 0||s===0:r===s}for(const r of jm)if(!t(this.values[r],e.values[r]))return!1;return!0}}const W0="Invalid Interval";function iut(n,e){return!n||!n.isValid?Hs.invalid("missing or invalid start"):!e||!e.isValid?Hs.invalid("missing or invalid end"):e<n?Hs.invalid("end before start",`The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`):null}class Hs{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new cc("need to specify a reason the Interval is invalid");const r=e instanceof du?e:new du(e,t);if(yi.throwOnInvalid)throw new Plt(r);return new Hs({invalid:r})}static fromDateTimes(e,t){const r=r1(e),s=r1(t),i=iut(r,s);return i??new Hs({start:r,end:s})}static after(e,t){const r=Sr.fromDurationLike(t),s=r1(e);return Hs.fromDateTimes(s,s.plus(r))}static before(e,t){const r=Sr.fromDurationLike(t),s=r1(e);return Hs.fromDateTimes(s.minus(r),s)}static fromISO(e,t){const[r,s]=(e||"").split("/",2);if(r&&s){let i,o;try{i=bn.fromISO(r,t),o=i.isValid}catch{o=!1}let a,l;try{a=bn.fromISO(s,t),l=a.isValid}catch{l=!1}if(o&&l)return Hs.fromDateTimes(i,a);if(o){const c=Sr.fromISO(s,t);if(c.isValid)return Hs.after(i,c)}else if(l){const c=Sr.fromISO(r,t);if(c.isValid)return Hs.before(a,c)}}return Hs.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return this.invalidReason===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds"){if(!this.isValid)return NaN;const t=this.start.startOf(e),r=this.end.startOf(e);return Math.floor(r.diff(t,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return this.isValid?this.isEmpty()||this.e.minus(1).hasSame(this.s,e):!1}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return this.isValid?this.s>e:!1}isBefore(e){return this.isValid?this.e<=e:!1}contains(e){return this.isValid?this.s<=e&&this.e>e:!1}set({start:e,end:t}={}){return this.isValid?Hs.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];const t=e.map(r1).filter(o=>this.contains(o)).sort(),r=[];let{s}=this,i=0;for(;s<this.e;){const o=t[i]||this.e,a=+o>+this.e?this.e:o;r.push(Hs.fromDateTimes(s,a)),s=a,i+=1}return r}splitBy(e){const t=Sr.fromDurationLike(e);if(!this.isValid||!t.isValid||t.as("milliseconds")===0)return[];let{s:r}=this,s=1,i;const o=[];for(;r<this.e;){const a=this.start.plus(t.mapUnits(l=>l*s));i=+a>+this.e?this.e:a,o.push(Hs.fromDateTimes(r,i)),r=i,s+=1}return o}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return this.isValid?+this.e==+e.s:!1}abutsEnd(e){return this.isValid?+e.e==+this.s:!1}engulfs(e){return this.isValid?this.s<=e.s&&this.e>=e.e:!1}equals(e){return!this.isValid||!e.isValid?!1:this.s.equals(e.s)&&this.e.equals(e.e)}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,r=this.e<e.e?this.e:e.e;return t>=r?null:Hs.fromDateTimes(t,r)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,r=this.e>e.e?this.e:e.e;return Hs.fromDateTimes(t,r)}static merge(e){const[t,r]=e.sort((s,i)=>s.s-i.s).reduce(([s,i],o)=>i?i.overlaps(o)||i.abutsStart(o)?[s,i.union(o)]:[s.concat([i]),o]:[s,o],[[],null]);return r&&t.push(r),t}static xor(e){let t=null,r=0;const s=[],i=e.map(l=>[{time:l.s,type:"s"},{time:l.e,type:"e"}]),o=Array.prototype.concat(...i),a=o.sort((l,c)=>l.time-c.time);for(const l of a)r+=l.type==="s"?1:-1,r===1?t=l.time:(t&&+t!=+l.time&&s.push(Hs.fromDateTimes(t,l.time)),t=null);return Hs.merge(s)}difference(...e){return Hs.xor([this].concat(e)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:W0}toLocaleString(e=xA,t={}){return this.isValid?Ho.create(this.s.loc.clone(t),e).formatInterval(this):W0}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:W0}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:W0}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:W0}toFormat(e,{separator:t=" – "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:W0}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):Sr.invalid(this.invalidReason)}mapEndpoints(e){return Hs.fromDateTimes(e(this.s),e(this.e))}}class AT{static hasDST(e=yi.defaultZone){const t=bn.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return Lf.isValidZone(e)}static normalizeZone(e){return Rd(e,yi.defaultZone)}static months(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return ds.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return ds.create(t,null,"gregory").eras(e)}static features(){return{relative:Mie()}}}function vj(n,e){const t=s=>s.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=t(e)-t(n);return Math.floor(Sr.fromMillis(r).as("days"))}function out(n,e,t){const r=[["years",(l,c)=>c.year-l.year],["quarters",(l,c)=>c.quarter-l.quarter+(c.year-l.year)*4],["months",(l,c)=>c.month-l.month+(c.year-l.year)*12],["weeks",(l,c)=>{const u=vj(l,c);return(u-u%7)/7}],["days",vj]],s={},i=n;let o,a;for(const[l,c]of r)t.indexOf(l)>=0&&(o=l,s[l]=c(n,e),a=i.plus(s),a>e?(s[l]--,n=i.plus(s),n>e&&(a=n,s[l]--,n=i.plus(s))):n=a);return[n,s,a,o]}function aut(n,e,t,r){let[s,i,o,a]=out(n,e,t);const l=e-s,c=t.filter(h=>["hours","minutes","seconds","milliseconds"].indexOf(h)>=0);c.length===0&&(o<e&&(o=s.plus({[a]:1})),o!==s&&(i[a]=(i[a]||0)+l/(o-s)));const u=Sr.fromObject(i,r);return c.length>0?Sr.fromMillis(l,r).shiftTo(...c).plus(u):u}const K4={arab:"[٠-٩]",arabext:"[۰-۹]",bali:"[᭐-᭙]",beng:"[০-৯]",deva:"[०-९]",fullwide:"[０-９]",gujr:"[૦-૯]",hanidec:"[〇|一|二|三|四|五|六|七|八|九]",khmr:"[០-៩]",knda:"[೦-೯]",laoo:"[໐-໙]",limb:"[᥆-᥏]",mlym:"[൦-൯]",mong:"[᠐-᠙]",mymr:"[၀-၉]",orya:"[୦-୯]",tamldec:"[௦-௯]",telu:"[౦-౯]",thai:"[๐-๙]",tibt:"[༠-༩]",latn:"\\d"},wj={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},lut=K4.hanidec.replace(/[\[|\]]/g,"").split("");function cut(n){let e=parseInt(n,10);if(isNaN(e)){e="";for(let t=0;t<n.length;t++){const r=n.charCodeAt(t);if(n[t].search(K4.hanidec)!==-1)e+=lut.indexOf(n[t]);else for(const s in wj){const[i,o]=wj[s];r>=i&&r<=o&&(e+=r-i)}}return parseInt(e,10)}else return e}function Kc({numberingSystem:n},e=""){return new RegExp(`${K4[n||"latn"]}${e}`)}const uut="missing Intl.DateTimeFormat.formatToParts support";function Ir(n,e=t=>t){return{regex:n,deser:([t])=>e(cut(t))}}const hut=String.fromCharCode(160),Xie=`[ ${hut}]`,Kie=new RegExp(Xie,"g");function fut(n){return n.replace(/\./g,"\\.?").replace(Kie,Xie)}function xj(n){return n.replace(/\./g,"").replace(Kie," ").toLowerCase()}function Yc(n,e){return n===null?null:{regex:RegExp(n.map(fut).join("|")),deser:([t])=>n.findIndex(r=>xj(t)===xj(r))+e}}function _j(n,e){return{regex:n,deser:([,t,r])=>I$(t,r),groups:e}}function MT(n){return{regex:n,deser:([e])=>e}}function dut(n){return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}function put(n,e){const t=Kc(e),r=Kc(e,"{2}"),s=Kc(e,"{3}"),i=Kc(e,"{4}"),o=Kc(e,"{6}"),a=Kc(e,"{1,2}"),l=Kc(e,"{1,3}"),c=Kc(e,"{1,6}"),u=Kc(e,"{1,9}"),h=Kc(e,"{2,4}"),f=Kc(e,"{4,6}"),d=g=>({regex:RegExp(dut(g.val)),deser:([y])=>y,literal:!0}),m=(g=>{if(n.literal)return d(g);switch(g.val){case"G":return Yc(e.eras("short"),0);case"GG":return Yc(e.eras("long"),0);case"y":return Ir(c);case"yy":return Ir(h,wF);case"yyyy":return Ir(i);case"yyyyy":return Ir(f);case"yyyyyy":return Ir(o);case"M":return Ir(a);case"MM":return Ir(r);case"MMM":return Yc(e.months("short",!0),1);case"MMMM":return Yc(e.months("long",!0),1);case"L":return Ir(a);case"LL":return Ir(r);case"LLL":return Yc(e.months("short",!1),1);case"LLLL":return Yc(e.months("long",!1),1);case"d":return Ir(a);case"dd":return Ir(r);case"o":return Ir(l);case"ooo":return Ir(s);case"HH":return Ir(r);case"H":return Ir(a);case"hh":return Ir(r);case"h":return Ir(a);case"mm":return Ir(r);case"m":return Ir(a);case"q":return Ir(a);case"qq":return Ir(r);case"s":return Ir(a);case"ss":return Ir(r);case"S":return Ir(l);case"SSS":return Ir(s);case"u":return MT(u);case"uu":return MT(a);case"uuu":return Ir(t);case"a":return Yc(e.meridiems(),0);case"kkkk":return Ir(i);case"kk":return Ir(h,wF);case"W":return Ir(a);case"WW":return Ir(r);case"E":case"c":return Ir(t);case"EEE":return Yc(e.weekdays("short",!1),1);case"EEEE":return Yc(e.weekdays("long",!1),1);case"ccc":return Yc(e.weekdays("short",!0),1);case"cccc":return Yc(e.weekdays("long",!0),1);case"Z":case"ZZ":return _j(new RegExp(`([+-]${a.source})(?::(${r.source}))?`),2);case"ZZZ":return _j(new RegExp(`([+-]${a.source})(${r.source})?`),2);case"z":return MT(/[a-z_+-/]{1,256}?/i);case" ":return MT(/[^\S\n\r]/);default:return d(g)}})(n)||{invalidReason:uut};return m.token=n,m}const mut={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};function gut(n,e,t){const{type:r,value:s}=n;if(r==="literal"){const l=/^\s+$/.test(s);return{literal:!l,val:l?" ":s}}const i=e[r];let o=r;r==="hour"&&(e.hour12!=null?o=e.hour12?"hour12":"hour24":e.hourCycle!=null?e.hourCycle==="h11"||e.hourCycle==="h12"?o="hour12":o="hour24":o=t.hour12?"hour12":"hour24");let a=mut[o];if(typeof a=="object"&&(a=a[i]),a)return{literal:!1,val:a}}function yut(n){return[`^${n.map(t=>t.regex).reduce((t,r)=>`${t}(${r.source})`,"")}$`,n]}function but(n,e,t){const r=n.match(e);if(r){const s={};let i=1;for(const o in t)if(dv(t,o)){const a=t[o],l=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(r.slice(i,i+l))),i+=l}return[r,s]}else return[r,{}]}function vut(n){const e=i=>{switch(i){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}};let t=null,r;return fr(n.z)||(t=Lf.create(n.z)),fr(n.Z)||(t||(t=new ga(n.Z)),r=n.Z),fr(n.q)||(n.M=(n.q-1)*3+1),fr(n.h)||(n.h<12&&n.a===1?n.h+=12:n.h===12&&n.a===0&&(n.h=0)),n.G===0&&n.y&&(n.y=-n.y),fr(n.u)||(n.S=G4(n.u)),[Object.keys(n).reduce((i,o)=>{const a=e(o);return a&&(i[a]=n[o]),i},{}),t,r]}let Z3=null;function wut(){return Z3||(Z3=bn.fromMillis(1555555555555)),Z3}function xut(n,e){if(n.literal)return n;const t=Ho.macroTokenToFormatOpts(n.val),r=Jie(t,e);return r==null||r.includes(void 0)?n:r}function Yie(n,e){return Array.prototype.concat(...n.map(t=>xut(t,e)))}function Zie(n,e,t){const r=Yie(Ho.parseFormat(t),n),s=r.map(o=>put(o,n)),i=s.find(o=>o.invalidReason);if(i)return{input:e,tokens:r,invalidReason:i.invalidReason};{const[o,a]=yut(s),l=RegExp(o,"i"),[c,u]=but(e,l,a),[h,f,d]=u?vut(u):[null,null,void 0];if(dv(u,"a")&&dv(u,"H"))throw new O1("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:r,regex:l,rawMatches:c,matches:u,result:h,zone:f,specificOffset:d}}}function _ut(n,e,t){const{result:r,zone:s,specificOffset:i,invalidReason:o}=Zie(n,e,t);return[r,s,i,o]}function Jie(n,e){if(!n)return null;const r=Ho.create(e,n).dtFormatter(wut()),s=r.formatToParts(),i=r.resolvedOptions();return s.map(o=>gut(o,n,i))}const Qie=[0,31,59,90,120,151,181,212,243,273,304,334],eoe=[0,31,60,91,121,152,182,213,244,274,305,335];function bc(n,e){return new du("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`)}function toe(n,e,t){const r=new Date(Date.UTC(n,e-1,t));n<100&&n>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const s=r.getUTCDay();return s===0?7:s}function noe(n,e,t){return t+(FC(n)?eoe:Qie)[e-1]}function roe(n,e){const t=FC(n)?eoe:Qie,r=t.findIndex(i=>i<e),s=e-t[r];return{month:r+1,day:s}}function xF(n){const{year:e,month:t,day:r}=n,s=noe(e,t,r),i=toe(e,t,r);let o=Math.floor((s-i+10)/7),a;return o<1?(a=e-1,o=SA(a)):o>SA(e)?(a=e+1,o=1):a=e,{weekYear:a,weekNumber:o,weekday:i,...A$(n)}}function Sj(n){const{weekYear:e,weekNumber:t,weekday:r}=n,s=toe(e,1,4),i=o_(e);let o=t*7+r-s-3,a;o<1?(a=e-1,o+=o_(a)):o>i?(a=e+1,o-=o_(e)):a=e;const{month:l,day:c}=roe(a,o);return{year:a,month:l,day:c,...A$(n)}}function J3(n){const{year:e,month:t,day:r}=n,s=noe(e,t,r);return{year:e,ordinal:s,...A$(n)}}function Cj(n){const{year:e,ordinal:t}=n,{month:r,day:s}=roe(e,t);return{year:e,month:r,day:s,...A$(n)}}function Sut(n){const e=T$(n.weekYear),t=Mf(n.weekNumber,1,SA(n.weekYear)),r=Mf(n.weekday,1,7);return e?t?r?!1:bc("weekday",n.weekday):bc("week",n.week):bc("weekYear",n.weekYear)}function Cut(n){const e=T$(n.year),t=Mf(n.ordinal,1,o_(n.year));return e?t?!1:bc("ordinal",n.ordinal):bc("year",n.year)}function soe(n){const e=T$(n.year),t=Mf(n.month,1,12),r=Mf(n.day,1,_A(n.year,n.month));return e?t?r?!1:bc("day",n.day):bc("month",n.month):bc("year",n.year)}function ioe(n){const{hour:e,minute:t,second:r,millisecond:s}=n,i=Mf(e,0,23)||e===24&&t===0&&r===0&&s===0,o=Mf(t,0,59),a=Mf(r,0,59),l=Mf(s,0,999);return i?o?a?l?!1:bc("millisecond",s):bc("second",r):bc("minute",t):bc("hour",e)}const Q3="Invalid DateTime",kj=864e13;function NT(n){return new du("unsupported zone",`the zone "${n.name}" is not supported`)}function eP(n){return n.weekData===null&&(n.weekData=xF(n.c)),n.weekData}function mm(n,e){const t={ts:n.ts,zone:n.zone,c:n.c,o:n.o,loc:n.loc,invalid:n.invalid};return new bn({...t,...e,old:t})}function ooe(n,e,t){let r=n-e*60*1e3;const s=t.offset(r);if(e===s)return[r,e];r-=(s-e)*60*1e3;const i=t.offset(r);return s===i?[r,s]:[n-Math.min(s,i)*60*1e3,Math.max(s,i)]}function $T(n,e){n+=e*60*1e3;const t=new Date(n);return{year:t.getUTCFullYear(),month:t.getUTCMonth()+1,day:t.getUTCDate(),hour:t.getUTCHours(),minute:t.getUTCMinutes(),second:t.getUTCSeconds(),millisecond:t.getUTCMilliseconds()}}function nI(n,e,t){return ooe(E$(n),e,t)}function Tj(n,e){const t=n.o,r=n.c.year+Math.trunc(e.years),s=n.c.month+Math.trunc(e.months)+Math.trunc(e.quarters)*3,i={...n.c,year:r,month:s,day:Math.min(n.c.day,_A(r,s))+Math.trunc(e.days)+Math.trunc(e.weeks)*7},o=Sr.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=E$(i);let[l,c]=ooe(a,t,n.zone);return o!==0&&(l+=o,c=n.zone.offset(l)),{ts:l,o:c}}function n1(n,e,t,r,s,i){const{setZone:o,zone:a}=t;if(n&&Object.keys(n).length!==0||e){const l=e||a,c=bn.fromObject(n,{...t,zone:l,specificOffset:i});return o?c:c.setZone(a)}else return bn.invalid(new du("unparsable",`the input "${s}" can't be parsed as ${r}`))}function RT(n,e,t=!0){return n.isValid?Ho.create(ds.create("en-US"),{allowZ:t,forceSimple:!0}).formatDateTimeFromString(n,e):null}function tP(n,e){const t=n.c.year>9999||n.c.year<0;let r="";return t&&n.c.year>=0&&(r+="+"),r+=vi(n.c.year,t?6:4),e?(r+="-",r+=vi(n.c.month),r+="-",r+=vi(n.c.day)):(r+=vi(n.c.month),r+=vi(n.c.day)),r}function Ej(n,e,t,r,s,i){let o=vi(n.c.hour);return e?(o+=":",o+=vi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=":")):o+=vi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=vi(n.c.second),(n.c.millisecond!==0||!r)&&(o+=".",o+=vi(n.c.millisecond,3))),s&&(n.isOffsetFixed&&n.offset===0&&!i?o+="Z":n.o<0?(o+="-",o+=vi(Math.trunc(-n.o/60)),o+=":",o+=vi(Math.trunc(-n.o%60))):(o+="+",o+=vi(Math.trunc(n.o/60)),o+=":",o+=vi(Math.trunc(n.o%60)))),i&&(o+="["+n.zone.ianaName+"]"),o}const aoe={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},kut={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},Tut={ordinal:1,hour:0,minute:0,second:0,millisecond:0},loe=["year","month","day","hour","minute","second","millisecond"],Eut=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],Iut=["year","ordinal","hour","minute","second","millisecond"];function Ij(n){const e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[n.toLowerCase()];if(!e)throw new uie(n);return e}function Aj(n,e){const t=Rd(e.zone,yi.defaultZone),r=ds.fromObject(e),s=yi.now();let i,o;if(fr(n.year))i=s;else{for(const c of loe)fr(n[c])&&(n[c]=aoe[c]);const a=soe(n)||ioe(n);if(a)return bn.invalid(a);const l=t.offset(s);[i,o]=nI(n,l,t)}return new bn({ts:i,zone:t,loc:r,o})}function Mj(n,e,t){const r=fr(t.round)?!0:t.round,s=(o,a)=>(o=H4(o,r||t.calendary?0:2,!0),e.loc.clone(t).relFormatter(t).format(o,a)),i=o=>t.calendary?e.hasSame(n,o)?0:e.startOf(o).diff(n.startOf(o),o).get(o):e.diff(n,o).get(o);if(t.unit)return s(i(t.unit),t.unit);for(const o of t.units){const a=i(o);if(Math.abs(a)>=1)return s(a,o)}return s(n>e?-0:0,t.units[t.units.length-1])}function Nj(n){let e={},t;return n.length>0&&typeof n[n.length-1]=="object"?(e=n[n.length-1],t=Array.from(n).slice(0,n.length-1)):t=Array.from(n),[e,t]}class bn{constructor(e){const t=e.zone||yi.defaultZone;let r=e.invalid||(Number.isNaN(e.ts)?new du("invalid input"):null)||(t.isValid?null:NT(t));this.ts=fr(e.ts)?yi.now():e.ts;let s=null,i=null;if(!r)if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[s,i]=[e.old.c,e.old.o];else{const a=t.offset(this.ts);s=$T(this.ts,a),r=Number.isNaN(s.year)?new du("invalid input"):null,s=r?null:s,i=r?null:a}this._zone=t,this.loc=e.loc||ds.create(),this.invalid=r,this.weekData=null,this.c=s,this.o=i,this.isLuxonDateTime=!0}static now(){return new bn({})}static local(){const[e,t]=Nj(arguments),[r,s,i,o,a,l,c]=t;return Aj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static utc(){const[e,t]=Nj(arguments),[r,s,i,o,a,l,c]=t;return e.zone=ga.utcInstance,Aj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static fromJSDate(e,t={}){const r=nct(e)?e.valueOf():NaN;if(Number.isNaN(r))return bn.invalid("invalid input");const s=Rd(t.zone,yi.defaultZone);return s.isValid?new bn({ts:r,zone:s,loc:ds.fromObject(t)}):bn.invalid(NT(s))}static fromMillis(e,t={}){if(tg(e))return e<-kj||e>kj?bn.invalid("Timestamp out of range"):new bn({ts:e,zone:Rd(t.zone,yi.defaultZone),loc:ds.fromObject(t)});throw new cc(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(tg(e))return new bn({ts:e*1e3,zone:Rd(t.zone,yi.defaultZone),loc:ds.fromObject(t)});throw new cc("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};const r=Rd(t.zone,yi.defaultZone);if(!r.isValid)return bn.invalid(NT(r));const s=yi.now(),i=fr(t.specificOffset)?r.offset(s):t.specificOffset,o=CA(e,Ij),a=!fr(o.ordinal),l=!fr(o.year),c=!fr(o.month)||!fr(o.day),u=l||c,h=o.weekYear||o.weekNumber,f=ds.fromObject(t);if((u||a)&&h)throw new O1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(c&&a)throw new O1("Can't mix ordinal dates with month/day");const d=h||o.weekday&&!u;let p,m,g=$T(s,i);d?(p=Eut,m=kut,g=xF(g)):a?(p=Iut,m=Tut,g=J3(g)):(p=loe,m=aoe);let y=!1;for(const A of p){const M=o[A];fr(M)?y?o[A]=m[A]:o[A]=g[A]:y=!0}const b=d?Sut(o):a?Cut(o):soe(o),x=b||ioe(o);if(x)return bn.invalid(x);const w=d?Sj(o):a?Cj(o):o,[S,C]=nI(w,i,r),k=new bn({ts:S,zone:r,o:C,loc:f});return o.weekday&&u&&e.weekday!==k.weekday?bn.invalid("mismatched weekday",`you can't specify both a weekday of ${o.weekday} and a date of ${k.toISO()}`):k}static fromISO(e,t={}){const[r,s]=Hct(e);return n1(r,s,t,"ISO 8601",e)}static fromRFC2822(e,t={}){const[r,s]=jct(e);return n1(r,s,t,"RFC 2822",e)}static fromHTTP(e,t={}){const[r,s]=qct(e);return n1(r,s,t,"HTTP",t)}static fromFormat(e,t,r={}){if(fr(e)||fr(t))throw new cc("fromFormat requires an input string and a format");const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0}),[a,l,c,u]=_ut(o,e,t);return u?bn.invalid(u):n1(a,l,r,`format ${t}`,e,c)}static fromString(e,t,r={}){return bn.fromFormat(e,t,r)}static fromSQL(e,t={}){const[r,s]=eut(e);return n1(r,s,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new cc("need to specify a reason the DateTime is invalid");const r=e instanceof du?e:new du(e,t);if(yi.throwOnInvalid)throw new Rlt(r);return new bn({invalid:r})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e,t={}){const r=Jie(e,ds.fromObject(t));return r?r.map(s=>s?s.val:null).join(""):null}static expandFormat(e,t={}){return Yie(Ho.parseFormat(e),ds.fromObject(t)).map(s=>s.val).join("")}get(e){return this[e]}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?eP(this).weekYear:NaN}get weekNumber(){return this.isValid?eP(this).weekNumber:NaN}get weekday(){return this.isValid?eP(this).weekday:NaN}get ordinal(){return this.isValid?J3(this.c).ordinal:NaN}get monthShort(){return this.isValid?AT.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?AT.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?AT.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?AT.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return this.isOffsetFixed?!1:this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,r=E$(this.c),s=this.zone.offset(r-e),i=this.zone.offset(r+e),o=this.zone.offset(r-s*t),a=this.zone.offset(r-i*t);if(o===a)return[this];const l=r-o*t,c=r-a*t,u=$T(l,o),h=$T(c,a);return u.hour===h.hour&&u.minute===h.minute&&u.second===h.second&&u.millisecond===h.millisecond?[mm(this,{ts:l}),mm(this,{ts:c})]:[this]}get isInLeapYear(){return FC(this.year)}get daysInMonth(){return _A(this.year,this.month)}get daysInYear(){return this.isValid?o_(this.year):NaN}get weeksInWeekYear(){return this.isValid?SA(this.weekYear):NaN}resolvedLocaleOptions(e={}){const{locale:t,numberingSystem:r,calendar:s}=Ho.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:r,outputCalendar:s}}toUTC(e=0,t={}){return this.setZone(ga.instance(e),t)}toLocal(){return this.setZone(yi.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:r=!1}={}){if(e=Rd(e,yi.defaultZone),e.equals(this.zone))return this;if(e.isValid){let s=this.ts;if(t||r){const i=e.offset(this.ts),o=this.toObject();[s]=nI(o,i,e)}return mm(this,{ts:s,zone:e})}else return bn.invalid(NT(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:r}={}){const s=this.loc.clone({locale:e,numberingSystem:t,outputCalendar:r});return mm(this,{loc:s})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=CA(e,Ij),r=!fr(t.weekYear)||!fr(t.weekNumber)||!fr(t.weekday),s=!fr(t.ordinal),i=!fr(t.year),o=!fr(t.month)||!fr(t.day),a=i||o,l=t.weekYear||t.weekNumber;if((a||s)&&l)throw new O1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&s)throw new O1("Can't mix ordinal dates with month/day");let c;r?c=Sj({...xF(this.c),...t}):fr(t.ordinal)?(c={...this.toObject(),...t},fr(t.day)&&(c.day=Math.min(_A(c.year,c.month),c.day))):c=Cj({...J3(this.c),...t});const[u,h]=nI(c,this.o,this.zone);return mm(this,{ts:u,o:h})}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return mm(this,Tj(this,t))}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e).negate();return mm(this,Tj(this,t))}startOf(e){if(!this.isValid)return this;const t={},r=Sr.normalizeUnit(e);switch(r){case"years":t.month=1;case"quarters":case"months":t.day=1;case"weeks":case"days":t.hour=0;case"hours":t.minute=0;case"minutes":t.second=0;case"seconds":t.millisecond=0;break}if(r==="weeks"&&(t.weekday=1),r==="quarters"){const s=Math.ceil(this.month/3);t.month=(s-1)*3+1}return this.set(t)}endOf(e){return this.isValid?this.plus({[e]:1}).startOf(e).minus(1):this}toFormat(e,t={}){return this.isValid?Ho.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):Q3}toLocaleString(e=xA,t={}){return this.isValid?Ho.create(this.loc.clone(t),e).formatDateTime(this):Q3}toLocaleParts(e={}){return this.isValid?Ho.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:r=!1,includeOffset:s=!0,extendedZone:i=!1}={}){if(!this.isValid)return null;const o=e==="extended";let a=tP(this,o);return a+="T",a+=Ej(this,o,t,r,s,i),a}toISODate({format:e="extended"}={}){return this.isValid?tP(this,e==="extended"):null}toISOWeekDate(){return RT(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:r=!0,includePrefix:s=!1,extendedZone:i=!1,format:o="extended"}={}){return this.isValid?(s?"T":"")+Ej(this,o==="extended",t,e,r,i):null}toRFC2822(){return RT(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return RT(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?tP(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:r=!0}={}){let s="HH:mm:ss.SSS";return(t||e)&&(r&&(s+=" "),t?s+="z":e&&(s+="ZZ")),RT(this,s,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():Q3}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};const t={...this.c};return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",r={}){if(!this.isValid||!e.isValid)return Sr.invalid("created by diffing an invalid DateTime");const s={locale:this.locale,numberingSystem:this.numberingSystem,...r},i=rct(t).map(Sr.normalizeUnit),o=e.valueOf()>this.valueOf(),a=o?this:e,l=o?e:this,c=aut(a,l,i,s);return o?c.negate():c}diffNow(e="milliseconds",t={}){return this.diff(bn.now(),e,t)}until(e){return this.isValid?Hs.fromDateTimes(this,e):this}hasSame(e,t){if(!this.isValid)return!1;const r=e.valueOf(),s=this.setZone(e.zone,{keepLocalTime:!0});return s.startOf(t)<=r&&r<=s.endOf(t)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;const t=e.base||bn.fromObject({},{zone:this.zone}),r=e.padding?this<t?-e.padding:e.padding:0;let s=["years","months","days","hours","minutes","seconds"],i=e.unit;return Array.isArray(e.unit)&&(s=e.unit,i=void 0),Mj(t,this.plus(r),{...e,numeric:"always",units:s,unit:i})}toRelativeCalendar(e={}){return this.isValid?Mj(e.base||bn.fromObject({},{zone:this.zone}),this,{...e,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(...e){if(!e.every(bn.isDateTime))throw new cc("min requires all arguments be DateTimes");return pj(e,t=>t.valueOf(),Math.min)}static max(...e){if(!e.every(bn.isDateTime))throw new cc("max requires all arguments be DateTimes");return pj(e,t=>t.valueOf(),Math.max)}static fromFormatExplain(e,t,r={}){const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0});return Zie(o,e,t)}static fromStringExplain(e,t,r={}){return bn.fromFormatExplain(e,t,r)}static get DATE_SHORT(){return xA}static get DATE_MED(){return hie}static get DATE_MED_WITH_WEEKDAY(){return Olt}static get DATE_FULL(){return fie}static get DATE_HUGE(){return die}static get TIME_SIMPLE(){return pie}static get TIME_WITH_SECONDS(){return mie}static get TIME_WITH_SHORT_OFFSET(){return gie}static get TIME_WITH_LONG_OFFSET(){return yie}static get TIME_24_SIMPLE(){return bie}static get TIME_24_WITH_SECONDS(){return vie}static get TIME_24_WITH_SHORT_OFFSET(){return wie}static get TIME_24_WITH_LONG_OFFSET(){return xie}static get DATETIME_SHORT(){return _ie}static get DATETIME_SHORT_WITH_SECONDS(){return Sie}static get DATETIME_MED(){return Cie}static get DATETIME_MED_WITH_SECONDS(){return kie}static get DATETIME_MED_WITH_WEEKDAY(){return Flt}static get DATETIME_FULL(){return Tie}static get DATETIME_FULL_WITH_SECONDS(){return Eie}static get DATETIME_HUGE(){return Iie}static get DATETIME_HUGE_WITH_SECONDS(){return Aie}}function r1(n){if(bn.isDateTime(n))return n;if(n&&n.valueOf&&tg(n.valueOf()))return bn.fromJSDate(n);if(n&&typeof n=="object")return bn.fromObject(n);throw new cc(`Unknown datetime argument: ${n}, of type ${typeof n}`)}/*!
 * chartjs-adapter-luxon v1.3.1
 * https://www.chartjs.org
 * (c) 2023 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */const Aut={datetime:bn.DATETIME_MED_WITH_SECONDS,millisecond:"h:mm:ss.SSS a",second:bn.TIME_WITH_SECONDS,minute:bn.TIME_SIMPLE,hour:{hour:"numeric"},day:{day:"numeric",month:"short"},week:"DD",month:{month:"short",year:"numeric"},quarter:"'Q'q - yyyy",year:{year:"numeric"}};Wse._date.override({_id:"luxon",_create:function(n){return bn.fromMillis(n,this.options)},init(n){this.options.locale||(this.options.locale=n.locale)},formats:function(){return Aut},parse:function(n,e){const t=this.options,r=typeof n;return n===null||r==="undefined"?null:(r==="number"?n=this._create(n):r==="string"?typeof e=="string"?n=bn.fromFormat(n,e,t):n=bn.fromISO(n,t):n instanceof Date?n=bn.fromJSDate(n,t):r==="object"&&!(n instanceof bn)&&(n=bn.fromObject(n,t)),n.isValid?n.valueOf():null)},format:function(n,e){const t=this._create(n);return typeof e=="string"?t.toFormat(e):t.toLocaleString(e)},add:function(n,e,t){const r={};return r[t]=e,this._create(n).plus(r).valueOf()},diff:function(n,e,t){return this._create(n).diff(this._create(e)).as(t).valueOf()},startOf:function(n,e,t){if(e==="isoWeek"){t=Math.trunc(Math.min(Math.max(0,t),6));const r=this._create(n);return r.minus({days:(r.weekday-t+7)%7}).startOf("day").valueOf()}return e?this._create(n).startOf(e).valueOf():n},endOf:function(n,e){return this._create(n).endOf(e).valueOf()}});var $j=Object.prototype.hasOwnProperty;function Rj(n,e,t){for(t of n.keys())if(l_(t,e))return t}function l_(n,e){var t,r,s;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&l_(n[r],e[r]););return r===-1}if(t===Set){if(n.size!==e.size)return!1;for(r of n)if(s=r,s&&typeof s=="object"&&(s=Rj(e,s),!s)||!e.has(s))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(r of n)if(s=r[0],s&&typeof s=="object"&&(s=Rj(e,s),!s)||!l_(r[1],e.get(s)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((r=n.byteLength)===e.byteLength)for(;r--&&n.getInt8(r)===e.getInt8(r););return r===-1}if(ArrayBuffer.isView(n)){if((r=n.byteLength)===e.byteLength)for(;r--&&n[r]===e[r];);return r===-1}if(!t||typeof n=="object"){r=0;for(t in n)if($j.call(n,t)&&++r&&!$j.call(e,t)||!(t in e)||!l_(n[t],e[t]))return!1;return Object.keys(e).length===r}}return n!==n&&e!==e}/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */var Mut="2.0.1";class L1 extends _c{initialize(){this.enableOptionSharing=!0,super.initialize()}update(e){const t=this,r=t._cachedMeta;t.updateElements(r.data,0,r.data.length,e)}updateElements(e,t,r,s){const i=this,o=s==="reset",{xScale:a,yScale:l}=i._cachedMeta,c=i.resolveDataElementOptions(t,s),u=i.getSharedOptions(s,e[t],c);for(let h=t;h<t+r;h++){const f=!o&&i.getParsed(h),d=o?a.getBasePixel():a.getPixelForValue(f.x),p=o?l.getBasePixel():l.getPixelForValue(f.y),m=i.resolveDataElementOptions(h,s),{width:g,height:y,anchorX:b,anchorY:x}=m,w={x:Nut(b,d,g),y:$ut(x,p,y),width:g,height:y,options:m};i.updateElement(e[h],h,w,s)}i.updateSharedOptions(u,s)}draw(){const e=this,t=e.getMeta().data||[];let r,s;for(r=0,s=t.length;r<s;++r)t[r].draw(e._ctx)}}Mt(L1,"id","matrix"),Mt(L1,"version",Mut),Mt(L1,"defaults",{dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}}),Mt(L1,"overrides",{interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}});function Nut(n,e,t){return n==="left"||n==="start"?e:n==="right"||n==="end"?e-t:e-t/2}function $ut(n,e,t){return n==="top"||n==="start"?e:n==="bottom"||n==="end"?e-t:e-t/2}function coe(n,e){const{x:t,y:r,width:s,height:i}=n.getProps(["x","y","width","height"],e);return{left:t,top:r,right:t+s,bottom:r+i}}function PT(n,e,t){return Math.max(Math.min(n,t),e)}function Rut(n,e,t){const r=n.options.borderWidth;let s,i,o,a;return nr(r)?(s=+r.top||0,i=+r.right||0,o=+r.bottom||0,a=+r.left||0):s=i=o=a=+r||0,{t:PT(s,0,t),r:PT(i,0,e),b:PT(o,0,t),l:PT(a,0,e)}}function Put(n){const e=coe(n),t=e.right-e.left,r=e.bottom-e.top,s=Rut(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r},inner:{x:e.left+s.l,y:e.top+s.t,w:t-s.l-s.r,h:r-s.t-s.b}}}function nP(n,e,t,r){const s=e===null,i=t===null,o=!n||s&&i?!1:coe(n,r);return o&&(s||e>=o.left&&e<=o.right)&&(i||t>=o.top&&t<=o.bottom)}class _F extends Mc{constructor(e){super(),this.options=void 0,this.width=void 0,this.height=void 0,e&&Object.assign(this,e)}draw(e){const t=this.options,{inner:r,outer:s}=Put(this),i=Qd(t.borderRadius);e.save(),s.w!==r.w||s.h!==r.h?(e.beginPath(),Jd(e,{x:s.x,y:s.y,w:s.w,h:s.h,radius:i}),Jd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:i}),e.fillStyle=t.backgroundColor,e.fill(),e.fillStyle=t.borderColor,e.fill("evenodd")):(e.beginPath(),Jd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:i}),e.fillStyle=t.backgroundColor,e.fill()),e.restore()}inRange(e,t,r){return nP(this,e,t,r)}inXRange(e,t){return nP(this,e,null,t)}inYRange(e,t){return nP(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,width:s,height:i}=this.getProps(["x","y","width","height"],e);return{x:t+s/2,y:r+i/2}}tooltipPosition(){return this.getCenterPoint()}getRange(e){return e==="x"?this.width/2:this.height/2}}Mt(_F,"id","matrix"),Mt(_F,"defaults",{backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20});var Dut={exports:{}};/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */(function(n){(function(e,t,r,s){var i=["","webkit","Moz","MS","ms","o"],o=t.createElement("div"),a="function",l=Math.round,c=Math.abs,u=Date.now;function h(H,Y,pe){return setTimeout(x(H,pe),Y)}function f(H,Y,pe){return Array.isArray(H)?(d(H,pe[Y],pe),!0):!1}function d(H,Y,pe){var Re;if(H)if(H.forEach)H.forEach(Y,pe);else if(H.length!==s)for(Re=0;Re<H.length;)Y.call(pe,H[Re],Re,H),Re++;else for(Re in H)H.hasOwnProperty(Re)&&Y.call(pe,H[Re],Re,H)}function p(H,Y,pe){var Re="DEPRECATED METHOD: "+Y+`
`+pe+` AT 
`;return function(){var at=new Error("get-stack-trace"),Vt=at&&at.stack?at.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",$n=e.console&&(e.console.warn||e.console.log);return $n&&$n.call(e.console,Re,Vt),H.apply(this,arguments)}}var m;typeof Object.assign!="function"?m=function(Y){if(Y===s||Y===null)throw new TypeError("Cannot convert undefined or null to object");for(var pe=Object(Y),Re=1;Re<arguments.length;Re++){var at=arguments[Re];if(at!==s&&at!==null)for(var Vt in at)at.hasOwnProperty(Vt)&&(pe[Vt]=at[Vt])}return pe}:m=Object.assign;var g=p(function(Y,pe,Re){for(var at=Object.keys(pe),Vt=0;Vt<at.length;)(!Re||Re&&Y[at[Vt]]===s)&&(Y[at[Vt]]=pe[at[Vt]]),Vt++;return Y},"extend","Use `assign`."),y=p(function(Y,pe){return g(Y,pe,!0)},"merge","Use `assign`.");function b(H,Y,pe){var Re=Y.prototype,at;at=H.prototype=Object.create(Re),at.constructor=H,at._super=Re,pe&&m(at,pe)}function x(H,Y){return function(){return H.apply(Y,arguments)}}function w(H,Y){return typeof H==a?H.apply(Y&&Y[0]||s,Y):H}function S(H,Y){return H===s?Y:H}function C(H,Y,pe){d(E(Y),function(Re){H.addEventListener(Re,pe,!1)})}function k(H,Y,pe){d(E(Y),function(Re){H.removeEventListener(Re,pe,!1)})}function A(H,Y){for(;H;){if(H==Y)return!0;H=H.parentNode}return!1}function M(H,Y){return H.indexOf(Y)>-1}function E(H){return H.trim().split(/\s+/g)}function N(H,Y,pe){if(H.indexOf&&!pe)return H.indexOf(Y);for(var Re=0;Re<H.length;){if(pe&&H[Re][pe]==Y||!pe&&H[Re]===Y)return Re;Re++}return-1}function O(H){return Array.prototype.slice.call(H,0)}function R(H,Y,pe){for(var Re=[],at=[],Vt=0;Vt<H.length;){var $n=Y?H[Vt][Y]:H[Vt];N(at,$n)<0&&Re.push(H[Vt]),at[Vt]=$n,Vt++}return pe&&(Y?Re=Re.sort(function(Us,pi){return Us[Y]>pi[Y]}):Re=Re.sort()),Re}function D(H,Y){for(var pe,Re,at=Y[0].toUpperCase()+Y.slice(1),Vt=0;Vt<i.length;){if(pe=i[Vt],Re=pe?pe+at:Y,Re in H)return Re;Vt++}return s}var z=1;function B(){return z++}function X(H){var Y=H.ownerDocument||H;return Y.defaultView||Y.parentWindow||e}var G=/mobile|tablet|ip(ad|hone|od)|android/i,te="ontouchstart"in e,ge=D(e,"PointerEvent")!==s,ae=te&&G.test(navigator.userAgent),Ne="touch",ke="pen",De="mouse",be="kinect",Xe=25,Oe=1,it=2,We=4,dt=8,ct=1,Ve=2,ze=4,Be=8,ut=16,Ke=Ve|ze,ee=Be|ut,J=Ke|ee,rt=["x","y"],Ge=["clientX","clientY"];function ye(H,Y){var pe=this;this.manager=H,this.callback=Y,this.element=H.element,this.target=H.options.inputTarget,this.domHandler=function(Re){w(H.options.enable,[H])&&pe.handler(Re)},this.init()}ye.prototype={handler:function(){},init:function(){this.evEl&&C(this.element,this.evEl,this.domHandler),this.evTarget&&C(this.target,this.evTarget,this.domHandler),this.evWin&&C(X(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&k(this.element,this.evEl,this.domHandler),this.evTarget&&k(this.target,this.evTarget,this.domHandler),this.evWin&&k(X(this.element),this.evWin,this.domHandler)}};function Ze(H){var Y,pe=H.options.inputClass;return pe?Y=pe:ge?Y=Di:ae?Y=vt:te?Y=En:Y=Wl,new Y(H,yt)}function yt(H,Y,pe){var Re=pe.pointers.length,at=pe.changedPointers.length,Vt=Y&Oe&&Re-at===0,$n=Y&(We|dt)&&Re-at===0;pe.isFirst=!!Vt,pe.isFinal=!!$n,Vt&&(H.session={}),pe.eventType=Y,Ct(H,pe),H.emit("hammer.input",pe),H.recognize(pe),H.session.prevInput=pe}function Ct(H,Y){var pe=H.session,Re=Y.pointers,at=Re.length;pe.firstInput||(pe.firstInput=nt(Y)),at>1&&!pe.firstMultiple?pe.firstMultiple=nt(Y):at===1&&(pe.firstMultiple=!1);var Vt=pe.firstInput,$n=pe.firstMultiple,Rs=$n?$n.center:Vt.center,Us=Y.center=St(Re);Y.timeStamp=u(),Y.deltaTime=Y.timeStamp-Vt.timeStamp,Y.angle=Cr(Rs,Us),Y.distance=Mn(Rs,Us),ft(pe,Y),Y.offsetDirection=Gt(Y.deltaX,Y.deltaY);var pi=gt(Y.deltaTime,Y.deltaX,Y.deltaY);Y.overallVelocityX=pi.x,Y.overallVelocityY=pi.y,Y.overallVelocity=c(pi.x)>c(pi.y)?pi.x:pi.y,Y.scale=$n?As($n.pointers,Re):1,Y.rotation=$n?Bs($n.pointers,Re):0,Y.maxPointers=pe.prevInput?Y.pointers.length>pe.prevInput.maxPointers?Y.pointers.length:pe.prevInput.maxPointers:Y.pointers.length,ce(pe,Y);var Na=H.element;A(Y.srcEvent.target,Na)&&(Na=Y.srcEvent.target),Y.target=Na}function ft(H,Y){var pe=Y.center,Re=H.offsetDelta||{},at=H.prevDelta||{},Vt=H.prevInput||{};(Y.eventType===Oe||Vt.eventType===We)&&(at=H.prevDelta={x:Vt.deltaX||0,y:Vt.deltaY||0},Re=H.offsetDelta={x:pe.x,y:pe.y}),Y.deltaX=at.x+(pe.x-Re.x),Y.deltaY=at.y+(pe.y-Re.y)}function ce(H,Y){var pe=H.lastInterval||Y,Re=Y.timeStamp-pe.timeStamp,at,Vt,$n,Rs;if(Y.eventType!=dt&&(Re>Xe||pe.velocity===s)){var Us=Y.deltaX-pe.deltaX,pi=Y.deltaY-pe.deltaY,Na=gt(Re,Us,pi);Vt=Na.x,$n=Na.y,at=c(Na.x)>c(Na.y)?Na.x:Na.y,Rs=Gt(Us,pi),H.lastInterval=Y}else at=pe.velocity,Vt=pe.velocityX,$n=pe.velocityY,Rs=pe.direction;Y.velocity=at,Y.velocityX=Vt,Y.velocityY=$n,Y.direction=Rs}function nt(H){for(var Y=[],pe=0;pe<H.pointers.length;)Y[pe]={clientX:l(H.pointers[pe].clientX),clientY:l(H.pointers[pe].clientY)},pe++;return{timeStamp:u(),pointers:Y,center:St(Y),deltaX:H.deltaX,deltaY:H.deltaY}}function St(H){var Y=H.length;if(Y===1)return{x:l(H[0].clientX),y:l(H[0].clientY)};for(var pe=0,Re=0,at=0;at<Y;)pe+=H[at].clientX,Re+=H[at].clientY,at++;return{x:l(pe/Y),y:l(Re/Y)}}function gt(H,Y,pe){return{x:Y/H||0,y:pe/H||0}}function Gt(H,Y){return H===Y?ct:c(H)>=c(Y)?H<0?Ve:ze:Y<0?Be:ut}function Mn(H,Y,pe){pe||(pe=rt);var Re=Y[pe[0]]-H[pe[0]],at=Y[pe[1]]-H[pe[1]];return Math.sqrt(Re*Re+at*at)}function Cr(H,Y,pe){pe||(pe=rt);var Re=Y[pe[0]]-H[pe[0]],at=Y[pe[1]]-H[pe[1]];return Math.atan2(at,Re)*180/Math.PI}function Bs(H,Y){return Cr(Y[1],Y[0],Ge)+Cr(H[1],H[0],Ge)}function As(H,Y){return Mn(Y[0],Y[1],Ge)/Mn(H[0],H[1],Ge)}var Ms={mousedown:Oe,mousemove:it,mouseup:We},Vh="mousedown",Ul="mousemove mouseup";function Wl(){this.evEl=Vh,this.evWin=Ul,this.pressed=!1,ye.apply(this,arguments)}b(Wl,ye,{handler:function(Y){var pe=Ms[Y.type];pe&Oe&&Y.button===0&&(this.pressed=!0),pe&it&&Y.which!==1&&(pe=We),this.pressed&&(pe&We&&(this.pressed=!1),this.callback(this.manager,pe,{pointers:[Y],changedPointers:[Y],pointerType:De,srcEvent:Y}))}});var go={pointerdown:Oe,pointermove:it,pointerup:We,pointercancel:dt,pointerout:dt},Gl={2:Ne,3:ke,4:De,5:be},Lc="pointerdown",zc="pointermove pointerup pointercancel";e.MSPointerEvent&&!e.PointerEvent&&(Lc="MSPointerDown",zc="MSPointerMove MSPointerUp MSPointerCancel");function Di(){this.evEl=Lc,this.evWin=zc,ye.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}b(Di,ye,{handler:function(Y){var pe=this.store,Re=!1,at=Y.type.toLowerCase().replace("ms",""),Vt=go[at],$n=Gl[Y.pointerType]||Y.pointerType,Rs=$n==Ne,Us=N(pe,Y.pointerId,"pointerId");Vt&Oe&&(Y.button===0||Rs)?Us<0&&(pe.push(Y),Us=pe.length-1):Vt&(We|dt)&&(Re=!0),!(Us<0)&&(pe[Us]=Y,this.callback(this.manager,Vt,{pointers:pe,changedPointers:[Y],pointerType:$n,srcEvent:Y}),Re&&pe.splice(Us,1))}});var Uh={touchstart:Oe,touchmove:it,touchend:We,touchcancel:dt},il="touchstart",Wh="touchstart touchmove touchend touchcancel";function re(){this.evTarget=il,this.evWin=Wh,this.started=!1,ye.apply(this,arguments)}b(re,ye,{handler:function(Y){var pe=Uh[Y.type];if(pe===Oe&&(this.started=!0),!!this.started){var Re=Ue.call(this,Y,pe);pe&(We|dt)&&Re[0].length-Re[1].length===0&&(this.started=!1),this.callback(this.manager,pe,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}}});function Ue(H,Y){var pe=O(H.touches),Re=O(H.changedTouches);return Y&(We|dt)&&(pe=R(pe.concat(Re),"identifier",!0)),[pe,Re]}var Fe={touchstart:Oe,touchmove:it,touchend:We,touchcancel:dt},Je="touchstart touchmove touchend touchcancel";function vt(){this.evTarget=Je,this.targetIds={},ye.apply(this,arguments)}b(vt,ye,{handler:function(Y){var pe=Fe[Y.type],Re=zn.call(this,Y,pe);Re&&this.callback(this.manager,pe,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}});function zn(H,Y){var pe=O(H.touches),Re=this.targetIds;if(Y&(Oe|it)&&pe.length===1)return Re[pe[0].identifier]=!0,[pe,pe];var at,Vt,$n=O(H.changedTouches),Rs=[],Us=this.target;if(Vt=pe.filter(function(pi){return A(pi.target,Us)}),Y===Oe)for(at=0;at<Vt.length;)Re[Vt[at].identifier]=!0,at++;for(at=0;at<$n.length;)Re[$n[at].identifier]&&Rs.push($n[at]),Y&(We|dt)&&delete Re[$n[at].identifier],at++;if(Rs.length)return[R(Vt.concat(Rs),"identifier",!0),Rs]}var sn=2500,Tn=25;function En(){ye.apply(this,arguments);var H=x(this.handler,this);this.touch=new vt(this.manager,H),this.mouse=new Wl(this.manager,H),this.primaryTouch=null,this.lastTouches=[]}b(En,ye,{handler:function(Y,pe,Re){var at=Re.pointerType==Ne,Vt=Re.pointerType==De;if(!(Vt&&Re.sourceCapabilities&&Re.sourceCapabilities.firesTouchEvents)){if(at)Nn.call(this,pe,Re);else if(Vt&&_n.call(this,Re))return;this.callback(Y,pe,Re)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});function Nn(H,Y){H&Oe?(this.primaryTouch=Y.changedPointers[0].identifier,er.call(this,Y)):H&(We|dt)&&er.call(this,Y)}function er(H){var Y=H.changedPointers[0];if(Y.identifier===this.primaryTouch){var pe={x:Y.clientX,y:Y.clientY};this.lastTouches.push(pe);var Re=this.lastTouches,at=function(){var Vt=Re.indexOf(pe);Vt>-1&&Re.splice(Vt,1)};setTimeout(at,sn)}}function _n(H){for(var Y=H.srcEvent.clientX,pe=H.srcEvent.clientY,Re=0;Re<this.lastTouches.length;Re++){var at=this.lastTouches[Re],Vt=Math.abs(Y-at.x),$n=Math.abs(pe-at.y);if(Vt<=Tn&&$n<=Tn)return!0}return!1}var ur=D(o.style,"touchAction"),Oi=ur!==s,xr="compute",Zi="auto",Ar="manipulation",Io="none",rs="pan-x",yo="pan-y",Ao=Gh();function Ns(H,Y){this.manager=H,this.set(Y)}Ns.prototype={set:function(H){H==xr&&(H=this.compute()),Oi&&this.manager.element.style&&Ao[H]&&(this.manager.element.style[ur]=H),this.actions=H.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var H=[];return d(this.manager.recognizers,function(Y){w(Y.options.enable,[Y])&&(H=H.concat(Y.getTouchAction()))}),bo(H.join(" "))},preventDefaults:function(H){var Y=H.srcEvent,pe=H.offsetDirection;if(this.manager.session.prevented){Y.preventDefault();return}var Re=this.actions,at=M(Re,Io)&&!Ao[Io],Vt=M(Re,yo)&&!Ao[yo],$n=M(Re,rs)&&!Ao[rs];if(at){var Rs=H.pointers.length===1,Us=H.distance<2,pi=H.deltaTime<250;if(Rs&&Us&&pi)return}if(!($n&&Vt)&&(at||Vt&&pe&Ke||$n&&pe&ee))return this.preventSrc(Y)},preventSrc:function(H){this.manager.session.prevented=!0,H.preventDefault()}};function bo(H){if(M(H,Io))return Io;var Y=M(H,rs),pe=M(H,yo);return Y&&pe?Io:Y||pe?Y?rs:yo:M(H,Ar)?Ar:Zi}function Gh(){if(!Oi)return!1;var H={},Y=e.CSS&&e.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(pe){H[pe]=Y?e.CSS.supports("touch-action",pe):!0}),H}var ol=1,Ji=2,Bc=4,Ma=8,$s=Ma,Vc=16,Qi=32;function Vs(H){this.options=m({},this.defaults,H||{}),this.id=B(),this.manager=null,this.options.enable=S(this.options.enable,!0),this.state=ol,this.simultaneous={},this.requireFail=[]}Vs.prototype={defaults:{},set:function(H){return m(this.options,H),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(H){if(f(H,"recognizeWith",this))return this;var Y=this.simultaneous;return H=jh(H,this),Y[H.id]||(Y[H.id]=H,H.recognizeWith(this)),this},dropRecognizeWith:function(H){return f(H,"dropRecognizeWith",this)?this:(H=jh(H,this),delete this.simultaneous[H.id],this)},requireFailure:function(H){if(f(H,"requireFailure",this))return this;var Y=this.requireFail;return H=jh(H,this),N(Y,H)===-1&&(Y.push(H),H.requireFailure(this)),this},dropRequireFailure:function(H){if(f(H,"dropRequireFailure",this))return this;H=jh(H,this);var Y=N(this.requireFail,H);return Y>-1&&this.requireFail.splice(Y,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(H){return!!this.simultaneous[H.id]},emit:function(H){var Y=this,pe=this.state;function Re(at){Y.manager.emit(at,H)}pe<Ma&&Re(Y.options.event+Hh(pe)),Re(Y.options.event),H.additionalEvent&&Re(H.additionalEvent),pe>=Ma&&Re(Y.options.event+Hh(pe))},tryEmit:function(H){if(this.canEmit())return this.emit(H);this.state=Qi},canEmit:function(){for(var H=0;H<this.requireFail.length;){if(!(this.requireFail[H].state&(Qi|ol)))return!1;H++}return!0},recognize:function(H){var Y=m({},H);if(!w(this.options.enable,[this,Y])){this.reset(),this.state=Qi;return}this.state&($s|Vc|Qi)&&(this.state=ol),this.state=this.process(Y),this.state&(Ji|Bc|Ma|Vc)&&this.tryEmit(Y)},process:function(H){},getTouchAction:function(){},reset:function(){}};function Hh(H){return H&Vc?"cancel":H&Ma?"end":H&Bc?"move":H&Ji?"start":""}function u0(H){return H==ut?"down":H==Be?"up":H==Ve?"left":H==ze?"right":""}function jh(H,Y){var pe=Y.manager;return pe?pe.get(H):H}function eo(){Vs.apply(this,arguments)}b(eo,Vs,{defaults:{pointers:1},attrTest:function(H){var Y=this.options.pointers;return Y===0||H.pointers.length===Y},process:function(H){var Y=this.state,pe=H.eventType,Re=Y&(Ji|Bc),at=this.attrTest(H);return Re&&(pe&dt||!at)?Y|Vc:Re||at?pe&We?Y|Ma:Y&Ji?Y|Bc:Ji:Qi}});function qh(){eo.apply(this,arguments),this.pX=null,this.pY=null}b(qh,eo,{defaults:{event:"pan",threshold:10,pointers:1,direction:J},getTouchAction:function(){var H=this.options.direction,Y=[];return H&Ke&&Y.push(yo),H&ee&&Y.push(rs),Y},directionTest:function(H){var Y=this.options,pe=!0,Re=H.distance,at=H.direction,Vt=H.deltaX,$n=H.deltaY;return at&Y.direction||(Y.direction&Ke?(at=Vt===0?ct:Vt<0?Ve:ze,pe=Vt!=this.pX,Re=Math.abs(H.deltaX)):(at=$n===0?ct:$n<0?Be:ut,pe=$n!=this.pY,Re=Math.abs(H.deltaY))),H.direction=at,pe&&Re>Y.threshold&&at&Y.direction},attrTest:function(H){return eo.prototype.attrTest.call(this,H)&&(this.state&Ji||!(this.state&Ji)&&this.directionTest(H))},emit:function(H){this.pX=H.deltaX,this.pY=H.deltaY;var Y=u0(H.direction);Y&&(H.additionalEvent=this.options.event+Y),this._super.emit.call(this,H)}});function rd(){eo.apply(this,arguments)}b(rd,eo,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[Io]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.scale-1)>this.options.threshold||this.state&Ji)},emit:function(H){if(H.scale!==1){var Y=H.scale<1?"in":"out";H.additionalEvent=this.options.event+Y}this._super.emit.call(this,H)}});function qu(){Vs.apply(this,arguments),this._timer=null,this._input=null}b(qu,Vs,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[Zi]},process:function(H){var Y=this.options,pe=H.pointers.length===Y.pointers,Re=H.distance<Y.threshold,at=H.deltaTime>Y.time;if(this._input=H,!Re||!pe||H.eventType&(We|dt)&&!at)this.reset();else if(H.eventType&Oe)this.reset(),this._timer=h(function(){this.state=$s,this.tryEmit()},Y.time,this);else if(H.eventType&We)return $s;return Qi},reset:function(){clearTimeout(this._timer)},emit:function(H){this.state===$s&&(H&&H.eventType&We?this.manager.emit(this.options.event+"up",H):(this._input.timeStamp=u(),this.manager.emit(this.options.event,this._input)))}});function sd(){eo.apply(this,arguments)}b(sd,eo,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[Io]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.rotation)>this.options.threshold||this.state&Ji)}});function Xh(){eo.apply(this,arguments)}b(Xh,eo,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Ke|ee,pointers:1},getTouchAction:function(){return qh.prototype.getTouchAction.call(this)},attrTest:function(H){var Y=this.options.direction,pe;return Y&(Ke|ee)?pe=H.overallVelocity:Y&Ke?pe=H.overallVelocityX:Y&ee&&(pe=H.overallVelocityY),this._super.attrTest.call(this,H)&&Y&H.offsetDirection&&H.distance>this.options.threshold&&H.maxPointers==this.options.pointers&&c(pe)>this.options.velocity&&H.eventType&We},emit:function(H){var Y=u0(H.offsetDirection);Y&&this.manager.emit(this.options.event+Y,H),this.manager.emit(this.options.event,H)}});function Hl(){Vs.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}b(Hl,Vs,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[Ar]},process:function(H){var Y=this.options,pe=H.pointers.length===Y.pointers,Re=H.distance<Y.threshold,at=H.deltaTime<Y.time;if(this.reset(),H.eventType&Oe&&this.count===0)return this.failTimeout();if(Re&&at&&pe){if(H.eventType!=We)return this.failTimeout();var Vt=this.pTime?H.timeStamp-this.pTime<Y.interval:!0,$n=!this.pCenter||Mn(this.pCenter,H.center)<Y.posThreshold;this.pTime=H.timeStamp,this.pCenter=H.center,!$n||!Vt?this.count=1:this.count+=1,this._input=H;var Rs=this.count%Y.taps;if(Rs===0)return this.hasRequireFailures()?(this._timer=h(function(){this.state=$s,this.tryEmit()},Y.interval,this),Ji):$s}return Qi},failTimeout:function(){return this._timer=h(function(){this.state=Qi},this.options.interval,this),Qi},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==$s&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}});function Zr(H,Y){return Y=Y||{},Y.recognizers=S(Y.recognizers,Zr.defaults.preset),new Uc(H,Y)}Zr.VERSION="2.0.7",Zr.defaults={domEvents:!1,touchAction:xr,enable:!0,inputTarget:null,inputClass:null,preset:[[sd,{enable:!1}],[rd,{enable:!1},["rotate"]],[Xh,{direction:Ke}],[qh,{direction:Ke},["swipe"]],[Hl],[Hl,{event:"doubletap",taps:2},["tap"]],[qu]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var h0=1,id=2;function Uc(H,Y){this.options=m({},Zr.defaults,Y||{}),this.options.inputTarget=this.options.inputTarget||H,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=H,this.input=Ze(this),this.touchAction=new Ns(this,this.options.touchAction),Kh(this,!0),d(this.options.recognizers,function(pe){var Re=this.add(new pe[0](pe[1]));pe[2]&&Re.recognizeWith(pe[2]),pe[3]&&Re.requireFailure(pe[3])},this)}Uc.prototype={set:function(H){return m(this.options,H),H.touchAction&&this.touchAction.update(),H.inputTarget&&(this.input.destroy(),this.input.target=H.inputTarget,this.input.init()),this},stop:function(H){this.session.stopped=H?id:h0},recognize:function(H){var Y=this.session;if(!Y.stopped){this.touchAction.preventDefaults(H);var pe,Re=this.recognizers,at=Y.curRecognizer;(!at||at&&at.state&$s)&&(at=Y.curRecognizer=null);for(var Vt=0;Vt<Re.length;)pe=Re[Vt],Y.stopped!==id&&(!at||pe==at||pe.canRecognizeWith(at))?pe.recognize(H):pe.reset(),!at&&pe.state&(Ji|Bc|Ma)&&(at=Y.curRecognizer=pe),Vt++}},get:function(H){if(H instanceof Vs)return H;for(var Y=this.recognizers,pe=0;pe<Y.length;pe++)if(Y[pe].options.event==H)return Y[pe];return null},add:function(H){if(f(H,"add",this))return this;var Y=this.get(H.options.event);return Y&&this.remove(Y),this.recognizers.push(H),H.manager=this,this.touchAction.update(),H},remove:function(H){if(f(H,"remove",this))return this;if(H=this.get(H),H){var Y=this.recognizers,pe=N(Y,H);pe!==-1&&(Y.splice(pe,1),this.touchAction.update())}return this},on:function(H,Y){if(H!==s&&Y!==s){var pe=this.handlers;return d(E(H),function(Re){pe[Re]=pe[Re]||[],pe[Re].push(Y)}),this}},off:function(H,Y){if(H!==s){var pe=this.handlers;return d(E(H),function(Re){Y?pe[Re]&&pe[Re].splice(N(pe[Re],Y),1):delete pe[Re]}),this}},emit:function(H,Y){this.options.domEvents&&f0(H,Y);var pe=this.handlers[H]&&this.handlers[H].slice();if(!(!pe||!pe.length)){Y.type=H,Y.preventDefault=function(){Y.srcEvent.preventDefault()};for(var Re=0;Re<pe.length;)pe[Re](Y),Re++}},destroy:function(){this.element&&Kh(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}};function Kh(H,Y){var pe=H.element;if(pe.style){var Re;d(H.options.cssProps,function(at,Vt){Re=D(pe.style,Vt),Y?(H.oldCssProps[Re]=pe.style[Re],pe.style[Re]=at):pe.style[Re]=H.oldCssProps[Re]||""}),Y||(H.oldCssProps={})}}function f0(H,Y){var pe=t.createEvent("Event");pe.initEvent(H,!0,!0),pe.gesture=Y,Y.target.dispatchEvent(pe)}m(Zr,{INPUT_START:Oe,INPUT_MOVE:it,INPUT_END:We,INPUT_CANCEL:dt,STATE_POSSIBLE:ol,STATE_BEGAN:Ji,STATE_CHANGED:Bc,STATE_ENDED:Ma,STATE_RECOGNIZED:$s,STATE_CANCELLED:Vc,STATE_FAILED:Qi,DIRECTION_NONE:ct,DIRECTION_LEFT:Ve,DIRECTION_RIGHT:ze,DIRECTION_UP:Be,DIRECTION_DOWN:ut,DIRECTION_HORIZONTAL:Ke,DIRECTION_VERTICAL:ee,DIRECTION_ALL:J,Manager:Uc,Input:ye,TouchAction:Ns,TouchInput:vt,MouseInput:Wl,PointerEventInput:Di,TouchMouseInput:En,SingleTouchInput:re,Recognizer:Vs,AttrRecognizer:eo,Tap:Hl,Pan:qh,Swipe:Xh,Pinch:rd,Rotate:sd,Press:qu,on:C,off:k,each:d,merge:y,extend:g,assign:m,inherit:b,bindFn:x,prefixed:D});var d0=typeof e<"u"?e:typeof self<"u"?self:{};d0.Hammer=Zr,typeof s=="function"&&s.amd?s(function(){return Zr}):n.exports?n.exports=Zr:e[r]=Zr})(window,document,"Hammer")})(Dut);var uoe={exports:{}};(function(n){(function(e){var t=e.URL||e.webkitURL;function r(c){return t?t.createObjectURL(c):!1}function s(c){return t?t.revokeObjectURL(c):!1}function i(c,u){c&&c.slice(0,5)==="blob:"&&!(u&&u.noRevoke)&&s(c)}function o(c,u,h,f){if(!e.FileReader)return!1;var d=new FileReader;d.onload=function(){u.call(d,this.result)},h&&(d.onabort=d.onerror=function(){h.call(d,this.error)});var p=d[f||"readAsDataURL"];if(p)return p.call(d,c),d}function a(c,u){return Object.prototype.toString.call(u)==="[object "+c+"]"}function l(c,u,h){function f(d,p){var m=document.createElement("img"),g;function y(x,w){if(d===p){d&&d(x,w);return}else if(x instanceof Error){p(x);return}w=w||{},w.image=x,d(w)}function b(x,w){w&&e.console&&console.log(w),x&&a("Blob",x)?(c=x,g=r(c)):(g=c,h&&h.crossOrigin&&(m.crossOrigin=h.crossOrigin)),m.src=g}if(m.onerror=function(x){i(g,h),p&&p.call(m,x)},m.onload=function(){i(g,h);var x={originalWidth:m.naturalWidth||m.width,originalHeight:m.naturalHeight||m.height};try{l.transform(m,h,y,c,x)}catch(w){p&&p(w)}},typeof c=="string")return l.requiresMetaData(h)?l.fetchBlob(c,b,h):b(),m;if(a("Blob",c)||a("File",c))return g=r(c),g?(m.src=g,m):o(c,function(x){m.src=x},p)}return e.Promise&&typeof u!="function"?(h=u,new Promise(f)):f(u,u)}l.requiresMetaData=function(c){return c&&c.meta},l.fetchBlob=function(c,u){u()},l.transform=function(c,u,h,f,d){h(c,d)},l.global=e,l.readFile=o,l.isInstanceOf=a,l.createObjectURL=r,l.revokeObjectURL=s,n.exports?n.exports=l:e.loadImage=l})(typeof window<"u"&&window||pt)})(uoe);var Zf=uoe.exports,hoe={exports:{}};(function(n){(function(e){n.exports?e(Zf):e(window.loadImage)})(function(e){var t=e.transform;e.createCanvas=function(r,s,i){if(i&&e.global.OffscreenCanvas)return new OffscreenCanvas(r,s);var o=document.createElement("canvas");return o.width=r,o.height=s,o},e.transform=function(r,s,i,o,a){t.call(e,e.scale(r,s,a),s,i,o,a)},e.transformCoordinates=function(){},e.getTransformedOptions=function(r,s){var i=s.aspectRatio,o,a,l,c;if(!i)return s;o={};for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(o[a]=s[a]);return o.crop=!0,l=r.naturalWidth||r.width,c=r.naturalHeight||r.height,l/c>i?(o.maxWidth=c*i,o.maxHeight=c):(o.maxWidth=l,o.maxHeight=l/i),o},e.drawImage=function(r,s,i,o,a,l,c,u,h){var f=s.getContext("2d");return h.imageSmoothingEnabled===!1?(f.msImageSmoothingEnabled=!1,f.imageSmoothingEnabled=!1):h.imageSmoothingQuality&&(f.imageSmoothingQuality=h.imageSmoothingQuality),f.drawImage(r,i,o,a,l,0,0,c,u),f},e.requiresCanvas=function(r){return r.canvas||r.crop||!!r.aspectRatio},e.scale=function(r,s,i){s=s||{},i=i||{};var o=r.getContext||e.requiresCanvas(s)&&!!e.global.HTMLCanvasElement,a=r.naturalWidth||r.width,l=r.naturalHeight||r.height,c=a,u=l,h,f,d,p,m,g,y,b,x,w,S,C;function k(){var M=Math.max((d||c)/c,(p||u)/u);M>1&&(c*=M,u*=M)}function A(){var M=Math.min((h||c)/c,(f||u)/u);M<1&&(c*=M,u*=M)}if(o&&(s=e.getTransformedOptions(r,s,i),y=s.left||0,b=s.top||0,s.sourceWidth?(m=s.sourceWidth,s.right!==void 0&&s.left===void 0&&(y=a-m-s.right)):m=a-y-(s.right||0),s.sourceHeight?(g=s.sourceHeight,s.bottom!==void 0&&s.top===void 0&&(b=l-g-s.bottom)):g=l-b-(s.bottom||0),c=m,u=g),h=s.maxWidth,f=s.maxHeight,d=s.minWidth,p=s.minHeight,o&&h&&f&&s.crop?(c=h,u=f,S=m/g-h/f,S<0?(g=f*m/h,s.top===void 0&&s.bottom===void 0&&(b=(l-g)/2)):S>0&&(m=h*g/f,s.left===void 0&&s.right===void 0&&(y=(a-m)/2))):((s.contain||s.cover)&&(d=h=h||d,p=f=f||p),s.cover?(A(),k()):(k(),A())),o){if(x=s.pixelRatio,x>1&&!(r.style.width&&Math.floor(parseFloat(r.style.width,10))===Math.floor(a/x))&&(c*=x,u*=x),e.orientationCropBug&&!r.getContext&&(y||b||m!==a||g!==l)&&(S=r,r=e.createCanvas(a,l,!0),e.drawImage(S,r,0,0,a,l,a,l,s)),w=s.downsamplingRatio,w>0&&w<1&&c<m&&u<g)for(;m*w>c;)C=e.createCanvas(m*w,g*w,!0),e.drawImage(r,C,y,b,m,g,C.width,C.height,s),y=0,b=0,m=C.width,g=C.height,r=C;return C=e.createCanvas(c,u),e.transformCoordinates(C,s,i),x>1&&(C.style.width=C.width/x+"px"),e.drawImage(r,C,y,b,m,g,c,u,s).setTransform(1,0,0,1,0,0),C}return r.width=c,r.height=u,r}})})(hoe);var Out=hoe.exports,foe={exports:{}};(function(n){(function(e){n.exports?e(Zf):e(window.loadImage)})(function(e){var t=e.global,r=e.transform,s=t.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice),i=t.ArrayBuffer&&ArrayBuffer.prototype.slice||function(u,h){h=h||this.byteLength-u;var f=new Uint8Array(this,u,h),d=new Uint8Array(h);return d.set(f),d.buffer},o={jpeg:{65505:[],65517:[]}};function a(u,h,f,d){var p=this;function m(g,y){if(!(t.DataView&&s&&u&&u.size>=12&&u.type==="image/jpeg"))return g(d);var b=f.maxMetaDataSize||262144;e.readFile(s.call(u,0,b),function(x){var w=new DataView(x);if(w.getUint16(0)!==65496)return y(new Error("Invalid JPEG file: Missing JPEG marker."));for(var S=2,C=w.byteLength-4,k=S,A,M,E,N;S<C&&(A=w.getUint16(S),A>=65504&&A<=65519||A===65534);){if(M=w.getUint16(S+2)+2,S+M>w.byteLength){console.log("Invalid JPEG metadata: Invalid segment size.");break}if(E=o.jpeg[A],E&&!f.disableMetaDataParsers)for(N=0;N<E.length;N+=1)E[N].call(p,w,S,M,d,f);S+=M,k=S}!f.disableImageHead&&k>6&&(d.imageHead=i.call(x,0,k)),g(d)},y,"readAsArrayBuffer")||g(d)}return f=f||{},t.Promise&&typeof h!="function"?(f=h||{},d=f,new Promise(m)):(d=d||{},m(h,h))}function l(u,h,f){return!u||!h||!f?null:new Blob([f,s.call(u,h.byteLength)],{type:"image/jpeg"})}function c(u,h,f){var d={maxMetaDataSize:1024,disableMetaDataParsers:!0};if(!f&&t.Promise)return a(u,d).then(function(p){return l(u,p.imageHead,h)});a(u,function(p){f(l(u,p.imageHead,h))},d)}e.transform=function(u,h,f,d,p){e.requiresMetaData(h)?(p=p||{},a(d,function(m){m!==p&&(t.console&&console.log(m),m=p),r.call(e,u,h,f,d,m)},h,p)):r.apply(e,arguments)},e.blobSlice=s,e.bufferSlice=i,e.replaceHead=c,e.parseMetaData=a,e.metaDataParsers=o})})(foe);var Y4=foe.exports,Fut={exports:{}};(function(n){(function(e){n.exports?e(Zf):e(window.loadImage)})(function(e){var t=e.global;t.fetch&&t.Request&&t.Response&&t.Response.prototype.blob?e.fetchBlob=function(r,s,i){function o(a){return a.blob()}if(t.Promise&&typeof s!="function")return fetch(new Request(r,s)).then(o);fetch(new Request(r,i)).then(o).then(s).catch(function(a){s(null,a)})}:t.XMLHttpRequest&&new XMLHttpRequest().responseType===""&&(e.fetchBlob=function(r,s,i){function o(a,l){i=i||{};var c=new XMLHttpRequest;c.open(i.method||"GET",r),i.headers&&Object.keys(i.headers).forEach(function(u){c.setRequestHeader(u,i.headers[u])}),c.withCredentials=i.credentials==="include",c.responseType="blob",c.onload=function(){a(c.response)},c.onerror=c.onabort=c.ontimeout=function(u){a===l?l(null,u):l(u)},c.send(i.body)}return t.Promise&&typeof s!="function"?(i=s,new Promise(o)):o(s,s)})})})(Fut);var doe={exports:{}};(function(n){(function(e){n.exports?e(Zf,Y4):e(window.loadImage)})(function(e){function t(c){c&&(Object.defineProperty(this,"map",{value:this.ifds[c].map}),Object.defineProperty(this,"tags",{value:this.tags&&this.tags[c]||{}}))}t.prototype.map={Orientation:274,Thumbnail:"ifd1",Blob:513,Exif:34665,GPSInfo:34853,Interoperability:40965},t.prototype.ifds={ifd1:{name:"Thumbnail",map:t.prototype.map},34665:{name:"Exif",map:{}},34853:{name:"GPSInfo",map:{}},40965:{name:"Interoperability",map:{}}},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){if(h){if(u+h>c.byteLength){console.log("Invalid Exif data: Invalid thumbnail data.");return}return new Blob([e.bufferSlice.call(c.buffer,u,u+h)],{type:"image/jpeg"})}}var s={1:{getValue:function(c,u){return c.getUint8(u)},size:1},2:{getValue:function(c,u){return String.fromCharCode(c.getUint8(u))},size:1,ascii:!0},3:{getValue:function(c,u,h){return c.getUint16(u,h)},size:2},4:{getValue:function(c,u,h){return c.getUint32(u,h)},size:4},5:{getValue:function(c,u,h){return c.getUint32(u,h)/c.getUint32(u+4,h)},size:8},9:{getValue:function(c,u,h){return c.getInt32(u,h)},size:4},10:{getValue:function(c,u,h){return c.getInt32(u,h)/c.getInt32(u+4,h)},size:8}};s[7]=s[1];function i(c,u,h,f,d,p){var m=s[f],g,y,b,x,w,S;if(!m){console.log("Invalid Exif data: Invalid tag type.");return}if(g=m.size*d,y=g>4?u+c.getUint32(h+8,p):h+8,y+g>c.byteLength){console.log("Invalid Exif data: Invalid data offset.");return}if(d===1)return m.getValue(c,y,p);for(b=[],x=0;x<d;x+=1)b[x]=m.getValue(c,y+x*m.size,p);if(m.ascii){for(w="",x=0;x<b.length&&(S=b[x],S!=="\0");x+=1)w+=S;return w}return b}function o(c,u,h){return(!c||c[h])&&(!u||u[h]!==!0)}function a(c,u,h,f,d,p,m,g){var y,b,x,w,S,C;if(h+6>c.byteLength){console.log("Invalid Exif data: Invalid directory offset.");return}if(y=c.getUint16(h,f),b=h+2+12*y,b+4>c.byteLength){console.log("Invalid Exif data: Invalid directory size.");return}for(x=0;x<y;x+=1)w=h+2+12*x,S=c.getUint16(w,f),o(m,g,S)&&(C=i(c,u,w,c.getUint16(w+2,f),c.getUint32(w+4,f),f),d[S]=C,p&&(p[S]=w));return c.getUint32(b,f)}function l(c,u,h,f,d,p,m){var g=c.exif[u];g&&(c.exif[u]=new t(u),c.exifOffsets&&(c.exifOffsets[u]=new t(u)),a(h,f,f+g,d,c.exif[u],c.exifOffsets&&c.exifOffsets[u],p&&p[u],m&&m[u]))}e.parseExifData=function(c,u,h,f,d){if(!d.disableExif){var p=d.includeExifTags,m=d.excludeExifTags||{34665:{37500:!0}},g=u+10,y,b,x;if(c.getUint32(u+4)===1165519206){if(g+8>c.byteLength){console.log("Invalid Exif data: Invalid segment size.");return}if(c.getUint16(u+8)!==0){console.log("Invalid Exif data: Missing byte alignment offset.");return}switch(c.getUint16(g)){case 18761:y=!0;break;case 19789:y=!1;break;default:console.log("Invalid Exif data: Invalid byte alignment marker.");return}if(c.getUint16(g+2,y)!==42){console.log("Invalid Exif data: Missing TIFF marker.");return}b=c.getUint32(g+4,y),f.exif=new t,d.disableExifOffsets||(f.exifOffsets=new t,f.exifTiffOffset=g,f.exifLittleEndian=y),b=a(c,g,g+b,y,f.exif,f.exifOffsets,p,m),b&&o(p,m,"ifd1")&&(f.exif.ifd1=b,f.exifOffsets&&(f.exifOffsets.ifd1=g+b)),Object.keys(f.exif.ifds).forEach(function(w){l(f,w,c,g,y,p,m)}),x=f.exif.ifd1,x&&x[513]&&(x[513]=r(c,g+x[513],x[514]))}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData),e.exifWriters={274:function(c,u,h){var f=u.exifOffsets[274];if(!f)return c;var d=new DataView(c,f+8,2);return d.setUint16(0,h,u.exifLittleEndian),c}},e.writeExifData=function(c,u,h,f){return e.exifWriters[u.exif.map[h]](c,u,f)},e.ExifMap=t})})(doe);var Lut=doe.exports,zut={exports:{}};(function(n){(function(e){n.exports?e(Zf,Lut):e(window.loadImage)})(function(e){var t=e.ExifMap.prototype;t.tags={256:"ImageWidth",257:"ImageHeight",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",34665:{36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",36880:"OffsetTime",36881:"OffsetTimeOriginal",36882:"OffsetTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber"},34853:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},40965:{1:"InteroperabilityIndex"}},t.tags.ifd1=t.tags,t.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"Original",2:"Horizontal flip",3:"Rotate 180° CCW",4:"Vertical flip",5:"Vertical flip + Rotate 90° CW",6:"Rotate 90° CW",7:"Horizontal flip + Rotate 90° CW",8:"Rotate 90° CCW"}},t.getText=function(r){var s=this.get(r);switch(r){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[r][s];case"ExifVersion":case"FlashpixVersion":return s?String.fromCharCode(s[0],s[1],s[2],s[3]):void 0;case"ComponentsConfiguration":return s?this.stringValues[r][s[0]]+this.stringValues[r][s[1]]+this.stringValues[r][s[2]]+this.stringValues[r][s[3]]:void 0;case"GPSVersionID":return s?s[0]+"."+s[1]+"."+s[2]+"."+s[3]:void 0}return String(s)},t.getAll=function(){var r={},s,i,o;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this[s],i&&i.getAll?r[this.ifds[s].name]=i.getAll():(o=this.tags[s],o&&(r[o]=this.getText(o))));return r},t.getName=function(r){var s=this.tags[r];return typeof s=="object"?this.ifds[r].name:s},function(){var r=t.tags,s,i,o;for(s in r)if(Object.prototype.hasOwnProperty.call(r,s))if(i=t.ifds[s],i){o=r[s];for(s in o)Object.prototype.hasOwnProperty.call(o,s)&&(i.map[o[s]]=Number(s))}else t.map[r[s]]=Number(s)}()})})(zut);var poe={exports:{}};(function(n){(function(e){n.exports?e(Zf,Y4):e(window.loadImage)})(function(e){function t(){}t.prototype.map={ObjectName:5},t.prototype.types={0:"Uint16",200:"Uint16",201:"Uint16",202:"binary"},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){for(var f="",d=u+h,p=u;p<d;p+=1)f+=String.fromCharCode(c.getUint8(p));return f}function s(c,u,h,f,d){return u.types[c]==="binary"?new Blob([h.buffer.slice(f,f+d)]):u.types[c]==="Uint16"?h.getUint16(f):r(h,f,d)}function i(c,u){return c===void 0?u:c instanceof Array?(c.push(u),c):[c,u]}function o(c,u,h,f,d,p){for(var m,g,y,b=u+h,x=u;x<b;)c.getUint8(x)===28&&c.getUint8(x+1)===2&&(y=c.getUint8(x+2),(!d||d[y])&&(!p||!p[y])&&(g=c.getInt16(x+3),m=s(y,f.iptc,c,x+5,g),f.iptc[y]=i(f.iptc[y],m),f.iptcOffsets&&(f.iptcOffsets[y]=x))),x+=1}function a(c,u){return c.getUint32(u)===943868237&&c.getUint16(u+4)===1028}function l(c,u){var h=c.getUint8(u+7);return h%2!==0&&(h+=1),h===0&&(h=4),h}e.parseIptcData=function(c,u,h,f,d){if(!d.disableIptc)for(var p=u+h;u+8<p;){if(a(c,u)){var m=l(c,u),g=u+8+m;if(g>p){console.log("Invalid IPTC data: Invalid segment offset.");break}var y=c.getUint16(u+6+m);if(u+y>p){console.log("Invalid IPTC data: Invalid segment size.");break}f.iptc=new t,d.disableIptcOffsets||(f.iptcOffsets=new t),o(c,g,y,f,d.includeIptcTags,d.excludeIptcTags||{202:!0});return}u+=1}},e.metaDataParsers.jpeg[65517].push(e.parseIptcData),e.IptcMap=t})})(poe);var But=poe.exports,Vut={exports:{}};(function(n){(function(e){n.exports?e(Zf,But):e(window.loadImage)})(function(e){var t=e.IptcMap.prototype;t.tags={0:"ApplicationRecordVersion",3:"ObjectTypeReference",4:"ObjectAttributeReference",5:"ObjectName",7:"EditStatus",8:"EditorialUpdate",10:"Urgency",12:"SubjectReference",15:"Category",20:"SupplementalCategories",22:"FixtureIdentifier",25:"Keywords",26:"ContentLocationCode",27:"ContentLocationName",30:"ReleaseDate",35:"ReleaseTime",37:"ExpirationDate",38:"ExpirationTime",40:"SpecialInstructions",42:"ActionAdvised",45:"ReferenceService",47:"ReferenceDate",50:"ReferenceNumber",55:"DateCreated",60:"TimeCreated",62:"DigitalCreationDate",63:"DigitalCreationTime",65:"OriginatingProgram",70:"ProgramVersion",75:"ObjectCycle",80:"Byline",85:"BylineTitle",90:"City",92:"Sublocation",95:"State",100:"CountryCode",101:"Country",103:"OriginalTransmissionReference",105:"Headline",110:"Credit",115:"Source",116:"CopyrightNotice",118:"Contact",120:"Caption",121:"LocalCaption",122:"Writer",125:"RasterizedCaption",130:"ImageType",131:"ImageOrientation",135:"LanguageIdentifier",150:"AudioType",151:"AudioSamplingRate",152:"AudioSamplingResolution",153:"AudioDuration",154:"AudioOutcue",184:"JobID",185:"MasterDocumentID",186:"ShortDocumentID",187:"UniqueDocumentID",188:"OwnerID",200:"ObjectPreviewFileFormat",201:"ObjectPreviewFileVersion",202:"ObjectPreviewData",221:"Prefs",225:"ClassifyState",228:"SimilarityIndex",230:"DocumentNotes",231:"DocumentHistory",232:"ExifCameraInfo",255:"CatalogSets"},t.stringValues={10:{0:"0 (reserved)",1:"1 (most urgent)",2:"2",3:"3",4:"4",5:"5 (normal urgency)",6:"6",7:"7",8:"8 (least urgent)",9:"9 (user-defined priority)"},75:{a:"Morning",b:"Both Morning and Evening",p:"Evening"},131:{L:"Landscape",P:"Portrait",S:"Square"}},t.getText=function(r){var s=this.get(r),i=this.map[r],o=this.stringValues[i];return o?o[s]:String(s)},t.getAll=function(){var r={},s,i;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this.tags[s],i&&(r[i]=this.getText(i)));return r},t.getName=function(r){return this.tags[r]},function(){var r=t.tags,s=t.map||{},i;for(i in r)Object.prototype.hasOwnProperty.call(r,i)&&(s[r[i]]=Number(i))}()})})(Vut);var Uut={exports:{}};(function(n){(function(e){n.exports?e(Zf,Out,Y4):e(window.loadImage)})(function(e){var t=e.transform,r=e.requiresCanvas,s=e.requiresMetaData,i=e.transformCoordinates,o=e.getTransformedOptions;(function(u){if(u.global.document){var h="data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/xABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQvoP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXwH/9k=",f=document.createElement("img");f.onload=function(){if(u.orientation=f.width===2&&f.height===3,u.orientation){var d=u.createCanvas(1,1,!0),p=d.getContext("2d");p.drawImage(f,1,1,1,1,0,0,1,1),u.orientationCropBug=p.getImageData(0,0,1,1).data.toString()!=="255,255,255,255"}},f.src=h}})(e);function a(u,h){var f=u&&u.orientation;return f===!0&&!e.orientation||f===1&&e.orientation||(!h||e.orientation)&&f>1&&f<9}function l(u,h){return u!==h&&(u===1&&h>1&&h<9||u>1&&u<9)}function c(u,h){if(h>1&&h<9)switch(u){case 2:case 4:return h>4;case 5:case 7:return h%2===0;case 6:case 8:return h===2||h===4||h===5||h===7}return!1}e.requiresCanvas=function(u){return a(u)||r.call(e,u)},e.requiresMetaData=function(u){return a(u,!0)||s.call(e,u)},e.transform=function(u,h,f,d,p){t.call(e,u,h,function(m,g){if(g){var y=e.orientation&&g.exif&&g.exif.get("Orientation");if(y>4&&y<9){var b=g.originalWidth,x=g.originalHeight;g.originalWidth=x,g.originalHeight=b}}f(m,g)},d,p)},e.getTransformedOptions=function(u,h,f){var d=o.call(e,u,h),p=f.exif&&f.exif.get("Orientation"),m=d.orientation,g=e.orientation&&p;if(m===!0&&(m=p),!l(m,g))return d;var y=d.top,b=d.right,x=d.bottom,w=d.left,S={};for(var C in d)Object.prototype.hasOwnProperty.call(d,C)&&(S[C]=d[C]);if(S.orientation=m,(m>4&&!(g>4)||m<5&&g>4)&&(S.maxWidth=d.maxHeight,S.maxHeight=d.maxWidth,S.minWidth=d.minHeight,S.minHeight=d.minWidth,S.sourceWidth=d.sourceHeight,S.sourceHeight=d.sourceWidth),g>1){switch(g){case 2:b=d.left,w=d.right;break;case 3:y=d.bottom,b=d.left,x=d.top,w=d.right;break;case 4:y=d.bottom,x=d.top;break;case 5:y=d.left,b=d.bottom,x=d.right,w=d.top;break;case 6:y=d.left,b=d.top,x=d.right,w=d.bottom;break;case 7:y=d.right,b=d.top,x=d.left,w=d.bottom;break;case 8:y=d.right,b=d.bottom,x=d.left,w=d.top;break}if(c(m,g)){var k=y,A=b;y=x,b=w,x=k,w=A}}switch(S.top=y,S.right=b,S.bottom=x,S.left=w,m){case 2:S.right=w,S.left=b;break;case 3:S.top=x,S.right=w,S.bottom=y,S.left=b;break;case 4:S.top=x,S.bottom=y;break;case 5:S.top=w,S.right=x,S.bottom=b,S.left=y;break;case 6:S.top=b,S.right=x,S.bottom=w,S.left=y;break;case 7:S.top=b,S.right=y,S.bottom=w,S.left=x;break;case 8:S.top=w,S.right=y,S.bottom=b,S.left=x;break}return S},e.transformCoordinates=function(u,h,f){i.call(e,u,h,f);var d=h.orientation,p=e.orientation&&f.exif&&f.exif.get("Orientation");if(l(d,p)){var m=u.getContext("2d"),g=u.width,y=u.height,b=g,x=y;switch((d>4&&!(p>4)||d<5&&p>4)&&(u.width=y,u.height=g),d>4&&(b=y,x=g),p){case 2:m.translate(b,0),m.scale(-1,1);break;case 3:m.translate(b,x),m.rotate(Math.PI);break;case 4:m.translate(0,x),m.scale(1,-1);break;case 5:m.rotate(-.5*Math.PI),m.scale(-1,1);break;case 6:m.rotate(-.5*Math.PI),m.translate(-b,0);break;case 7:m.rotate(-.5*Math.PI),m.translate(-b,x),m.scale(1,-1);break;case 8:m.rotate(.5*Math.PI),m.translate(0,-x);break}switch(c(d,p)&&(m.translate(b,x),m.rotate(Math.PI)),d){case 2:m.translate(g,0),m.scale(-1,1);break;case 3:m.translate(g,y),m.rotate(Math.PI);break;case 4:m.translate(0,y),m.scale(1,-1);break;case 5:m.rotate(.5*Math.PI),m.scale(1,-1);break;case 6:m.rotate(.5*Math.PI),m.translate(0,-y);break;case 7:m.rotate(.5*Math.PI),m.translate(g,-y),m.scale(-1,1);break;case 8:m.rotate(-.5*Math.PI),m.translate(-g,0);break}}}})})(Uut);var Wut=Zf;const Pj=Np(Wut);function M$(n,e){let t=0;for(let r=0;r<n.length;r++)t+=(n[r]-e[r])*(n[r]-e[r]);return t}const rP={distanceFunction:M$};function Gut(n,e,t=rP){const r=t.distanceFunction||rP.distanceFunction,s=t.similarityFunction||rP.similarityFunction;let i=-1;if(typeof s=="function"){let o=Number.MIN_VALUE;for(let a=0;a<n.length;a++){const l=s(e,n[a]);l>o&&(o=l,i=a)}}else if(typeof r=="function"){let o=Number.MAX_VALUE;for(let a=0;a<n.length;a++){const l=r(e,n[a]);l<o&&(o=l,i=a)}}else throw new Error("A similarity or distance function it's required");return i}function Hut(n,e){for(var t=new Array(n.length),r=0;r<n.length;++r)for(var s=r;s<n.length;++s){t[r]||(t[r]=new Array(n.length)),t[s]||(t[s]=new Array(n.length));const i=e(n[r],n[s]);t[r][s]=i,t[s][r]=i}return t}function moe(n,e,t,r){for(var s=0;s<n.length;s++)t[s]=Gut(e,n[s],{distanceFunction:r});return t}function jut(n,e,t,r){const s=e[0].length;for(var i=new Array(r),o=new Array(r),a=0;a<r;a++){i[a]=new Array(s),o[a]=0;for(var l=0;l<s;l++)i[a][l]=0}for(var c=0;c<e.length;c++){o[t[c]]++;for(var u=0;u<s;u++)i[t[c]][u]+=e[c][u]}for(var h=0;h<r;h++)for(var f=0;f<s;f++)o[h]?i[h][f]/=o[h]:i[h][f]=n[h][f];return i}function qut(n,e,t,r){for(var s=0;s<n.length;s++)if(t(n[s],e[s])>r)return!1;return!0}const Dj=8,Xut=1/16777216,Kut=15,Yut=18,Zut=11;function Jut(n,e){n>>>=0,e>>>=0;const t=n&65535;return((n-t)*e>>>0)+t*e>>>0}class Qut{constructor(e=Date.now()){this.state=new Uint32Array(4),this.init(e),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*Xut}init(e){if(!Number.isInteger(e))throw new TypeError("seed must be an integer");this.state[0]=e,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<Dj;t++)this.state[t&3]^=t+Jut(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<Dj;t++)this.nextState()}periodCertification(){this.state[0]===0&&this.state[1]===0&&this.state[2]===0&&this.state[3]===0&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let e=this.state[0];e^=e<<Kut,e^=e>>>Yut,e^=this.state[3]<<Zut,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=e}}const eht=1e-8;function Oj(n,e={},t=Math.random){const{size:r=1,replace:s=!1,probabilities:i}=e;let o,a;if(typeof n=="number"?o=tht(n):o=n.slice(),i){if(!s)throw new Error("choice with probabilities and no replacement is not implemented");if(i.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[i[0]];for(let c=1;c<i.length;c++)a[c]=a[c-1]+i[c];if(Math.abs(1-a[a.length-1])>eht)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(s===!1&&r>o.length)throw new Error("size option is too large");const l=[];for(let c=0;c<r;c++){const u=nht(o.length,t,a);l.push(o[u]),s||o.splice(u,1)}return l}function tht(n){const e=[];for(let t=0;t<n;t++)e.push(t);return e}function nht(n,e,t){const r=e();if(t){let s=0;for(;r>t[s];)s++;return s}else return Math.floor(r*n)}class Z4{constructor(e=Math.random){if(typeof e=="number"){const t=new Qut(e);this.randomGenerator=t.random}else this.randomGenerator=e}choice(e,t){return typeof e=="number"?Oj(e,t,this.randomGenerator):Oj(e,t,this.randomGenerator)}random(){return this.randomGenerator()}randInt(e,t){return t===void 0&&(t=e,e=0),e+Math.floor(this.randomGenerator()*(t-e))}randomSample(e){const t=[];for(let r=0;r<e;r++)t.push(this.random());return t}}var cr={};const rht=Object.prototype.toString;function oS(n){const e=rht.call(n);return e.endsWith("Array]")&&!e.includes("Big")}const sht=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray:oS},Symbol.toStringTag,{value:"Module"})),iht=Gf(sht);function oht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!oS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]>o&&(o=n[a]);return o}function aht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!oS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]<o&&(o=n[a]);return o}function lht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(oS(n)){if(n.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var t;if(e.output!==void 0){if(!oS(e.output))throw new TypeError("output option must be an array if specified");t=e.output}else t=new Array(n.length);var r=aht(n),s=oht(n);if(r===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=e.min,o=i===void 0?e.autoMinMax?r:0:i,a=e.max,l=a===void 0?e.autoMinMax?s:1:a;if(o>=l)throw new RangeError("min option must be smaller than max option");for(var c=(l-o)/(s-r),u=0;u<n.length;u++)t[u]=(n[u]-r)*c+o;return t}const cht=Object.freeze(Object.defineProperty({__proto__:null,default:lht},Symbol.toStringTag,{value:"Module"})),uht=Gf(cht);var Ua=iht,Fj=uht;const DT=" ".repeat(2),goe=" ".repeat(4);function hht(){return yoe(this)}function yoe(n,e={}){const{maxRows:t=15,maxColumns:r=10,maxNumSize:s=8,padMinus:i="auto"}=e;return`${n.constructor.name} {
${DT}[
${goe}${fht(n,t,r,s,i)}
${DT}]
${DT}rows: ${n.rows}
${DT}columns: ${n.columns}
}`}function fht(n,e,t,r,s){const{rows:i,columns:o}=n,a=Math.min(i,e),l=Math.min(o,t),c=[];if(s==="auto"){s=!1;e:for(let u=0;u<a;u++)for(let h=0;h<l;h++)if(n.get(u,h)<0){s=!0;break e}}for(let u=0;u<a;u++){let h=[];for(let f=0;f<l;f++)h.push(dht(n.get(u,f),r,s));c.push(`${h.join(" ")}`)}return l!==o&&(c[c.length-1]+=` ... ${o-t} more columns`),a!==i&&c.push(`... ${i-e} more rows`),c.join(`
${goe}`)}function dht(n,e,t){return(n>=0&&t?` ${Lj(n,e-1)}`:Lj(n,e)).padEnd(e)}function Lj(n,e){let t=n.toString();if(t.length<=e)return t;let r=n.toFixed(e);if(r.length>e&&(r=n.toFixed(Math.max(0,e-(r.length-e)))),r.length<=e&&!r.startsWith("0.000")&&!r.startsWith("-0.000"))return r;let s=n.toExponential(e);return s.length>e&&(s=n.toExponential(Math.max(0,e-(s.length-e)))),s.slice(0)}function pht(n,e){n.prototype.add=function(r){return typeof r=="number"?this.addS(r):this.addM(r)},n.prototype.addS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r);return this},n.prototype.addM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r.get(s,i));return this},n.add=function(r,s){return new e(r).add(s)},n.prototype.sub=function(r){return typeof r=="number"?this.subS(r):this.subM(r)},n.prototype.subS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r);return this},n.prototype.subM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r.get(s,i));return this},n.sub=function(r,s){return new e(r).sub(s)},n.prototype.subtract=n.prototype.sub,n.prototype.subtractS=n.prototype.subS,n.prototype.subtractM=n.prototype.subM,n.subtract=n.sub,n.prototype.mul=function(r){return typeof r=="number"?this.mulS(r):this.mulM(r)},n.prototype.mulS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r);return this},n.prototype.mulM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r.get(s,i));return this},n.mul=function(r,s){return new e(r).mul(s)},n.prototype.multiply=n.prototype.mul,n.prototype.multiplyS=n.prototype.mulS,n.prototype.multiplyM=n.prototype.mulM,n.multiply=n.mul,n.prototype.div=function(r){return typeof r=="number"?this.divS(r):this.divM(r)},n.prototype.divS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r);return this},n.prototype.divM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r.get(s,i));return this},n.div=function(r,s){return new e(r).div(s)},n.prototype.divide=n.prototype.div,n.prototype.divideS=n.prototype.divS,n.prototype.divideM=n.prototype.divM,n.divide=n.div,n.prototype.mod=function(r){return typeof r=="number"?this.modS(r):this.modM(r)},n.prototype.modS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r);return this},n.prototype.modM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r.get(s,i));return this},n.mod=function(r,s){return new e(r).mod(s)},n.prototype.modulus=n.prototype.mod,n.prototype.modulusS=n.prototype.modS,n.prototype.modulusM=n.prototype.modM,n.modulus=n.mod,n.prototype.and=function(r){return typeof r=="number"?this.andS(r):this.andM(r)},n.prototype.andS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r);return this},n.prototype.andM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r.get(s,i));return this},n.and=function(r,s){return new e(r).and(s)},n.prototype.or=function(r){return typeof r=="number"?this.orS(r):this.orM(r)},n.prototype.orS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r);return this},n.prototype.orM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r.get(s,i));return this},n.or=function(r,s){return new e(r).or(s)},n.prototype.xor=function(r){return typeof r=="number"?this.xorS(r):this.xorM(r)},n.prototype.xorS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r);return this},n.prototype.xorM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r.get(s,i));return this},n.xor=function(r,s){return new e(r).xor(s)},n.prototype.leftShift=function(r){return typeof r=="number"?this.leftShiftS(r):this.leftShiftM(r)},n.prototype.leftShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r);return this},n.prototype.leftShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r.get(s,i));return this},n.leftShift=function(r,s){return new e(r).leftShift(s)},n.prototype.signPropagatingRightShift=function(r){return typeof r=="number"?this.signPropagatingRightShiftS(r):this.signPropagatingRightShiftM(r)},n.prototype.signPropagatingRightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r);return this},n.prototype.signPropagatingRightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r.get(s,i));return this},n.signPropagatingRightShift=function(r,s){return new e(r).signPropagatingRightShift(s)},n.prototype.rightShift=function(r){return typeof r=="number"?this.rightShiftS(r):this.rightShiftM(r)},n.prototype.rightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r);return this},n.prototype.rightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r.get(s,i));return this},n.rightShift=function(r,s){return new e(r).rightShift(s)},n.prototype.zeroFillRightShift=n.prototype.rightShift,n.prototype.zeroFillRightShiftS=n.prototype.rightShiftS,n.prototype.zeroFillRightShiftM=n.prototype.rightShiftM,n.zeroFillRightShift=n.rightShift,n.prototype.not=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,~this.get(r,s));return this},n.not=function(r){return new e(r).not()},n.prototype.abs=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.abs(this.get(r,s)));return this},n.abs=function(r){return new e(r).abs()},n.prototype.acos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acos(this.get(r,s)));return this},n.acos=function(r){return new e(r).acos()},n.prototype.acosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acosh(this.get(r,s)));return this},n.acosh=function(r){return new e(r).acosh()},n.prototype.asin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asin(this.get(r,s)));return this},n.asin=function(r){return new e(r).asin()},n.prototype.asinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asinh(this.get(r,s)));return this},n.asinh=function(r){return new e(r).asinh()},n.prototype.atan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atan(this.get(r,s)));return this},n.atan=function(r){return new e(r).atan()},n.prototype.atanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atanh(this.get(r,s)));return this},n.atanh=function(r){return new e(r).atanh()},n.prototype.cbrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cbrt(this.get(r,s)));return this},n.cbrt=function(r){return new e(r).cbrt()},n.prototype.ceil=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.ceil(this.get(r,s)));return this},n.ceil=function(r){return new e(r).ceil()},n.prototype.clz32=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.clz32(this.get(r,s)));return this},n.clz32=function(r){return new e(r).clz32()},n.prototype.cos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cos(this.get(r,s)));return this},n.cos=function(r){return new e(r).cos()},n.prototype.cosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cosh(this.get(r,s)));return this},n.cosh=function(r){return new e(r).cosh()},n.prototype.exp=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.exp(this.get(r,s)));return this},n.exp=function(r){return new e(r).exp()},n.prototype.expm1=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.expm1(this.get(r,s)));return this},n.expm1=function(r){return new e(r).expm1()},n.prototype.floor=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.floor(this.get(r,s)));return this},n.floor=function(r){return new e(r).floor()},n.prototype.fround=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.fround(this.get(r,s)));return this},n.fround=function(r){return new e(r).fround()},n.prototype.log=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log(this.get(r,s)));return this},n.log=function(r){return new e(r).log()},n.prototype.log1p=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log1p(this.get(r,s)));return this},n.log1p=function(r){return new e(r).log1p()},n.prototype.log10=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log10(this.get(r,s)));return this},n.log10=function(r){return new e(r).log10()},n.prototype.log2=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log2(this.get(r,s)));return this},n.log2=function(r){return new e(r).log2()},n.prototype.round=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.round(this.get(r,s)));return this},n.round=function(r){return new e(r).round()},n.prototype.sign=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sign(this.get(r,s)));return this},n.sign=function(r){return new e(r).sign()},n.prototype.sin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sin(this.get(r,s)));return this},n.sin=function(r){return new e(r).sin()},n.prototype.sinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sinh(this.get(r,s)));return this},n.sinh=function(r){return new e(r).sinh()},n.prototype.sqrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sqrt(this.get(r,s)));return this},n.sqrt=function(r){return new e(r).sqrt()},n.prototype.tan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tan(this.get(r,s)));return this},n.tan=function(r){return new e(r).tan()},n.prototype.tanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tanh(this.get(r,s)));return this},n.tanh=function(r){return new e(r).tanh()},n.prototype.trunc=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.trunc(this.get(r,s)));return this},n.trunc=function(r){return new e(r).trunc()},n.pow=function(r,s){return new e(r).pow(s)},n.prototype.pow=function(r){return typeof r=="number"?this.powS(r):this.powM(r)},n.prototype.powS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r));return this},n.prototype.powM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r.get(s,i)));return this}}function ic(n,e,t){let r=t?n.rows:n.rows-1;if(e<0||e>r)throw new RangeError("Row index out of range")}function oc(n,e,t){let r=t?n.columns:n.columns-1;if(e<0||e>r)throw new RangeError("Column index out of range")}function bb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function vb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function J4(n,e){if(!Ua.isAnyArray(e))throw new TypeError("row indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.rows)throw new RangeError("row indices are out of range")}function Q4(n,e){if(!Ua.isAnyArray(e))throw new TypeError("column indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.columns)throw new RangeError("column indices are out of range")}function SF(n,e,t,r,s){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(OT("startRow",e),OT("endRow",t),OT("startColumn",r),OT("endColumn",s),e>t||r>s||e<0||e>=n.rows||t<0||t>=n.rows||r<0||r>=n.columns||s<0||s>=n.columns)throw new RangeError("Submatrix indices are out of range")}function N$(n,e=0){let t=[];for(let r=0;r<n;r++)t.push(e);return t}function OT(n,e){if(typeof e!="number")throw new TypeError(`${n} must be a number`)}function G0(n){if(n.isEmpty())throw new Error("Empty matrix has no elements to index")}function mht(n){let e=N$(n.rows);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]+=n.get(t,r);return e}function ght(n){let e=N$(n.columns);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]+=n.get(t,r);return e}function yht(n){let e=0;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e+=n.get(t,r);return e}function bht(n){let e=N$(n.rows,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]*=n.get(t,r);return e}function vht(n){let e=N$(n.columns,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]*=n.get(t,r);return e}function wht(n){let e=1;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e*=n.get(t,r);return e}function xht(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<r;o++){let a=0,l=0,c=0;for(let u=0;u<s;u++)c=n.get(o,u)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/s)/(s-1)):i.push((l-a*a/s)/s)}return i}function _ht(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<s;o++){let a=0,l=0,c=0;for(let u=0;u<r;u++)c=n.get(u,o)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/r)/(r-1)):i.push((l-a*a/r)/r)}return i}function Sht(n,e,t){const r=n.rows,s=n.columns,i=r*s;let o=0,a=0,l=0;for(let c=0;c<r;c++)for(let u=0;u<s;u++)l=n.get(c,u)-t,o+=l,a+=l*l;return e?(a-o*o/i)/(i-1):(a-o*o/i)/i}function Cht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[t])}function kht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[r])}function Tht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e)}function Eht(n){const e=[];for(let t=0;t<n.rows;t++){let r=0;for(let s=0;s<n.columns;s++)r+=Math.pow(n.get(t,s),2)/(n.columns-1);e.push(Math.sqrt(r))}return e}function Iht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[t])}function Aht(n){const e=[];for(let t=0;t<n.columns;t++){let r=0;for(let s=0;s<n.rows;s++)r+=Math.pow(n.get(s,t),2)/(n.rows-1);e.push(Math.sqrt(r))}return e}function Mht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[r])}function Nht(n){const e=n.size-1;let t=0;for(let r=0;r<n.columns;r++)for(let s=0;s<n.rows;s++)t+=Math.pow(n.get(s,r),2)/e;return Math.sqrt(t)}function $ht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e)}class Gn{static from1DArray(e,t,r){if(e*t!==r.length)throw new RangeError("data length does not match given dimensions");let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,r[o*t+a]);return i}static rowVector(e){let t=new Wt(1,e.length);for(let r=0;r<e.length;r++)t.set(0,r,e[r]);return t}static columnVector(e){let t=new Wt(e.length,1);for(let r=0;r<e.length;r++)t.set(r,0,e[r]);return t}static zeros(e,t){return new Wt(e,t)}static ones(e,t){return new Wt(e,t).fill(1)}static rand(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{random:s=Math.random}=r;let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,s());return i}static randInt(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:s=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(s>=i)throw new RangeError("min must be smaller than max");let a=i-s,l=new Wt(e,t);for(let c=0;c<e;c++)for(let u=0;u<t;u++){let h=s+Math.round(o()*a);l.set(c,u,h)}return l}static eye(e,t,r){t===void 0&&(t=e),r===void 0&&(r=1);let s=Math.min(e,t),i=this.zeros(e,t);for(let o=0;o<s;o++)i.set(o,o,r);return i}static diag(e,t,r){let s=e.length;t===void 0&&(t=s),r===void 0&&(r=t);let i=Math.min(s,t,r),o=this.zeros(t,r);for(let a=0;a<i;a++)o.set(a,a,e[a]);return o}static min(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new Wt(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.min(e.get(o,a),t.get(o,a)));return i}static max(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new this(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.max(e.get(o,a),t.get(o,a)));return i}static checkMatrix(e){return Gn.isMatrix(e)?e:new Wt(e)}static isMatrix(e){return e!=null&&e.klass==="Matrix"}get size(){return this.rows*this.columns}apply(e){if(typeof e!="function")throw new TypeError("callback must be a function");for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.call(this,t,r);return this}to1DArray(){let e=[];for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}to2DArray(){let e=[];for(let t=0;t<this.rows;t++){e.push([]);for(let r=0;r<this.columns;r++)e[t].push(this.get(t,r))}return e}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let e=0;e<this.rows;e++)for(let t=0;t<=e;t++)if(this.get(e,t)!==this.get(t,e))return!1;return!0}return!1}isEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);e++}return s}isReducedEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);for(let o=t+1;o<this.rows;o++)this.get(e,o)!==0&&(s=!1);e++}return s}echelonForm(){let e=this.clone(),t=0,r=0;for(;t<e.rows&&r<e.columns;){let s=t;for(let i=t;i<e.rows;i++)e.get(i,r)>e.get(s,r)&&(s=i);if(e.get(s,r)===0)r++;else{e.swapRows(t,s);let i=e.get(t,r);for(let o=r;o<e.columns;o++)e.set(t,o,e.get(t,o)/i);for(let o=t+1;o<e.rows;o++){let a=e.get(o,r)/e.get(t,r);e.set(o,r,0);for(let l=r+1;l<e.columns;l++)e.set(o,l,e.get(o,l)-e.get(t,l)*a)}t++,r++}}return e}reducedEchelonForm(){let e=this.echelonForm(),t=e.columns,r=e.rows,s=r-1;for(;s>=0;)if(e.maxRow(s)===0)s--;else{let i=0,o=!1;for(;i<r&&o===!1;)e.get(s,i)===1?o=!0:i++;for(let a=0;a<s;a++){let l=e.get(a,i);for(let c=i;c<t;c++){let u=e.get(a,c)-l*e.get(s,c);e.set(a,c,u)}}s--}return e}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{rows:t=1,columns:r=1}=e;if(!Number.isInteger(t)||t<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new Wt(this.rows*t,this.columns*r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)s.setSubMatrix(this,this.rows*i,this.columns*o);return s}fill(e){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,e);return this}neg(){return this.mulS(-1)}getRow(e){ic(this,e);let t=[];for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}getRowVector(e){return Wt.rowVector(this.getRow(e))}setRow(e,t){ic(this,e),t=bb(this,t);for(let r=0;r<this.columns;r++)this.set(e,r,t[r]);return this}swapRows(e,t){ic(this,e),ic(this,t);for(let r=0;r<this.columns;r++){let s=this.get(e,r);this.set(e,r,this.get(t,r)),this.set(t,r,s)}return this}getColumn(e){oc(this,e);let t=[];for(let r=0;r<this.rows;r++)t.push(this.get(r,e));return t}getColumnVector(e){return Wt.columnVector(this.getColumn(e))}setColumn(e,t){oc(this,e),t=vb(this,t);for(let r=0;r<this.rows;r++)this.set(r,e,t[r]);return this}swapColumns(e,t){oc(this,e),oc(this,t);for(let r=0;r<this.rows;r++){let s=this.get(r,e);this.set(r,e,this.get(r,t)),this.set(r,t,s)}return this}addRowVector(e){e=bb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[r]);return this}subRowVector(e){e=bb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[r]);return this}mulRowVector(e){e=bb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[r]);return this}divRowVector(e){e=bb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[r]);return this}addColumnVector(e){e=vb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[t]);return this}subColumnVector(e){e=vb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[t]);return this}mulColumnVector(e){e=vb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[t]);return this}divColumnVector(e){e=vb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[t]);return this}mulRow(e,t){ic(this,e);for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this}mulColumn(e,t){oc(this,e);for(let r=0;r<this.rows;r++)this.set(r,e,this.get(r,e)*t);return this}max(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}maxIndex(){G0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}min(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}minIndex(){G0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}maxRow(e){if(ic(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxRowIndex(e){ic(this,e),G0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)>t&&(t=this.get(e,s),r[1]=s);return r}minRow(e){if(ic(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minRowIndex(e){ic(this,e),G0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)<t&&(t=this.get(e,s),r[1]=s);return r}maxColumn(e){if(oc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)>t&&(t=this.get(r,e));return t}maxColumnIndex(e){oc(this,e),G0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)>t&&(t=this.get(s,e),r[0]=s);return r}minColumn(e){if(oc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)<t&&(t=this.get(r,e));return t}minColumnIndex(e){oc(this,e),G0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)<t&&(t=this.get(s,e),r[0]=s);return r}diag(){let e=Math.min(this.rows,this.columns),t=[];for(let r=0;r<e;r++)t.push(this.get(r,r));return t}norm(e="frobenius"){switch(e){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${e}`)}}cumulativeSum(){let e=0;for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r),this.set(t,r,e);return this}dot(e){Gn.isMatrix(e)&&(e=e.to1DArray());let t=this.to1DArray();if(t.length!==e.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<t.length;s++)r+=t[s]*e[s];return r}mmul(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.columns,i=new Wt(t,s),o=new Float64Array(r);for(let a=0;a<s;a++){for(let l=0;l<r;l++)o[l]=e.get(l,a);for(let l=0;l<t;l++){let c=0;for(let u=0;u<r;u++)c+=this.get(l,u)*o[u];i.set(l,a,c)}}return i}strassen2x2(e){e=Wt.checkMatrix(e);let t=new Wt(2,2);const r=this.get(0,0),s=e.get(0,0),i=this.get(0,1),o=e.get(0,1),a=this.get(1,0),l=e.get(1,0),c=this.get(1,1),u=e.get(1,1),h=(r+c)*(s+u),f=(a+c)*s,d=r*(o-u),p=c*(l-s),m=(r+i)*u,g=(a-r)*(s+o),y=(i-c)*(l+u),b=h+p-m+y,x=d+m,w=f+p,S=h-f+d+g;return t.set(0,0,b),t.set(0,1,x),t.set(1,0,w),t.set(1,1,S),t}strassen3x3(e){e=Wt.checkMatrix(e);let t=new Wt(3,3);const r=this.get(0,0),s=this.get(0,1),i=this.get(0,2),o=this.get(1,0),a=this.get(1,1),l=this.get(1,2),c=this.get(2,0),u=this.get(2,1),h=this.get(2,2),f=e.get(0,0),d=e.get(0,1),p=e.get(0,2),m=e.get(1,0),g=e.get(1,1),y=e.get(1,2),b=e.get(2,0),x=e.get(2,1),w=e.get(2,2),S=(r+s+i-o-a-u-h)*g,C=(r-o)*(-d+g),k=a*(-f+d+m-g-y-b+w),A=(-r+o+a)*(f-d+g),M=(o+a)*(-f+d),E=r*f,N=(-r+c+u)*(f-p+y),O=(-r+c)*(p-y),R=(c+u)*(-f+p),D=(r+s+i-a-l-c-u)*y,z=u*(-f+p+m-g-y-b+x),B=(-i+u+h)*(g+b-x),X=(i-h)*(g-x),G=i*b,te=(u+h)*(-b+x),ge=(-i+a+l)*(y+b-w),ae=(i-l)*(y-w),Ne=(a+l)*(-b+w),ke=s*m,De=l*x,be=o*p,Xe=c*d,Oe=h*w,it=E+G+ke,We=S+A+M+E+B+G+te,dt=E+N+R+D+G+ge+Ne,ct=C+k+A+E+G+ge+ae,Ve=C+A+M+E+De,ze=G+ge+ae+Ne+be,Be=E+N+O+z+B+X+G,ut=B+X+G+te+Xe,Ke=E+N+O+R+Oe;return t.set(0,0,it),t.set(0,1,We),t.set(0,2,dt),t.set(1,0,ct),t.set(1,1,Ve),t.set(1,2,ze),t.set(2,0,Be),t.set(2,1,ut),t.set(2,2,Ke),t}mmulStrassen(e){e=Wt.checkMatrix(e);let t=this.clone(),r=t.rows,s=t.columns,i=e.rows,o=e.columns;s!==i&&console.warn(`Multiplying ${r} x ${s} and ${i} x ${o} matrix: dimensions do not match.`);function a(h,f,d){let p=h.rows,m=h.columns;if(p===f&&m===d)return h;{let g=Gn.zeros(f,d);return g=g.setSubMatrix(h,0,0),g}}let l=Math.max(r,i),c=Math.max(s,o);t=a(t,l,c),e=a(e,l,c);function u(h,f,d,p){if(d<=512||p<=512)return h.mmul(f);d%2===1&&p%2===1?(h=a(h,d+1,p+1),f=a(f,d+1,p+1)):d%2===1?(h=a(h,d+1,p),f=a(f,d+1,p)):p%2===1&&(h=a(h,d,p+1),f=a(f,d,p+1));let m=parseInt(h.rows/2,10),g=parseInt(h.columns/2,10),y=h.subMatrix(0,m-1,0,g-1),b=f.subMatrix(0,m-1,0,g-1),x=h.subMatrix(0,m-1,g,h.columns-1),w=f.subMatrix(0,m-1,g,f.columns-1),S=h.subMatrix(m,h.rows-1,0,g-1),C=f.subMatrix(m,f.rows-1,0,g-1),k=h.subMatrix(m,h.rows-1,g,h.columns-1),A=f.subMatrix(m,f.rows-1,g,f.columns-1),M=u(Gn.add(y,k),Gn.add(b,A),m,g),E=u(Gn.add(S,k),b,m,g),N=u(y,Gn.sub(w,A),m,g),O=u(k,Gn.sub(C,b),m,g),R=u(Gn.add(y,x),A,m,g),D=u(Gn.sub(S,y),Gn.add(b,w),m,g),z=u(Gn.sub(x,k),Gn.add(C,A),m,g),B=Gn.add(M,O);B.sub(R),B.add(z);let X=Gn.add(N,R),G=Gn.add(E,O),te=Gn.sub(M,E);te.add(N),te.add(D);let ge=Gn.zeros(2*B.rows,2*B.columns);return ge=ge.setSubMatrix(B,0,0),ge=ge.setSubMatrix(X,B.rows,0),ge=ge.setSubMatrix(G,0,B.columns),ge=ge.setSubMatrix(te,B.rows,B.columns),ge.subMatrix(0,d-1,0,p-1)}return u(t,e,l,c)}scaleRows(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.rows;i++){const o=this.getRow(i);o.length>0&&Fj(o,{min:t,max:r,output:o}),s.setRow(i,o)}return s}scaleColumns(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.columns;i++){const o=this.getColumn(i);o.length&&Fj(o,{min:t,max:r,output:o}),s.setColumn(i,o)}return s}flipRows(){const e=Math.ceil(this.columns/2);for(let t=0;t<this.rows;t++)for(let r=0;r<e;r++){let s=this.get(t,r),i=this.get(t,this.columns-1-r);this.set(t,r,i),this.set(t,this.columns-1-r,s)}return this}flipColumns(){const e=Math.ceil(this.rows/2);for(let t=0;t<this.columns;t++)for(let r=0;r<e;r++){let s=this.get(r,t),i=this.get(this.rows-1-r,t);this.set(r,t,i),this.set(this.rows-1-r,t,s)}return this}kroneckerProduct(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.rows,i=e.columns,o=new Wt(t*s,r*i);for(let a=0;a<t;a++)for(let l=0;l<r;l++)for(let c=0;c<s;c++)for(let u=0;u<i;u++)o.set(s*a+c,i*l+u,this.get(a,l)*e.get(c,u));return o}kroneckerSum(e){if(e=Wt.checkMatrix(e),!this.isSquare()||!e.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let t=this.rows,r=e.rows,s=this.kroneckerProduct(Wt.eye(r,r)),i=Wt.eye(t,t).kroneckerProduct(e);return s.add(i)}transpose(){let e=new Wt(this.columns,this.rows);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(r,t,this.get(t,r));return e}sortRows(e=zj){for(let t=0;t<this.rows;t++)this.setRow(t,this.getRow(t).sort(e));return this}sortColumns(e=zj){for(let t=0;t<this.columns;t++)this.setColumn(t,this.getColumn(t).sort(e));return this}subMatrix(e,t,r,s){SF(this,e,t,r,s);let i=new Wt(t-e+1,s-r+1);for(let o=e;o<=t;o++)for(let a=r;a<=s;a++)i.set(o-e,a-r,this.get(o,a));return i}subMatrixRow(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.columns-1),t>r||t<0||t>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new Wt(e.length,r-t+1);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.rows)throw new RangeError(`Row index out of range: ${e[i]}`);s.set(i,o-t,this.get(e[i],o))}return s}subMatrixColumn(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.rows-1),t>r||t<0||t>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new Wt(r-t+1,e.length);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.columns)throw new RangeError(`Column index out of range: ${e[i]}`);s.set(o-t,i,this.get(o,e[i]))}return s}setSubMatrix(e,t,r){if(e=Wt.checkMatrix(e),e.isEmpty())return this;let s=t+e.rows-1,i=r+e.columns-1;SF(this,t,s,r,i);for(let o=0;o<e.rows;o++)for(let a=0;a<e.columns;a++)this.set(t+o,r+a,e.get(o,a));return this}selection(e,t){J4(this,e),Q4(this,t);let r=new Wt(e.length,t.length);for(let s=0;s<e.length;s++){let i=e[s];for(let o=0;o<t.length;o++){let a=t[o];r.set(s,o,this.get(i,a))}}return r}trace(){let e=Math.min(this.rows,this.columns),t=0;for(let r=0;r<e;r++)t+=this.get(r,r);return t}clone(){let e=new Wt(this.rows,this.columns);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(t,r,this.get(t,r));return e}sum(e){switch(e){case"row":return mht(this);case"column":return ght(this);case void 0:return yht(this);default:throw new Error(`invalid option: ${e}`)}}product(e){switch(e){case"row":return bht(this);case"column":return vht(this);case void 0:return wht(this);default:throw new Error(`invalid option: ${e}`)}}mean(e){const t=this.sum(e);switch(e){case"row":{for(let r=0;r<this.rows;r++)t[r]/=this.columns;return t}case"column":{for(let r=0;r<this.columns;r++)t[r]/=this.rows;return t}case void 0:return t/this.size;default:throw new Error(`invalid option: ${e}`)}}variance(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(e)}=t;if(typeof r!="boolean")throw new TypeError("unbiased must be a boolean");switch(e){case"row":{if(!Ua.isAnyArray(s))throw new TypeError("mean must be an array");return xht(this,r,s)}case"column":{if(!Ua.isAnyArray(s))throw new TypeError("mean must be an array");return _ht(this,r,s)}case void 0:{if(typeof s!="number")throw new TypeError("mean must be a number");return Sht(this,r,s)}default:throw new Error(`invalid option: ${e}`)}}standardDeviation(e,t){typeof e=="object"&&(t=e,e=void 0);const r=this.variance(e,t);if(e===void 0)return Math.sqrt(r);for(let s=0;s<r.length;s++)r[s]=Math.sqrt(r[s]);return r}center(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{center:r=this.mean(e)}=t;switch(e){case"row":{if(!Ua.isAnyArray(r))throw new TypeError("center must be an array");return Cht(this,r),this}case"column":{if(!Ua.isAnyArray(r))throw new TypeError("center must be an array");return kht(this,r),this}case void 0:{if(typeof r!="number")throw new TypeError("center must be a number");return Tht(this,r),this}default:throw new Error(`invalid option: ${e}`)}}scale(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");let r=t.scale;switch(e){case"row":{if(r===void 0)r=Eht(this);else if(!Ua.isAnyArray(r))throw new TypeError("scale must be an array");return Iht(this,r),this}case"column":{if(r===void 0)r=Aht(this);else if(!Ua.isAnyArray(r))throw new TypeError("scale must be an array");return Mht(this,r),this}case void 0:{if(r===void 0)r=Nht(this);else if(typeof r!="number")throw new TypeError("scale must be a number");return $ht(this,r),this}default:throw new Error(`invalid option: ${e}`)}}toString(e){return yoe(this,e)}}Gn.prototype.klass="Matrix";typeof Symbol<"u"&&(Gn.prototype[Symbol.for("nodejs.util.inspect.custom")]=hht);function zj(n,e){return n-e}function Rht(n){return n.every(e=>typeof e=="number")}Gn.random=Gn.rand;Gn.randomInt=Gn.randInt;Gn.diagonal=Gn.diag;Gn.prototype.diagonal=Gn.prototype.diag;Gn.identity=Gn.eye;Gn.prototype.negate=Gn.prototype.neg;Gn.prototype.tensorProduct=Gn.prototype.kroneckerProduct;let Wt=class boe extends Gn{constructor(e,t){if(super(),boe.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0)if(this.data=[],Number.isInteger(t)&&t>=0)for(let r=0;r<e;r++)this.data.push(new Float64Array(t));else throw new TypeError("nColumns must be a positive integer");else if(Ua.isAnyArray(e)){const r=e;if(e=r.length,t=e?r[0].length:0,typeof t!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<e;s++){if(r[s].length!==t)throw new RangeError("Inconsistent array dimensions");if(!Rht(r[s]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[s]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=e,this.columns=t}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}removeRow(e){return ic(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,t){return t===void 0&&(t=e,e=this.rows),ic(this,e,!0),t=Float64Array.from(bb(this,t)),this.data.splice(e,0,t),this.rows+=1,this}removeColumn(e){oc(this,e);for(let t=0;t<this.rows;t++){const r=new Float64Array(this.columns-1);for(let s=0;s<e;s++)r[s]=this.data[t][s];for(let s=e+1;s<this.columns;s++)r[s-1]=this.data[t][s];this.data[t]=r}return this.columns-=1,this}addColumn(e,t){typeof t>"u"&&(t=e,e=this.columns),oc(this,e,!0),t=vb(this,t);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let i=0;for(;i<e;i++)s[i]=this.data[r][i];for(s[i++]=t[r];i<this.columns+1;i++)s[i]=this.data[r][i-1];this.data[r]=s}return this.columns+=1,this}};pht(Gn,Wt);class Jf extends Gn{constructor(e,t,r){super(),this.matrix=e,this.rows=t,this.columns=r}}class Pht extends Jf{constructor(e,t){oc(e,t),super(e,e.rows,1),this.column=t}set(e,t,r){return this.matrix.set(e,this.column,r),this}get(e){return this.matrix.get(e,this.column)}}class Dht extends Jf{constructor(e,t){Q4(e,t),super(e,e.rows,t.length),this.columnIndices=t}set(e,t,r){return this.matrix.set(e,this.columnIndices[t],r),this}get(e,t){return this.matrix.get(e,this.columnIndices[t])}}class Oht extends Jf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(e,this.columns-t-1,r),this}get(e,t){return this.matrix.get(e,this.columns-t-1)}}class Fht extends Jf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(this.rows-e-1,t,r),this}get(e,t){return this.matrix.get(this.rows-e-1,t)}}class Lht extends Jf{constructor(e,t){ic(e,t),super(e,1,e.columns),this.row=t}set(e,t,r){return this.matrix.set(this.row,t,r),this}get(e,t){return this.matrix.get(this.row,t)}}class zht extends Jf{constructor(e,t){J4(e,t),super(e,t.length,e.columns),this.rowIndices=t}set(e,t,r){return this.matrix.set(this.rowIndices[e],t,r),this}get(e,t){return this.matrix.get(this.rowIndices[e],t)}}class rI extends Jf{constructor(e,t,r){J4(e,t),Q4(e,r),super(e,t.length,r.length),this.rowIndices=t,this.columnIndices=r}set(e,t,r){return this.matrix.set(this.rowIndices[e],this.columnIndices[t],r),this}get(e,t){return this.matrix.get(this.rowIndices[e],this.columnIndices[t])}}class Bht extends Jf{constructor(e,t,r,s,i){SF(e,t,r,s,i),super(e,r-t+1,i-s+1),this.startRow=t,this.startColumn=s}set(e,t,r){return this.matrix.set(this.startRow+e,this.startColumn+t,r),this}get(e,t){return this.matrix.get(this.startRow+e,this.startColumn+t)}}class Vht extends Jf{constructor(e){super(e,e.columns,e.rows)}set(e,t,r){return this.matrix.set(t,e,r),this}get(e,t){return this.matrix.get(t,e)}}class voe extends Gn{constructor(e,t={}){const{rows:r=1}=t;if(e.length%r!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=e.length/r,this.data=e}set(e,t,r){let s=this._calculateIndex(e,t);return this.data[s]=r,this}get(e,t){let r=this._calculateIndex(e,t);return this.data[r]}_calculateIndex(e,t){return e*this.columns+t}}class Pl extends Gn{constructor(e){super(),this.data=e,this.rows=e.length,this.columns=e[0].length}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}}function Uht(n,e){if(Ua.isAnyArray(n))return n[0]&&Ua.isAnyArray(n[0])?new Pl(n):new voe(n,e);throw new Error("the argument is not an array")}class $${constructor(e){e=Pl.checkMatrix(e);let t=e.clone(),r=t.rows,s=t.columns,i=new Float64Array(r),o=1,a,l,c,u,h,f,d,p,m;for(a=0;a<r;a++)i[a]=a;for(p=new Float64Array(r),l=0;l<s;l++){for(a=0;a<r;a++)p[a]=t.get(a,l);for(a=0;a<r;a++){for(m=Math.min(a,l),h=0,c=0;c<m;c++)h+=t.get(a,c)*p[c];p[a]-=h,t.set(a,l,p[a])}for(u=l,a=l+1;a<r;a++)Math.abs(p[a])>Math.abs(p[u])&&(u=a);if(u!==l){for(c=0;c<s;c++)f=t.get(u,c),t.set(u,c,t.get(l,c)),t.set(l,c,f);d=i[u],i[u]=i[l],i[l]=d,o=-o}if(l<r&&t.get(l,l)!==0)for(a=l+1;a<r;a++)t.set(a,l,t.get(a,l)/t.get(l,l))}this.LU=t,this.pivotVector=i,this.pivotSign=o}isSingular(){let e=this.LU,t=e.columns;for(let r=0;r<t;r++)if(e.get(r,r)===0)return!0;return!1}solve(e){e=Wt.checkMatrix(e);let t=this.LU;if(t.rows!==e.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let s=e.columns,i=e.subMatrixRow(this.pivotVector,0,s-1),o=t.columns,a,l,c;for(c=0;c<o;c++)for(a=c+1;a<o;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c));for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/t.get(c,c));for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i}get determinant(){let e=this.LU;if(!e.isSquare())throw new Error("Matrix must be square");let t=this.pivotSign,r=e.columns;for(let s=0;s<r;s++)t*=e.get(s,s);return t}get lowerTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i>o?s.set(i,o,e.get(i,o)):i===o?s.set(i,o,1):s.set(i,o,0);return s}get upperTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i<=o?s.set(i,o,e.get(i,o)):s.set(i,o,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function Sf(n,e){let t=0;return Math.abs(n)>Math.abs(e)?(t=e/n,Math.abs(n)*Math.sqrt(1+t*t)):e!==0?(t=n/e,Math.abs(e)*Math.sqrt(1+t*t)):0}class eV{constructor(e){e=Pl.checkMatrix(e);let t=e.clone(),r=e.rows,s=e.columns,i=new Float64Array(s),o,a,l,c;for(l=0;l<s;l++){let u=0;for(o=l;o<r;o++)u=Sf(u,t.get(o,l));if(u!==0){for(t.get(l,l)<0&&(u=-u),o=l;o<r;o++)t.set(o,l,t.get(o,l)/u);for(t.set(l,l,t.get(l,l)+1),a=l+1;a<s;a++){for(c=0,o=l;o<r;o++)c+=t.get(o,l)*t.get(o,a);for(c=-c/t.get(l,l),o=l;o<r;o++)t.set(o,a,t.get(o,a)+c*t.get(o,l))}}i[l]=-u}this.QR=t,this.Rdiag=i}solve(e){e=Wt.checkMatrix(e);let t=this.QR,r=t.rows;if(e.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s=e.columns,i=e.clone(),o=t.columns,a,l,c,u;for(c=0;c<o;c++)for(l=0;l<s;l++){for(u=0,a=c;a<r;a++)u+=t.get(a,c)*i.get(a,l);for(u=-u/t.get(c,c),a=c;a<r;a++)i.set(a,l,i.get(a,l)+u*t.get(a,c))}for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/this.Rdiag[c]);for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i.subMatrix(0,o-1,0,s-1)}isFullRank(){let e=this.QR.columns;for(let t=0;t<e;t++)if(this.Rdiag[t]===0)return!1;return!0}get upperTriangularMatrix(){let e=this.QR,t=e.columns,r=new Wt(t,t),s,i;for(s=0;s<t;s++)for(i=0;i<t;i++)s<i?r.set(s,i,e.get(s,i)):s===i?r.set(s,i,this.Rdiag[s]):r.set(s,i,0);return r}get orthogonalMatrix(){let e=this.QR,t=e.rows,r=e.columns,s=new Wt(t,r),i,o,a,l;for(a=r-1;a>=0;a--){for(i=0;i<t;i++)s.set(i,a,0);for(s.set(a,a,1),o=a;o<r;o++)if(e.get(a,a)!==0){for(l=0,i=a;i<t;i++)l+=e.get(i,a)*s.get(i,o);for(l=-l/e.get(a,a),i=a;i<t;i++)s.set(i,o,s.get(i,o)+l*e.get(i,a))}}return s}}class ix{constructor(e,t={}){if(e=Pl.checkMatrix(e),e.isEmpty())throw new Error("Matrix must be non-empty");let r=e.rows,s=e.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:a=!1}=t;let l=!!i,c=!!o,u=!1,h;if(r<s)if(!a)h=e.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{h=e.transpose(),r=h.rows,s=h.columns,u=!0;let E=l;l=c,c=E}else h=e.clone();let f=Math.min(r,s),d=Math.min(r+1,s),p=new Float64Array(d),m=new Wt(r,f),g=new Wt(s,s),y=new Float64Array(s),b=new Float64Array(r),x=new Float64Array(d);for(let E=0;E<d;E++)x[E]=E;let w=Math.min(r-1,s),S=Math.max(0,Math.min(s-2,r)),C=Math.max(w,S);for(let E=0;E<C;E++){if(E<w){p[E]=0;for(let N=E;N<r;N++)p[E]=Sf(p[E],h.get(N,E));if(p[E]!==0){h.get(E,E)<0&&(p[E]=-p[E]);for(let N=E;N<r;N++)h.set(N,E,h.get(N,E)/p[E]);h.set(E,E,h.get(E,E)+1)}p[E]=-p[E]}for(let N=E+1;N<s;N++){if(E<w&&p[E]!==0){let O=0;for(let R=E;R<r;R++)O+=h.get(R,E)*h.get(R,N);O=-O/h.get(E,E);for(let R=E;R<r;R++)h.set(R,N,h.get(R,N)+O*h.get(R,E))}y[N]=h.get(E,N)}if(l&&E<w)for(let N=E;N<r;N++)m.set(N,E,h.get(N,E));if(E<S){y[E]=0;for(let N=E+1;N<s;N++)y[E]=Sf(y[E],y[N]);if(y[E]!==0){y[E+1]<0&&(y[E]=0-y[E]);for(let N=E+1;N<s;N++)y[N]/=y[E];y[E+1]+=1}if(y[E]=-y[E],E+1<r&&y[E]!==0){for(let N=E+1;N<r;N++)b[N]=0;for(let N=E+1;N<r;N++)for(let O=E+1;O<s;O++)b[N]+=y[O]*h.get(N,O);for(let N=E+1;N<s;N++){let O=-y[N]/y[E+1];for(let R=E+1;R<r;R++)h.set(R,N,h.get(R,N)+O*b[R])}}if(c)for(let N=E+1;N<s;N++)g.set(N,E,y[N])}}let k=Math.min(s,r+1);if(w<s&&(p[w]=h.get(w,w)),r<k&&(p[k-1]=0),S+1<k&&(y[S]=h.get(S,k-1)),y[k-1]=0,l){for(let E=w;E<f;E++){for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}for(let E=w-1;E>=0;E--)if(p[E]!==0){for(let N=E+1;N<f;N++){let O=0;for(let R=E;R<r;R++)O+=m.get(R,E)*m.get(R,N);O=-O/m.get(E,E);for(let R=E;R<r;R++)m.set(R,N,m.get(R,N)+O*m.get(R,E))}for(let N=E;N<r;N++)m.set(N,E,-m.get(N,E));m.set(E,E,1+m.get(E,E));for(let N=0;N<E-1;N++)m.set(N,E,0)}else{for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}}if(c)for(let E=s-1;E>=0;E--){if(E<S&&y[E]!==0)for(let N=E+1;N<s;N++){let O=0;for(let R=E+1;R<s;R++)O+=g.get(R,E)*g.get(R,N);O=-O/g.get(E+1,E);for(let R=E+1;R<s;R++)g.set(R,N,g.get(R,N)+O*g.get(R,E))}for(let N=0;N<s;N++)g.set(N,E,0);g.set(E,E,1)}let A=k-1,M=Number.EPSILON;for(;k>0;){let E,N;for(E=k-2;E>=-1&&E!==-1;E--){const O=Number.MIN_VALUE+M*Math.abs(p[E]+Math.abs(p[E+1]));if(Math.abs(y[E])<=O||Number.isNaN(y[E])){y[E]=0;break}}if(E===k-2)N=4;else{let O;for(O=k-1;O>=E&&O!==E;O--){let R=(O!==k?Math.abs(y[O]):0)+(O!==E+1?Math.abs(y[O-1]):0);if(Math.abs(p[O])<=M*R){p[O]=0;break}}O===E?N=3:O===k-1?N=1:(N=2,E=O)}switch(E++,N){case 1:{let O=y[k-2];y[k-2]=0;for(let R=k-2;R>=E;R--){let D=Sf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,R!==E&&(O=-B*y[R-1],y[R-1]=z*y[R-1]),c)for(let X=0;X<s;X++)D=z*g.get(X,R)+B*g.get(X,k-1),g.set(X,k-1,-B*g.get(X,R)+z*g.get(X,k-1)),g.set(X,R,D)}break}case 2:{let O=y[E-1];y[E-1]=0;for(let R=E;R<k;R++){let D=Sf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,O=-B*y[R],y[R]=z*y[R],l)for(let X=0;X<r;X++)D=z*m.get(X,R)+B*m.get(X,E-1),m.set(X,E-1,-B*m.get(X,R)+z*m.get(X,E-1)),m.set(X,R,D)}break}case 3:{const O=Math.max(Math.abs(p[k-1]),Math.abs(p[k-2]),Math.abs(y[k-2]),Math.abs(p[E]),Math.abs(y[E])),R=p[k-1]/O,D=p[k-2]/O,z=y[k-2]/O,B=p[E]/O,X=y[E]/O,G=((D+R)*(D-R)+z*z)/2,te=R*z*(R*z);let ge=0;(G!==0||te!==0)&&(G<0?ge=0-Math.sqrt(G*G+te):ge=Math.sqrt(G*G+te),ge=te/(G+ge));let ae=(B+R)*(B-R)+ge,Ne=B*X;for(let ke=E;ke<k-1;ke++){let De=Sf(ae,Ne);De===0&&(De=Number.MIN_VALUE);let be=ae/De,Xe=Ne/De;if(ke!==E&&(y[ke-1]=De),ae=be*p[ke]+Xe*y[ke],y[ke]=be*y[ke]-Xe*p[ke],Ne=Xe*p[ke+1],p[ke+1]=be*p[ke+1],c)for(let Oe=0;Oe<s;Oe++)De=be*g.get(Oe,ke)+Xe*g.get(Oe,ke+1),g.set(Oe,ke+1,-Xe*g.get(Oe,ke)+be*g.get(Oe,ke+1)),g.set(Oe,ke,De);if(De=Sf(ae,Ne),De===0&&(De=Number.MIN_VALUE),be=ae/De,Xe=Ne/De,p[ke]=De,ae=be*y[ke]+Xe*p[ke+1],p[ke+1]=-Xe*y[ke]+be*p[ke+1],Ne=Xe*y[ke+1],y[ke+1]=be*y[ke+1],l&&ke<r-1)for(let Oe=0;Oe<r;Oe++)De=be*m.get(Oe,ke)+Xe*m.get(Oe,ke+1),m.set(Oe,ke+1,-Xe*m.get(Oe,ke)+be*m.get(Oe,ke+1)),m.set(Oe,ke,De)}y[k-2]=ae;break}case 4:{if(p[E]<=0&&(p[E]=p[E]<0?-p[E]:0,c))for(let O=0;O<=A;O++)g.set(O,E,-g.get(O,E));for(;E<A&&!(p[E]>=p[E+1]);){let O=p[E];if(p[E]=p[E+1],p[E+1]=O,c&&E<s-1)for(let R=0;R<s;R++)O=g.get(R,E+1),g.set(R,E+1,g.get(R,E)),g.set(R,E,O);if(l&&E<r-1)for(let R=0;R<r;R++)O=m.get(R,E+1),m.set(R,E+1,m.get(R,E)),m.set(R,E,O);E++}k--;break}}}if(u){let E=g;g=m,m=E}this.m=r,this.n=s,this.s=p,this.U=m,this.V=g}solve(e){let t=e,r=this.threshold,s=this.s.length,i=Wt.zeros(s,s);for(let f=0;f<s;f++)Math.abs(this.s[f])<=r?i.set(f,f,0):i.set(f,f,1/this.s[f]);let o=this.U,a=this.rightSingularVectors,l=a.mmul(i),c=a.rows,u=o.rows,h=Wt.zeros(c,u);for(let f=0;f<c;f++)for(let d=0;d<u;d++){let p=0;for(let m=0;m<s;m++)p+=l.get(f,m)*o.get(d,m);h.set(f,d,p)}return h.mmul(t)}solveForDiagonal(e){return this.solve(Wt.diag(e))}inverse(){let e=this.V,t=this.threshold,r=e.rows,s=e.columns,i=new Wt(r,this.s.length);for(let u=0;u<r;u++)for(let h=0;h<s;h++)Math.abs(this.s[h])>t&&i.set(u,h,e.get(u,h)/this.s[h]);let o=this.U,a=o.rows,l=o.columns,c=new Wt(r,a);for(let u=0;u<r;u++)for(let h=0;h<a;h++){let f=0;for(let d=0;d<l;d++)f+=i.get(u,d)*o.get(h,d);c.set(u,h,f)}return c}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let e=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,t=0,r=this.s;for(let s=0,i=r.length;s<i;s++)r[s]>e&&t++;return t}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Wt.diag(this.s)}}function Wht(n,e=!1){return n=Pl.checkMatrix(n),e?new ix(n).inverse():woe(n,Wt.eye(n.rows))}function woe(n,e,t=!1){return n=Pl.checkMatrix(n),e=Pl.checkMatrix(e),t?new ix(n).solve(e):n.isSquare()?new $$(n).solve(e):new eV(n).solve(e)}function sI(n){if(n=Wt.checkMatrix(n),n.isSquare()){if(n.columns===0)return 1;let e,t,r,s;if(n.columns===2)return e=n.get(0,0),t=n.get(0,1),r=n.get(1,0),s=n.get(1,1),e*s-t*r;if(n.columns===3){let i,o,a;return i=new rI(n,[1,2],[1,2]),o=new rI(n,[1,2],[0,2]),a=new rI(n,[1,2],[0,1]),e=n.get(0,0),t=n.get(0,1),r=n.get(0,2),e*sI(i)-t*sI(o)+r*sI(a)}else return new $$(n).determinant}else throw Error("determinant can only be calculated for a square matrix")}function Ght(n,e){let t=[];for(let r=0;r<n;r++)r!==e&&t.push(r);return t}function Hht(n,e,t,r=1e-9,s=1e-9){if(n>s)return new Array(e.rows+1).fill(0);{let i=e.addRow(t,[0]);for(let o=0;o<i.rows;o++)Math.abs(i.get(o,0))<r&&i.set(o,0,0);return i.to1DArray()}}function jht(n,e={}){const{thresholdValue:t=1e-9,thresholdError:r=1e-9}=e;n=Wt.checkMatrix(n);let s=n.rows,i=new Wt(s,s);for(let o=0;o<s;o++){let a=Wt.columnVector(n.getRow(o)),l=n.subMatrixRow(Ght(s,o)).transpose(),u=new ix(l).solve(a),h=Wt.sub(a,l.mmul(u)).abs().max();i.setRow(o,Hht(h,u,o,t,r))}return i}function qht(n,e=Number.EPSILON){if(n=Wt.checkMatrix(n),n.isEmpty())return n.transpose();let t=new ix(n,{autoTranspose:!0}),r=t.leftSingularVectors,s=t.rightSingularVectors,i=t.diagonal;for(let o=0;o<i.length;o++)Math.abs(i[o])>e?i[o]=1/i[o]:i[o]=0;return s.mmul(Wt.diag(i).mmul(r.transpose()))}function Xht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!Ua.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0}=t;s&&(n=n.center("column"),r||(e=e.center("column")));const i=n.transpose().mmul(e);for(let o=0;o<i.rows;o++)for(let a=0;a<i.columns;a++)i.set(o,a,i.get(o,a)*(1/(n.rows-1)));return i}function Kht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!Ua.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0,scale:i=!0}=t;s&&(n.center("column"),r||e.center("column")),i&&(n.scale("column"),r||e.scale("column"));const o=n.standardDeviation("column",{unbiased:!0}),a=r?o:e.standardDeviation("column",{unbiased:!0}),l=n.transpose().mmul(e);for(let c=0;c<l.rows;c++)for(let u=0;u<l.columns;u++)l.set(c,u,l.get(c,u)*(1/(o[c]*a[u]))*(1/(n.rows-1)));return l}class xoe{constructor(e,t={}){const{assumeSymmetric:r=!1}=t;if(e=Pl.checkMatrix(e),!e.isSquare())throw new Error("Matrix is not a square matrix");if(e.isEmpty())throw new Error("Matrix must be non-empty");let s=e.columns,i=new Wt(s,s),o=new Float64Array(s),a=new Float64Array(s),l=e,c,u,h=!1;if(r?h=!0:h=e.isSymmetric(),h){for(c=0;c<s;c++)for(u=0;u<s;u++)i.set(c,u,l.get(c,u));Yht(s,a,o,i),Zht(s,a,o,i)}else{let f=new Wt(s,s),d=new Float64Array(s);for(u=0;u<s;u++)for(c=0;c<s;c++)f.set(c,u,l.get(c,u));Jht(s,f,d,i),Qht(s,a,o,i,f)}this.n=s,this.e=a,this.d=o,this.V=i}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let e=this.n,t=this.e,r=this.d,s=new Wt(e,e),i,o;for(i=0;i<e;i++){for(o=0;o<e;o++)s.set(i,o,0);s.set(i,i,r[i]),t[i]>0?s.set(i,i+1,t[i]):t[i]<0&&s.set(i,i-1,t[i])}return s}}function Yht(n,e,t,r){let s,i,o,a,l,c,u,h;for(l=0;l<n;l++)t[l]=r.get(n-1,l);for(a=n-1;a>0;a--){for(h=0,o=0,c=0;c<a;c++)h=h+Math.abs(t[c]);if(h===0)for(e[a]=t[a-1],l=0;l<a;l++)t[l]=r.get(a-1,l),r.set(a,l,0),r.set(l,a,0);else{for(c=0;c<a;c++)t[c]/=h,o+=t[c]*t[c];for(s=t[a-1],i=Math.sqrt(o),s>0&&(i=-i),e[a]=h*i,o=o-s*i,t[a-1]=s-i,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(s=t[l],r.set(l,a,s),i=e[l]+r.get(l,l)*s,c=l+1;c<=a-1;c++)i+=r.get(c,l)*t[c],e[c]+=r.get(c,l)*s;e[l]=i}for(s=0,l=0;l<a;l++)e[l]/=o,s+=e[l]*t[l];for(u=s/(o+o),l=0;l<a;l++)e[l]-=u*t[l];for(l=0;l<a;l++){for(s=t[l],i=e[l],c=l;c<=a-1;c++)r.set(c,l,r.get(c,l)-(s*e[c]+i*t[c]));t[l]=r.get(a-1,l),r.set(a,l,0)}}t[a]=o}for(a=0;a<n-1;a++){if(r.set(n-1,a,r.get(a,a)),r.set(a,a,1),o=t[a+1],o!==0){for(c=0;c<=a;c++)t[c]=r.get(c,a+1)/o;for(l=0;l<=a;l++){for(i=0,c=0;c<=a;c++)i+=r.get(c,a+1)*r.get(c,l);for(c=0;c<=a;c++)r.set(c,l,r.get(c,l)-i*t[c])}}for(c=0;c<=a;c++)r.set(c,a+1,0)}for(l=0;l<n;l++)t[l]=r.get(n-1,l),r.set(n-1,l,0);r.set(n-1,n-1,1),e[0]=0}function Zht(n,e,t,r){let s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x;for(o=1;o<n;o++)e[o-1]=e[o];e[n-1]=0;let w=0,S=0,C=Number.EPSILON;for(c=0;c<n;c++){for(S=Math.max(S,Math.abs(t[c])+Math.abs(e[c])),u=c;u<n&&!(Math.abs(e[u])<=C*S);)u++;if(u>c)do{for(s=t[c],h=(t[c+1]-s)/(2*e[c]),f=Sf(h,1),h<0&&(f=-f),t[c]=e[c]/(h+f),t[c+1]=e[c]*(h+f),d=t[c+1],i=s-t[c],o=c+2;o<n;o++)t[o]-=i;for(w=w+i,h=t[u],p=1,m=p,g=p,y=e[c+1],b=0,x=0,o=u-1;o>=c;o--)for(g=m,m=p,x=b,s=p*e[o],i=p*h,f=Sf(h,e[o]),e[o+1]=b*f,b=e[o]/f,p=h/f,h=p*t[o]-b*s,t[o+1]=i+b*(p*s+b*t[o]),l=0;l<n;l++)i=r.get(l,o+1),r.set(l,o+1,b*r.get(l,o)+p*i),r.set(l,o,p*r.get(l,o)-b*i);h=-b*x*g*y*e[c]/d,e[c]=b*h,t[c]=p*h}while(Math.abs(e[c])>C*S);t[c]=t[c]+w,e[c]=0}for(o=0;o<n-1;o++){for(l=o,h=t[o],a=o+1;a<n;a++)t[a]<h&&(l=a,h=t[a]);if(l!==o)for(t[l]=t[o],t[o]=h,a=0;a<n;a++)h=r.get(a,o),r.set(a,o,r.get(a,l)),r.set(a,l,h)}}function Jht(n,e,t,r){let s=0,i=n-1,o,a,l,c,u,h,f;for(h=s+1;h<=i-1;h++){for(f=0,c=h;c<=i;c++)f=f+Math.abs(e.get(c,h-1));if(f!==0){for(l=0,c=i;c>=h;c--)t[c]=e.get(c,h-1)/f,l+=t[c]*t[c];for(a=Math.sqrt(l),t[h]>0&&(a=-a),l=l-t[h]*a,t[h]=t[h]-a,u=h;u<n;u++){for(o=0,c=i;c>=h;c--)o+=t[c]*e.get(c,u);for(o=o/l,c=h;c<=i;c++)e.set(c,u,e.get(c,u)-o*t[c])}for(c=0;c<=i;c++){for(o=0,u=i;u>=h;u--)o+=t[u]*e.get(c,u);for(o=o/l,u=h;u<=i;u++)e.set(c,u,e.get(c,u)-o*t[u])}t[h]=f*t[h],e.set(h,h-1,f*a)}}for(c=0;c<n;c++)for(u=0;u<n;u++)r.set(c,u,c===u?1:0);for(h=i-1;h>=s+1;h--)if(e.get(h,h-1)!==0){for(c=h+1;c<=i;c++)t[c]=e.get(c,h-1);for(u=h;u<=i;u++){for(a=0,c=h;c<=i;c++)a+=t[c]*r.get(c,u);for(a=a/t[h]/e.get(h,h-1),c=h;c<=i;c++)r.set(c,u,r.get(c,u)+a*t[c])}}}function Qht(n,e,t,r,s){let i=n-1,o=0,a=n-1,l=Number.EPSILON,c=0,u=0,h=0,f=0,d=0,p=0,m=0,g=0,y,b,x,w,S,C,k,A,M,E,N,O,R,D,z;for(y=0;y<n;y++)for((y<o||y>a)&&(t[y]=s.get(y,y),e[y]=0),b=Math.max(y-1,0);b<n;b++)u=u+Math.abs(s.get(y,b));for(;i>=o;){for(w=i;w>o&&(p=Math.abs(s.get(w-1,w-1))+Math.abs(s.get(w,w)),p===0&&(p=u),!(Math.abs(s.get(w,w-1))<l*p));)w--;if(w===i)s.set(i,i,s.get(i,i)+c),t[i]=s.get(i,i),e[i]=0,i--,g=0;else if(w===i-1){if(k=s.get(i,i-1)*s.get(i-1,i),h=(s.get(i-1,i-1)-s.get(i,i))/2,f=h*h+k,m=Math.sqrt(Math.abs(f)),s.set(i,i,s.get(i,i)+c),s.set(i-1,i-1,s.get(i-1,i-1)+c),A=s.get(i,i),f>=0){for(m=h>=0?h+m:h-m,t[i-1]=A+m,t[i]=t[i-1],m!==0&&(t[i]=A-k/m),e[i-1]=0,e[i]=0,A=s.get(i,i-1),p=Math.abs(A)+Math.abs(m),h=A/p,f=m/p,d=Math.sqrt(h*h+f*f),h=h/d,f=f/d,b=i-1;b<n;b++)m=s.get(i-1,b),s.set(i-1,b,f*m+h*s.get(i,b)),s.set(i,b,f*s.get(i,b)-h*m);for(y=0;y<=i;y++)m=s.get(y,i-1),s.set(y,i-1,f*m+h*s.get(y,i)),s.set(y,i,f*s.get(y,i)-h*m);for(y=o;y<=a;y++)m=r.get(y,i-1),r.set(y,i-1,f*m+h*r.get(y,i)),r.set(y,i,f*r.get(y,i)-h*m)}else t[i-1]=A+h,t[i]=A+h,e[i-1]=m,e[i]=-m;i=i-2,g=0}else{if(A=s.get(i,i),M=0,k=0,w<i&&(M=s.get(i-1,i-1),k=s.get(i,i-1)*s.get(i-1,i)),g===10){for(c+=A,y=o;y<=i;y++)s.set(y,y,s.get(y,y)-A);p=Math.abs(s.get(i,i-1))+Math.abs(s.get(i-1,i-2)),A=M=.75*p,k=-.4375*p*p}if(g===30&&(p=(M-A)/2,p=p*p+k,p>0)){for(p=Math.sqrt(p),M<A&&(p=-p),p=A-k/((M-A)/2+p),y=o;y<=i;y++)s.set(y,y,s.get(y,y)-p);c+=p,A=M=k=.964}for(g=g+1,S=i-2;S>=w&&(m=s.get(S,S),d=A-m,p=M-m,h=(d*p-k)/s.get(S+1,S)+s.get(S,S+1),f=s.get(S+1,S+1)-m-d-p,d=s.get(S+2,S+1),p=Math.abs(h)+Math.abs(f)+Math.abs(d),h=h/p,f=f/p,d=d/p,!(S===w||Math.abs(s.get(S,S-1))*(Math.abs(f)+Math.abs(d))<l*(Math.abs(h)*(Math.abs(s.get(S-1,S-1))+Math.abs(m)+Math.abs(s.get(S+1,S+1))))));)S--;for(y=S+2;y<=i;y++)s.set(y,y-2,0),y>S+2&&s.set(y,y-3,0);for(x=S;x<=i-1&&(D=x!==i-1,x!==S&&(h=s.get(x,x-1),f=s.get(x+1,x-1),d=D?s.get(x+2,x-1):0,A=Math.abs(h)+Math.abs(f)+Math.abs(d),A!==0&&(h=h/A,f=f/A,d=d/A)),A!==0);x++)if(p=Math.sqrt(h*h+f*f+d*d),h<0&&(p=-p),p!==0){for(x!==S?s.set(x,x-1,-p*A):w!==S&&s.set(x,x-1,-s.get(x,x-1)),h=h+p,A=h/p,M=f/p,m=d/p,f=f/h,d=d/h,b=x;b<n;b++)h=s.get(x,b)+f*s.get(x+1,b),D&&(h=h+d*s.get(x+2,b),s.set(x+2,b,s.get(x+2,b)-h*m)),s.set(x,b,s.get(x,b)-h*A),s.set(x+1,b,s.get(x+1,b)-h*M);for(y=0;y<=Math.min(i,x+3);y++)h=A*s.get(y,x)+M*s.get(y,x+1),D&&(h=h+m*s.get(y,x+2),s.set(y,x+2,s.get(y,x+2)-h*d)),s.set(y,x,s.get(y,x)-h),s.set(y,x+1,s.get(y,x+1)-h*f);for(y=o;y<=a;y++)h=A*r.get(y,x)+M*r.get(y,x+1),D&&(h=h+m*r.get(y,x+2),r.set(y,x+2,r.get(y,x+2)-h*d)),r.set(y,x,r.get(y,x)-h),r.set(y,x+1,r.get(y,x+1)-h*f)}}}if(u!==0){for(i=n-1;i>=0;i--)if(h=t[i],f=e[i],f===0)for(w=i,s.set(i,i,1),y=i-1;y>=0;y--){for(k=s.get(y,y)-h,d=0,b=w;b<=i;b++)d=d+s.get(y,b)*s.get(b,i);if(e[y]<0)m=k,p=d;else if(w=y,e[y]===0?s.set(y,i,k!==0?-d/k:-d/(l*u)):(A=s.get(y,y+1),M=s.get(y+1,y),f=(t[y]-h)*(t[y]-h)+e[y]*e[y],C=(A*p-m*d)/f,s.set(y,i,C),s.set(y+1,i,Math.abs(A)>Math.abs(m)?(-d-k*C)/A:(-p-M*C)/m)),C=Math.abs(s.get(y,i)),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i,s.get(b,i)/C)}else if(f<0)for(w=i-1,Math.abs(s.get(i,i-1))>Math.abs(s.get(i-1,i))?(s.set(i-1,i-1,f/s.get(i,i-1)),s.set(i-1,i,-(s.get(i,i)-h)/s.get(i,i-1))):(z=FT(0,-s.get(i-1,i),s.get(i-1,i-1)-h,f),s.set(i-1,i-1,z[0]),s.set(i-1,i,z[1])),s.set(i,i-1,0),s.set(i,i,1),y=i-2;y>=0;y--){for(E=0,N=0,b=w;b<=i;b++)E=E+s.get(y,b)*s.get(b,i-1),N=N+s.get(y,b)*s.get(b,i);if(k=s.get(y,y)-h,e[y]<0)m=k,d=E,p=N;else if(w=y,e[y]===0?(z=FT(-E,-N,k,f),s.set(y,i-1,z[0]),s.set(y,i,z[1])):(A=s.get(y,y+1),M=s.get(y+1,y),O=(t[y]-h)*(t[y]-h)+e[y]*e[y]-f*f,R=(t[y]-h)*2*f,O===0&&R===0&&(O=l*u*(Math.abs(k)+Math.abs(f)+Math.abs(A)+Math.abs(M)+Math.abs(m))),z=FT(A*d-m*E+f*N,A*p-m*N-f*E,O,R),s.set(y,i-1,z[0]),s.set(y,i,z[1]),Math.abs(A)>Math.abs(m)+Math.abs(f)?(s.set(y+1,i-1,(-E-k*s.get(y,i-1)+f*s.get(y,i))/A),s.set(y+1,i,(-N-k*s.get(y,i)-f*s.get(y,i-1))/A)):(z=FT(-d-M*s.get(y,i-1),-p-M*s.get(y,i),m,f),s.set(y+1,i-1,z[0]),s.set(y+1,i,z[1]))),C=Math.max(Math.abs(s.get(y,i-1)),Math.abs(s.get(y,i))),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i-1,s.get(b,i-1)/C),s.set(b,i,s.get(b,i)/C)}for(y=0;y<n;y++)if(y<o||y>a)for(b=y;b<n;b++)r.set(y,b,s.get(y,b));for(b=n-1;b>=o;b--)for(y=o;y<=a;y++){for(m=0,x=o;x<=Math.min(b,a);x++)m=m+r.get(y,x)*s.get(x,b);r.set(y,b,m)}}}function FT(n,e,t,r){let s,i;return Math.abs(t)>Math.abs(r)?(s=r/t,i=t+s*r,[(n+s*e)/i,(e-s*n)/i]):(s=t/r,i=r+s*t,[(s*n+e)/i,(s*e-n)/i])}class _oe{constructor(e){if(e=Pl.checkMatrix(e),!e.isSymmetric())throw new Error("Matrix is not symmetric");let t=e,r=t.rows,s=new Wt(r,r),i=!0,o,a,l;for(a=0;a<r;a++){let c=0;for(l=0;l<a;l++){let u=0;for(o=0;o<l;o++)u+=s.get(l,o)*s.get(a,o);u=(t.get(a,l)-u)/s.get(l,l),s.set(a,l,u),c=c+u*u}for(c=t.get(a,a)-c,i&=c>0,s.set(a,a,Math.sqrt(Math.max(c,0))),l=a+1;l<r;l++)s.set(a,l,0)}this.L=s,this.positiveDefinite=!!i}isPositiveDefinite(){return this.positiveDefinite}solve(e){e=Pl.checkMatrix(e);let t=this.L,r=t.rows;if(e.rows!==r)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let s=e.columns,i=e.clone(),o,a,l;for(l=0;l<r;l++)for(a=0;a<s;a++){for(o=0;o<l;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(l,o));i.set(l,a,i.get(l,a)/t.get(l,l))}for(l=r-1;l>=0;l--)for(a=0;a<s;a++){for(o=l+1;o<r;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(o,l));i.set(l,a,i.get(l,a)/t.get(l,l))}return i}get lowerTriangularMatrix(){return this.L}}class Soe{constructor(e,t={}){e=Pl.checkMatrix(e);let{Y:r}=t;const{scaleScores:s=!1,maxIterations:i=1e3,terminationCriteria:o=1e-10}=t;let a;if(r){if(Ua.isAnyArray(r)&&typeof r[0]=="number"?r=Wt.columnVector(r):r=Pl.checkMatrix(r),r.rows!==e.rows)throw new Error("Y should have the same number of rows as X");a=r.getColumnVector(0)}else a=e.getColumnVector(0);let l=1,c,u,h,f;for(let d=0;d<i&&l>o;d++)h=e.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),h=h.div(h.norm()),c=e.mmul(h).div(h.transpose().mmul(h).get(0,0)),d>0&&(l=c.clone().sub(f).pow(2).sum()),f=c.clone(),r?(u=r.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),u=u.div(u.norm()),a=r.mmul(u).div(u.transpose().mmul(u).get(0,0))):a=c;if(r){let d=e.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0));d=d.div(d.norm());let p=e.clone().sub(c.clone().mmul(d.transpose())),m=a.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),g=r.clone().sub(c.clone().mulS(m.get(0,0)).mmul(u.transpose()));this.t=c,this.p=d.transpose(),this.w=h.transpose(),this.q=u,this.u=a,this.s=c.transpose().mmul(c),this.xResidual=p,this.yResidual=g,this.betas=m}else this.w=h.transpose(),this.s=c.transpose().mmul(c).sqrt(),s?this.t=c.clone().div(this.s.get(0,0)):this.t=c,this.xResidual=e.sub(c.mmul(h.transpose()))}}cr.AbstractMatrix=Gn;cr.CHO=_oe;cr.CholeskyDecomposition=_oe;cr.EVD=xoe;cr.EigenvalueDecomposition=xoe;cr.LU=$$;cr.LuDecomposition=$$;cr.Matrix=Wt;cr.MatrixColumnSelectionView=Dht;cr.MatrixColumnView=Pht;cr.MatrixFlipColumnView=Oht;cr.MatrixFlipRowView=Fht;cr.MatrixRowSelectionView=zht;cr.MatrixRowView=Lht;cr.MatrixSelectionView=rI;cr.MatrixSubView=Bht;cr.MatrixTransposeView=Vht;cr.NIPALS=Soe;cr.Nipals=Soe;cr.QR=eV;cr.QrDecomposition=eV;cr.SVD=ix;cr.SingularValueDecomposition=ix;cr.WrapperMatrix1D=voe;cr.WrapperMatrix2D=Pl;cr.correlation=Kht;cr.covariance=Xht;cr.default=Wt;cr.determinant=sI;cr.inverse=Wht;cr.linearDependencies=jht;cr.pseudoInverse=qht;cr.solve=woe;cr.wrap=Uht;const hh=cr.Matrix,eft=cr.inverse;function tft(n,e,t){return new Z4(t).choice(n,{size:e})}function nft(n,e,t,r){const s=new Z4(r);var i=new Array(e);if(i[0]=Math.floor(s.random()*n.length),e>1){for(var o={dist:-1,index:-1},a=0;a<n.length;++a)t[i[0]][a]>o.dist&&(o.dist=t[i[0]][a],o.index=a);if(i[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<n.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},f=0;f<l;++f)t[f][u]<h.dist&&i.indexOf(u)===-1&&(h={dist:t[f][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}i[l]=c.index}}return i.map(d=>n[d])}function rft(n,e,t={}){n=new hh(n);const r=n.rows,s=new Z4(t.seed),i=[],o=t.localTrials||2+Math.floor(Math.log(e)),a=s.randInt(r);i.push(n.getRow(a));let l=new hh(1,n.rows);for(let f=0;f<n.rows;f++)l.set(0,f,M$(n.getRow(f),i[0]));let c=[Bj(l.getRow(0))];const u=1/c[0][r-1];let h=hh.mul(l,u);for(let f=1;f<e;f++){const d=s.choice(r,{replace:!0,size:o,probabilities:h[0]}),p=n.selection(d,ift(n.columns)),m=sft(p,n);let g,y,b;for(let x=0;x<o;x++){const w=hh.min(l,[m.getRow(x)]),S=w.sum();(g===void 0||S<y)&&(g=d[x],y=S,b=w)}i[f]=n.getRow(g),l=b,c=[Bj(l.getRow(0))],h=hh.mul(l,1/c[0][r-1])}return i}function sft(n,e){const t=new hh(n.rows,e.rows);for(let r=0;r<n.rows;r++)for(let s=0;s<e.rows;s++)t.set(r,s,M$(n.getRow(r),e.getRow(s)));return t}function ift(n){let e=[];for(let t=0;t<n;t++)e.push(t);return e}function Bj(n){let e=[n[0]];for(let t=1;t<n.length;t++)e[t]=e[t-1]+n[t];return e}const LT=Symbol("distance");class tV{constructor(e,t,r,s,i){this.clusters=e,this.centroids=t,this.converged=r,this.iterations=s,this[LT]=i}nearest(e){const t=new Array(e.length),r=this.centroids.map(function(s){return s.centroid});return moe(e,r,t,this[LT])}computeInformation(e){for(var t=this.centroids.map(function(i){return{centroid:i,error:0,size:0}}),r=0;r<e.length;r++)t[this.clusters[r]].error+=this[LT](e[r],this.centroids[this.clusters[r]]),t[this.clusters[r]].size++;for(var s=0;s<this.centroids.length;s++)t[s].size?t[s].error/=t[s].size:t[s].error=null;return new tV(this.clusters,t,this.converged,this.iterations,this[LT])}}const oft={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:M$};function Coe(n,e,t,r,s,i){t=moe(e,n,t,s.distanceFunction);var o=jut(n,e,t,r),a=qut(o,n,s.distanceFunction,s.tolerance);return new tV(t,o,a,i,s.distanceFunction)}function*aft(n,e,t,r,s){for(var i=!1,o=0,a;!i&&o<s.maxIterations;)a=Coe(n,e,t,r,s,++o),yield a.computeInformation(e),i=a.converged,n=a.centroids}function lft(n,e,t){if(t=Object.assign({},oft,t),e<=0||e>n.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var r;if(Array.isArray(t.initialization)){if(t.initialization.length!==e)throw new Error("The initial centers should have the same length as K");r=t.initialization}else switch(t.initialization){case"kmeans++":r=rft(n,e,t);break;case"random":r=tft(n,e,t.seed);break;case"mostDistant":r=nft(n,e,Hut(n,t.distanceFunction),t.seed);break;default:throw new Error(`Unknown initialization method: "${t.initialization}"`)}t.maxIterations===0&&(t.maxIterations=Number.MAX_VALUE);var s=new Array(n.length);if(t.withIterations)return aft(r,n,s,e,t);for(var i=!1,o=0,a;!i&&o<t.maxIterations;)a=Coe(r,n,s,e,t,++o),i=a.converged,r=a.centroids;return a.computeInformation(n)}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    *//*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function cft(n,e,t,r){function s(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(h){o(h)}}function l(u){try{c(r.throw(u))}catch(h){o(h)}}function c(u){u.done?i(u.value):s(u.value).then(a,l)}c((r=r.apply(n,e||[])).next())})}function uft(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hft(n,e){return n==null&&e==null?null:n==null?e.clone():e===null?n.clone():cs([n,e],0)}function fft(n,e){for(var t=[],r=0;r<n.length;r++)t.push({value:n[r],index:r});t.sort(function(o,a){return a.value-o.value});for(var s=new Float32Array(e),i=new Int32Array(e),r=0;r<e;r++)s[r]=t[r].value,i[r]=t[r].index;return{values:s,indices:i}}var dft=function(){function n(){this.classDatasetMatrices={},this.classExampleCount={},this.labelToClassId={},this.nextClassId=0}return n.prototype.addExample=function(e,t){var r=this;if(this.exampleShape==null&&(this.exampleShape=e.shape),!Rn(this.exampleShape,e.shape))throw new Error("Example shape provided, ".concat(e.shape," does not match ")+"previously provided example shapes ".concat(this.exampleShape,"."));this.clearTrainDatasetMatrix(),t in this.labelToClassId||(this.labelToClassId[t]=this.nextClassId++),Se(function(){var s=r.normalizeVectorToUnitLength(ve(e,[e.size])),i=s.shape[0];if(r.classDatasetMatrices[t]==null)r.classDatasetMatrices[t]=ve(s,[1,i]);else{var o=cs([ve(r.classDatasetMatrices[t],[r.classExampleCount[t],i]),ve(s,[1,i])],0);r.classDatasetMatrices[t].dispose(),r.classDatasetMatrices[t]=o}Xs(r.classDatasetMatrices[t]),r.classExampleCount[t]==null&&(r.classExampleCount[t]=0),r.classExampleCount[t]++})},n.prototype.similarities=function(e){var t=this;return Se(function(){var r=t.normalizeVectorToUnitLength(ve(e,[e.size])),s=r.shape[0];if(t.trainDatasetMatrix==null){var i=null;for(var o in t.classDatasetMatrices)i=hft(i,t.classDatasetMatrices[o]);t.trainDatasetMatrix=i}if(t.trainDatasetMatrix==null)return console.warn("Cannot predict without providing training examples."),null;Xs(t.trainDatasetMatrix);var a=t.getNumExamples();return ve(Hn(ve(t.trainDatasetMatrix,[a,s]),ve(r,[s,1])),[a])})},n.prototype.predictClass=function(e,t){return t===void 0&&(t=3),cft(this,void 0,void 0,function(){var r,s,i,o,a=this;return uft(this,function(l){switch(l.label){case 0:if(t<1)throw new Error("Please provide a positive integer k value to predictClass.");if(this.getNumExamples()===0)throw new Error("You have not added any examples to the KNN classifier. Please add examples before calling predictClass.");return r=Se(function(){return wt(a.similarities(e),"float32")}),s=Math.min(t,this.getNumExamples()),o=fft,[4,r.data()];case 1:return i=o.apply(void 0,[l.sent(),s]).indices,r.dispose(),[2,this.calculateTopClass(i,s)]}})})},n.prototype.clearClass=function(e){if(this.classDatasetMatrices[e]==null)throw new Error("Cannot clear invalid class ".concat(e));this.classDatasetMatrices[e].dispose(),delete this.classDatasetMatrices[e],delete this.classExampleCount[e],this.clearTrainDatasetMatrix()},n.prototype.clearAllClasses=function(){for(var e in this.classDatasetMatrices)this.clearClass(e)},n.prototype.getClassExampleCount=function(){return this.classExampleCount},n.prototype.getClassifierDataset=function(){return this.classDatasetMatrices},n.prototype.getNumClasses=function(){return Object.keys(this.classExampleCount).length},n.prototype.setClassifierDataset=function(e){this.clearTrainDatasetMatrix(),this.classDatasetMatrices=e;for(var t in e)this.classExampleCount[t]=e[t].shape[0]},n.prototype.calculateTopClass=function(e,t){var r,s={};if(e==null)return{classIndex:this.labelToClassId[r],label:r,confidences:s};var i={},o=0;for(var a in this.classDatasetMatrices)o+=this.classExampleCount[a],i[a]=o;var l={};for(var a in this.classDatasetMatrices)l[a]=0;for(var c=0;c<e.length;c++){var u=e[c];for(var a in this.classDatasetMatrices)if(u<i[a]){l[a]++;break}}var h=0;for(var a in this.classDatasetMatrices){var f=l[a]/t;f>h&&(h=f,r=a),s[a]=f}return{classIndex:this.labelToClassId[r],label:r,confidences:s}},n.prototype.clearTrainDatasetMatrix=function(){this.trainDatasetMatrix!=null&&(this.trainDatasetMatrix.dispose(),this.trainDatasetMatrix=null)},n.prototype.normalizeVectorToUnitLength=function(e){return Se(function(){var t=Nw(e);return Lt(e,t)})},n.prototype.getNumExamples=function(){var e=0;for(var t in this.classDatasetMatrices)e+=this.classExampleCount[t];return e},n.prototype.dispose=function(){this.clearTrainDatasetMatrix();for(var e in this.classDatasetMatrices)this.classDatasetMatrices[e].dispose()},n}();/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function kA(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function TA(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(s=(s=o.trys).length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var pft={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},yd=224,mft={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},wb={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function Vj(n){return n===void 0&&(n={version:1,alpha:1}),kA(this,void 0,void 0,function(){var e,t,r,s,i,o,a;return TA(this,function(l){switch(l.label){case 0:if(vZ==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=n.version.toFixed(2),t=n.alpha?n.alpha.toFixed(2):"",r=-1,s=1,n.modelUrl==null){if(!(e in wb))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(wb));if(!(t in wb[e]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(wb[e])+".");o=wb[e][t].inputRange,r=o[0],s=o[1]}return n.inputRange!=null&&(a=n.inputRange,r=a[0],s=a[1]),[4,(i=new gft(e,t,n.modelUrl,r,s)).load()];case 1:return l.sent(),[2,i]}})})}var gft=function(){function n(e,t,r,s,i){s===void 0&&(s=-1),i===void 0&&(i=1),this.version=e,this.alpha=t,this.modelUrl=r,this.inputMin=s,this.inputMax=i,this.normalizationConstant=(i-s)/255}return n.prototype.load=function(){return kA(this,void 0,void 0,function(){var e,t,r,s,i=this;return TA(this,function(o){switch(o.label){case 0:return this.modelUrl?(e=this,[4,Rl(this.modelUrl)]):[3,2];case 1:return e.model=o.sent(),[3,4];case 2:return t=wb[this.version][this.alpha].url,r=this,[4,Rl(t,{fromTFHub:!0})];case 3:r.model=o.sent(),o.label=4;case 4:return[4,(s=Se(function(){return i.model.predict(ms([1,yd,yd,3]))})).data()];case 5:return o.sent(),s.dispose(),[2]}})})},n.prototype.infer=function(e,t){var r=this;return t===void 0&&(t=!1),Se(function(){e instanceof jn||(e=cC(e));var s=qe(fe(wt(e,"float32"),r.normalizationConstant),r.inputMin),i=s;(e.shape[0]!==yd||e.shape[1]!==yd)&&(i=Ci.resizeBilinear(s,[yd,yd],!0));var o,a=ve(i,[-1,yd,yd,3]);if(t){var l=mft[r.version],c=r.model.execute(a,l);o=vr(c,[1,2])}else{var u=r.model.predict(a);o=dn(u,[0,1],[-1,1e3])}return o})},n.prototype.classify=function(e,t){return t===void 0&&(t=3),kA(this,void 0,void 0,function(){var r,s;return TA(this,function(i){switch(i.label){case 0:return[4,yft(r=this.infer(e),t)];case 1:return s=i.sent(),r.dispose(),[2,s]}})})},n}();function yft(n,e){return kA(this,void 0,void 0,function(){var t,r,s,i,o,a,l;return TA(this,function(c){switch(c.label){case 0:return[4,(t=iC(n)).data()];case 1:for(r=c.sent(),t.dispose(),s=[],l=0;l<r.length;l++)s.push({value:r[l],index:l});for(s.sort(function(u,h){return h.value-u.value}),i=new Float32Array(e),o=new Int32Array(e),l=0;l<e;l++)i[l]=s[l].value,o[l]=s[l].index;for(a=[],l=0;l<o.length;l++)a.push({className:pft[o[l]],probability:i[l]});return[2,a]}})})}var bft={};(function(){var n;function e(T){var $=0;return function(){return $<T.length?{done:!1,value:T[$++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,$,L){return T==Array.prototype||T==Object.prototype||(T[$]=L.value),T};function r(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof pt=="object"&&pt];for(var $=0;$<T.length;++$){var L=T[$];if(L&&L.Math==Math)return L}throw Error("Cannot find global object")}var s=r(this);function i(T,$){if($)e:{var L=s;T=T.split(".");for(var W=0;W<T.length-1;W++){var ne=T[W];if(!(ne in L))break e;L=L[ne]}T=T[T.length-1],W=L[T],$=$(W),$!=W&&$!=null&&t(L,T,{configurable:!0,writable:!0,value:$})}}i("Symbol",function(T){function $(oe){if(this instanceof $)throw new TypeError("Symbol is not a constructor");return new L(W+(oe||"")+"_"+ne++,oe)}function L(oe,ie){this.h=oe,t(this,"description",{configurable:!0,writable:!0,value:ie})}if(T)return T;L.prototype.toString=function(){return this.h};var W="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ne=0;return $}),i("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var $="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),L=0;L<$.length;L++){var W=s[$[L]];typeof W=="function"&&typeof W.prototype[T]!="function"&&t(W.prototype,T,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function a(T){var $=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return $?$.call(T):{next:e(T)}}function l(T){if(!(T instanceof Array)){T=a(T);for(var $,L=[];!($=T.next()).done;)L.push($.value);T=L}return T}var c=typeof Object.assign=="function"?Object.assign:function(T,$){for(var L=1;L<arguments.length;L++){var W=arguments[L];if(W)for(var ne in W)Object.prototype.hasOwnProperty.call(W,ne)&&(T[ne]=W[ne])}return T};i("Object.assign",function(T){return T||c});var u=typeof Object.create=="function"?Object.create:function(T){function $(){}return $.prototype=T,new $},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},p={};try{p.__proto__=d,f=p.a;break e}catch{}f=!1}h=f?function(T,$){if(T.__proto__=$,T.__proto__!==$)throw new TypeError(T+" is not extensible");return T}:null}var m=h;function g(T,$){if(T.prototype=u($.prototype),T.prototype.constructor=T,m)m(T,$);else for(var L in $)if(L!="prototype")if(Object.defineProperties){var W=Object.getOwnPropertyDescriptor($,L);W&&Object.defineProperty(T,L,W)}else T[L]=$[L];T.za=$.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function b(T){if(T.m)throw new TypeError("Generator is already running");T.m=!0}y.prototype.u=function(T){this.i=T};function x(T,$){T.l={ma:$,na:!0},T.h=T.s||T.v}y.prototype.return=function(T){this.l={return:T},this.h=this.v};function w(T,$,L){return T.h=L,{value:$}}function S(T){this.h=new y,this.i=T}function C(T,$){b(T.h);var L=T.h.j;return L?k(T,"return"in L?L.return:function(W){return{value:W,done:!0}},$,T.h.return):(T.h.return($),A(T))}function k(T,$,L,W){try{var ne=$.call(T.h.j,L);if(!(ne instanceof Object))throw new TypeError("Iterator result "+ne+" is not an object");if(!ne.done)return T.h.m=!1,ne;var oe=ne.value}catch(ie){return T.h.j=null,x(T.h,ie),A(T)}return T.h.j=null,W.call(T.h,oe),A(T)}function A(T){for(;T.h.h;)try{var $=T.i(T.h);if($)return T.h.m=!1,{value:$.value,done:!1}}catch(L){T.h.i=void 0,x(T.h,L)}if(T.h.m=!1,T.h.l){if($=T.h.l,T.h.l=null,$.na)throw $.ma;return{value:$.return,done:!0}}return{value:void 0,done:!0}}function M(T){this.next=function($){return b(T.h),T.h.j?$=k(T,T.h.j.next,$,T.h.u):(T.h.u($),$=A(T)),$},this.throw=function($){return b(T.h),T.h.j?$=k(T,T.h.j.throw,$,T.h.u):(x(T.h,$),$=A(T)),$},this.return=function($){return C(T,$)},this[Symbol.iterator]=function(){return this}}function E(T){function $(W){return T.next(W)}function L(W){return T.throw(W)}return new Promise(function(W,ne){function oe(ie){ie.done?W(ie.value):Promise.resolve(ie.value).then($,L).then(oe,ne)}oe(T.next())})}function N(T){return E(new M(new S(T)))}i("Promise",function(T){function $(ie){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Ce=this.l();try{ie(Ce.resolve,Ce.reject)}catch(Pe){Ce.reject(Pe)}}function L(){this.h=null}function W(ie){return ie instanceof $?ie:new $(function(Ce){Ce(ie)})}if(T)return T;L.prototype.i=function(ie){if(this.h==null){this.h=[];var Ce=this;this.j(function(){Ce.m()})}this.h.push(ie)};var ne=s.setTimeout;L.prototype.j=function(ie){ne(ie,0)},L.prototype.m=function(){for(;this.h&&this.h.length;){var ie=this.h;this.h=[];for(var Ce=0;Ce<ie.length;++Ce){var Pe=ie[Ce];ie[Ce]=null;try{Pe()}catch(ht){this.l(ht)}}}this.h=null},L.prototype.l=function(ie){this.j(function(){throw ie})},$.prototype.l=function(){function ie(ht){return function(Et){Pe||(Pe=!0,ht.call(Ce,Et))}}var Ce=this,Pe=!1;return{resolve:ie(this.I),reject:ie(this.m)}},$.prototype.I=function(ie){if(ie===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(ie instanceof $)this.L(ie);else{e:switch(typeof ie){case"object":var Ce=ie!=null;break e;case"function":Ce=!0;break e;default:Ce=!1}Ce?this.F(ie):this.s(ie)}},$.prototype.F=function(ie){var Ce=void 0;try{Ce=ie.then}catch(Pe){this.m(Pe);return}typeof Ce=="function"?this.M(Ce,ie):this.s(ie)},$.prototype.m=function(ie){this.v(2,ie)},$.prototype.s=function(ie){this.v(1,ie)},$.prototype.v=function(ie,Ce){if(this.i!=0)throw Error("Cannot settle("+ie+", "+Ce+"): Promise already settled in state"+this.i);this.i=ie,this.j=Ce,this.i===2&&this.K(),this.H()},$.prototype.K=function(){var ie=this;ne(function(){if(ie.D()){var Ce=s.console;typeof Ce<"u"&&Ce.error(ie.j)}},1)},$.prototype.D=function(){if(this.u)return!1;var ie=s.CustomEvent,Ce=s.Event,Pe=s.dispatchEvent;return typeof Pe>"u"?!0:(typeof ie=="function"?ie=new ie("unhandledrejection",{cancelable:!0}):typeof Ce=="function"?ie=new Ce("unhandledrejection",{cancelable:!0}):(ie=s.document.createEvent("CustomEvent"),ie.initCustomEvent("unhandledrejection",!1,!0,ie)),ie.promise=this,ie.reason=this.j,Pe(ie))},$.prototype.H=function(){if(this.h!=null){for(var ie=0;ie<this.h.length;++ie)oe.i(this.h[ie]);this.h=null}};var oe=new L;return $.prototype.L=function(ie){var Ce=this.l();ie.T(Ce.resolve,Ce.reject)},$.prototype.M=function(ie,Ce){var Pe=this.l();try{ie.call(Ce,Pe.resolve,Pe.reject)}catch(ht){Pe.reject(ht)}},$.prototype.then=function(ie,Ce){function Pe(Ut,Rt){return typeof Ut=="function"?function(an){try{ht(Ut(an))}catch(Bn){Et(Bn)}}:Rt}var ht,Et,hn=new $(function(Ut,Rt){ht=Ut,Et=Rt});return this.T(Pe(ie,ht),Pe(Ce,Et)),hn},$.prototype.catch=function(ie){return this.then(void 0,ie)},$.prototype.T=function(ie,Ce){function Pe(){switch(ht.i){case 1:ie(ht.j);break;case 2:Ce(ht.j);break;default:throw Error("Unexpected state: "+ht.i)}}var ht=this;this.h==null?oe.i(Pe):this.h.push(Pe),this.u=!0},$.resolve=W,$.reject=function(ie){return new $(function(Ce,Pe){Pe(ie)})},$.race=function(ie){return new $(function(Ce,Pe){for(var ht=a(ie),Et=ht.next();!Et.done;Et=ht.next())W(Et.value).T(Ce,Pe)})},$.all=function(ie){var Ce=a(ie),Pe=Ce.next();return Pe.done?W([]):new $(function(ht,Et){function hn(an){return function(Bn){Ut[an]=Bn,Rt--,Rt==0&&ht(Ut)}}var Ut=[],Rt=0;do Ut.push(void 0),Rt++,W(Pe.value).T(hn(Ut.length-1),Et),Pe=Ce.next();while(!Pe.done)})},$});function O(T,$){T instanceof String&&(T+="");var L=0,W=!1,ne={next:function(){if(!W&&L<T.length){var oe=L++;return{value:$(oe,T[oe]),done:!1}}return W=!0,{done:!0,value:void 0}}};return ne[Symbol.iterator]=function(){return ne},ne}i("Array.prototype.keys",function(T){return T||function(){return O(this,function($){return $})}}),i("Array.prototype.fill",function(T){return T||function($,L,W){var ne=this.length||0;for(0>L&&(L=Math.max(0,ne+L)),(W==null||W>ne)&&(W=ne),W=Number(W),0>W&&(W=Math.max(0,ne+W)),L=Number(L||0);L<W;L++)this[L]=$;return this}});function R(T){return T||Array.prototype.fill}i("Int8Array.prototype.fill",R),i("Uint8Array.prototype.fill",R),i("Uint8ClampedArray.prototype.fill",R),i("Int16Array.prototype.fill",R),i("Uint16Array.prototype.fill",R),i("Int32Array.prototype.fill",R),i("Uint32Array.prototype.fill",R),i("Float32Array.prototype.fill",R),i("Float64Array.prototype.fill",R),i("Object.is",function(T){return T||function($,L){return $===L?$!==0||1/$===1/L:$!==$&&L!==L}}),i("Array.prototype.includes",function(T){return T||function($,L){var W=this;W instanceof String&&(W=String(W));var ne=W.length;for(L=L||0,0>L&&(L=Math.max(L+ne,0));L<ne;L++){var oe=W[L];if(oe===$||Object.is(oe,$))return!0}return!1}}),i("String.prototype.includes",function(T){return T||function($,L){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if($ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf($,L||0)!==-1}});var D=this||self;function z(T,$){T=T.split(".");var L=D;T[0]in L||typeof L.execScript>"u"||L.execScript("var "+T[0]);for(var W;T.length&&(W=T.shift());)T.length||$===void 0?L[W]&&L[W]!==Object.prototype[W]?L=L[W]:L=L[W]={}:L[W]=$}function B(T){var $;e:{if(($=D.navigator)&&($=$.userAgent))break e;$=""}return $.indexOf(T)!=-1}var X=Array.prototype.map?function(T,$){return Array.prototype.map.call(T,$,void 0)}:function(T,$){for(var L=T.length,W=Array(L),ne=typeof T=="string"?T.split(""):T,oe=0;oe<L;oe++)oe in ne&&(W[oe]=$.call(void 0,ne[oe],oe,T));return W},G={},te=null;function ge(T){var $=T.length,L=3*$/4;L%3?L=Math.floor(L):"=.".indexOf(T[$-1])!=-1&&(L="=.".indexOf(T[$-2])!=-1?L-2:L-1);var W=new Uint8Array(L),ne=0;return ae(T,function(oe){W[ne++]=oe}),ne!==L?W.subarray(0,ne):W}function ae(T,$){function L(Pe){for(;W<T.length;){var ht=T.charAt(W++),Et=te[ht];if(Et!=null)return Et;if(!/^[\s\xa0]*$/.test(ht))throw Error("Unknown base64 encoding at char: "+ht)}return Pe}Ne();for(var W=0;;){var ne=L(-1),oe=L(0),ie=L(64),Ce=L(64);if(Ce===64&&ne===-1)break;$(ne<<2|oe>>4),ie!=64&&($(oe<<4&240|ie>>2),Ce!=64&&$(ie<<6&192|Ce))}}function Ne(){if(!te){te={};for(var T="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),$=["+/=","+/","-_=","-_.","-_"],L=0;5>L;L++){var W=T.concat($[L].split(""));G[L]=W;for(var ne=0;ne<W.length;ne++){var oe=W[ne];te[oe]===void 0&&(te[oe]=ne)}}}}var ke=typeof Uint8Array<"u",De=!(B("Trident")||B("MSIE"))&&typeof D.btoa=="function";function be(T){if(!De){var $;$===void 0&&($=0),Ne(),$=G[$];for(var L=Array(Math.floor(T.length/3)),W=$[64]||"",ne=0,oe=0;ne<T.length-2;ne+=3){var ie=T[ne],Ce=T[ne+1],Pe=T[ne+2],ht=$[ie>>2];ie=$[(ie&3)<<4|Ce>>4],Ce=$[(Ce&15)<<2|Pe>>6],Pe=$[Pe&63],L[oe++]=ht+ie+Ce+Pe}switch(ht=0,Pe=W,T.length-ne){case 2:ht=T[ne+1],Pe=$[(ht&15)<<2]||W;case 1:T=T[ne],L[oe]=$[T>>2]+$[(T&3)<<4|ht>>4]+Pe+W}return L.join("")}for($="";10240<T.length;)$+=String.fromCharCode.apply(null,T.subarray(0,10240)),T=T.subarray(10240);return $+=String.fromCharCode.apply(null,T),btoa($)}var Xe=RegExp("[-_.]","g");function Oe(T){switch(T){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function it(T){if(!De)return ge(T);Xe.test(T)&&(T=T.replace(Xe,Oe)),T=atob(T);for(var $=new Uint8Array(T.length),L=0;L<T.length;L++)$[L]=T.charCodeAt(L);return $}var We;function dt(){return We||(We=new Uint8Array(0))}var ct={},Ve=typeof Uint8Array.prototype.slice=="function",ze=0,Be=0;function ut(T){var $=0>T;T=Math.abs(T);var L=T>>>0;T=Math.floor((T-L)/4294967296),$&&(L=a(ee(L,T)),$=L.next().value,T=L.next().value,L=$),ze=L>>>0,Be=T>>>0}var Ke=typeof BigInt=="function";function ee(T,$){return $=~$,T?T=~T+1:$+=1,[T,$]}function J(T,$){this.i=T>>>0,this.h=$>>>0}function rt(T){if(!T)return Ge||(Ge=new J(0,0));if(!/^-?\d+$/.test(T))return null;if(16>T.length)ut(Number(T));else if(Ke)T=BigInt(T),ze=Number(T&BigInt(4294967295))>>>0,Be=Number(T>>BigInt(32)&BigInt(4294967295));else{var $=+(T[0]==="-");Be=ze=0;for(var L=T.length,W=$,ne=(L-$)%6+$;ne<=L;W=ne,ne+=6)W=Number(T.slice(W,ne)),Be*=1e6,ze=1e6*ze+W,4294967296<=ze&&(Be+=ze/4294967296|0,ze%=4294967296);$&&($=a(ee(ze,Be)),T=$.next().value,$=$.next().value,ze=T,Be=$)}return new J(ze,Be)}var Ge;function ye(T,$){return Error("Invalid wire type: "+T+" (at position "+$+")")}function Ze(){return Error("Failed to read varint, encoding is invalid.")}function yt(T,$){return Error("Tried to read past the end of the data "+$+" > "+T)}function Ct(){throw Error("Invalid UTF8")}function ft(T,$){return $=String.fromCharCode.apply(null,$),T==null?$:T+$}var ce=void 0,nt,St=typeof TextDecoder<"u",gt,Gt=typeof TextEncoder<"u",Mn;function Cr(T){if(T!==ct)throw Error("illegal external caller")}function Bs(T,$){if(Cr($),this.V=T,T!=null&&T.length===0)throw Error("ByteString should be constructed with non-empty values")}function As(){return Mn||(Mn=new Bs(null,ct))}function Ms(T){Cr(ct);var $=T.V;return $=$==null||ke&&$!=null&&$ instanceof Uint8Array?$:typeof $=="string"?it($):null,$==null?$:T.V=$}function Vh(T){if(typeof T=="string")return{buffer:it(T),C:!1};if(Array.isArray(T))return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Uint8Array)return{buffer:T,C:!1};if(T.constructor===ArrayBuffer)return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Bs)return{buffer:Ms(T)||dt(),C:!0};if(T instanceof Uint8Array)return{buffer:new Uint8Array(T.buffer,T.byteOffset,T.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ul(T,$){this.i=null,this.m=!1,this.h=this.j=this.l=0,Wl(this,T,$)}function Wl(T,$,L){L=L===void 0?{}:L,T.S=L.S===void 0?!1:L.S,$&&($=Vh($),T.i=$.buffer,T.m=$.C,T.l=0,T.j=T.i.length,T.h=T.l)}Ul.prototype.reset=function(){this.h=this.l};function go(T,$){if(T.h=$,$>T.j)throw yt(T.j,$)}function Gl(T){var $=T.i,L=T.h,W=$[L++],ne=W&127;if(W&128&&(W=$[L++],ne|=(W&127)<<7,W&128&&(W=$[L++],ne|=(W&127)<<14,W&128&&(W=$[L++],ne|=(W&127)<<21,W&128&&(W=$[L++],ne|=W<<28,W&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128)))))throw Ze();return go(T,L),ne}function Lc(T,$){if(0>$)throw Error("Tried to read a negative byte length: "+$);var L=T.h,W=L+$;if(W>T.j)throw yt($,T.j-L);return T.h=W,L}var zc=[];function Di(){this.h=[]}Di.prototype.length=function(){return this.h.length},Di.prototype.end=function(){var T=this.h;return this.h=[],T};function Uh(T,$,L){for(;0<L||127<$;)T.h.push($&127|128),$=($>>>7|L<<25)>>>0,L>>>=7;T.h.push($)}function il(T,$){for(;127<$;)T.h.push($&127|128),$>>>=7;T.h.push($)}function Wh(T,$){if(zc.length){var L=zc.pop();Wl(L,T,$),T=L}else T=new Ul(T,$);this.h=T,this.j=this.h.h,this.i=this.l=-1,this.setOptions($)}Wh.prototype.setOptions=function(T){T=T===void 0?{}:T,this.ca=T.ca===void 0?!1:T.ca},Wh.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function re(T){var $=T.h;if($.h==$.j)return!1;T.j=T.h.h;var L=Gl(T.h)>>>0;if($=L>>>3,L&=7,!(0<=L&&5>=L))throw ye(L,T.j);if(1>$)throw Error("Invalid field number: "+$+" (at position "+T.j+")");return T.l=$,T.i=L,!0}function Ue(T){switch(T.i){case 0:if(T.i!=0)Ue(T);else e:{T=T.h;for(var $=T.h,L=$+10,W=T.i;$<L;)if(!(W[$++]&128)){go(T,$);break e}throw Ze()}break;case 1:T=T.h,go(T,T.h+8);break;case 2:T.i!=2?Ue(T):($=Gl(T.h)>>>0,T=T.h,go(T,T.h+$));break;case 5:T=T.h,go(T,T.h+4);break;case 3:$=T.l;do{if(!re(T))throw Error("Unmatched start-group tag: stream EOF");if(T.i==4){if(T.l!=$)throw Error("Unmatched end-group tag");break}Ue(T)}while(1);break;default:throw ye(T.i,T.j)}}var Fe=[];function Je(){this.j=[],this.i=0,this.h=new Di}function vt(T,$){$.length!==0&&(T.j.push($),T.i+=$.length)}function zn(T,$){if($=$.R){vt(T,T.h.end());for(var L=0;L<$.length;L++)vt(T,Ms($[L])||dt())}}var sn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Tn(T,$){return sn?T[sn]|=$:T.A!==void 0?T.A|=$:(Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}}),$)}function En(T,$){sn?T[sn]&&(T[sn]&=~$):T.A!==void 0&&(T.A&=~$)}function Nn(T){var $;return sn?$=T[sn]:$=T.A,$??0}function er(T,$){sn?T[sn]=$:T.A!==void 0?T.A=$:Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}})}function _n(T){return Tn(T,1),T}function ur(T,$){er($,(T|0)&-51)}function Oi(T,$){er($,(T|18)&-41)}var xr={};function Zi(T){return T!==null&&typeof T=="object"&&!Array.isArray(T)&&T.constructor===Object}var Ar,Io=[];er(Io,23),Ar=Object.freeze(Io);function rs(T){if(Nn(T.o)&2)throw Error("Cannot mutate an immutable Message")}function yo(T){var $=T.length;($=$?T[$-1]:void 0)&&Zi($)?$.g=1:($={},T.push(($.g=1,$)))}function Ao(T){var $=T.i+T.G;return T.B||(T.B=T.o[$]={})}function Ns(T,$){return $===-1?null:$>=T.i?T.B?T.B[$]:void 0:T.o[$+T.G]}function bo(T,$,L,W){rs(T),Gh(T,$,L,W)}function Gh(T,$,L,W){T.j&&(T.j=void 0),$>=T.i||W?Ao(T)[$]=L:(T.o[$+T.G]=L,(T=T.B)&&$ in T&&delete T[$])}function ol(T,$,L,W){var ne=Ns(T,$);Array.isArray(ne)||(ne=Ar);var oe=Nn(ne);if(oe&1||_n(ne),W)oe&2||Tn(ne,2),L&1||Object.freeze(ne);else{W=!(L&2);var ie=oe&2;L&1||!ie?W&&oe&16&&!ie&&En(ne,16):(ne=_n(Array.prototype.slice.call(ne)),Gh(T,$,ne))}return ne}function Ji(T,$){var L=Ns(T,$),W=L==null?L:typeof L=="number"||L==="NaN"||L==="Infinity"||L==="-Infinity"?Number(L):void 0;return W!=null&&W!==L&&Gh(T,$,W),W}function Bc(T,$,L,W,ne){T.h||(T.h={});var oe=T.h[L],ie=ol(T,L,3,ne);if(!oe){var Ce=ie;oe=[];var Pe=!!(Nn(T.o)&16);ie=!!(Nn(Ce)&2);var ht=Ce;!ne&&ie&&(Ce=Array.prototype.slice.call(Ce));for(var Et=ie,hn=0;hn<Ce.length;hn++){var Ut=Ce[hn],Rt=$,an=!1;if(an=an===void 0?!1:an,Ut=Array.isArray(Ut)?new Rt(Ut):an?new Rt:void 0,Ut!==void 0){Rt=Ut.o;var Bn=an=Nn(Rt);ie&&(Bn|=2),Pe&&(Bn|=16),Bn!=an&&er(Rt,Bn),Rt=Bn,Et=Et||!!(2&Rt),oe.push(Ut)}}return T.h[L]=oe,Pe=Nn(Ce),$=Pe|33,$=Et?$&-9:$|8,Pe!=$&&(Et=Ce,Object.isFrozen(Et)&&(Et=Array.prototype.slice.call(Et)),er(Et,$),Ce=Et),ht!==Ce&&Gh(T,L,Ce),(ne||W&&ie)&&Tn(oe,2),W&&Object.freeze(oe),oe}return ne||(ne=Object.isFrozen(oe),W&&!ne?Object.freeze(oe):!W&&ne&&(oe=Array.prototype.slice.call(oe),T.h[L]=oe)),oe}function Ma(T,$,L){var W=!!(Nn(T.o)&2);if($=Bc(T,$,L,W,W),T=ol(T,L,3,W),!(W||Nn(T)&8)){for(W=0;W<$.length;W++){if(L=$[W],Nn(L.o)&2){var ne=Hl(L,!1);ne.j=L}else ne=L;L!==ne&&($[W]=ne,T[W]=ne.o)}Tn(T,8)}return $}function $s(T,$,L){if(L!=null&&typeof L!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof L+": "+L);bo(T,$,L)}function Vc(T,$,L,W,ne){rs(T);var oe=Bc(T,L,$,!1,!1);return L=W??new L,T=ol(T,$,2,!1),ne!=null?(oe.splice(ne,0,L),T.splice(ne,0,L.o)):(oe.push(L),T.push(L.o)),L.C()&&En(T,8),L}function Qi(T,$){return T??$}function Vs(T,$,L){return L=L===void 0?0:L,Qi(Ji(T,$),L)}var Hh;function u0(T){switch(typeof T){case"number":return isFinite(T)?T:String(T);case"object":if(T)if(Array.isArray(T)){if(Nn(T)&128)return T=Array.prototype.slice.call(T),yo(T),T}else{if(ke&&T!=null&&T instanceof Uint8Array)return be(T);if(T instanceof Bs){var $=T.V;return $==null?"":typeof $=="string"?$:T.V=be($)}}}return T}function jh(T,$,L,W){if(T!=null){if(Array.isArray(T))T=eo(T,$,L,W!==void 0);else if(Zi(T)){var ne={},oe;for(oe in T)ne[oe]=jh(T[oe],$,L,W);T=ne}else T=$(T,W);return T}}function eo(T,$,L,W){var ne=Nn(T);W=W?!!(ne&16):void 0,T=Array.prototype.slice.call(T);for(var oe=0;oe<T.length;oe++)T[oe]=jh(T[oe],$,L,W);return L(ne,T),T}function qh(T){return T.ja===xr?T.toJSON():u0(T)}function rd(T,$){T&128&&yo($)}function qu(T,$,L){if(L=L===void 0?Oi:L,T!=null){if(ke&&T instanceof Uint8Array)return T.length?new Bs(new Uint8Array(T),ct):As();if(Array.isArray(T)){var W=Nn(T);return W&2?T:$&&!(W&32)&&(W&16||W===0)?(er(T,W|2),T):(T=eo(T,qu,W&4?Oi:L,!0),$=Nn(T),$&4&&$&2&&Object.freeze(T),T)}return T.ja===xr?Xh(T):T}}function sd(T,$,L,W,ne,oe,ie){if(T=T.h&&T.h[L]){if(W=Nn(T),W&2?W=T:(oe=X(T,Xh),Oi(W,oe),Object.freeze(oe),W=oe),rs($),ie=W==null?Ar:_n([]),W!=null){for(oe=!!W.length,T=0;T<W.length;T++){var Ce=W[T];oe=oe&&!(Nn(Ce.o)&2),ie[T]=Ce.o}oe=(oe?8:0)|1,T=Nn(ie),(T&oe)!==oe&&(Object.isFrozen(ie)&&(ie=Array.prototype.slice.call(ie)),er(ie,T|oe)),$.h||($.h={}),$.h[L]=W}else $.h&&($.h[L]=void 0);Gh($,L,ie,ne)}else bo($,L,qu(W,oe,ie),ne)}function Xh(T){return Nn(T.o)&2||(T=Hl(T,!0),Tn(T.o,2)),T}function Hl(T,$){var L=T.o,W=[];Tn(W,16);var ne=T.constructor.h;if(ne&&W.push(ne),ne=T.B,ne){W.length=L.length,W.fill(void 0,W.length,L.length);var oe={};W[W.length-1]=oe}Nn(L)&128&&yo(W),$=$||T.C()?Oi:ur,oe=T.constructor,Hh=W,W=new oe(W),Hh=void 0,T.R&&(W.R=T.R.slice()),oe=!!(Nn(L)&16);for(var ie=ne?L.length-1:L.length,Ce=0;Ce<ie;Ce++)sd(T,W,Ce-T.G,L[Ce],!1,oe,$);if(ne)for(var Pe in ne)sd(T,W,+Pe,ne[Pe],!0,oe,$);return W}function Zr(T,$,L){T==null&&(T=Hh),Hh=void 0;var W=this.constructor.i||0,ne=0<W,oe=this.constructor.h,ie=!1;if(T==null){T=oe?[oe]:[];var Ce=48,Pe=!0;ne&&(W=0,Ce|=128),er(T,Ce)}else{if(!Array.isArray(T)||oe&&oe!==T[0])throw Error();var ht=Ce=Tn(T,0);if((Pe=(16&ht)!==0)&&((ie=(32&ht)!==0)||(ht|=32)),ne){if(128&ht)W=0;else if(0<T.length){var Et=T[T.length-1];if(Zi(Et)&&"g"in Et){W=0,ht|=128,delete Et.g;var hn=!0,Ut;for(Ut in Et){hn=!1;break}hn&&T.pop()}}}else if(128&ht)throw Error();Ce!==ht&&er(T,ht)}this.G=(oe?0:-1)-W,this.h=void 0,this.o=T;e:{if(oe=this.o.length,W=oe-1,oe&&(oe=this.o[W],Zi(oe))){this.B=oe,this.i=W-this.G;break e}$!==void 0&&-1<$?(this.i=Math.max($,W+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!ne&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(L){$=Pe&&!ie&&!0,ne=this.i;var Rt;for(Pe=0;Pe<L.length;Pe++)ie=L[Pe],ie<ne?(ie+=this.G,(W=T[ie])?h0(W,$):T[ie]=Ar):(Rt||(Rt=Ao(this)),(W=Rt[ie])?h0(W,$):Rt[ie]=Ar)}}Zr.prototype.toJSON=function(){return eo(this.o,qh,rd)},Zr.prototype.C=function(){return!!(Nn(this.o)&2)};function h0(T,$){if(Array.isArray(T)){var L=Nn(T),W=1;!$||L&2||(W|=16),(L&W)!==W&&er(T,L|W)}}Zr.prototype.ja=xr,Zr.prototype.toString=function(){return this.o.toString()};function id(T,$,L){if(L){var W={},ne;for(ne in L){var oe=L[ne],ie=oe.ra;ie||(W.J=oe.xa||oe.oa.W,oe.ia?(W.aa=at(oe.ia),ie=function(Ce){return function(Pe,ht,Et){return Ce.J(Pe,ht,Et,Ce.aa)}}(W)):oe.ka?(W.Z=Vt(oe.da.P,oe.ka),ie=function(Ce){return function(Pe,ht,Et){return Ce.J(Pe,ht,Et,Ce.Z)}}(W)):ie=W.J,oe.ra=ie),ie($,T,oe.da),W={J:W.J,aa:W.aa,Z:W.Z}}}zn($,T)}var Uc=Symbol();function Kh(T,$,L){return T[Uc]||(T[Uc]=function(W,ne){return $(W,ne,L)})}function f0(T){var $=T[Uc];if(!$){var L=_x(T);$=function(W,ne){return p0(W,ne,L)},T[Uc]=$}return $}function d0(T){var $=T.ia;if($)return f0($);if($=T.wa)return Kh(T.da.P,$,T.ka)}function H(T){var $=d0(T),L=T.da,W=T.oa.U;return $?function(ne,oe){return W(ne,oe,L,$)}:function(ne,oe){return W(ne,oe,L)}}function Y(T,$){var L=T[$];return typeof L=="function"&&L.length===0&&(L=L(),T[$]=L),Array.isArray(L)&&(Kp in L||$n in L||0<L.length&&typeof L[0]=="function")?L:void 0}function pe(T,$,L,W,ne,oe){$.P=T[0];var ie=1;if(T.length>ie&&typeof T[ie]!="number"){var Ce=T[ie++];L($,Ce)}for(;ie<T.length;){L=T[ie++];for(var Pe=ie+1;Pe<T.length&&typeof T[Pe]!="number";)Pe++;switch(Ce=T[ie++],Pe-=ie,Pe){case 0:W($,L,Ce);break;case 1:(Pe=Y(T,ie))?(ie++,ne($,L,Ce,Pe)):W($,L,Ce,T[ie++]);break;case 2:Pe=ie++,Pe=Y(T,Pe),ne($,L,Ce,Pe,T[ie++]);break;case 3:oe($,L,Ce,T[ie++],T[ie++],T[ie++]);break;case 4:oe($,L,Ce,T[ie++],T[ie++],T[ie++],T[ie++]);break;default:throw Error("unexpected number of binary field arguments: "+Pe)}}return $}var Re=Symbol();function at(T){var $=T[Re];if(!$){var L=xx(T);$=function(W,ne){return tk(W,ne,L)},T[Re]=$}return $}function Vt(T,$){var L=T[Re];return L||(L=function(W,ne){return id(W,ne,$)},T[Re]=L),L}var $n=Symbol();function Rs(T,$){T.push($)}function Us(T,$,L){T.push($,L.W)}function pi(T,$,L,W){var ne=at(W),oe=xx(W).P,ie=L.W;T.push($,function(Ce,Pe,ht){return ie(Ce,Pe,ht,oe,ne)})}function Na(T,$,L,W,ne,oe){var ie=Vt(W,oe),Ce=L.W;T.push($,function(Pe,ht,Et){return Ce(Pe,ht,Et,W,ie)})}function xx(T){var $=T[$n];return $||($=pe(T,T[$n]=[],Rs,Us,pi,Na),Kp in T&&$n in T&&(T.length=0),$)}var Kp=Symbol();function ek(T,$){T[0]=$}function J$(T,$,L,W){var ne=L.U;T[$]=W?function(oe,ie,Ce){return ne(oe,ie,Ce,W)}:ne}function Q$(T,$,L,W,ne){var oe=L.U,ie=f0(W),Ce=_x(W).P;T[$]=function(Pe,ht,Et){return oe(Pe,ht,Et,Ce,ie,ne)}}function eR(T,$,L,W,ne,oe,ie){var Ce=L.U,Pe=Kh(W,ne,oe);T[$]=function(ht,Et,hn){return Ce(ht,Et,hn,W,Pe,ie)}}function _x(T){var $=T[Kp];return $||($=pe(T,T[Kp]={},ek,J$,Q$,eR),Kp in T&&$n in T&&(T.length=0),$)}function p0(T,$,L){for(;re($)&&$.i!=4;){var W=$.l,ne=L[W];if(!ne){var oe=L[0];oe&&(oe=oe[W])&&(ne=L[W]=H(oe))}if(!ne||!ne($,T,W)){ne=$,W=T,oe=ne.j,Ue(ne);var ie=ne;if(!ie.ca){if(ne=ie.h.h-oe,ie.h.h=oe,ie=ie.h,ne==0)ne=As();else{if(oe=Lc(ie,ne),ie.S&&ie.m)ne=ie.i.subarray(oe,oe+ne);else{ie=ie.i;var Ce=oe;ne=oe+ne,ne=Ce===ne?dt():Ve?ie.slice(Ce,ne):new Uint8Array(ie.subarray(Ce,ne))}ne=ne.length==0?As():new Bs(ne,ct)}(oe=W.R)?oe.push(ne):W.R=[ne]}}}return T}function tk(T,$,L){for(var W=L.length,ne=W%2==1,oe=ne?1:0;oe<W;oe+=2)(0,L[oe+1])($,T,L[oe]);id(T,$,ne?L[0]:void 0)}function Yp(T,$){return{U:T,W:$}}var al=Yp(function(T,$,L){if(T.i!==5)return!1;T=T.h;var W=T.i,ne=T.h,oe=W[ne],ie=W[ne+1],Ce=W[ne+2];return W=W[ne+3],go(T,T.h+4),ie=(oe<<0|ie<<8|Ce<<16|W<<24)>>>0,T=2*(ie>>31)+1,oe=ie>>>23&255,ie&=8388607,bo($,L,oe==255?ie?NaN:1/0*T:oe==0?T*Math.pow(2,-149)*ie:T*Math.pow(2,oe-150)*(ie+Math.pow(2,23))),!0},function(T,$,L){if($=Ji($,L),$!=null){il(T.h,8*L+5),T=T.h;var W=+$;W===0?0<1/W?ze=Be=0:(Be=0,ze=2147483648):isNaN(W)?(Be=0,ze=2147483647):(W=(L=0>W?-2147483648:0)?-W:W,34028234663852886e22<W?(Be=0,ze=(L|2139095040)>>>0):11754943508222875e-54>W?(W=Math.round(W/Math.pow(2,-149)),Be=0,ze=(L|W)>>>0):($=Math.floor(Math.log(W)/Math.LN2),W*=Math.pow(2,-$),W=Math.round(8388608*W),16777216<=W&&++$,Be=0,ze=(L|$+127<<23|W&8388607)>>>0)),L=ze,T.h.push(L>>>0&255),T.h.push(L>>>8&255),T.h.push(L>>>16&255),T.h.push(L>>>24&255)}}),tR=Yp(function(T,$,L){if(T.i!==0)return!1;var W=T.h,ne=0,oe=T=0,ie=W.i,Ce=W.h;do{var Pe=ie[Ce++];ne|=(Pe&127)<<oe,oe+=7}while(32>oe&&Pe&128);for(32<oe&&(T|=(Pe&127)>>4),oe=3;32>oe&&Pe&128;oe+=7)Pe=ie[Ce++],T|=(Pe&127)<<oe;if(go(W,Ce),128>Pe)W=ne>>>0,Pe=T>>>0,(T=Pe&2147483648)&&(W=~W+1>>>0,Pe=~Pe>>>0,W==0&&(Pe=Pe+1>>>0)),W=4294967296*Pe+(W>>>0);else throw Ze();return bo($,L,T?-W:W),!0},function(T,$,L){$=Ns($,L),$!=null&&(typeof $=="string"&&rt($),$!=null&&(il(T.h,8*L),typeof $=="number"?(T=T.h,ut($),Uh(T,ze,Be)):(L=rt($),Uh(T.h,L.i,L.h))))}),nR=Yp(function(T,$,L){return T.i!==0?!1:(bo($,L,Gl(T.h)),!0)},function(T,$,L){if($=Ns($,L),$!=null&&$!=null)if(il(T.h,8*L),T=T.h,L=$,0<=L)il(T,L);else{for($=0;9>$;$++)T.h.push(L&127|128),L>>=7;T.h.push(1)}}),Br=Yp(function(T,$,L){if(T.i!==2)return!1;var W=Gl(T.h)>>>0;T=T.h;var ne=Lc(T,W);if(T=T.i,St){var oe=T,ie;(ie=nt)||(ie=nt=new TextDecoder("utf-8",{fatal:!0})),T=ne+W,oe=ne===0&&T===oe.length?oe:oe.subarray(ne,T);try{var Ce=ie.decode(oe)}catch(hn){if(ce===void 0){try{ie.decode(new Uint8Array([128]))}catch{}try{ie.decode(new Uint8Array([97])),ce=!0}catch{ce=!1}}throw!ce&&(nt=void 0),hn}}else{Ce=ne,W=Ce+W,ne=[];for(var Pe=null,ht,Et;Ce<W;)ht=T[Ce++],128>ht?ne.push(ht):224>ht?Ce>=W?Ct():(Et=T[Ce++],194>ht||(Et&192)!==128?(Ce--,Ct()):ne.push((ht&31)<<6|Et&63)):240>ht?Ce>=W-1?Ct():(Et=T[Ce++],(Et&192)!==128||ht===224&&160>Et||ht===237&&160<=Et||((oe=T[Ce++])&192)!==128?(Ce--,Ct()):ne.push((ht&15)<<12|(Et&63)<<6|oe&63)):244>=ht?Ce>=W-2?Ct():(Et=T[Ce++],(Et&192)!==128||(ht<<28)+(Et-144)>>30||((oe=T[Ce++])&192)!==128||((ie=T[Ce++])&192)!==128?(Ce--,Ct()):(ht=(ht&7)<<18|(Et&63)<<12|(oe&63)<<6|ie&63,ht-=65536,ne.push((ht>>10&1023)+55296,(ht&1023)+56320))):Ct(),8192<=ne.length&&(Pe=ft(Pe,ne),ne.length=0);Ce=ft(Pe,ne)}return bo($,L,Ce),!0},function(T,$,L){if($=Ns($,L),$!=null){var W=!1;if(W=W===void 0?!1:W,Gt){if(W&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test($))throw Error("Found an unpaired surrogate");$=(gt||(gt=new TextEncoder)).encode($)}else{for(var ne=0,oe=new Uint8Array(3*$.length),ie=0;ie<$.length;ie++){var Ce=$.charCodeAt(ie);if(128>Ce)oe[ne++]=Ce;else{if(2048>Ce)oe[ne++]=Ce>>6|192;else{if(55296<=Ce&&57343>=Ce){if(56319>=Ce&&ie<$.length){var Pe=$.charCodeAt(++ie);if(56320<=Pe&&57343>=Pe){Ce=1024*(Ce-55296)+Pe-56320+65536,oe[ne++]=Ce>>18|240,oe[ne++]=Ce>>12&63|128,oe[ne++]=Ce>>6&63|128,oe[ne++]=Ce&63|128;continue}else ie--}if(W)throw Error("Found an unpaired surrogate");Ce=65533}oe[ne++]=Ce>>12|224,oe[ne++]=Ce>>6&63|128}oe[ne++]=Ce&63|128}}$=ne===oe.length?oe:oe.subarray(0,ne)}il(T.h,8*L+2),il(T.h,$.length),vt(T,T.h.end()),vt(T,$)}}),Rr=Yp(function(T,$,L,W,ne){if(T.i!==2)return!1;$=Vc($,L,W),L=T.h.j,W=Gl(T.h)>>>0;var oe=T.h.h+W,ie=oe-L;if(0>=ie&&(T.h.j=oe,ne($,T,void 0,void 0,void 0),ie=oe-T.h.h),ie)throw Error("Message parsing ended unexpectedly. Expected to read "+(W+" bytes, instead read "+(W-ie)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return T.h.h=oe,T.h.j=L,!0},function(T,$,L,W,ne){if($=Ma($,W,L),$!=null)for(W=0;W<$.length;W++){var oe=T;il(oe.h,8*L+2);var ie=oe.h.end();vt(oe,ie),ie.push(oe.i),oe=ie,ne($[W],T),ie=T;var Ce=oe.pop();for(Ce=ie.i+ie.h.length()-Ce;127<Ce;)oe.push(Ce&127|128),Ce>>>=7,ie.i++;oe.push(Ce),ie.i++}});function Sx(T){return function($,L){e:{if(Fe.length){var W=Fe.pop();W.setOptions(L),Wl(W.h,$,L),$=W}else $=new Wh($,L);try{var ne=_x(T),oe=p0(new ne.P,$,ne);break e}finally{ne=$.h,ne.i=null,ne.m=!1,ne.l=0,ne.j=0,ne.h=0,ne.S=!1,$.l=-1,$.i=-1,100>Fe.length&&Fe.push($)}oe=void 0}return oe}}function Cx(T){return function(){var $=new Je;tk(this,$,xx(T)),vt($,$.h.end());for(var L=new Uint8Array($.i),W=$.j,ne=W.length,oe=0,ie=0;ie<ne;ie++){var Ce=W[ie];L.set(Ce,oe),oe+=Ce.length}return $.j=[L],L}}function od(T){Zr.call(this,T)}g(od,Zr);var nk=[od,1,nR,2,al,3,Br,4,Br];od.prototype.l=Cx(nk);function kx(T){Zr.call(this,T,-1,rR)}g(kx,Zr),kx.prototype.addClassification=function(T,$){return Vc(this,1,od,T,$),this};var rR=[1],rk=Sx([kx,1,Rr,nk]);function Zp(T){Zr.call(this,T)}g(Zp,Zr);var mi=[Zp,1,al,2,al,3,al,4,al,5,al];Zp.prototype.l=Cx(mi);function m0(T){Zr.call(this,T,-1,Yh)}g(m0,Zr);var Yh=[1],sk=Sx([m0,1,Rr,mi]);function ad(T){Zr.call(this,T)}g(ad,Zr);var oa=[ad,1,al,2,al,3,al,4,al,5,al,6,tR],ik=Sx(oa);ad.prototype.l=Cx(oa);function Tx(T,$,L){if(L=T.createShader(L===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(L,$),T.compileShader(L),!T.getShaderParameter(L,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(L));return L}function ok(T){return Ma(T,od,1).map(function($){var L=Ns($,1);return{index:L??0,qa:Vs($,2),label:Ns($,3)!=null?Qi(Ns($,3),""):void 0,displayName:Ns($,4)!=null?Qi(Ns($,4),""):void 0}})}function ak(T){return{x:Vs(T,1),y:Vs(T,2),z:Vs(T,3),visibility:Ji(T,4)!=null?Vs(T,4):void 0}}function g0(T){return Ma(sk(T),Zp,1).map(ak)}function y0(T,$){this.i=T,this.h=$,this.m=0}function Mo(T,$,L){return sR(T,$),typeof T.h.canvas.transferToImageBitmap=="function"?Promise.resolve(T.h.canvas.transferToImageBitmap()):L?Promise.resolve(T.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.h.canvas):(T.j===void 0&&(T.j=document.createElement("canvas")),new Promise(function(W){T.j.height=T.h.canvas.height,T.j.width=T.h.canvas.width,T.j.getContext("2d",{}).drawImage(T.h.canvas,0,0,T.h.canvas.width,T.h.canvas.height),W(T.j)}))}function sR(T,$){var L=T.h;if(T.s===void 0){var W=Tx(L,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ne=Tx(L,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),oe=L.createProgram();if(L.attachShader(oe,W),L.attachShader(oe,ne),L.linkProgram(oe),!L.getProgramParameter(oe,L.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+L.getProgramInfoLog(oe));W=T.s=oe,L.useProgram(W),ne=L.getUniformLocation(W,"sampler0"),T.l={O:L.getAttribLocation(W,"aVertex"),N:L.getAttribLocation(W,"aTex"),ya:ne},T.v=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.enableVertexAttribArray(T.l.O),L.vertexAttribPointer(T.l.O,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),T.u=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.enableVertexAttribArray(T.l.N),L.vertexAttribPointer(T.l.N,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),L.uniform1i(ne,0)}W=T.l,L.useProgram(T.s),L.canvas.width=$.width,L.canvas.height=$.height,L.viewport(0,0,$.width,$.height),L.activeTexture(L.TEXTURE0),T.i.bindTexture2d($.glName),L.enableVertexAttribArray(W.O),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.vertexAttribPointer(W.O,2,L.FLOAT,!1,0,0),L.enableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.vertexAttribPointer(W.N,2,L.FLOAT,!1,0,0),L.bindFramebuffer(L.DRAW_FRAMEBUFFER?L.DRAW_FRAMEBUFFER:L.FRAMEBUFFER,null),L.clearColor(0,0,0,0),L.clear(L.COLOR_BUFFER_BIT),L.colorMask(!0,!0,!0,!0),L.drawArrays(L.TRIANGLE_FAN,0,4),L.disableVertexAttribArray(W.O),L.disableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,null),T.i.bindTexture2d(0)}function $a(T){this.h=T}var iR=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function lk(T,$){return $+T}function Wc(T,$){window[T]=$}function b0(T){var $=document.createElement("script");return $.setAttribute("src",T),$.setAttribute("crossorigin","anonymous"),new Promise(function(L){$.addEventListener("load",function(){L()},!1),$.addEventListener("error",function(){L()},!1),document.body.appendChild($)})}function Ex(){return N(function(T){switch(T.h){case 1:return T.s=2,w(T,WebAssembly.instantiate(iR),4);case 4:T.h=3,T.s=0;break;case 2:return T.s=0,T.l=null,T.return(!1);case 3:return T.return(!0)}})}function Vr(T){if(this.h=T,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=T&&T.locateFile||lk,typeof window=="object")var $=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")$=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=$,T.options){$=a(Object.keys(T.options));for(var L=$.next();!L.done;L=$.next()){L=L.value;var W=T.options[L].default;W!==void 0&&(this.l[L]=typeof W=="function"?W():W)}}}n=Vr.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Xu(T){var $,L,W,ne,oe,ie,Ce,Pe,ht,Et,hn;return N(function(Ut){switch(Ut.h){case 1:return T.ga?($=T.h.files===void 0?[]:typeof T.h.files=="function"?T.h.files(T.l):T.h.files,w(Ut,Ex(),2)):Ut.return();case 2:if(L=Ut.i,typeof window=="object")return Wc("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),Wc("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),ie=$.filter(function(Rt){return Rt.data!==void 0}),Ce=$.filter(function(Rt){return Rt.data===void 0}),Pe=Promise.all(ie.map(function(Rt){var an=ld(T,Rt.url);if(Rt.path!==void 0){var Bn=Rt.path;an=an.then(function(Ur){return T.overrideFile(Bn,Ur),Promise.resolve(Ur)})}return an})),ht=Promise.all(Ce.map(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L?b0(T.locateFile(Rt.url,T.ha)):Promise.resolve()})).then(function(){var Rt,an,Bn;return N(function(Ur){if(Ur.h==1)return Rt=window.createMediapipeSolutionsWasm,an=window.createMediapipeSolutionsPackedAssets,Bn=T,w(Ur,Rt(an),2);Bn.i=Ur.i,Ur.h=0})}),Et=function(){return N(function(Rt){return T.h.graph&&T.h.graph.url?Rt=w(Rt,ld(T,T.h.graph.url),0):(Rt.h=0,Rt=void 0),Rt})}(),w(Ut,Promise.all([ht,Pe,Et]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return W=$.filter(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L}).map(function(Rt){return T.locateFile(Rt.url,T.ha)}),importScripts.apply(null,l(W)),ne=T,w(Ut,createMediapipeSolutionsWasm(Module),6);case 6:ne.i=Ut.i,T.m=new OffscreenCanvas(1,1),T.i.canvas=T.m,oe=T.i.GL.createContext(T.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),T.i.GL.makeContextCurrent(oe),Ut.h=4;break;case 7:if(T.m=document.createElement("canvas"),hn=T.m.getContext("webgl2",{}),!hn&&(hn=T.m.getContext("webgl",{}),!hn))return alert("Failed to create WebGL canvas context when passing video frame."),Ut.return();T.K=hn,T.i.canvas=T.m,T.i.createContext(T.m,!0,!0,{});case 4:T.j=new T.i.SolutionWasm,T.ga=!1,Ut.h=0}})}function Ix(T){var $,L,W,ne,oe,ie,Ce,Pe;return N(function(ht){if(ht.h==1){if(T.h.graph&&T.h.graph.url&&T.fa===T.h.graph.url)return ht.return();if(T.u=!0,!T.h.graph||!T.h.graph.url){ht.h=2;return}return T.fa=T.h.graph.url,w(ht,ld(T,T.h.graph.url),3)}for(ht.h!=2&&($=ht.i,T.j.loadGraph($)),L=a(Object.keys(T.D)),W=L.next();!W.done;W=L.next())ne=W.value,T.j.overrideFile(ne,T.D[ne]);if(T.D={},T.h.listeners)for(oe=a(T.h.listeners),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,cR(T,Ce);Pe=T.l,T.l={},T.setOptions(Pe),ht.h=0})}n.reset=function(){var T=this;return N(function($){T.j&&(T.j.reset(),T.s={},T.v={}),$.h=0})},n.setOptions=function(T,$){var L=this;if($=$||this.h.options){for(var W=[],ne=[],oe={},ie=a(Object.keys(T)),Ce=ie.next();!Ce.done;oe={X:oe.X,Y:oe.Y},Ce=ie.next())if(Ce=Ce.value,!(Ce in this.l&&this.l[Ce]===T[Ce])){this.l[Ce]=T[Ce];var Pe=$[Ce];Pe!==void 0&&(Pe.onChange&&(oe.X=Pe.onChange,oe.Y=T[Ce],W.push(function(ht){return function(){var Et;return N(function(hn){if(hn.h==1)return w(hn,ht.X(ht.Y),2);Et=hn.i,Et===!0&&(L.u=!0),hn.h=0})}}(oe))),Pe.graphOptionXref&&(Ce=Object.assign({},{calculatorName:"",calculatorIndex:0},Pe.graphOptionXref,{valueNumber:Pe.type===1?T[Ce]:0,valueBoolean:Pe.type===0?T[Ce]:!1,valueString:Pe.type===2?T[Ce]:""}),ne.push(Ce)))}(W.length!==0||ne.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(ne),this.F=(this.F===void 0?[]:this.F).concat(W))}};function oR(T){var $,L,W,ne,oe,ie,Ce;return N(function(Pe){switch(Pe.h){case 1:if(!T.u)return Pe.return();if(!T.F){Pe.h=2;break}$=a(T.F),L=$.next();case 3:if(L.done){Pe.h=5;break}return W=L.value,w(Pe,W(),4);case 4:L=$.next(),Pe.h=3;break;case 5:T.F=void 0;case 2:if(T.H){for(ne=new T.i.GraphOptionChangeRequestList,oe=a(T.H),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,ne.push_back(Ce);T.j.changeOptions(ne),ne.delete(),T.H=void 0}T.u=!1,Pe.h=0}})}n.initialize=function(){var T=this;return N(function($){return $.h==1?w($,Xu(T),2):$.h!=3?w($,Ix(T),3):w($,oR(T),0)})};function ld(T,$){var L,W;return N(function(ne){return $ in T.L?ne.return(T.L[$]):(L=T.locateFile($,""),W=fetch(L).then(function(oe){return oe.arrayBuffer()}),T.L[$]=W,ne.return(W))})}n.overrideFile=function(T,$){this.j?this.j.overrideFile(T,$):this.D[T]=$},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(T,$){var L=this,W,ne,oe,ie,Ce,Pe,ht,Et,hn;return N(function(Ut){switch(Ut.h){case 1:return L.h.inputs?(W=1e3*($??performance.now()),w(Ut,L.I,2)):Ut.return();case 2:return w(Ut,L.initialize(),3);case 3:for(ne=new L.i.PacketDataList,oe=a(Object.keys(T)),ie=oe.next();!ie.done;ie=oe.next())if(Ce=ie.value,Pe=L.h.inputs[Ce]){e:{var Rt=T[Ce];switch(Pe.type){case"video":var an=L.s[Pe.stream];if(an||(an=new y0(L.i,L.K),L.s[Pe.stream]=an),an.m===0&&(an.m=an.i.createTexture()),typeof HTMLVideoElement<"u"&&Rt instanceof HTMLVideoElement)var Bn=Rt.videoWidth,Ur=Rt.videoHeight;else typeof HTMLImageElement<"u"&&Rt instanceof HTMLImageElement?(Bn=Rt.naturalWidth,Ur=Rt.naturalHeight):(Bn=Rt.width,Ur=Rt.height);Ur={glName:an.m,width:Bn,height:Ur},Bn=an.h,Bn.canvas.width=Ur.width,Bn.canvas.height=Ur.height,Bn.activeTexture(Bn.TEXTURE0),an.i.bindTexture2d(an.m),Bn.texImage2D(Bn.TEXTURE_2D,0,Bn.RGBA,Bn.RGBA,Bn.UNSIGNED_BYTE,Rt),an.i.bindTexture2d(0),an=Ur;break e;case"detections":for(an=L.s[Pe.stream],an||(an=new $a(L.i),L.s[Pe.stream]=an),an.data||(an.data=new an.h.DetectionListData),an.data.reset(Rt.length),Ur=0;Ur<Rt.length;++Ur){Bn=Rt[Ur];var Wr=an.data,Fi=Wr.setBoundingBox,Ra=Ur,No=Bn.la,br=new ad;if($s(br,1,No.sa),$s(br,2,No.ta),$s(br,3,No.height),$s(br,4,No.width),$s(br,5,No.rotation),bo(br,6,No.pa),No=br.l(),Fi.call(Wr,Ra,No),Bn.ea)for(Wr=0;Wr<Bn.ea.length;++Wr){br=Bn.ea[Wr],Fi=an.data,Ra=Fi.addNormalizedLandmark,No=Ur,br=Object.assign({},br,{visibility:br.visibility?br.visibility:0});var xs=new Zp;$s(xs,1,br.x),$s(xs,2,br.y),$s(xs,3,br.z),br.visibility&&$s(xs,4,br.visibility),br=xs.l(),Ra.call(Fi,No,br)}if(Bn.ba)for(Wr=0;Wr<Bn.ba.length;++Wr)Fi=an.data,Ra=Fi.addClassification,No=Ur,br=Bn.ba[Wr],xs=new od,$s(xs,2,br.qa),br.index&&bo(xs,1,br.index),br.label&&bo(xs,3,br.label),br.displayName&&bo(xs,4,br.displayName),br=xs.l(),Ra.call(Fi,No,br)}an=an.data;break e;default:an={}}}switch(ht=an,Et=Pe.stream,Pe.type){case"video":ne.pushTexture2d(Object.assign({},ht,{stream:Et,timestamp:W}));break;case"detections":hn=ht,hn.stream=Et,hn.timestamp=W,ne.pushDetectionList(hn);break;default:throw Error("Unknown input config type: '"+Pe.type+"'")}}return L.j.send(ne),w(Ut,L.I,4);case 4:ne.delete(),Ut.h=0}})};function aR(T,$,L){var W,ne,oe,ie,Ce,Pe,ht,Et,hn,Ut,Rt,an,Bn,Ur;return N(function(Wr){switch(Wr.h){case 1:if(!L)return Wr.return($);for(W={},ne=0,oe=a(Object.keys(L)),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,Pe=L[Ce],typeof Pe!="string"&&Pe.type==="texture"&&$[Pe.stream]!==void 0&&++ne;1<ne&&(T.M=!1),ht=a(Object.keys(L)),ie=ht.next();case 2:if(ie.done){Wr.h=4;break}if(Et=ie.value,hn=L[Et],typeof hn=="string")return Bn=W,Ur=Et,w(Wr,lR(T,Et,$[hn]),14);if(Ut=$[hn.stream],hn.type==="detection_list"){if(Ut){for(var Fi=Ut.getRectList(),Ra=Ut.getLandmarksList(),No=Ut.getClassificationsList(),br=[],xs=0;xs<Fi.size();++xs){var Ku=ik(Fi.get(xs)),uR=Vs(Ku,1),Mx=Vs(Ku,2),ck=Vs(Ku,3),Yu=Vs(Ku,4),v0=Vs(Ku,5,0),w0=void 0;w0=w0===void 0?0:w0,Ku={la:{sa:uR,ta:Mx,height:ck,width:Yu,rotation:v0,pa:Qi(Ns(Ku,6),w0)},ea:g0(Ra.get(xs)),ba:ok(rk(No.get(xs)))},br.push(Ku)}Fi=br}else Fi=[];W[Et]=Fi,Wr.h=7;break}if(hn.type==="proto_list"){if(Ut){for(Fi=Array(Ut.size()),Ra=0;Ra<Ut.size();Ra++)Fi[Ra]=Ut.get(Ra);Ut.delete()}else Fi=[];W[Et]=Fi,Wr.h=7;break}if(Ut===void 0){Wr.h=3;break}if(hn.type==="float_list"){W[Et]=Ut,Wr.h=7;break}if(hn.type==="proto"){W[Et]=Ut,Wr.h=7;break}if(hn.type!=="texture")throw Error("Unknown output config type: '"+hn.type+"'");return Rt=T.v[Et],Rt||(Rt=new y0(T.i,T.K),T.v[Et]=Rt),w(Wr,Mo(Rt,Ut,T.M),13);case 13:an=Wr.i,W[Et]=an;case 7:hn.transform&&W[Et]&&(W[Et]=hn.transform(W[Et])),Wr.h=3;break;case 14:Bn[Ur]=Wr.i;case 3:ie=ht.next(),Wr.h=2;break;case 4:return Wr.return(W)}})}function lR(T,$,L){var W;return N(function(ne){return typeof L=="number"||L instanceof Uint8Array||L instanceof T.i.Uint8BlobList?ne.return(L):L instanceof T.i.Texture2dDataOut?(W=T.v[$],W||(W=new y0(T.i,T.K),T.v[$]=W),ne.return(Mo(W,L,T.M))):ne.return(void 0)})}function cR(T,$){for(var L=$.name||"$",W=[].concat(l($.wants)),ne=new T.i.StringList,oe=a($.wants),ie=oe.next();!ie.done;ie=oe.next())ne.push_back(ie.value);oe=T.i.PacketListener.implement({onResults:function(Ce){for(var Pe={},ht=0;ht<$.wants.length;++ht)Pe[W[ht]]=Ce.get(ht);var Et=T.listeners[L];Et&&(T.I=aR(T,Pe,$.outs).then(function(hn){hn=Et(hn);for(var Ut=0;Ut<$.wants.length;++Ut){var Rt=Pe[W[Ut]];typeof Rt=="object"&&Rt.hasOwnProperty&&Rt.hasOwnProperty("delete")&&Rt.delete()}hn&&(T.I=hn)}))}}),T.j.attachMultiListener(ne,oe),ne.delete()}n.onResults=function(T,$){this.listeners[$||"$"]=T},z("Solution",Vr),z("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Ax(T){switch(T===void 0&&(T=0),T){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Jp(T){var $=this;T=T||{},this.h=new Vr({locateFile:T.locateFile,files:function(L){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Ax(L.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:g0},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:g0},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(L){var W,ne,oe;return N(function(ie){return ie.h==1?(W=Ax(L),ne="third_party/mediapipe/modules/pose_landmark/"+W,w(ie,ld($.h,W),2)):(oe=ie.i,$.h.overrideFile(ne,oe),ie.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Jp.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(T){this.h.onResults(T)},n.initialize=function(){var T=this;return N(function($){return w($,T.h.initialize(),0)})},n.send=function(T,$){var L=this;return N(function(W){return w(W,L.h.send(T,$),0)})},n.setOptions=function(T){this.h.setOptions(T)},z("Pose",Jp),z("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),z("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),z("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),z("VERSION","0.5.1675469404")}).call(pt);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var koe=function(n,e){return(koe=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])})(n,e)};function Toe(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}koe(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var qr=function(){return(qr=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function or(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function ar(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function qm(n,e,t){if(t||arguments.length===2)for(var r,s=0,i=e.length;s<i;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return n.concat(r||Array.prototype.slice.call(e))}var Th=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],aS=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],vft={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},wft={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},xft=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],_ft=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function EA(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function Eoe(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof jn?[4,lC(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=EA(n.width),e.height=EA(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function Ioe(n){return or(this,void 0,void 0,function(){var e,t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:return n instanceof jn?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,lC(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return i=document.createElement("canvas"),o=i.getContext("2d"),i.width=EA(n.width),i.height=EA(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,i.width,i.height)]}})})}function Sft(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,Eoe(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,cC(e,4)]}})})}function Aoe(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var s1={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Cft=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Ioe(this.mask)]})})},n.prototype.toTensor=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Sft(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function kft(n){return Aoe(n),"person"}var Tft=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new bft.Pose({locateFile:function(s,i){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(s)}return"".concat(i,"/").concat(s)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var i=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(i.segmentation={maskValueToLabel:kft,mask:new Cft(s.segmentationMask)}),r.poses=[i]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(i,o){return{x:i.x*r.width,y:i.y*r.height,z:i.z,score:i.visibility,name:aS[o]}})};return t!=null&&(s.keypoints3D=t.map(function(i,o){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:aS[o]}})),s},n.prototype.estimatePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i;return ar(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof jn?(i=ImageData.bind,[4,lC(e)]):[3,2];case 1:return s=new(i.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,o.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function Eft(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return qr({},s1);var i=qr({},s);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=s1.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=s1.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=s1.smoothSegmentation),i.modelType==null&&(i.modelType=s1.modelType),i}(n),[4,(t=new Tft(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function pv(n){return n instanceof jn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function Moe(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function nV(n){return n instanceof jn?n:cC(n)}function Noe(n,e,t){return CF(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function CF(n,e){U(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),U(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function sP(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,i=n.locationData,o=i.relativeKeypoints[r].x*e.width,a=i.relativeKeypoints[r].y*e.height,l=i.relativeKeypoints[s].x*e.width,c=i.relativeKeypoints[s].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(f,d,p){var m,g=f.locationData,y=p.rotationVectorStartKeypointIndex,b=p.rotationVectorEndKeypointIndex;m=p.rotationVectorTargetAngle?p.rotationVectorTargetAngle:Math.PI*p.rotationVectorTargetAngleDegree/180;var x=g.relativeKeypoints[y].x*d.width,w=g.relativeKeypoints[y].y*d.height,S=g.relativeKeypoints[b].x*d.width,C=g.relativeKeypoints[b].y*d.height;return Moe(m-Math.atan2(-(C-w),S-x))}(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function $oe(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function iP(n,e,t,r,s,i,o){return n[e][s]*(n[t][i]*n[r][o]-n[t][o]*n[r][i])}function Po(n,e,t){var r=(e+1)%4,s=(e+2)%4,i=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return iP(n,r,s,i,o,a,l)+iP(n,s,i,r,o,a,l)+iP(n,i,r,s,o,a,l)}function Uj(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,i=n;s<i.length;s++){var o=i[s],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var f=o.z*e.width,d=qr({},o);d.x=u,d.y=h,d.z=f,r.push(d)}return r}function Roe(n,e){var t=function(r,s,i,o){var a=s-r,l=o-i;if(a===0)throw new Error("Original min and max are both ".concat(r,", range cannot be 0."));var c=l/a;return{scale:c,offset:i-r*c}}(0,255,e[0],e[1]);return Se(function(){return qe(fe(n,t.scale),t.offset)})}function kF(n,e,t){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y=e.outputTensorSize,b=e.keepAspectRatio,x=e.borderMode,w=e.outputTensorFloatRange,S=pv(n),C=function(M,E){return E?{xCenter:E.xCenter*M.width,yCenter:E.yCenter*M.height,width:E.width*M.width,height:E.height*M.height,rotation:E.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(S,t),k=function(M,E,N){if(N===void 0&&(N=!1),!N)return{top:0,left:0,right:0,bottom:0};var O=E.height,R=E.width;CF(E,"targetSize"),CF(M,"roi");var D,z,B=O/R,X=M.height/M.width,G=0,te=0;return B>X?(D=M.width,z=M.width*B,te=(1-X/B)/2):(D=M.height/B,z=M.height,G=(1-B/X)/2),M.width=D,M.height=z,{top:te,left:G,right:G,bottom:te}}(C,y,b),A=(r=C,s=S.width,i=S.height,o=!1,a=r.width,l=r.height,c=o?-1:1,u=Math.cos(r.rotation),h=Math.sin(r.rotation),f=r.xCenter,d=r.yCenter,p=1/s,m=1/i,(g=new Array(16))[0]=a*u*c*p,g[1]=-l*h*p,g[2]=0,g[3]=(-.5*a*u*c+.5*l*h+f)*p,g[4]=a*h*c*m,g[5]=l*u*m,g[6]=0,g[7]=(-.5*l*u-.5*a*h*c+d)*m,g[8]=0,g[9]=0,g[10]=a*p,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,$oe(g));return{imageTensor:Se(function(){var M=nV(n),E=Xa(Noe(A,S,y),[1,8]),N=x==="zero"?"constant":"nearest",O=Ci.transform(oi(wt(M,"float32")),E,"bilinear",N,0,[y.height,y.width]);return w!=null?Roe(O,w):O}),padding:k,transformationMatrix:A}}function Wj(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function Ift(n){return Se(function(){var e=function(s){return Se(function(){return[dn(s,[0,0,0],[1,-1,1]),dn(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:vr(r),logits:vr(t)}})}function Poe(n){return n!=null&&n.currentTime!=null}function Gj(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),i=Math.max(i,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:i,width:r-t,height:i-s},e}function Aft(n,e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l;return ar(this,function(c){switch(c.label){case 0:return n.sort(function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)}),s=Xa(n.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),i=Ks(n.map(function(u){return u.score[0]})),[4,Ci.nonMaxSuppressionAsync(s,i,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter(function(u,h){return a.indexOf(h)>-1}),nn([s,i,o]),[2,l]}})})}function Doe(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function Mft(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E;return ar(this,function(N){switch(N.label){case 0:if(r=vr(e,[0]),s=r.shape,i=s[0],o=s[1],a=s[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=N.sent(),u=0;u<n.length;u++)if(h=n[u],f=qr({},h),l.push(f),d=Math.trunc(f.x*o),p=Math.trunc(f.y*i),!(d<0||d>=o||p<0||d>=i)){for(m=Math.trunc((t.kernelSize-1)/2),g=Math.max(0,d-m),y=Math.min(o,d+m+1),b=Math.max(0,p-m),x=Math.min(i,p+m+1),w=0,S=0,C=0,k=0,A=b;A<x;++A)for(M=g;M<y;++M)E=c.get(A,M,u),w+=E,k=Math.max(k,E),S+=M*E,C+=A*E;k>=t.minConfidenceToRefine&&w>0&&(f.x=S/o/w,f.y=C/i/w)}return r.dispose(),[2,l]}})})}function Hj(n,e){var t=e.left,r=e.top,s=e.left+e.right,i=e.top+e.bottom;return n.map(function(o){return qr(qr({},o),{x:(o.x-t)/(1-s),y:(o.y-r)/(1-i),z:o.z/(1-s)})})}function Nft(n,e,t){return C_()==="webgl"?function(r,s,i){var o=i.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=cg();return Se(function(){var c=l.compileAndRun(a,[r,s]);return xo().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):Se(function(){var r=Dt(e,.5),s=Or(r),i=Dt(1,hp(1,fe(s,qe(5.68842,fe(s,qe(-.748699,fe(s,qe(-57.8051,fe(s,qe(291.309,fe(s,-624.717)))))))))));return qe(e,fe(Dt(n,e),fe(i,t.combineWithPreviousRatio)))})}function $ft(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a;return ar(this,function(l){switch(l.label){case 0:return r=n[0],s=n[1],i=function(c,u,h){return Se(function(){var f,d,p,m;h.reverseOutputOrder?(d=vr(dn(c,[0,h.boxCoordOffset+0],[-1,1])),f=vr(dn(c,[0,h.boxCoordOffset+1],[-1,1])),m=vr(dn(c,[0,h.boxCoordOffset+2],[-1,1])),p=vr(dn(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=vr(dn(c,[0,h.boxCoordOffset+0],[-1,1])),d=vr(dn(c,[0,h.boxCoordOffset+1],[-1,1])),p=vr(dn(c,[0,h.boxCoordOffset+2],[-1,1])),m=vr(dn(c,[0,h.boxCoordOffset+3],[-1,1]))),d=qe(fe(Lt(d,h.xScale),u.w),u.x),f=qe(fe(Lt(f,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(p=fe(Yo(Lt(p,h.hScale)),u.h),m=fe(Yo(Lt(m,h.wScale)),u.w)):(p=fe(Lt(p,h.hScale),u.h),m=fe(Lt(m,h.wScale),u.h));var g=Dt(f,Lt(p,2)),y=Dt(d,Lt(m,2)),b=qe(f,Lt(p,2)),x=qe(d,Lt(m,2)),w=cs([ve(g,[h.numBoxes,1]),ve(y,[h.numBoxes,1]),ve(b,[h.numBoxes,1]),ve(x,[h.numBoxes,1])],1);if(h.numKeypoints)for(var S=0;S<h.numKeypoints;++S){var C=h.keypointCoordOffset+S*h.numValuesPerKeypoint,k=void 0,A=void 0;h.reverseOutputOrder?(k=vr(dn(c,[0,C],[-1,1])),A=vr(dn(c,[0,C+1],[-1,1]))):(A=vr(dn(c,[0,C],[-1,1])),k=vr(dn(c,[0,C+1],[-1,1])));var M=qe(fe(Lt(k,h.xScale),u.w),u.x),E=qe(fe(Lt(A,h.yScale),u.h),u.y);w=cs([w,ve(M,[h.numBoxes,1]),ve(E,[h.numBoxes,1])],1)}return w})}(s,e,t),o=Se(function(){var c=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=xa(r,-t.scoreClippingThresh,t.scoreClippingThresh)),c=El(c)):c}),[4,Rft(i,o,t)];case 1:return a=l.sent(),nn([i,o]),[2,a]}})})}function Rft(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p;return ar(this,function(m){switch(m.label){case 0:return r=[],[4,n.data()];case 1:return s=m.sent(),[4,e.data()];case 2:for(i=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&i[o]<t.minScoreThresh||(a=o*t.numCoords,l=Pft(s[a+0],s[a+1],s[a+2],s[a+3],i[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,f=0;f<h;f+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+f,p={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},u.relativeKeypoints.push(p);r.push(l)}return[2,r]}})})}function Pft(n,e,t,r,s,i,o){return{score:[s],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:n,xMax:r,yMax:i?1-n:t,width:r-e,height:t-n}}}}function Dft(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function jj(n,e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h;return ar(this,function(f){switch(f.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,i=s/e.numLandmarks,[4,n.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*i,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],i>1&&(h.y=r?e.inputImageHeight-o[c+1]:o[c+1]),i>2&&(h.z=o[c+2]),i>3&&(h.score=Dft(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function qj(n,e,t){var r=n.width,s=n.height,i=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(i=function(u,h){return h.rotation!=null?u+=h.rotation:h.rotationDegree!=null&&(u+=Math.PI*h.rotationDegree/180),Moe(u)}(i,t)),i===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var o=(e.width*r*t.shiftX*Math.cos(i)-e.height*s*t.shiftY*Math.sin(i))/e.width,a=(e.width*r*t.shiftX*Math.sin(i)+e.height*s*t.shiftY*Math.cos(i))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}if(t.squareLong){var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}else if(t.squareShort){var c=Math.min(r*e.width,s*e.height);r=c/e.width,s=c/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function Oft(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var Wd=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),oP=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Wd(this.getAlpha(this.minCutOff)),this.dx=new Wd(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,o=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),TF=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return qm([],e,!0);i=1/r}return e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new oP(t.config)}),this.yFilters=e.map(function(r){return new oP(t.config)}),this.zFilters=e.map(function(r){return new oP(t.config)}))},n}(),aP=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Wd(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(this.lastTimestamp===-1)s=1;else{for(var o=e*r-this.lastValue*this.lastValueScale,a=i-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,f=this.window;h<f.length;h++){var d=f[h];if(c+d.duration>u)break;l+=d.distance,c+=d.duration}var p=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,s)},n}(),Fft=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return qm([],e,!0);i=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new aP(t.config)}),this.yFilters=e.map(function(r){return new aP(t.config)}),this.zFilters=e.map(function(r){return new aP(t.config)}))},n}(),lP=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new Fft(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new TF(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,i){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var o=i!=null?function(c,u){return(c.width*u.width+c.height*u.height)/2}(i,r):1,a=s?Doe(e,r):e,l=this.keypointsFilter.apply(a,t,o);return s?Oft(l,r):l},n}(),Xj=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Wd(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var i=e[s],o=qr({},i);o.score=this.visibilityFilters[s].apply(i.score),r.push(o)}return r},n}(),Lft={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},H0={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},zft={maxPoses:1,flipHorizontal:!1},Bft={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Vft=.3,Kj={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Uft={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Wft={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Gft={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Hft={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},jft={kernelSize:7,minConfidenceToRefine:.5},Yj={alpha:.1},qft={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Xft={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},Kft={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Yft={activation:"none"},Zft={combineWithPreviousRatio:.7},Jft=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Eoe(this.mask)]})})},n.prototype.toImageData=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Ioe(this.mask)]})})},n.prototype.toTensor=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function Qft(n){return Aoe(n),"person"}var edt=function(){function n(e,t,r,s,i,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=i,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var f=[],d=0;d<h.numLayers;){for(var p=[],m=[],g=[],y=[],b=d;b<h.strides.length&&h.strides[b]===h.strides[d];){var x=Wj(h.minScale,h.maxScale,b,h.strides.length);if(b===0&&h.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(x),y.push(x);else{for(var w=0;w<h.aspectRatios.length;++w)g.push(h.aspectRatios[w]),y.push(x);if(h.interpolatedScaleAspectRatio>0){var S=b===h.strides.length-1?1:Wj(h.minScale,h.maxScale,b+1,h.strides.length);y.push(Math.sqrt(x*S)),g.push(h.interpolatedScaleAspectRatio)}}b++}for(var C=0;C<g.length;++C){var k=Math.sqrt(g[C]);p.push(y[C]/k),m.push(y[C]*k)}var A=0,M=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[d],M=h.featureMapWidth[d];else{var E=h.strides[d];A=Math.ceil(h.inputSizeHeight/E),M=Math.ceil(h.inputSizeWidth/E)}for(var N=0;N<A;++N)for(var O=0;O<M;++O)for(var R=0;R<p.length;++R){var D={xCenter:(O+h.anchorOffsetX)/M,yCenter:(N+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(D.width=1,D.height=1):(D.width=m[R],D.height=p[R]),f.push(D)}d=b}return f}(Lft);var a=Ks(this.anchors.map(function(h){return h.width})),l=Ks(this.anchors.map(function(h){return h.height})),c=Ks(this.anchors.map(function(h){return h.xCenter})),u=Ks(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?Xa([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E;return ar(this,function(N){switch(N.label){case 0:return s=function(O){var R;if((R=O==null?zft:qr({},O)).maxPoses==null&&(R.maxPoses=1),R.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(R.maxPoses,". Should be > 0."));if(R.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return R}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:Poe(e)?1e6*e.currentTime:null,i=pv(e),o=Se(function(){return wt(nV(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=N.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,i),N.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=N.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,g=this.poseLandmarkFiltering(h,f,p,i),y=g.actualLandmarksFiltered,b=g.auxiliaryLandmarksFiltered,x=g.actualWorldLandmarksFiltered,w=this.poseLandmarksToRoi(b,i),this.regionOfInterest=w,S=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(C=y!=null?Doe(y,i):null)!=null&&C.forEach(function(O,R){O.name=aS[R]}),(k=x)!=null&&k.forEach(function(O,R){O.name=aS[R]}),A={score:d,keypoints:C,keypoints3D:k},S!==null&&(M=Se(function(){var O=oi(S,2),R=wu(O,[[0,0],[0,0],[0,1]]);return yz(R,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||nn(S),E={maskValueToLabel:Qft,mask:new Jft(M)},A.segmentation=E),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Nft(t,e,Zft),nn(e)),nn(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),nn([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(nn(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Xa([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h;return ar(this,function(f){switch(f.label){case 0:return t=kF(e,Uft),r=t.imageTensor,s=t.padding,i=this.detectorModel.predict(r),o=Ift(i),a=o.boxes,[4,$ft([l=o.logits,a],this.anchorTensor,Bft)];case 1:return(c=f.sent()).length===0?(nn([r,i,l,a]),[2,c]):[4,Aft(c,this.maxPoses,Vft)];case 2:return u=f.sent(),h=function(d,p){d===void 0&&(d=[]);for(var m=p.left,g=p.top,y=p.left+p.right,b=p.top+p.bottom,x=0;x<d.length;x++){var w=d[x],S=w.locationData.relativeBoundingBox,C=(S.xMin-m)/(1-y),k=(S.yMin-g)/(1-b),A=S.width/(1-y),M=S.height/(1-b);S.xMin=C,S.yMin=k,S.width=A,S.height=M,S.xMax=C+A,S.yMax=k+M;var E=w.locationData.relativeKeypoints;E&&E.forEach(function(N){var O=(N.x-m)/(1-y),R=(N.y-g)/(1-b);N.x=O,N.y=R})}return d}(u,s),nn([r,i,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return qj(sP(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Kj)},n.prototype.poseLandmarksByRoi=function(e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g;return ar(this,function(y){switch(y.label){case 0:if(r=pv(t),s=kF(t,Wft,e),i=s.imageTensor,o=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(i,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=y.sent())==null?(nn(c),nn(i),[2,null]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,o,a,h,f,p,m)]);case 2:return g=y.sent(),nn(c),nn(i),[2,qr({poseScore:d},g)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,i,o,a,l){return or(this,void 0,void 0,function(){var c,u,h,f,d,p;return ar(this,function(m){return c=Hj(i,r),u=Hj(o,r),h=Uj(c,t),f=Uj(u,t),d=function(g,y){for(var b=[],x=0,w=g;x<w.length;x++){var S=w[x],C=S.x,k=S.y,A=y.rotation,M=Math.cos(A)*C-Math.sin(A)*k,E=Math.sin(A)*C+Math.cos(A)*k,N=qr({},S);N.x=M,N.y=E,b.push(N)}return b}(a,t),p=null,this.enableSegmentation&&(p=Se(function(){var g=l.shape,y=g[0],b=g[1],x=function(C){var k=$oe(new Array(16).fill(0));k[0][0]=Po(C,0,0),k[1][0]=-Po(C,0,1),k[2][0]=Po(C,0,2),k[3][0]=-Po(C,0,3),k[0][2]=Po(C,2,0),k[1][2]=-Po(C,2,1),k[2][2]=Po(C,2,2),k[3][2]=-Po(C,2,3),k[0][1]=-Po(C,1,0),k[1][1]=Po(C,1,1),k[2][1]=-Po(C,1,2),k[3][1]=Po(C,1,3),k[0][3]=-Po(C,3,0),k[1][3]=Po(C,3,1),k[2][3]=-Po(C,3,2),k[3][3]=Po(C,3,3);for(var A=C[0][0]*k[0][0]+C[1][0]*k[0][1]+C[2][0]*k[0][2]+C[3][0]*k[0][3],M=0;M<k.length;M++)for(var E=0;E<k.length;E++)k[M][E]/=A;return k}(s),w=Xa(Noe(x,{width:b,height:y},e),[1,8]),S=[1,y,b,1];return vr(Ci.transform(ve(l,S),w,"bilinear","constant",0,[e.height,e.width]),[0,3])}),nn(l)),[2,{landmarks:h,auxiliaryLandmarks:f,worldLandmarks:d,segmentationMask:p}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h,f,d,p;return ar(this,function(m){switch(m.label){case 0:return t=e[0],r=e[1],s=e[2],i=e[3],o=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,jj(t,Gft)];case 2:return[4,Mft(m.sent(),s,jft)];case 3:return l=m.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,jj(i,Hft)];case 4:return h=m.sent(),f=h.slice(0,33),d=function(g,y,b){b===void 0&&(b=!0);for(var x=[],w=0;w<g.length;w++){var S=qr({},y[w]);b&&(S.score=g[w].score),x.push(S)}return x}(c,f,!0),p=this.enableSegmentation?function(g,y,b){return Se(function(){var x=vr(g,[0]),w=x.shape[2];if(w===1){var S=x;switch(y.activation){case"none":break;case"sigmoid":S=El(S);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(y.activation,")"))}var C=b?Ci.resizeBilinear(S,[b.height,b.width]):S;return vr(C,[2])}throw new Error("Unsupported number of tensor channels ".concat(w))})}(o,Yft):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:d,segmentationMask:p}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return qj(sP(Gj(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Kj)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var i,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=sP(Gj(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Xj(Yj)),i=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Xj(Yj)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new lP(qft)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new lP(Xft)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new lP(Kft)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else i=e,o=t,a=r;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n}();function tdt(n){return or(this,void 0,void 0,function(){var e,t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:return e=function(l){var c=qr({},l??H0);if(c.enableSmoothing==null&&(c.enableSmoothing=H0.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=H0.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=H0.smoothSegmentation),c.modelType==null&&(c.modelType=H0.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=H0.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Rl(e.detectorModelUrl,{fromTFHub:t}),Rl(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),i=s[0],o=s[1],[2,new edt(i,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var ng,io,Ooe=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var i=s[r];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),i=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(s.length!==0){for(var c=-1,u=-1,h=0,f=s;h<f.length;h++){var d=f[h],p=t[l][d];p>=this.minSimilarity&&p>u&&(c=d,u=p)}if(c>=0){var m=this.tracks[c];m=Object.assign(m,this.createTrack(e[l],r,m.id)),e[l].id=m.id;var g=s.indexOf(c);s.splice(g,1)}else i.push(l)}else i.push(l)}for(var y=0,b=i;y<b.length;y++){l=b[y];var x=this.createTrack(e[l],r);this.tracks.push(x),e[l].id=x.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:qm([],e.keypoints,!0).map(function(i){return qr({},i)})};return e.box!==void 0&&(s.box=qr({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),ndt=function(n){function e(t){return n.call(this,t)||this}return Toe(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(i){return r.iou(s,i)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),i=Math.max(t.box.yMin,r.box.yMin),o=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(s>=o||i>=a)return 0;var l=(o-s)*(a-i);return l/(t.box.width*t.box.height+r.box.width*r.box.height-l)},e}(Ooe),rdt=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return Toe(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,i=t;s<i.length;s++){for(var o=i[s],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,i=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];i+=Math.exp(-1*u/(2*s*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:i/o},e.prototype.area=function(t){var r=this,s=t.filter(function(l){return l.score>r.keypointThreshold}),i=Math.min.apply(Math,qm([1],s.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,qm([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,qm([1],s.map(function(l){return l.y}),!1));return(o-i)*(Math.max.apply(Math,qm([0],s.map(function(l){return l.y}),!1))-a)},e}(Ooe);function Foe(n){switch(n){case io.BlazePose:return aS.reduce(function(e,t,r){return e[t]=r,e},{});case io.PoseNet:case io.MoveNet:return Th.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(ng||(ng={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(io||(io={}));var Zj=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case io.BlazePose:return vft;case io.PoseNet:case io.MoveNet:return wft;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case io.BlazePose:return _ft;case io.PoseNet:case io.MoveNet:return xft;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:Foe}),Jj=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],Loe={modelType:"SinglePose.Lightning",enableSmoothing:!0},Qj={},e8={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},cP={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},t8={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function sdt(n,e,t,r){for(var s={},i=0,o=Th;i<o.length;i++){var a=o[i];s[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function(b,x){return(b[x.left_hip].score>.2||b[x.right_hip].score>.2)&&(b[x.left_shoulder].score>.2||b[x.right_shoulder].score>.2)}(e,t)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,u=function(b,x,w,S,C){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,M=0,E=0;E<k.length;E++)(z=Math.abs(S-w[k[E]][0]))>A&&(A=z),(B=Math.abs(C-w[k[E]][1]))>M&&(M=B);for(var N=0,O=0,R=0,D=Object.keys(w);R<D.length;R++){var z,B,X=D[R];b[x[X]].score<.2||((z=Math.abs(S-w[X][0]))>N&&(N=z),(B=Math.abs(C-w[X][1]))>O&&(O=B))}return[A,M,N,O]}(e,t,s,l,c),h=u[0],f=u[1],d=u[2],p=u[3],m=Math.max(1.9*f,1.9*h,1.2*d,1.2*p),g=[l-(m=Math.min(m,Math.max(c,r.width-c,l,r.height-l))),c-m];if(m>Math.max(r.width,r.height)/2)return EF(n==null,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return EF(n==null,r)}function EF(n,e){var t,r,s,i;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:i,yMax:s+t,xMax:i+r,height:t,width:r}}function idt(n){var e,t=n==null?Loe:qr({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Jj.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(Jj));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=ng.BoundingBox),t.trackerType===ng.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=n8(cP,r);return s.keypointTrackerParams=qr({},cP.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=cP;else{if(t.trackerType!==ng.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,n8(t8,e)):t.trackerConfig=t8}return t}function n8(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var odt=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Foe(io.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new TF(e8),this.cropRegionFilterYMin=new Wd(.9),this.cropRegionFilterXMin=new Wd(.9),this.cropRegionFilterYMax=new Wd(.9),this.cropRegionFilterXMax=new Wd(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===ng.Keypoint?this.tracker=new rdt(t.trackerConfig):t.trackerType===ng.BoundingBox&&(this.tracker=new ndt(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return C_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},i=0,o=0;o<17;++o)s.keypoints[o]={y:r[3*o],x:r[3*o+1],score:r[3*o+2]},s.keypoints[o].score>.2&&(++i,s.score+=s.keypoints[o].score);return i>0&&(s.score/=i),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c;return ar(this,function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return C_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=u.sent(),u.label=3;case 3:for(t.dispose(),s=[],i=r.length/56,o=0;o<i;++o)for(s[o]={keypoints:[]},a=56*o+51,s[o].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*o+55,s[o].score=r[l],s[o].keypoints=[],c=0;c<17;++c)s[o].keypoints[c]={y:r[56*o+3*c],x:r[56*o+3*c+1],score:r[56*o+3*c+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Qj),or(this,void 0,void 0,function(){var s,i,o,a,l,c;return ar(this,function(u){switch(u.label){case 0:return t=function(h){return h==null?Qj:qr({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?Poe(e)&&(r=1e6*e.currentTime):r*=1e3,s=nV(e),i=pv(s),o=oi(s,0),e instanceof jn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,i,r)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,i,r)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Th[c],a[l].keypoints[c].y*=i.height,a[l].keypoints[c].x*=i.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l=this;return ar(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=EF(this.cropRegion==null,t)),s=Se(function(){var u=Xa([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=ms([1],"int32"),f=[l.modelInputResolution.height,l.modelInputResolution.width];return wt(Ci.cropAndResize(e,u,h,f,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(i=c.sent(),s.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<i.keypoints.length;++o)i.keypoints[o].y=this.cropRegion.yMin+i.keypoints[o].y*this.cropRegion.height,i.keypoints[o].x=this.cropRegion.xMin+i.keypoints[o].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,r,1)),a=sdt(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[i]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m=this;return ar(this,function(g){switch(g.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=Ci.resizeBilinear(e,[o,i]),l=i,c=32*Math.ceil(o/32),a=wu(s,[[0,0],[0,c-o],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,s=Ci.resizeBilinear(e,[o,i]),l=32*Math.ceil(i/32),c=o,a=wu(s,[[0,0],[0,0],[0,l-i],[0,0]])),s.dispose(),e.dispose(),u=wt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=g.sent(),u.dispose(),h=h.filter(function(y){return y.score>=m.minPoseScore}),d=0;d<h.length;++d)for(f=0;f<h[d].keypoints.length;++f)h[d].keypoints[f].y*=c/o,h[d].keypoints[f].x*=l/i;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new TF(e8)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,b){p.has(b)||m.keypointFilterMap.delete(b)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:i,height:s-t,width:i-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function adt(n){return n===void 0&&(n=Loe),or(this,void 0,void 0,function(){var e,t,r,s;return ar(this,function(i){switch(i.label){case 0:return e=idt(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Rl(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=i.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Rl(s,{fromTFHub:r})];case 3:t=i.sent(),i.label=4;case 4:return C_()==="webgl"&&Ee().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new odt(t,e)]}})})}var r8={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},s8=["MobileNetV1","ResNet50"],i8={MobileNetV1:[8,16],ResNet50:[16]},ldt=[8,16,32],o8={MobileNetV1:[.5,.75,1],ResNet50:[1]},a8=[1,2,4],l8={maxPoses:1,flipHorizontal:!1},cdt={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},udt=[-123.15,-115.9,-103.06];function uP(n){return Math.floor(n/2)}var hdt=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(uP(e),e);)this.exchange(e,uP(e)),e=uP(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function fdt(n,e,t,r,s,i){for(var o=i.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-s,0),h=Math.min(t+s+1,a),f=u;f<h;++f){for(var d=Math.max(r-s,0),p=Math.min(r+s+1,l),m=d;m<p;++m)if(i.get(f,m,n)>e){c=!1;break}if(!c)break}return c}function ddt(n){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function zoe(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function Boe(n,e,t){var r=zoe(n.heatmapY,n.heatmapX,n.id,t),s=r.y,i=r.x;return{x:n.heatmapX*e+i,y:n.heatmapY*e+s}}function Voe(n,e,t,r){var s=t.x,i=t.y;return n.some(function(o){var a,l,c,u,h,f,d=o.keypoints;return a=i,l=s,c=d[r].y,u=d[r].x,(h=c-a)*h+(f=u-l)*f<=e})}var c8=Th.reduce(function(n,e,t){return n[e]=t,n},{}),Uoe=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[c8[e],c8[t]]}),hP=Uoe.map(function(n){return n[1]}),u8=Uoe.map(function(n){return n[0]});function h8(n,e,t){return n<e?e:n>t?t:n}function fP(n,e,t,r){return{y:h8(Math.round(n.y/e),0,t-1),x:h8(Math.round(n.x/e),0,r-1)}}function f8(n,e){return{x:n.x+e.x,y:n.y+e.y}}function d8(n,e,t,r,s,i,o,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},f=f8(h,function(b,x,w){var S=w.shape[2]/2;return{y:w.get(x.y,x.x,b),x:w.get(x.y,x.x,S+b)}}(n,fP(h,i,c,u),o)),d=0;d<a;d++){var p=fP(f,i,c,u),m=zoe(p.y,p.x,t,s);f=f8({x:p.x*i,y:p.y*i},{x:m.x,y:m.y})}var g=fP(f,i,c,u),y=r.get(g.y,g.x,t);return{y:f.y,x:f.x,name:Th[t],score:y}}function pdt(n,e,t,r,s,i){var o=e.shape[2],a=hP.length,l=new Array(o),c=n.part,u=n.score,h=Boe(c,r,t);l[c.id]={score:u,name:Th[c.id],y:h.y,x:h.x};for(var f=a-1;f>=0;--f){var d=hP[f],p=u8[f];l[d]&&!l[p]&&(l[p]=d8(f,l[d],p,e,t,r,i))}for(f=0;f<a;++f)d=u8[f],p=hP[f],l[d]&&!l[p]&&(l[p]=d8(f,l[d],p,e,t,r,s));return l}function mdt(n,e,t){return t.reduce(function(r,s,i){var o=s.y,a=s.x,l=s.score;return Voe(n,e,{y:o,x:a},i)||(r+=l),r},0)/t.length}function gdt(n,e,t,r,s,i,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),or(this,void 0,void 0,function(){var l,c,u,h,f,d,p,m,g,y,b,x;return ar(this,function(w){switch(w.label){case 0:return[4,ddt([n,e,t,r])];case 1:for(l=w.sent(),c=l[0],u=l[1],h=l[2],f=l[3],d=[],p=function(S,C,k){for(var A=k.shape,M=A[0],E=A[1],N=A[2],O=new hdt(M*E*N,function(X){return X.score}),R=0;R<M;++R)for(var D=0;D<E;++D)for(var z=0;z<N;++z){var B=k.get(R,D,z);B<S||fdt(z,B,R,D,C,k)&&O.enqueue({score:B,part:{heatmapY:R,heatmapX:D,id:z}})}return O}(o,1,c),m=a*a;d.length<i&&!p.empty();)g=p.dequeue(),y=Boe(g.part,s,u),Voe(d,m,y,g.part.id)||(b=pdt(g,c,u,s,h,f),x=mdt(d,m,b),d.push({keypoints:b,score:x}));return[2,d]}})})}function Woe(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var ydt=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(Woe("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function bdt(n,e){if(cg()instanceof Gw)return function(t,r){var s=cg(),i=new ydt(r.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return xo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var vdt=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Ot(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(Woe("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function wdt(n,e){if(cg()instanceof Gw)return function(t,r){var s=cg(),i=new vdt(t.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return xo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function Goe(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return Se(function(){var i,o,a=ve(n,[t*r,s]),l=ug(a,0),c=oi(Lt(l,en(r,"int32")),1),u=oi((i=l,o=r,Se(function(){var h=Lt(i,en(o,"int32"));return Dt(i,fe(h,en(o,"int32")))})),1);return cs([c,u],1)})}function xdt(n,e,t){return Se(function(){var r=function(s,i){for(var o=[],a=0;a<Th.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),u=_dt(l,c,a,i),h=u.x,f=u.y;o.push(f),o.push(h)}return Xa(o,[Th.length,2])}(n,t);return qe(wt(fe(n.toTensor(),en(e,"int32")),"float32"),r)})}function _dt(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+Th.length)}}function Sdt(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f;return ar(this,function(d){switch(d.label){case 0:return r=0,s=Goe(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return i=d.sent(),o=i[0],a=i[1],l=i[2],[4,(c=xdt(l,t,a)).buffer()];case 2:return u=d.sent(),h=Array.from(function(p,m){for(var g=m.shape[0],y=new Float32Array(g),b=0;b<g;b++){var x=m.get(b,0),w=m.get(b,1);y[b]=p.get(x,w,b)}return y}(o,l)),f=h.map(function(p,m){return r+=p,{y:u.get(m,0),x:u.get(m,1),score:p,name:Th[m]}}),s.dispose(),c.dispose(),[2,{keypoints:f,score:r/f.length}]}})})}function Cdt(n,e,t){return or(this,void 0,void 0,function(){var r,s,i;return ar(this,function(o){return r=Goe(n),s=function(a,l,c){return Se(function(){var u=wdt(a,c);return qe(wt(fe(a,en(l,"int32")),"float32"),u)})}(r,t,e),i=bdt(n,r),[2,[s,i]]})})}function p8(n,e){return(n-1)%e==0}var m8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",g8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function y8(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var b8=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;U(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,i,o=(s=t.inputResolution,i=t.outputStride,{height:y8(s.height,i),width:y8(s.width,i)});(function(a){U(ldt.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,l){U(p8(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),U(p8(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=l8),or(this,void 0,void 0,function(){return ar(this,function(r){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,r){return t===void 0&&(t=l8),r===void 0&&(r=!1),or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S;return ar(this,function(C){switch(C.label){case 0:return s=function(k){var A=k;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=qr(qr({},cdt),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(t),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,i=kF(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=i.imageTensor,a=i.padding,l=this.architecture==="ResNet50"?qe(o,udt):Roe(o,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(u=vr(c[2],[0]),h=vr(c[3],[0]),f=vr(c[0],[0]),d=vr(c[1],[0])):(u=vr(c[0],[0]),h=vr(c[1],[0]),f=vr(c[2],[0]),d=vr(c[3],[0])),p=El(h),this.maxPoses!==1?[3,5]:r?[4,Cdt(p,u,this.outputStride)]:[3,2]);case 1:return g=C.sent(),b=g[0],y=g[1],m=[b,y],[3,4];case 2:return[4,Sdt(p,u,this.outputStride)];case 3:b=C.sent(),m=[b],C.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,gdt(p,u,f,d,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:m=C.sent(),C.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");x=this.getCanvasInfo(pv(e),this.inputResolution,a)}else S=pv(e),w=function(k,A,M,E){var N=A.height,O=A.width,R=N/(M.height*(1-E.top-E.bottom)),D=O/(M.width*(1-E.left-E.right)),z=-E.top*M.height,B=-E.left*M.width;if(D===1&&R===1&&z===0&&B===0)return k;for(var X=0,G=k;X<G.length;X++)for(var te=0,ge=G[X].keypoints;te<ge.length;te++){var ae=ge[te];ae.x=(ae.x+B)*D,ae.y=(ae.y+z)*R}return k}(m,S,this.inputResolution,a),s.flipHorizontal&&(w=function(k,A){for(var M=0,E=k;M<E.length;M++)for(var N=0,O=E[M].keypoints;N<O.length;N++){var R=O[N];R.x=A.width-1-R.x}return k}(w,S));return o.dispose(),l.dispose(),nn(c),u.dispose(),h.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,r?[m,x]:w]}})})},n.prototype.getCanvasInfo=function(e,t,r){var s=e.height,i=e.width,o=s/(t.height*(1-r.top-r.bottom)),a=i/(t.width*(1-r.left-r.right)),l=-r.top*t.height;return[-r.left*t.width,l,a,o,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function kdt(n){return n===void 0&&(n=r8),or(this,void 0,void 0,function(){var e,t,r,s,i;return ar(this,function(o){switch(o.label){case 0:return(e=function(u){var h=u||r8;if(h.architecture==null&&(h.architecture="MobileNetV1"),s8.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(s8));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),i8[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(i8[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),o8[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(o8[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),a8.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(a8," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),t=l===4?g8+"float/"+c:g8+"quant".concat(l,"/")+c,[4,Rl(e.modelUrl||t)]);case 1:return r=o.sent(),[2,new b8(r,e)];case 2:return s=function(u,h,f){var d={1:"100",.75:"075",.5:"050"},p="model-stride".concat(u,".json");return f===4?m8+"float/".concat(d[h],"/")+p:m8+"quant".concat(f,"/").concat(d[h],"/")+p}(e.outputStride,e.multiplier,e.quantBytes),[4,Rl(e.modelUrl||s)];case 3:return i=o.sent(),[2,new b8(i,e)]}var a,l,c})})}function Tdt(n,e){return or(this,void 0,void 0,function(){var t,r;return ar(this,function(s){switch(n){case io.PoseNet:return[2,kdt(e)];case io.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,tdt(e)];if(t.runtime==="mediapipe")return[2,Eft(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case io.MoveNet:return[2,adt(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var rV={},sV={},iV={};const oV="125",Cf={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},kf={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Hoe=0,IF=1,joe=2,Edt=3,Idt=0,aV=1,qoe=2,Tb=3,ox=0,gi=1,BC=2,lV=1,Adt=2,Rf=0,Lb=1,AF=2,MF=3,NF=4,Xoe=5,Vm=100,Koe=101,Yoe=102,$F=103,RF=104,Zoe=200,Joe=201,Qoe=202,eae=203,cV=204,uV=205,tae=206,nae=207,rae=208,sae=209,iae=210,oae=0,aae=1,lae=2,IA=3,cae=4,uae=5,hae=6,fae=7,VC=0,dae=1,pae=2,rg=0,mae=1,gae=2,yae=3,bae=4,vae=5,R$=300,UC=301,WC=302,AA=303,MA=304,ax=306,GC=307,lS=1e3,pa=1001,cS=1002,Ui=1003,NA=1004,Mdt=1004,$A=1005,Ndt=1005,lo=1006,hV=1007,$dt=1007,lx=1008,Rdt=1008,cx=1009,wae=1010,xae=1011,uS=1012,_ae=1013,c_=1014,If=1015,hS=1016,Sae=1017,Cae=1018,kae=1019,zb=1020,Tae=1021,ep=1022,Al=1023,Eae=1024,Iae=1025,Aae=Al,sg=1026,mv=1027,Mae=1028,Nae=1029,$ae=1030,Rae=1031,Pae=1032,Dae=1033,PF=33776,DF=33777,OF=33778,FF=33779,LF=35840,zF=35841,BF=35842,VF=35843,Oae=36196,UF=37492,WF=37496,Fae=37808,Lae=37809,zae=37810,Bae=37811,Vae=37812,Uae=37813,Wae=37814,Gae=37815,Hae=37816,jae=37817,qae=37818,Xae=37819,Kae=37820,Yae=37821,Zae=36492,Jae=37840,Qae=37841,ele=37842,tle=37843,nle=37844,rle=37845,sle=37846,ile=37847,ole=37848,ale=37849,lle=37850,cle=37851,ule=37852,hle=37853,fle=2200,dle=2201,ple=2202,fS=2300,u_=2301,iI=2302,Xm=2400,Km=2401,dS=2402,P$=2500,fV=2501,mle=0,Pdt=1,Ddt=2,Ca=3e3,HC=3001,D$=3007,O$=3002,gle=3003,dV=3004,pV=3005,mV=3006,yle=3200,ble=3201,n0=0,vle=1,Odt=0,oI=7680,Fdt=7681,Ldt=7682,zdt=7683,Bdt=34055,Vdt=34056,Udt=5386,Wdt=512,Gdt=513,Hdt=514,jdt=515,qdt=516,Xdt=517,Kdt=518,wle=519,jC=35044,Sg=35048,Ydt=35040,Zdt=35045,Jdt=35049,Qdt=35041,ept=35046,tpt=35050,npt=35042,rpt="100",GF="300 es";function Gu(){}Object.assign(Gu.prototype,{addEventListener:function(n,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[n]===void 0&&(t[n]=[]),t[n].indexOf(e)===-1&&t[n].push(e)},hasEventListener:function(n,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[n]!==void 0&&t[n].indexOf(e)!==-1},removeEventListener:function(n,e){if(this._listeners===void 0)return;const r=this._listeners[n];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const t=this._listeners[n.type];if(t!==void 0){n.target=this;const r=t.slice(0);for(let s=0,i=r.length;s<i;s++)r[s].call(this,n)}}});const wo=[];for(let n=0;n<256;n++)wo[n]=(n<16?"0":"")+n.toString(16);let zT=1234567;const In={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(wo[n&255]+wo[n>>8&255]+wo[n>>16&255]+wo[n>>24&255]+"-"+wo[e&255]+wo[e>>8&255]+"-"+wo[e>>16&15|64]+wo[e>>24&255]+"-"+wo[t&63|128]+wo[t>>8&255]+"-"+wo[t>>16&255]+wo[t>>24&255]+wo[r&255]+wo[r>>8&255]+wo[r>>16&255]+wo[r>>24&255]).toUpperCase()},clamp:function(n,e,t){return Math.max(e,Math.min(t,n))},euclideanModulo:function(n,e){return(n%e+e)%e},mapLinear:function(n,e,t,r,s){return r+(n-e)*(s-r)/(t-e)},lerp:function(n,e,t){return(1-t)*n+t*e},damp:function(n,e,t,r){return In.lerp(n,e,1-Math.exp(-t*r))},pingpong:function(n,e=1){return e-Math.abs(In.euclideanModulo(n,e*2)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&(zT=n%2147483647),zT=zT*16807%2147483647,(zT-1)/2147483646},degToRad:function(n){return n*In.DEG2RAD},radToDeg:function(n){return n*In.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,e,t,r,s){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),c=i((e+r)/2),u=o((e+r)/2),h=i((e-r)/2),f=o((e-r)/2),d=i((r-e)/2),p=o((r-e)/2);switch(s){case"XYX":n.set(a*u,l*h,l*f,a*c);break;case"YZY":n.set(l*f,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*f,a*u,a*c);break;case"XZX":n.set(a*u,l*p,l*d,a*c);break;case"YXY":n.set(l*d,a*u,l*p,a*c);break;case"ZYZ":n.set(l*p,l*d,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}};class st{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6],this.y=s[1]*t+s[4]*r+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),s=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*r-o*s+e.x,this.y=i*s+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class Cl{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=s,u[2]=a,u[3]=t,u[4]=i,u[5]=l,u[6]=r,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[3],l=r[6],c=r[1],u=r[4],h=r[7],f=r[2],d=r[5],p=r[8],m=s[0],g=s[3],y=s[6],b=s[1],x=s[4],w=s[7],S=s[2],C=s[5],k=s[8];return i[0]=o*m+a*b+l*S,i[3]=o*g+a*x+l*C,i[6]=o*y+a*w+l*k,i[1]=c*m+u*b+h*S,i[4]=c*g+u*x+h*C,i[7]=c*y+u*w+h*k,i[2]=f*m+d*b+p*S,i[5]=f*g+d*x+p*C,i[8]=f*y+d*w+p*k,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-r*i*u+r*a*l+s*i*c-s*o*l}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,f=a*l-u*i,d=c*i-o*l,p=t*h+r*f+s*d;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(s*c-u*r)*m,e[2]=(a*r-s*o)*m,e[3]=f*m,e[4]=(u*t-s*l)*m,e[5]=(s*i-a*t)*m,e[6]=d*m,e[7]=(r*l-c*t)*m,e[8]=(o*t-r*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,s,i,o,a){const l=Math.cos(i),c=Math.sin(i);return this.set(r*l,r*c,-r*(l*o+c*a)+o+e,-s*c,s*l,-s*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this}rotate(e){const t=Math.cos(e),r=Math.sin(e),s=this.elements,i=s[0],o=s[3],a=s[6],l=s[1],c=s[4],u=s[7];return s[0]=t*i+r*l,s[3]=t*o+r*c,s[6]=t*a+r*u,s[1]=-r*i+t*l,s[4]=-r*o+t*c,s[7]=-r*a+t*u,this}translate(e,t){const r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<9;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}}let j0;const r0={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement>"u")return n.src;let e;if(n instanceof HTMLCanvasElement)e=n;else{j0===void 0&&(j0=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),j0.width=n.width,j0.height=n.height;const t=j0.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=j0}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let spt=0;function Kr(n=Kr.DEFAULT_IMAGE,e=Kr.DEFAULT_MAPPING,t=pa,r=pa,s=lo,i=lx,o=Al,a=cx,l=1,c=Ca){Object.defineProperty(this,"id",{value:spt++}),this.uuid=In.generateUUID(),this.name="",this.image=n,this.mipmaps=[],this.mapping=e,this.wrapS=t,this.wrapT=r,this.magFilter=s,this.minFilter=i,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new st(0,0),this.repeat=new st(1,1),this.center=new st(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Cl,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}Kr.DEFAULT_IMAGE=void 0;Kr.DEFAULT_MAPPING=R$;Kr.prototype=Object.assign(Object.create(Gu.prototype),{constructor:Kr,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.name=n.name,this.image=n.image,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this},toJSON:function(n){const e=n===void 0||typeof n=="string";if(!e&&n.textures[this.uuid]!==void 0)return n.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=In.generateUUID()),!e&&n.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let i=0,o=r.length;i<o;i++)r[i].isDataTexture?s.push(dP(r[i].image)):s.push(dP(r[i]))}else s=dP(r);n.images[r.uuid]={uuid:r.uuid,url:s}}t.image=r.uuid}return e||(n.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(n){if(this.mapping!==R$)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case lS:n.x=n.x-Math.floor(n.x);break;case pa:n.x=n.x<0?0:1;break;case cS:Math.abs(Math.floor(n.x)%2)===1?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x);break}if(n.y<0||n.y>1)switch(this.wrapT){case lS:n.y=n.y-Math.floor(n.y);break;case pa:n.y=n.y<0?0:1;break;case cS:Math.abs(Math.floor(n.y)%2)===1?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y);break}return this.flipY&&(n.y=1-n.y),n}});Object.defineProperty(Kr.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function dP(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?r0.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Hr{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=r,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,s){return this.x=e,this.y=t,this.z=r,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*s+o[12]*i,this.y=o[1]*t+o[5]*r+o[9]*s+o[13]*i,this.z=o[2]*t+o[6]*r+o[10]*s+o[14]*i,this.w=o[3]*t+o[7]*r+o[11]*s+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,s,i;const l=e.elements,c=l[0],u=l[4],h=l[8],f=l[1],d=l[5],p=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-f)<.01&&Math.abs(h-m)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+f)<.1&&Math.abs(h+m)<.1&&Math.abs(p+g)<.1&&Math.abs(c+d+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,w=(d+1)/2,S=(y+1)/2,C=(u+f)/4,k=(h+m)/4,A=(p+g)/4;return x>w&&x>S?x<.01?(r=0,s=.707106781,i=.707106781):(r=Math.sqrt(x),s=C/r,i=k/r):w>S?w<.01?(r=.707106781,s=0,i=.707106781):(s=Math.sqrt(w),r=C/s,i=A/s):S<.01?(r=.707106781,s=.707106781,i=0):(i=Math.sqrt(S),r=k/i,s=A/i),this.set(r,s,i,t),this}let b=Math.sqrt((g-p)*(g-p)+(h-m)*(h-m)+(f-u)*(f-u));return Math.abs(b)<.001&&(b=1),this.x=(g-p)/b,this.y=(h-m)/b,this.z=(f-u)/b,this.w=Math.acos((c+d+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class tp extends Gu{constructor(e,t,r){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new Hr(0,0,e,t),this.scissorTest=!1,this.viewport=new Hr(0,0,e,t),r=r||{},this.texture=new Kr(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=r.generateMipmaps!==void 0?r.generateMipmaps:!1,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:lo,this.depthBuffer=r.depthBuffer!==void 0?r.depthBuffer:!0,this.stencilBuffer=r.stencilBuffer!==void 0?r.stencilBuffer:!1,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null}setSize(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ipt extends tp{constructor(e,t,r){super(e,t,r),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}class co{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=r,this._w=s}static slerp(e,t,r,s){return r.copy(e).slerp(t,s)}static slerpFlat(e,t,r,s,i,o,a){let l=r[s+0],c=r[s+1],u=r[s+2],h=r[s+3];const f=i[o+0],d=i[o+1],p=i[o+2],m=i[o+3];if(h!==m||l!==f||c!==d||u!==p){let g=1-a;const y=l*f+c*d+u*p+h*m,b=y>=0?1:-1,x=1-y*y;if(x>Number.EPSILON){const S=Math.sqrt(x),C=Math.atan2(S,y*b);g=Math.sin(g*C)/S,a=Math.sin(a*C)/S}const w=a*b;if(l=l*g+f*w,c=c*g+d*w,u=u*g+p*w,h=h*g+m*w,g===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,r,s,i,o){const a=r[s],l=r[s+1],c=r[s+2],u=r[s+3],h=i[o],f=i[o+1],d=i[o+2],p=i[o+3];return e[t]=a*p+u*h+l*d-c*f,e[t+1]=l*p+u*f+c*h-a*d,e[t+2]=c*p+u*d+a*f-l*h,e[t+3]=u*p-a*h-l*f-c*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=e._x,s=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(r/2),u=a(s/2),h=a(i/2),f=l(r/2),d=l(s/2),p=l(i/2);switch(o){case"XYZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"YXZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"ZXY":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"ZYX":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"YZX":this._x=f*u*h+c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h-f*d*p;break;case"XZY":this._x=f*u*h-c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h+f*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,s=Math.sin(r);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],s=t[4],i=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],f=r+a+h;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(u-l)*d,this._y=(i-c)*d,this._z=(o-s)*d}else if(r>a&&r>h){const d=2*Math.sqrt(1+r-a-h);this._w=(u-l)/d,this._x=.25*d,this._y=(s+o)/d,this._z=(i+c)/d}else if(a>h){const d=2*Math.sqrt(1+a-r-h);this._w=(i-c)/d,this._x=(s+o)/d,this._y=.25*d,this._z=(l+u)/d}else{const d=2*Math.sqrt(1+h-r-a);this._w=(o-s)/d,this._x=(i+c)/d,this._y=(l+u)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-6?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(In.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const s=Math.min(1,t/r);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,s=e._y,i=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=r*u+o*a+s*c-i*l,this._y=s*u+o*l+i*a-r*c,this._z=i*u+o*c+r*l-s*a,this._w=o*u-r*a-s*l-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,s=this._y,i=this._z,o=this._w;let a=o*e._w+r*e._x+s*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=s,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*r+t*this._x,this._y=d*s+t*this._y,this._z=d*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,f=Math.sin(t*u)/c;return this._w=o*h+this._w*f,this._x=r*h+this._x*f,this._y=s*h+this._y*f,this._z=i*h+this._z*f,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class Q{constructor(e=0,t=0,r=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(v8.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(v8.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6]*s,this.y=i[1]*t+i[4]*r+i[7]*s,this.z=i[2]*t+i[5]*r+i[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=e.elements,o=1/(i[3]*t+i[7]*r+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*r+i[8]*s+i[12])*o,this.y=(i[1]*t+i[5]*r+i[9]*s+i[13])*o,this.z=(i[2]*t+i[6]*r+i[10]*s+i[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,s=this.z,i=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*s-a*r,u=l*r+a*t-i*s,h=l*s+i*r-o*t,f=-i*t-o*r-a*s;return this.x=c*l+f*-i+u*-a-h*-o,this.y=u*l+f*-o+h*-i-c*-a,this.z=h*l+f*-a+c*-o-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[4]*r+i[8]*s,this.y=i[1]*t+i[5]*r+i[9]*s,this.z=i[2]*t+i[6]*r+i[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,s=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=s*l-i*a,this.y=i*o-r*l,this.z=r*a-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return pP.copy(this).projectOnVector(e),this.sub(pP)}reflect(e){return this.sub(pP.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(In.clamp(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,s=this.z-e.z;return t*t+r*r+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const s=Math.sin(t)*e;return this.x=s*Math.sin(r),this.y=Math.cos(t)*e,this.z=s*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const pP=new Q,v8=new co;class Qf{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new Q(1/0,1/0,1/0),this.max=t!==void 0?t:new Q(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],f=e[l+2];u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromBufferAttribute(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),f=e.getZ(l);u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=i1.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),gP.copy(t.boundingBox),gP.applyMatrix4(e.matrixWorld),this.union(gP));const r=e.children;for(let s=0,i=r.length;s<i;s++)this.expandByObject(r[s]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Q),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,i1),i1.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(o1),BT.subVectors(this.max,o1),q0.subVectors(e.a,o1),X0.subVectors(e.b,o1),K0.subVectors(e.c,o1),bd.subVectors(X0,q0),vd.subVectors(K0,X0),gm.subVectors(q0,K0);let t=[0,-bd.z,bd.y,0,-vd.z,vd.y,0,-gm.z,gm.y,bd.z,0,-bd.x,vd.z,0,-vd.x,gm.z,0,-gm.x,-bd.y,bd.x,0,-vd.y,vd.x,0,-gm.y,gm.x,0];return!mP(t,q0,X0,K0,BT)||(t=[1,0,0,0,1,0,0,0,1],!mP(t,q0,X0,K0,BT))?!1:(VT.crossVectors(bd,vd),t=[VT.x,VT.y,VT.z],mP(t,q0,X0,K0,BT))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Q),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return i1.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(i1).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(lf[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),lf[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),lf[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),lf[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),lf[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),lf[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),lf[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),lf[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(lf),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function mP(n,e,t,r,s){for(let i=0,o=n.length-3;i<=o;i+=3){ym.fromArray(n,i);const a=s.x*Math.abs(ym.x)+s.y*Math.abs(ym.y)+s.z*Math.abs(ym.z),l=e.dot(ym),c=t.dot(ym),u=r.dot(ym);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const lf=[new Q,new Q,new Q,new Q,new Q,new Q,new Q,new Q],i1=new Q,gP=new Qf,q0=new Q,X0=new Q,K0=new Q,bd=new Q,vd=new Q,gm=new Q,o1=new Q,BT=new Q,VT=new Q,ym=new Q,opt=new Qf;class Gp{constructor(e,t){this.center=e!==void 0?e:new Q,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):opt.setFromPoints(e).getCenter(r);let s=0;for(let i=0,o=e.length;i<o;i++)s=Math.max(s,r.distanceToSquared(e[i]));return this.radius=Math.sqrt(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Q),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Qf),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const cf=new Q,yP=new Q,UT=new Q,wd=new Q,bP=new Q,WT=new Q,vP=new Q;class ux{constructor(e,t){this.origin=e!==void 0?e:new Q,this.direction=t!==void 0?t:new Q(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new Q),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,cf)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Q),t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=cf.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(cf.copy(this.direction).multiplyScalar(t).add(this.origin),cf.distanceToSquared(e))}distanceSqToSegment(e,t,r,s){yP.copy(e).add(t).multiplyScalar(.5),UT.copy(t).sub(e).normalize(),wd.copy(this.origin).sub(yP);const i=e.distanceTo(t)*.5,o=-this.direction.dot(UT),a=wd.dot(this.direction),l=-wd.dot(UT),c=wd.lengthSq(),u=Math.abs(1-o*o);let h,f,d,p;if(u>0)if(h=o*l-a,f=o*a-l,p=i*u,h>=0)if(f>=-p)if(f<=p){const m=1/u;h*=m,f*=m,d=h*(h+o*f+2*a)+f*(o*h+f+2*l)+c}else f=i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f=-i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f<=-p?(h=Math.max(0,-(-o*i+a)),f=h>0?-i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c):f<=p?(h=0,f=Math.min(Math.max(-i,-l),i),d=f*(f+2*l)+c):(h=Math.max(0,-(o*i+a)),f=h>0?i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c);else f=o>0?-i:i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;return r&&r.copy(this.direction).multiplyScalar(h).add(this.origin),s&&s.copy(UT).multiplyScalar(f).add(yP),d}intersectSphere(e,t){cf.subVectors(e.center,this.origin);const r=cf.dot(this.direction),s=cf.dot(cf)-r*r,i=e.radius*e.radius;if(s>i)return null;const o=Math.sqrt(i-s),a=r-o,l=r+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,s,i,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,f=this.origin;return c>=0?(r=(e.min.x-f.x)*c,s=(e.max.x-f.x)*c):(r=(e.max.x-f.x)*c,s=(e.min.x-f.x)*c),u>=0?(i=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(i=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||i>s||((i>r||r!==r)&&(r=i),(o<s||s!==s)&&(s=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),r>l||a>s)||((a>r||r!==r)&&(r=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(r>=0?r:s,t)}intersectsBox(e){return this.intersectBox(e,cf)!==null}intersectTriangle(e,t,r,s,i){bP.subVectors(t,e),WT.subVectors(r,e),vP.crossVectors(bP,WT);let o=this.direction.dot(vP),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;wd.subVectors(this.origin,e);const l=a*this.direction.dot(WT.crossVectors(wd,WT));if(l<0)return null;const c=a*this.direction.dot(bP.cross(wd));if(c<0||l+c>o)return null;const u=-a*wd.dot(vP);return u<0?null:this.at(u/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Zn{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g){const y=this.elements;return y[0]=e,y[4]=t,y[8]=r,y[12]=s,y[1]=i,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=u,y[10]=h,y[14]=f,y[3]=d,y[7]=p,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zn().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,s=1/Y0.setFromMatrixColumn(e,0).length(),i=1/Y0.setFromMatrixColumn(e,1).length(),o=1/Y0.setFromMatrixColumn(e,2).length();return t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s,t[3]=0,t[4]=r[4]*i,t[5]=r[5]*i,t[6]=r[6]*i,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,r=e.x,s=e.y,i=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(s),c=Math.sin(s),u=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=d+p*c,t[5]=f-m*c,t[9]=-a*l,t[2]=m-f*c,t[6]=p+d*c,t[10]=o*l}else if(e.order==="YXZ"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f+m*a,t[4]=p*a-d,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=d*a-p,t[6]=m+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f-m*a,t[4]=-o*h,t[8]=p+d*a,t[1]=d+p*a,t[5]=o*u,t[9]=m-f*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-d,t[8]=f*c+m,t[1]=l*h,t[5]=m*c+f,t[9]=d*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-f*h,t[8]=p*h+d,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=d*h+p,t[10]=f-m*h}else if(e.order==="XZY"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=f*h+m,t[5]=o*u,t[9]=d*h-p,t[2]=p*h-d,t[6]=a*u,t[10]=m*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(apt,e,lpt)}lookAt(e,t,r){const s=this.elements;return fl.subVectors(e,t),fl.lengthSq()===0&&(fl.z=1),fl.normalize(),xd.crossVectors(r,fl),xd.lengthSq()===0&&(Math.abs(r.z)===1?fl.x+=1e-4:fl.z+=1e-4,fl.normalize(),xd.crossVectors(r,fl)),xd.normalize(),GT.crossVectors(fl,xd),s[0]=xd.x,s[4]=GT.x,s[8]=fl.x,s[1]=xd.y,s[5]=GT.y,s[9]=fl.y,s[2]=xd.z,s[6]=GT.z,s[10]=fl.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],p=r[2],m=r[6],g=r[10],y=r[14],b=r[3],x=r[7],w=r[11],S=r[15],C=s[0],k=s[4],A=s[8],M=s[12],E=s[1],N=s[5],O=s[9],R=s[13],D=s[2],z=s[6],B=s[10],X=s[14],G=s[3],te=s[7],ge=s[11],ae=s[15];return i[0]=o*C+a*E+l*D+c*G,i[4]=o*k+a*N+l*z+c*te,i[8]=o*A+a*O+l*B+c*ge,i[12]=o*M+a*R+l*X+c*ae,i[1]=u*C+h*E+f*D+d*G,i[5]=u*k+h*N+f*z+d*te,i[9]=u*A+h*O+f*B+d*ge,i[13]=u*M+h*R+f*X+d*ae,i[2]=p*C+m*E+g*D+y*G,i[6]=p*k+m*N+g*z+y*te,i[10]=p*A+m*O+g*B+y*ge,i[14]=p*M+m*R+g*X+y*ae,i[3]=b*C+x*E+w*D+S*G,i[7]=b*k+x*N+w*z+S*te,i[11]=b*A+x*O+w*B+S*ge,i[15]=b*M+x*R+w*X+S*ae,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],s=e[8],i=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],f=e[10],d=e[14],p=e[3],m=e[7],g=e[11],y=e[15];return p*(+i*l*h-s*c*h-i*a*f+r*c*f+s*a*d-r*l*d)+m*(+t*l*d-t*c*f+i*o*f-s*o*d+s*c*u-i*l*u)+g*(+t*c*h-t*a*d-i*o*h+r*o*d+i*a*u-r*c*u)+y*(-s*a*u-t*l*h+t*a*f+s*o*h-r*o*f+r*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],d=e[11],p=e[12],m=e[13],g=e[14],y=e[15],b=h*g*c-m*f*c+m*l*d-a*g*d-h*l*y+a*f*y,x=p*f*c-u*g*c-p*l*d+o*g*d+u*l*y-o*f*y,w=u*m*c-p*h*c+p*a*d-o*m*d-u*a*y+o*h*y,S=p*h*l-u*m*l-p*a*f+o*m*f+u*a*g-o*h*g,C=t*b+r*x+s*w+i*S;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/C;return e[0]=b*k,e[1]=(m*f*i-h*g*i-m*s*d+r*g*d+h*s*y-r*f*y)*k,e[2]=(a*g*i-m*l*i+m*s*c-r*g*c-a*s*y+r*l*y)*k,e[3]=(h*l*i-a*f*i-h*s*c+r*f*c+a*s*d-r*l*d)*k,e[4]=x*k,e[5]=(u*g*i-p*f*i+p*s*d-t*g*d-u*s*y+t*f*y)*k,e[6]=(p*l*i-o*g*i-p*s*c+t*g*c+o*s*y-t*l*y)*k,e[7]=(o*f*i-u*l*i+u*s*c-t*f*c-o*s*d+t*l*d)*k,e[8]=w*k,e[9]=(p*h*i-u*m*i-p*r*d+t*m*d+u*r*y-t*h*y)*k,e[10]=(o*m*i-p*a*i+p*r*c-t*m*c-o*r*y+t*a*y)*k,e[11]=(u*a*i-o*h*i-u*r*c+t*h*c+o*r*d-t*a*d)*k,e[12]=S*k,e[13]=(u*m*s-p*h*s+p*r*f-t*m*f-u*r*g+t*h*g)*k,e[14]=(p*a*s-o*m*s-p*r*l+t*m*l+o*r*g-t*a*g)*k,e[15]=(o*h*s-u*a*s+u*r*l-t*h*l-o*r*f+t*a*f)*k,this}scale(e){const t=this.elements,r=e.x,s=e.y,i=e.z;return t[0]*=r,t[4]*=s,t[8]*=i,t[1]*=r,t[5]*=s,t[9]*=i,t[2]*=r,t[6]*=s,t[10]*=i,t[3]*=r,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,s))}makeTranslation(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),s=Math.sin(t),i=1-r,o=e.x,a=e.y,l=e.z,c=i*o,u=i*a;return this.set(c*o+r,c*a-s*l,c*l+s*a,0,c*a+s*l,u*a+r,u*l-s*o,0,c*l-s*a,u*l+s*o,i*l*l+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this}compose(e,t,r){const s=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,c=i+i,u=o+o,h=a+a,f=i*c,d=i*u,p=i*h,m=o*u,g=o*h,y=a*h,b=l*c,x=l*u,w=l*h,S=r.x,C=r.y,k=r.z;return s[0]=(1-(m+y))*S,s[1]=(d+w)*S,s[2]=(p-x)*S,s[3]=0,s[4]=(d-w)*C,s[5]=(1-(f+y))*C,s[6]=(g+b)*C,s[7]=0,s[8]=(p+x)*k,s[9]=(g-b)*k,s[10]=(1-(f+m))*k,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,r){const s=this.elements;let i=Y0.set(s[0],s[1],s[2]).length();const o=Y0.set(s[4],s[5],s[6]).length(),a=Y0.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),e.x=s[12],e.y=s[13],e.z=s[14],Zc.copy(this);const c=1/i,u=1/o,h=1/a;return Zc.elements[0]*=c,Zc.elements[1]*=c,Zc.elements[2]*=c,Zc.elements[4]*=u,Zc.elements[5]*=u,Zc.elements[6]*=u,Zc.elements[8]*=h,Zc.elements[9]*=h,Zc.elements[10]*=h,t.setFromRotationMatrix(Zc),r.x=i,r.y=o,r.z=a,this}makePerspective(e,t,r,s,i,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*i/(t-e),c=2*i/(r-s),u=(t+e)/(t-e),h=(r+s)/(r-s),f=-(o+i)/(o-i),d=-2*o*i/(o-i);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,r,s,i,o){const a=this.elements,l=1/(t-e),c=1/(r-s),u=1/(o-i),h=(t+e)*l,f=(r+s)*c,d=(o+i)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<16;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const Y0=new Q,Zc=new Zn,apt=new Q(0,0,0),lpt=new Q(1,1,1),xd=new Q,GT=new Q,fl=new Q;class hx{constructor(e=0,t=0,r=0,s=hx.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=r,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._order=s||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,r){const s=In.clamp,i=e.elements,o=i[0],a=i[4],l=i[8],c=i[1],u=i[5],h=i[9],f=i[2],d=i[6],p=i[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(s(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-s(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-f,o),this._z=0);break;case"ZXY":this._x=Math.asin(s(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-s(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(s(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,u),this._y=Math.atan2(-f,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-s(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return w8.makeRotationFromQuaternion(e),this.setFromRotationMatrix(w8,t,r)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return x8.setFromEuler(this),this.setFromQuaternion(x8,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Q(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}hx.DefaultOrder="XYZ";hx.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const w8=new Zn,x8=new co;class gV{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let cpt=0;const _8=new Q,Z0=new co,uf=new Zn,HT=new Q,a1=new Q,upt=new Q,hpt=new co,S8=new Q(1,0,0),C8=new Q(0,1,0),k8=new Q(0,0,1),fpt={type:"added"},T8={type:"removed"};function rn(){Object.defineProperty(this,"id",{value:cpt++}),this.uuid=In.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rn.DefaultUp.clone();const n=new Q,e=new hx,t=new co,r=new Q(1,1,1);function s(){t.setFromEuler(e,!1)}function i(){e.setFromQuaternion(t,void 0,!1)}e._onChange(s),t._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Zn},normalMatrix:{value:new Cl}}),this.matrix=new Zn,this.matrixWorld=new Zn,this.matrixAutoUpdate=rn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new gV,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}rn.DefaultUp=new Q(0,1,0);rn.DefaultMatrixAutoUpdate=!0;rn.prototype=Object.assign(Object.create(Gu.prototype),{constructor:rn,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,e){this.quaternion.setFromAxisAngle(n,e)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,e){return Z0.setFromAxisAngle(n,e),this.quaternion.multiply(Z0),this},rotateOnWorldAxis:function(n,e){return Z0.setFromAxisAngle(n,e),this.quaternion.premultiply(Z0),this},rotateX:function(n){return this.rotateOnAxis(S8,n)},rotateY:function(n){return this.rotateOnAxis(C8,n)},rotateZ:function(n){return this.rotateOnAxis(k8,n)},translateOnAxis:function(n,e){return _8.copy(n).applyQuaternion(this.quaternion),this.position.add(_8.multiplyScalar(e)),this},translateX:function(n){return this.translateOnAxis(S8,n)},translateY:function(n){return this.translateOnAxis(C8,n)},translateZ:function(n){return this.translateOnAxis(k8,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(uf.copy(this.matrixWorld).invert())},lookAt:function(n,e,t){n.isVector3?HT.copy(n):HT.set(n,e,t);const r=this.parent;this.updateWorldMatrix(!0,!1),a1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?uf.lookAt(a1,HT,this.up):uf.lookAt(HT,a1,this.up),this.quaternion.setFromRotationMatrix(uf),r&&(uf.extractRotation(r.matrixWorld),Z0.setFromRotationMatrix(uf),this.quaternion.premultiply(Z0.invert()))},add:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(fpt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(n);return e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent(T8)),this},clear:function(){for(let n=0;n<this.children.length;n++){const e=this.children[n];e.parent=null,e.dispatchEvent(T8)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),uf.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),uf.multiply(n.parent.matrixWorld)),n.applyMatrix4(uf),n.updateWorldMatrix(!1,!1),this.add(n),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,e){if(this[n]===e)return this;for(let t=0,r=this.children.length;t<r;t++){const i=this.children[t].getObjectByProperty(n,e);if(i!==void 0)return i}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new co),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(a1,n,upt),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(a1,hpt,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverseVisible(n)},traverseAncestors:function(n){const e=this.parent;e!==null&&(n(e),e.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].updateMatrixWorld(n)},updateWorldMatrix:function(n,e){const t=this.parent;if(n===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,i=r.length;s<i;s++)r[s].updateWorldMatrix(!1,!0)}},toJSON:function(n){const e=n===void 0||typeof n=="string",t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON());function s(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const u=a[l];s(n.shapes,u)}else s(n.shapes,a)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(n.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(s(n.materials,this.material[a]));r.material=o}else r.material=s(n.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];r.animations.push(s(n.animations,a))}}if(e){const o=i(n.geometries),a=i(n.materials),l=i(n.textures),c=i(n.images),u=i(n.shapes),h=i(n.skeletons),f=i(n.animations);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),l.length>0&&(t.textures=l),c.length>0&&(t.images=c),u.length>0&&(t.shapes=u),h.length>0&&(t.skeletons=h),f.length>0&&(t.animations=f)}return t.object=r,t;function i(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,e=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),e===!0)for(let t=0;t<n.children.length;t++){const r=n.children[t];this.add(r.clone())}return this}});const wP=new Q,dpt=new Q,ppt=new Cl;class ch{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new Q(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,s){return this.normal.set(e,t,r),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const s=wP.subVectors(r,t).cross(dpt.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Q),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Q);const r=e.delta(wP),s=this.normal.dot(r);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const i=-(e.start.dot(this.normal)+this.constant)/s;if(!(i<0||i>1))return t.copy(r).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Q),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||ppt.getNormalMatrix(e),s=this.coplanarPoint(wP).applyMatrix4(e),i=this.normal.applyMatrix3(r).normalize();return this.constant=-s.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const Jc=new Q,hf=new Q,xP=new Q,ff=new Q,J0=new Q,Q0=new Q,E8=new Q,_P=new Q,SP=new Q,CP=new Q;class jo{constructor(e,t,r){this.a=e!==void 0?e:new Q,this.b=t!==void 0?t:new Q,this.c=r!==void 0?r:new Q}static getNormal(e,t,r,s){s===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),s=new Q),s.subVectors(r,t),Jc.subVectors(e,t),s.cross(Jc);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(e,t,r,s,i){Jc.subVectors(s,t),hf.subVectors(r,t),xP.subVectors(e,t);const o=Jc.dot(Jc),a=Jc.dot(hf),l=Jc.dot(xP),c=hf.dot(hf),u=hf.dot(xP),h=o*c-a*a;if(i===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),i=new Q),h===0)return i.set(-2,-1,-1);const f=1/h,d=(c*l-a*u)*f,p=(o*u-a*l)*f;return i.set(1-d-p,p,d)}static containsPoint(e,t,r,s){return this.getBarycoord(e,t,r,s,ff),ff.x>=0&&ff.y>=0&&ff.x+ff.y<=1}static getUV(e,t,r,s,i,o,a,l){return this.getBarycoord(e,t,r,s,ff),l.set(0,0),l.addScaledVector(i,ff.x),l.addScaledVector(o,ff.y),l.addScaledVector(a,ff.z),l}static isFrontFacing(e,t,r,s){return Jc.subVectors(r,t),hf.subVectors(e,t),Jc.cross(hf).dot(s)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,s){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[s]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Jc.subVectors(this.c,this.b),hf.subVectors(this.a,this.b),Jc.cross(hf).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Q),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return jo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new ch),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return jo.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,s,i){return jo.getUV(e,this.a,this.b,this.c,t,r,s,i)}containsPoint(e){return jo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return jo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Q);const r=this.a,s=this.b,i=this.c;let o,a;J0.subVectors(s,r),Q0.subVectors(i,r),_P.subVectors(e,r);const l=J0.dot(_P),c=Q0.dot(_P);if(l<=0&&c<=0)return t.copy(r);SP.subVectors(e,s);const u=J0.dot(SP),h=Q0.dot(SP);if(u>=0&&h<=u)return t.copy(s);const f=l*h-u*c;if(f<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(r).addScaledVector(J0,o);CP.subVectors(e,i);const d=J0.dot(CP),p=Q0.dot(CP);if(p>=0&&d<=p)return t.copy(i);const m=d*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(r).addScaledVector(Q0,a);const g=u*p-d*h;if(g<=0&&h-u>=0&&d-p>=0)return E8.subVectors(i,s),a=(h-u)/(h-u+(d-p)),t.copy(s).addScaledVector(E8,a);const y=1/(g+m+f);return o=m*y,a=f*y,t.copy(r).addScaledVector(J0,o).addScaledVector(Q0,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const xle={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Qc={h:0,s:0,l:0},jT={h:0,s:0,l:0};function kP(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function TP(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function EP(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Ht{constructor(e,t,r){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&r===void 0?this.set(e):this.setRGB(e,t,r)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,r){return this.r=e,this.g=t,this.b=r,this}setHSL(e,t,r){if(e=In.euclideanModulo(e,1),t=In.clamp(t,0,1),r=In.clamp(r,0,1),t===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+t):r+t-r*t,i=2*r-s;this.r=kP(i,s,e+1/3),this.g=kP(i,s,e),this.b=kP(i,s,e-1/3)}return this}setStyle(e){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const i=r[1],o=r[2];switch(i){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,t(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,t(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(s[1])/360,l=parseInt(s[2],10)/100,c=parseInt(s[3],10)/100;return t(s[4]),this.setHSL(a,l,c)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],i=s.length;if(i===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=xle[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=TP(e.r),this.g=TP(e.g),this.b=TP(e.b),this}copyLinearToSRGB(e){return this.r=EP(e.r),this.g=EP(e.g),this.b=EP(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,r=this.g,s=this.b,i=Math.max(t,r,s),o=Math.min(t,r,s);let a,l;const c=(o+i)/2;if(o===i)a=0,l=0;else{const u=i-o;switch(l=c<=.5?u/(i+o):u/(2-i-o),i){case t:a=(r-s)/u+(r<s?6:0);break;case r:a=(s-t)/u+2;break;case s:a=(t-r)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,r){return this.getHSL(Qc),Qc.h+=e,Qc.s+=t,Qc.l+=r,this.setHSL(Qc.h,Qc.s,Qc.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(Qc),e.getHSL(jT);const r=In.lerp(Qc.h,jT.h,t),s=In.lerp(Qc.s,jT.s,t),i=In.lerp(Qc.l,jT.l,t);return this.setHSL(r,s,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ht.NAMES=xle;Ht.prototype.r=1;Ht.prototype.g=1;Ht.prototype.b=1;class yV{constructor(e,t,r,s,i,o=0){this.a=e,this.b=t,this.c=r,this.normal=s&&s.isVector3?s:new Q,this.vertexNormals=Array.isArray(s)?s:[],this.color=i&&i.isColor?i:new Ht,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,r=e.vertexNormals.length;t<r;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,r=e.vertexColors.length;t<r;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let mpt=0;function kn(){Object.defineProperty(this,"id",{value:mpt++}),this.uuid=In.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Lb,this.side=ox,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=cV,this.blendDst=uV,this.blendEquation=Vm,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=IA,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=wle,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=oI,this.stencilZFail=oI,this.stencilZPass=oI,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}kn.prototype=Object.assign(Object.create(Gu.prototype),{constructor:kn,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const e in n){const t=n[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===lV;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t}},toJSON:function(n){const e=n===void 0||typeof n=="string";e&&(n={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Lb&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==ox&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function r(s){const i=[];for(const o in s){const a=s[o];delete a.metadata,i.push(a)}return i}if(e){const s=r(n.textures),i=r(n.images);s.length>0&&(t.textures=s),i.length>0&&(t.images=i)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.flatShading=n.flatShading,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const e=n.clippingPlanes;let t=null;if(e!==null){const r=e.length;t=new Array(r);for(let s=0;s!==r;++s)t[s]=e[s].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(kn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Dl(n){kn.call(this),this.type="MeshBasicMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=VC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(n)}Dl.prototype=Object.create(kn.prototype);Dl.prototype.constructor=Dl;Dl.prototype.isMeshBasicMaterial=!0;Dl.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this};const ss=new Q,qT=new st;function Cn(n,e,t){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=e,this.count=n!==void 0?n.length/e:0,this.normalized=t===!0,this.usage=jC,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Cn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Cn.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[n+r]=e.array[t+r];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new Ht),e[t++]=i.r,e[t++]=i.g,e[t++]=i.b}return this},copyVector2sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new st),e[t++]=i.x,e[t++]=i.y}return this},copyVector3sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new Q),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z}return this},copyVector4sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new Hr),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z,e[t++]=i.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)qT.fromBufferAttribute(this,e),qT.applyMatrix3(n),this.setXY(e,qT.x,qT.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)ss.fromBufferAttribute(this,e),ss.applyMatrix3(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},applyMatrix4:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.applyMatrix4(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},applyNormalMatrix:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.applyNormalMatrix(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},transformDirection:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.transformDirection(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},set:function(n,e=0){return this.array.set(n,e),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,e){return this.array[n*this.itemSize]=e,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,e){return this.array[n*this.itemSize+1]=e,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,e){return this.array[n*this.itemSize+2]=e,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,e){return this.array[n*this.itemSize+3]=e,this},setXY:function(n,e,t){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this.array[n+3]=s,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function pS(n,e,t){Cn.call(this,new Int8Array(n),e,t)}pS.prototype=Object.create(Cn.prototype);pS.prototype.constructor=pS;function mS(n,e,t){Cn.call(this,new Uint8Array(n),e,t)}mS.prototype=Object.create(Cn.prototype);mS.prototype.constructor=mS;function gS(n,e,t){Cn.call(this,new Uint8ClampedArray(n),e,t)}gS.prototype=Object.create(Cn.prototype);gS.prototype.constructor=gS;function yS(n,e,t){Cn.call(this,new Int16Array(n),e,t)}yS.prototype=Object.create(Cn.prototype);yS.prototype.constructor=yS;function Cg(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}Cg.prototype=Object.create(Cn.prototype);Cg.prototype.constructor=Cg;function bS(n,e,t){Cn.call(this,new Int32Array(n),e,t)}bS.prototype=Object.create(Cn.prototype);bS.prototype.constructor=bS;function kg(n,e,t){Cn.call(this,new Uint32Array(n),e,t)}kg.prototype=Object.create(Cn.prototype);kg.prototype.constructor=kg;function vS(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}vS.prototype=Object.create(Cn.prototype);vS.prototype.constructor=vS;vS.prototype.isFloat16BufferAttribute=!0;function Xt(n,e,t){Cn.call(this,new Float32Array(n),e,t)}Xt.prototype=Object.create(Cn.prototype);Xt.prototype.constructor=Xt;function wS(n,e,t){Cn.call(this,new Float64Array(n),e,t)}wS.prototype=Object.create(Cn.prototype);wS.prototype.constructor=wS;function _le(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,r=n.length;t<r;++t)n[t]>e&&(e=n[t]);return e}const gpt={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function z1(n,e){return new gpt[n](e)}let ypt=0;const eh=new Zn,IP=new rn,eb=new Q,dl=new Qf,l1=new Qf,no=new Q;function un(){Object.defineProperty(this,"id",{value:ypt++}),this.uuid=In.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}un.prototype=Object.assign(Object.create(Gu.prototype),{constructor:un,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(_le(n)>65535?kg:Cg)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,e){return this.attributes[n]=e,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,e,t=0){this.groups.push({start:n,count:e,materialIndex:t})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,e){this.drawRange.start=n,this.drawRange.count=e},applyMatrix4:function(n){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(n),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const s=new Cl().getNormalMatrix(n);t.applyNormalMatrix(s),t.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(n),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return eh.makeRotationX(n),this.applyMatrix4(eh),this},rotateY:function(n){return eh.makeRotationY(n),this.applyMatrix4(eh),this},rotateZ:function(n){return eh.makeRotationZ(n),this.applyMatrix4(eh),this},translate:function(n,e,t){return eh.makeTranslation(n,e,t),this.applyMatrix4(eh),this},scale:function(n,e,t){return eh.makeScale(n,e,t),this.applyMatrix4(eh),this},lookAt:function(n){return IP.lookAt(n),IP.updateMatrix(),this.applyMatrix4(IP.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(eb).negate(),this.translate(eb.x,eb.y,eb.z),this},setFromPoints:function(n){const e=[];for(let t=0,r=n.length;t<r;t++){const s=n[t];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Xt(e,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Qf);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Q(-1/0,-1/0,-1/0),new Q(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),e)for(let t=0,r=e.length;t<r;t++){const s=e[t];dl.setFromBufferAttribute(s),this.morphTargetsRelative?(no.addVectors(this.boundingBox.min,dl.min),this.boundingBox.expandByPoint(no),no.addVectors(this.boundingBox.max,dl.max),this.boundingBox.expandByPoint(no)):(this.boundingBox.expandByPoint(dl.min),this.boundingBox.expandByPoint(dl.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Gp);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Q,1/0);return}if(n){const t=this.boundingSphere.center;if(dl.setFromBufferAttribute(n),e)for(let s=0,i=e.length;s<i;s++){const o=e[s];l1.setFromBufferAttribute(o),this.morphTargetsRelative?(no.addVectors(dl.min,l1.min),dl.expandByPoint(no),no.addVectors(dl.max,l1.max),dl.expandByPoint(no)):(dl.expandByPoint(l1.min),dl.expandByPoint(l1.max))}dl.getCenter(t);let r=0;for(let s=0,i=n.count;s<i;s++)no.fromBufferAttribute(n,s),r=Math.max(r,t.distanceToSquared(no));if(e)for(let s=0,i=e.length;s<i;s++){const o=e[s],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)no.fromBufferAttribute(o,l),a&&(eb.fromBufferAttribute(n,l),no.add(eb)),r=Math.max(r,t.distanceToSquared(no))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,e=this.attributes;if(n===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=n.array,r=e.position.array,s=e.normal.array,i=e.uv.array,o=r.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Cn(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let M=0;M<o;M++)l[M]=new Q,c[M]=new Q;const u=new Q,h=new Q,f=new Q,d=new st,p=new st,m=new st,g=new Q,y=new Q;function b(M,E,N){u.fromArray(r,M*3),h.fromArray(r,E*3),f.fromArray(r,N*3),d.fromArray(i,M*2),p.fromArray(i,E*2),m.fromArray(i,N*2),h.sub(u),f.sub(u),p.sub(d),m.sub(d);const O=1/(p.x*m.y-m.x*p.y);isFinite(O)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(f,-p.y).multiplyScalar(O),y.copy(f).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(O),l[M].add(g),l[E].add(g),l[N].add(g),c[M].add(y),c[E].add(y),c[N].add(y))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.length}]);for(let M=0,E=x.length;M<E;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)b(t[D+0],t[D+1],t[D+2])}const w=new Q,S=new Q,C=new Q,k=new Q;function A(M){C.fromArray(s,M*3),k.copy(C);const E=l[M];w.copy(E),w.sub(C.multiplyScalar(C.dot(E))).normalize(),S.crossVectors(k,E);const O=S.dot(c[M])<0?-1:1;a[M*4]=w.x,a[M*4+1]=w.y,a[M*4+2]=w.z,a[M*4+3]=O}for(let M=0,E=x.length;M<E;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)A(t[D+0]),A(t[D+1]),A(t[D+2])}},computeVertexNormals:function(){const n=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Cn(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let h=0,f=t.count;h<f;h++)t.setXYZ(h,0,0,0);const r=new Q,s=new Q,i=new Q,o=new Q,a=new Q,l=new Q,c=new Q,u=new Q;if(n)for(let h=0,f=n.count;h<f;h+=3){const d=n.getX(h+0),p=n.getX(h+1),m=n.getX(h+2);r.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),i.fromBufferAttribute(e,m),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),o.fromBufferAttribute(t,d),a.fromBufferAttribute(t,p),l.fromBufferAttribute(t,m),o.add(c),a.add(c),l.add(c),t.setXYZ(d,o.x,o.y,o.z),t.setXYZ(p,a.x,a.y,a.z),t.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,f=e.count;h<f;h+=3)r.fromBufferAttribute(e,h+0),s.fromBufferAttribute(e,h+1),i.fromBufferAttribute(e,h+2),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),t.setXYZ(h+0,c.x,c.y,c.z),t.setXYZ(h+1,c.x,c.y,c.z),t.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(n,e){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const r in t){if(n.attributes[r]===void 0)continue;const i=t[r].array,o=n.attributes[r],a=o.array,l=o.itemSize*e,c=Math.min(a.length,i.length-l);for(let u=0,h=l;u<c;u++,h++)i[h]=a[u]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let e=0,t=n.count;e<t;e++)no.fromBufferAttribute(n,e),no.normalize(),n.setXYZ(e,no.x,no.y,no.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,u=o.normalized,h=new l.constructor(a.length*c);let f=0,d=0;for(let p=0,m=a.length;p<m;p++){f=a[p]*c;for(let g=0;g<c;g++)h[d++]=l[f++]}return new Cn(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new un,t=this.index.array,r=this.attributes;for(const o in r){const a=r[o],l=n(a,t);e.setAttribute(o,l)}const s=this.morphAttributes;for(const o in s){const a=[],l=s[o];for(let c=0,u=l.length;c<u;c++){const h=l[c],f=n(h,t);a.push(f)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let o=0,a=i.length;o<a;o++){const l=i[o];e.addGroup(l.start,l.count,l.materialIndex)}return e},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const e=this.index;e!==null&&(n.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const l=t[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const r={};let s=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let u=0,h=l.length;u<h;u++){const f=l[u],d=f.toJSON(n.data);f.name!==""&&(d.name=f.name),c.push(d)}c.length>0&&(r[a]=c,s=!0)}s&&(n.data.morphAttributes=r,n.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(n.data.groups=JSON.parse(JSON.stringify(i)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new un().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=n.name;const t=n.index;t!==null&&this.setIndex(t.clone(e));const r=n.attributes;for(const l in r){const c=r[l];this.setAttribute(l,c.clone(e))}const s=n.morphAttributes;for(const l in s){const c=[],u=s[l];for(let h=0,f=u.length;h<f;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const i=n.groups;for(let l=0,c=i.length;l<c;l++){const u=i[l];this.addGroup(u.start,u.count,u.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const I8=new Zn,tb=new ux,AP=new Gp,_d=new Q,Sd=new Q,Cd=new Q,MP=new Q,NP=new Q,$P=new Q,XT=new Q,KT=new Q,YT=new Q,ZT=new st,JT=new st,QT=new st,RP=new Q,eE=new Q;function hs(n=new un,e=new Dl){rn.call(this),this.type="Mesh",this.geometry=n,this.material=e,this.updateMorphTargets()}hs.prototype=Object.assign(Object.create(rn.prototype),{constructor:hs,isMesh:!0,copy:function(n){return rn.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,e){const t=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),AP.copy(t.boundingSphere),AP.applyMatrix4(s),n.ray.intersectsSphere(AP)===!1)||(I8.copy(s).invert(),tb.copy(n.ray).applyMatrix4(I8),t.boundingBox!==null&&tb.intersectsBox(t.boundingBox)===!1))return;let i;if(t.isBufferGeometry){const o=t.index,a=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.uv,h=t.attributes.uv2,f=t.groups,d=t.drawRange;if(o!==null)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=x;w<S;w+=3){const C=o.getX(w),k=o.getX(w+1),A=o.getX(w+2);i=tE(this,y,n,tb,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(o.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=o.getX(g),x=o.getX(g+1),w=o.getX(g+2);i=tE(this,r,n,tb,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}else if(a!==void 0)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=x;w<S;w+=3){const C=w,k=w+1,A=w+2;i=tE(this,y,n,tb,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(a.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=g,x=g+1,w=g+2;i=tE(this,r,n,tb,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}}else t.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function bpt(n,e,t,r,s,i,o,a){let l;if(e.side===gi?l=r.intersectTriangle(o,i,s,!0,a):l=r.intersectTriangle(s,i,o,e.side!==BC,a),l===null)return null;eE.copy(a),eE.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(eE);return c<t.near||c>t.far?null:{distance:c,point:eE.clone(),object:n}}function tE(n,e,t,r,s,i,o,a,l,c,u,h){_d.fromBufferAttribute(s,c),Sd.fromBufferAttribute(s,u),Cd.fromBufferAttribute(s,h);const f=n.morphTargetInfluences;if(e.morphTargets&&i&&f){XT.set(0,0,0),KT.set(0,0,0),YT.set(0,0,0);for(let p=0,m=i.length;p<m;p++){const g=f[p],y=i[p];g!==0&&(MP.fromBufferAttribute(y,c),NP.fromBufferAttribute(y,u),$P.fromBufferAttribute(y,h),o?(XT.addScaledVector(MP,g),KT.addScaledVector(NP,g),YT.addScaledVector($P,g)):(XT.addScaledVector(MP.sub(_d),g),KT.addScaledVector(NP.sub(Sd),g),YT.addScaledVector($P.sub(Cd),g)))}_d.add(XT),Sd.add(KT),Cd.add(YT)}n.isSkinnedMesh&&(n.boneTransform(c,_d),n.boneTransform(u,Sd),n.boneTransform(h,Cd));const d=bpt(n,e,t,r,_d,Sd,Cd,RP);if(d){a&&(ZT.fromBufferAttribute(a,c),JT.fromBufferAttribute(a,u),QT.fromBufferAttribute(a,h),d.uv=jo.getUV(RP,_d,Sd,Cd,ZT,JT,QT,new st)),l&&(ZT.fromBufferAttribute(l,c),JT.fromBufferAttribute(l,u),QT.fromBufferAttribute(l,h),d.uv2=jo.getUV(RP,_d,Sd,Cd,ZT,JT,QT,new st));const p=new yV(c,u,h);jo.getNormal(_d,Sd,Cd,p.normal),d.face=p}return d}class Tg extends un{constructor(e=1,t=1,r=1,s=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:s,heightSegments:i,depthSegments:o};const a=this;s=Math.floor(s),i=Math.floor(i),o=Math.floor(o);const l=[],c=[],u=[],h=[];let f=0,d=0;p("z","y","x",-1,-1,r,t,e,o,i,0),p("z","y","x",1,-1,r,t,-e,o,i,1),p("x","z","y",1,1,e,r,t,s,o,2),p("x","z","y",1,-1,e,r,-t,s,o,3),p("x","y","z",1,-1,e,t,r,s,i,4),p("x","y","z",-1,-1,e,t,-r,s,i,5),this.setIndex(l),this.setAttribute("position",new Xt(c,3)),this.setAttribute("normal",new Xt(u,3)),this.setAttribute("uv",new Xt(h,2));function p(m,g,y,b,x,w,S,C,k,A,M){const E=w/k,N=S/A,O=w/2,R=S/2,D=C/2,z=k+1,B=A+1;let X=0,G=0;const te=new Q;for(let ge=0;ge<B;ge++){const ae=ge*N-R;for(let Ne=0;Ne<z;Ne++){const ke=Ne*E-O;te[m]=ke*b,te[g]=ae*x,te[y]=D,c.push(te.x,te.y,te.z),te[m]=0,te[g]=0,te[y]=C>0?1:-1,u.push(te.x,te.y,te.z),h.push(Ne/k),h.push(1-ge/A),X+=1}}for(let ge=0;ge<A;ge++)for(let ae=0;ae<k;ae++){const Ne=f+ae+z*ge,ke=f+ae+z*(ge+1),De=f+(ae+1)+z*(ge+1),be=f+(ae+1)+z*ge;l.push(Ne,ke,be),l.push(ke,De,be),G+=6}a.addGroup(d,G,M),d+=G,f+=X}}}function gv(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const s=n[t][r];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture)?e[t][r]=s.clone():Array.isArray(s)?e[t][r]=s.slice():e[t][r]=s}}return e}function Fo(n){const e={};for(let t=0;t<n.length;t++){const r=gv(n[t]);for(const s in r)e[s]=r[s]}return e}const Sle={clone:gv,merge:Fo};var vpt=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,wpt=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function ka(n){kn.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=vpt,this.fragmentShader=wpt,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}ka.prototype=Object.create(kn.prototype);ka.prototype.constructor=ka;ka.prototype.isShaderMaterial=!0;ka.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=gv(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};ka.prototype.toJSON=function(n){const e=kn.prototype.toJSON.call(this,n);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const i=this.uniforms[r].value;i&&i.isTexture?e.uniforms[r]={type:"t",value:i.toJSON(n).uuid}:i&&i.isColor?e.uniforms[r]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[r]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[r]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[r]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[r]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[r]={type:"m4",value:i.toArray()}:e.uniforms[r]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const t={};for(const r in this.extensions)this.extensions[r]===!0&&(t[r]=!0);return Object.keys(t).length>0&&(e.extensions=t),e};function Eh(){rn.call(this),this.type="Camera",this.matrixWorldInverse=new Zn,this.projectionMatrix=new Zn,this.projectionMatrixInverse=new Zn}Eh.prototype=Object.assign(Object.create(rn.prototype),{constructor:Eh,isCamera:!0,copy:function(n,e){return rn.prototype.copy.call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(n){rn.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,e){rn.prototype.updateWorldMatrix.call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function Si(n=50,e=1,t=.1,r=2e3){Eh.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=t,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}Si.prototype=Object.assign(Object.create(Eh.prototype),{constructor:Si,isPerspectiveCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const e=.5*this.getFilmHeight()/n;this.fov=In.RAD2DEG*2*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(In.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return In.RAD2DEG*2*Math.atan(Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,e,t,r,s,i){this.aspect=n/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let e=n*Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom,t=2*e,r=this.aspect*t,s=-.5*r;const i=this.view;if(this.view!==null&&this.view.enabled){const a=i.fullWidth,l=i.fullHeight;s+=i.offsetX*r/a,e-=i.offsetY*t/l,r*=i.width/a,t*=i.height/l}const o=this.filmOffset;o!==0&&(s+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const nb=90,rb=1;function Eg(n,e,t){if(rn.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const r=new Si(nb,rb,n,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Q(1,0,0)),this.add(r);const s=new Si(nb,rb,n,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new Q(-1,0,0)),this.add(s);const i=new Si(nb,rb,n,e);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new Q(0,1,0)),this.add(i);const o=new Si(nb,rb,n,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new Q(0,-1,0)),this.add(o);const a=new Si(nb,rb,n,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new Q(0,0,1)),this.add(a);const l=new Si(nb,rb,n,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Q(0,0,-1)),this.add(l),this.update=function(c,u){this.parent===null&&this.updateMatrixWorld();const h=c.xr.enabled,f=c.getRenderTarget();c.xr.enabled=!1;const d=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,c.setRenderTarget(t,0),c.render(u,r),c.setRenderTarget(t,1),c.render(u,s),c.setRenderTarget(t,2),c.render(u,i),c.setRenderTarget(t,3),c.render(u,o),c.setRenderTarget(t,4),c.render(u,a),t.texture.generateMipmaps=d,c.setRenderTarget(t,5),c.render(u,l),c.setRenderTarget(f),c.xr.enabled=h}}Eg.prototype=Object.create(rn.prototype);Eg.prototype.constructor=Eg;function Ih(n,e,t,r,s,i,o,a,l,c){n=n!==void 0?n:[],e=e!==void 0?e:UC,o=o!==void 0?o:ep,Kr.call(this,n,e,t,r,s,i,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Ih.prototype=Object.create(Kr.prototype);Ih.prototype.constructor=Ih;Ih.prototype.isCubeTexture=!0;Object.defineProperty(Ih.prototype,"images",{get:function(){return this.image},set:function(n){this.image=n}});class bV extends tp{constructor(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new Ih(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Al,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new Tg(5,5,5),i=new ka({name:"CubemapFromEquirect",uniforms:gv(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:gi,blending:Rf});i.uniforms.tEquirect.value=t;const o=new hs(s,i),a=t.minFilter;return t.minFilter===lx&&(t.minFilter=lo),new Eg(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,s){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,s);e.setRenderTarget(i)}}function zf(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={data:n||null,width:e||1,height:t||1},this.magFilter=l!==void 0?l:Ui,this.minFilter=c!==void 0?c:Ui,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}zf.prototype=Object.create(Kr.prototype);zf.prototype.constructor=zf;zf.prototype.isDataTexture=!0;const sb=new Gp,nE=new Q;class qC{constructor(e,t,r,s,i,o){this.planes=[e!==void 0?e:new ch,t!==void 0?t:new ch,r!==void 0?r:new ch,s!==void 0?s:new ch,i!==void 0?i:new ch,o!==void 0?o:new ch]}set(e,t,r,s,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(s),a[4].copy(i),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e){const t=this.planes,r=e.elements,s=r[0],i=r[1],o=r[2],a=r[3],l=r[4],c=r[5],u=r[6],h=r[7],f=r[8],d=r[9],p=r[10],m=r[11],g=r[12],y=r[13],b=r[14],x=r[15];return t[0].setComponents(a-s,h-l,m-f,x-g).normalize(),t[1].setComponents(a+s,h+l,m+f,x+g).normalize(),t[2].setComponents(a+i,h+c,m+d,x+y).normalize(),t[3].setComponents(a-i,h-c,m-d,x-y).normalize(),t[4].setComponents(a-o,h-u,m-p,x-b).normalize(),t[5].setComponents(a+o,h+u,m+p,x+b).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),sb.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(sb)}intersectsSprite(e){return sb.center.set(0,0,0),sb.radius=.7071067811865476,sb.applyMatrix4(e.matrixWorld),this.intersectsSphere(sb)}intersectsSphere(e){const t=this.planes,r=e.center,s=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(r)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const s=t[r];if(nE.x=s.normal.x>0?e.max.x:e.min.x,nE.y=s.normal.y>0?e.max.y:e.min.y,nE.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(nE)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}}function Cle(){let n=null,e=!1,t=null,r=null;function s(i,o){t(i,o),r=n.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function xpt(n,e){const t=e.isWebGL2,r=new WeakMap;function s(c,u){const h=c.array,f=c.usage,d=n.createBuffer();n.bindBuffer(u,d),n.bufferData(u,h,f),c.onUploadCallback();let p=5126;return h instanceof Float32Array?p=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:h instanceof Int16Array?p=5122:h instanceof Uint32Array?p=5125:h instanceof Int32Array?p=5124:h instanceof Int8Array?p=5120:h instanceof Uint8Array&&(p=5121),{buffer:d,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function i(c,u,h){const f=u.array,d=u.updateRange;n.bindBuffer(h,c),d.count===-1?n.bufferSubData(h,0,f):(t?n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),r.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=r.get(c);u&&(n.deleteBuffer(u.buffer),r.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const f=r.get(c);(!f||f.version<c.version)&&r.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=r.get(c);h===void 0?r.set(c,s(c,u)):h.version<c.version&&(i(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class xS extends un{constructor(e=1,t=1,r=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:s};const i=e/2,o=t/2,a=Math.floor(r),l=Math.floor(s),c=a+1,u=l+1,h=e/a,f=t/l,d=[],p=[],m=[],g=[];for(let y=0;y<u;y++){const b=y*f-o;for(let x=0;x<c;x++){const w=x*h-i;p.push(w,-b,0),m.push(0,0,1),g.push(x/a),g.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const x=b+c*y,w=b+c*(y+1),S=b+1+c*(y+1),C=b+1+c*y;d.push(x,w,C),d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}var _pt=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Spt=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Cpt=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,kpt=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,Tpt=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Ept="vec3 transformed = vec3( position );",Ipt=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Apt=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Mpt=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Npt=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,$pt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Rpt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Ppt=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Dpt=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Opt=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Fpt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Lpt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,zpt=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Bpt=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Vpt=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Upt=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Wpt=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Gpt=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Hpt=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,jpt="gl_FragColor = linearToOutputTexel( gl_FragColor );",qpt=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Xpt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Kpt=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Ypt=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Zpt=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Jpt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Qpt=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,emt=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,tmt=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,nmt=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,rmt=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,smt=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,imt=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,omt=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,amt=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,lmt=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,cmt=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,umt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,hmt=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,fmt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,dmt=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,pmt=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,mmt=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,gmt=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,ymt=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,bmt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,vmt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,wmt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,xmt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,_mt=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,Smt=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Cmt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,kmt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Tmt=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Emt=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Imt=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Amt=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Mmt=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Nmt=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,$mt=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,Rmt=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,Pmt=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Dmt=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,Omt=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Fmt=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Lmt=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,zmt=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Bmt=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Vmt=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Umt=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Wmt=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Gmt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Hmt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,jmt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,qmt=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Xmt=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Kmt=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Ymt=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Zmt=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Jmt=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Qmt=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,egt=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tgt=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,ngt=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,rgt=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,sgt=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,igt=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,ogt=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,agt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,lgt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,cgt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,ugt=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,hgt=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,fgt=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,dgt=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,pgt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,mgt=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,ggt=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,ygt=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,bgt=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,vgt=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,wgt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,xgt=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,_gt=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Sgt=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Cgt=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,kgt=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Tgt=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Egt=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Igt=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Agt=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Mgt=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ngt=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$gt=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Rgt=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Pgt=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Dgt=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Ogt=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Fgt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Lgt=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,zgt=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Bgt=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Vgt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Ugt=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Jn={alphamap_fragment:_pt,alphamap_pars_fragment:Spt,alphatest_fragment:Cpt,aomap_fragment:kpt,aomap_pars_fragment:Tpt,begin_vertex:Ept,beginnormal_vertex:Ipt,bsdfs:Apt,bumpmap_pars_fragment:Mpt,clipping_planes_fragment:Npt,clipping_planes_pars_fragment:$pt,clipping_planes_pars_vertex:Rpt,clipping_planes_vertex:Ppt,color_fragment:Dpt,color_pars_fragment:Opt,color_pars_vertex:Fpt,color_vertex:Lpt,common:zpt,cube_uv_reflection_fragment:Bpt,defaultnormal_vertex:Vpt,displacementmap_pars_vertex:Upt,displacementmap_vertex:Wpt,emissivemap_fragment:Gpt,emissivemap_pars_fragment:Hpt,encodings_fragment:jpt,encodings_pars_fragment:qpt,envmap_fragment:Xpt,envmap_common_pars_fragment:Kpt,envmap_pars_fragment:Ypt,envmap_pars_vertex:Zpt,envmap_physical_pars_fragment:lmt,envmap_vertex:Jpt,fog_vertex:Qpt,fog_pars_vertex:emt,fog_fragment:tmt,fog_pars_fragment:nmt,gradientmap_pars_fragment:rmt,lightmap_fragment:smt,lightmap_pars_fragment:imt,lights_lambert_vertex:omt,lights_pars_begin:amt,lights_toon_fragment:cmt,lights_toon_pars_fragment:umt,lights_phong_fragment:hmt,lights_phong_pars_fragment:fmt,lights_physical_fragment:dmt,lights_physical_pars_fragment:pmt,lights_fragment_begin:mmt,lights_fragment_maps:gmt,lights_fragment_end:ymt,logdepthbuf_fragment:bmt,logdepthbuf_pars_fragment:vmt,logdepthbuf_pars_vertex:wmt,logdepthbuf_vertex:xmt,map_fragment:_mt,map_pars_fragment:Smt,map_particle_fragment:Cmt,map_particle_pars_fragment:kmt,metalnessmap_fragment:Tmt,metalnessmap_pars_fragment:Emt,morphnormal_vertex:Imt,morphtarget_pars_vertex:Amt,morphtarget_vertex:Mmt,normal_fragment_begin:Nmt,normal_fragment_maps:$mt,normalmap_pars_fragment:Rmt,clearcoat_normal_fragment_begin:Pmt,clearcoat_normal_fragment_maps:Dmt,clearcoat_pars_fragment:Omt,packing:Fmt,premultiplied_alpha_fragment:Lmt,project_vertex:zmt,dithering_fragment:Bmt,dithering_pars_fragment:Vmt,roughnessmap_fragment:Umt,roughnessmap_pars_fragment:Wmt,shadowmap_pars_fragment:Gmt,shadowmap_pars_vertex:Hmt,shadowmap_vertex:jmt,shadowmask_pars_fragment:qmt,skinbase_vertex:Xmt,skinning_pars_vertex:Kmt,skinning_vertex:Ymt,skinnormal_vertex:Zmt,specularmap_fragment:Jmt,specularmap_pars_fragment:Qmt,tonemapping_fragment:egt,tonemapping_pars_fragment:tgt,transmissionmap_fragment:ngt,transmissionmap_pars_fragment:rgt,uv_pars_fragment:sgt,uv_pars_vertex:igt,uv_vertex:ogt,uv2_pars_fragment:agt,uv2_pars_vertex:lgt,uv2_vertex:cgt,worldpos_vertex:ugt,background_frag:hgt,background_vert:fgt,cube_frag:dgt,cube_vert:pgt,depth_frag:mgt,depth_vert:ggt,distanceRGBA_frag:ygt,distanceRGBA_vert:bgt,equirect_frag:vgt,equirect_vert:wgt,linedashed_frag:xgt,linedashed_vert:_gt,meshbasic_frag:Sgt,meshbasic_vert:Cgt,meshlambert_frag:kgt,meshlambert_vert:Tgt,meshmatcap_frag:Egt,meshmatcap_vert:Igt,meshtoon_frag:Agt,meshtoon_vert:Mgt,meshphong_frag:Ngt,meshphong_vert:$gt,meshphysical_frag:Rgt,meshphysical_vert:Pgt,normal_frag:Dgt,normal_vert:Ogt,points_frag:Fgt,points_vert:Lgt,shadow_frag:zgt,shadow_vert:Bgt,sprite_frag:Vgt,sprite_vert:Ugt},Pt={common:{diffuse:{value:new Ht(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Cl},uv2Transform:{value:new Cl},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new st(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ht(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Cl}},sprite:{diffuse:{value:new Ht(15658734)},opacity:{value:1},center:{value:new st(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Cl}}},ou={basic:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.fog]),vertexShader:Jn.meshbasic_vert,fragmentShader:Jn.meshbasic_frag},lambert:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)}}]),vertexShader:Jn.meshlambert_vert,fragmentShader:Jn.meshlambert_frag},phong:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)},specular:{value:new Ht(1118481)},shininess:{value:30}}]),vertexShader:Jn.meshphong_vert,fragmentShader:Jn.meshphong_frag},standard:{uniforms:Fo([Pt.common,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.roughnessmap,Pt.metalnessmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag},toon:{uniforms:Fo([Pt.common,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.gradientmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)}}]),vertexShader:Jn.meshtoon_vert,fragmentShader:Jn.meshtoon_frag},matcap:{uniforms:Fo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,{matcap:{value:null}}]),vertexShader:Jn.meshmatcap_vert,fragmentShader:Jn.meshmatcap_frag},points:{uniforms:Fo([Pt.points,Pt.fog]),vertexShader:Jn.points_vert,fragmentShader:Jn.points_frag},dashed:{uniforms:Fo([Pt.common,Pt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Jn.linedashed_vert,fragmentShader:Jn.linedashed_frag},depth:{uniforms:Fo([Pt.common,Pt.displacementmap]),vertexShader:Jn.depth_vert,fragmentShader:Jn.depth_frag},normal:{uniforms:Fo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,{opacity:{value:1}}]),vertexShader:Jn.normal_vert,fragmentShader:Jn.normal_frag},sprite:{uniforms:Fo([Pt.sprite,Pt.fog]),vertexShader:Jn.sprite_vert,fragmentShader:Jn.sprite_frag},background:{uniforms:{uvTransform:{value:new Cl},t2D:{value:null}},vertexShader:Jn.background_vert,fragmentShader:Jn.background_frag},cube:{uniforms:Fo([Pt.envmap,{opacity:{value:1}}]),vertexShader:Jn.cube_vert,fragmentShader:Jn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Jn.equirect_vert,fragmentShader:Jn.equirect_frag},distanceRGBA:{uniforms:Fo([Pt.common,Pt.displacementmap,{referencePosition:{value:new Q},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Jn.distanceRGBA_vert,fragmentShader:Jn.distanceRGBA_frag},shadow:{uniforms:Fo([Pt.lights,Pt.fog,{color:{value:new Ht(0)},opacity:{value:1}}]),vertexShader:Jn.shadow_vert,fragmentShader:Jn.shadow_frag}};ou.physical={uniforms:Fo([ou.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new st(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ht(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag};function Wgt(n,e,t,r,s){const i=new Ht(0);let o=0,a,l,c=null,u=0,h=null;function f(p,m,g,y){let b=m.isScene===!0?m.background:null;b&&b.isTexture&&(b=e.get(b));const x=n.xr,w=x.getSession&&x.getSession();w&&w.environmentBlendMode==="additive"&&(b=null),b===null?d(i,o):b&&b.isColor&&(d(b,1),y=!0),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.isWebGLCubeRenderTarget||b.mapping===ax)?(l===void 0&&(l=new hs(new Tg(1,1,1),new ka({name:"BackgroundCubeMaterial",uniforms:gv(ou.cube.uniforms),vertexShader:ou.cube.vertexShader,fragmentShader:ou.cube.fragmentShader,side:gi,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,C,k){this.matrixWorld.copyPosition(k.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),b.isWebGLCubeRenderTarget&&(b=b.texture),l.material.uniforms.envMap.value=b,l.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b._needsFlipEnvMap?-1:1,(c!==b||u!==b.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):b&&b.isTexture&&(a===void 0&&(a=new hs(new xS(2,2),new ka({name:"BackgroundMaterial",uniforms:gv(ou.background.uniforms),vertexShader:ou.background.vertexShader,fragmentShader:ou.background.fragmentShader,side:ox,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=b,b.matrixAutoUpdate===!0&&b.updateMatrix(),a.material.uniforms.uvTransform.value.copy(b.matrix),(c!==b||u!==b.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function d(p,m){t.buffers.color.setClear(p.r,p.g,p.b,m,s)}return{getClearColor:function(){return i},setClearColor:function(p,m=1){i.set(p),o=m,d(i,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,d(i,o)},render:f}}function Ggt(n,e,t,r){const s=n.getParameter(34921),i=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||i!==null,a={},l=m(null);let c=l;function u(R,D,z,B,X){let G=!1;if(o){const te=p(B,z,D);c!==te&&(c=te,f(c.object)),G=g(B,X),G&&y(B,X)}else{const te=D.wireframe===!0;(c.geometry!==B.id||c.program!==z.id||c.wireframe!==te)&&(c.geometry=B.id,c.program=z.id,c.wireframe=te,G=!0)}R.isInstancedMesh===!0&&(G=!0),X!==null&&t.update(X,34963),G&&(k(R,D,z,B),X!==null&&n.bindBuffer(34963,t.get(X).buffer))}function h(){return r.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function f(R){return r.isWebGL2?n.bindVertexArray(R):i.bindVertexArrayOES(R)}function d(R){return r.isWebGL2?n.deleteVertexArray(R):i.deleteVertexArrayOES(R)}function p(R,D,z){const B=z.wireframe===!0;let X=a[R.id];X===void 0&&(X={},a[R.id]=X);let G=X[D.id];G===void 0&&(G={},X[D.id]=G);let te=G[B];return te===void 0&&(te=m(h()),G[B]=te),te}function m(R){const D=[],z=[],B=[];for(let X=0;X<s;X++)D[X]=0,z[X]=0,B[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:D,enabledAttributes:z,attributeDivisors:B,object:R,attributes:{},index:null}}function g(R,D){const z=c.attributes,B=R.attributes;let X=0;for(const G in B){const te=z[G],ge=B[G];if(te===void 0||te.attribute!==ge||te.data!==ge.data)return!0;X++}return c.attributesNum!==X||c.index!==D}function y(R,D){const z={},B=R.attributes;let X=0;for(const G in B){const te=B[G],ge={};ge.attribute=te,te.data&&(ge.data=te.data),z[G]=ge,X++}c.attributes=z,c.attributesNum=X,c.index=D}function b(){const R=c.newAttributes;for(let D=0,z=R.length;D<z;D++)R[D]=0}function x(R){w(R,0)}function w(R,D){const z=c.newAttributes,B=c.enabledAttributes,X=c.attributeDivisors;z[R]=1,B[R]===0&&(n.enableVertexAttribArray(R),B[R]=1),X[R]!==D&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,D),X[R]=D)}function S(){const R=c.newAttributes,D=c.enabledAttributes;for(let z=0,B=D.length;z<B;z++)D[z]!==R[z]&&(n.disableVertexAttribArray(z),D[z]=0)}function C(R,D,z,B,X,G){r.isWebGL2===!0&&(z===5124||z===5125)?n.vertexAttribIPointer(R,D,z,X,G):n.vertexAttribPointer(R,D,z,B,X,G)}function k(R,D,z,B){if(r.isWebGL2===!1&&(R.isInstancedMesh||B.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const X=B.attributes,G=z.getAttributes(),te=D.defaultAttributeValues;for(const ge in G){const ae=G[ge];if(ae>=0){const Ne=X[ge];if(Ne!==void 0){const ke=Ne.normalized,De=Ne.itemSize,be=t.get(Ne);if(be===void 0)continue;const Xe=be.buffer,Oe=be.type,it=be.bytesPerElement;if(Ne.isInterleavedBufferAttribute){const We=Ne.data,dt=We.stride,ct=Ne.offset;We&&We.isInstancedInterleavedBuffer?(w(ae,We.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=We.meshPerAttribute*We.count)):x(ae),n.bindBuffer(34962,Xe),C(ae,De,Oe,ke,dt*it,ct*it)}else Ne.isInstancedBufferAttribute?(w(ae,Ne.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Ne.meshPerAttribute*Ne.count)):x(ae),n.bindBuffer(34962,Xe),C(ae,De,Oe,ke,0,0)}else if(ge==="instanceMatrix"){const ke=t.get(R.instanceMatrix);if(ke===void 0)continue;const De=ke.buffer,be=ke.type;w(ae+0,1),w(ae+1,1),w(ae+2,1),w(ae+3,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae+0,4,be,!1,64,0),n.vertexAttribPointer(ae+1,4,be,!1,64,16),n.vertexAttribPointer(ae+2,4,be,!1,64,32),n.vertexAttribPointer(ae+3,4,be,!1,64,48)}else if(ge==="instanceColor"){const ke=t.get(R.instanceColor);if(ke===void 0)continue;const De=ke.buffer,be=ke.type;w(ae,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae,3,be,!1,12,0)}else if(te!==void 0){const ke=te[ge];if(ke!==void 0)switch(ke.length){case 2:n.vertexAttrib2fv(ae,ke);break;case 3:n.vertexAttrib3fv(ae,ke);break;case 4:n.vertexAttrib4fv(ae,ke);break;default:n.vertexAttrib1fv(ae,ke)}}}}S()}function A(){N();for(const R in a){const D=a[R];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R]}}function M(R){if(a[R.id]===void 0)return;const D=a[R.id];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R.id]}function E(R){for(const D in a){const z=a[D];if(z[R.id]===void 0)continue;const B=z[R.id];for(const X in B)d(B[X].object),delete B[X];delete z[R.id]}}function N(){O(),c!==l&&(c=l,f(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:N,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:M,releaseStatesOfProgram:E,initAttributes:b,enableAttribute:x,disableUnusedAttributes:S}}function Hgt(n,e,t,r){const s=r.isWebGL2;let i;function o(c){i=c}function a(c,u){n.drawArrays(i,c,u),t.update(u,i,1)}function l(c,u,h){if(h===0)return;let f,d;if(s)f=n,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](i,c,u,h),t.update(u,i,h)}this.setMode=o,this.render=a,this.renderInstances=l}function jgt(n,e,t){let r;function s(){if(r!==void 0)return r;const C=e.get("EXT_texture_filter_anisotropic");return C!==null?r=n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT):r=0,r}function i(C){if(C==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=t.logarithmicDepthBuffer===!0,u=n.getParameter(34930),h=n.getParameter(35660),f=n.getParameter(3379),d=n.getParameter(34076),p=n.getParameter(34921),m=n.getParameter(36347),g=n.getParameter(36348),y=n.getParameter(36349),b=h>0,x=o||!!e.get("OES_texture_float"),w=b&&x,S=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:s,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:f,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:b,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:S}}function qgt(n){const e=this;let t=null,r=0,s=!1,i=!1;const o=new ch,a=new Cl,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f,d){const p=h.length!==0||f||r!==0||s;return s=f,t=u(h,d,0),r=h.length,p},this.beginShadows=function(){i=!0,u(null)},this.endShadows=function(){i=!1,c()},this.setState=function(h,f,d){const p=h.clippingPlanes,m=h.clipIntersection,g=h.clipShadows,y=n.get(h);if(!s||p===null||p.length===0||i&&!g)i?u(null):c();else{const b=i?0:r,x=b*4;let w=y.clippingState||null;l.value=w,w=u(p,f,x,d);for(let S=0;S!==x;++S)w[S]=t[S];y.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(h,f,d,p){const m=h!==null?h.length:0;let g=null;if(m!==0){if(g=l.value,p!==!0||g===null){const y=d+m*4,b=f.matrixWorldInverse;a.getNormalMatrix(b),(g===null||g.length<y)&&(g=new Float32Array(y));for(let x=0,w=d;x!==m;++x,w+=4)o.copy(h[x]).applyMatrix4(b,a),o.normal.toArray(g,w),g[w+3]=o.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}}function Xgt(n){let e=new WeakMap;function t(o,a){return a===AA?o.mapping=UC:a===MA&&(o.mapping=WC),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===AA||a===MA)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderList(),u=n.getRenderTarget(),h=new bV(l.height/2);return h.fromEquirectangularTexture(n,o),e.set(o,h),n.setRenderTarget(u),n.setRenderList(c),o.addEventListener("dispose",s),t(h.texture,o.mapping)}else return null}}return o}function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:r,dispose:i}}function Kgt(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let s;switch(r){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(r)}return e[r]=s,s}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(r){const s=t(r);return s===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),s}}}function Ygt(n,e,t,r){const s={},i=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const p in f.attributes)e.remove(f.attributes[p]);f.removeEventListener("dispose",o),delete s[f.id];const d=i.get(f);d&&(e.remove(d),i.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return s[f.id]===!0||(f.addEventListener("dispose",o),s[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const p in f)e.update(f[p],34962);const d=h.morphAttributes;for(const p in d){const m=d[p];for(let g=0,y=m.length;g<y;g++)e.update(m[g],34962)}}function c(h){const f=[],d=h.index,p=h.attributes.position;let m=0;if(d!==null){const b=d.array;m=d.version;for(let x=0,w=b.length;x<w;x+=3){const S=b[x+0],C=b[x+1],k=b[x+2];f.push(S,C,C,k,k,S)}}else{const b=p.array;m=p.version;for(let x=0,w=b.length/3-1;x<w;x+=3){const S=x+0,C=x+1,k=x+2;f.push(S,C,C,k,k,S)}}const g=new(_le(f)>65535?kg:Cg)(f,1);g.version=m;const y=i.get(h);y&&e.remove(y),i.set(h,g)}function u(h){const f=i.get(h);if(f){const d=h.index;d!==null&&f.version<d.version&&c(h)}else c(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function Zgt(n,e,t,r){const s=r.isWebGL2;let i;function o(f){i=f}let a,l;function c(f){a=f.type,l=f.bytesPerElement}function u(f,d){n.drawElements(i,d,a,f*l),t.update(d,i,1)}function h(f,d,p){if(p===0)return;let m,g;if(s)m=n,g="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](i,d,a,f*l,p),t.update(d,i,p)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function Jgt(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(i,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(i/3);break;case 1:t.lines+=a*(i/2);break;case 3:t.lines+=a*(i-1);break;case 2:t.lines+=a*i;break;case 0:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:r}}function Qgt(n,e){return n[0]-e[0]}function eyt(n,e){return Math.abs(e[1])-Math.abs(n[1])}function tyt(n){const e={},t=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];function s(i,o,a,l){const c=i.morphTargetInfluences,u=c===void 0?0:c.length;let h=e[o.id];if(h===void 0){h=[];for(let g=0;g<u;g++)h[g]=[g,0];e[o.id]=h}for(let g=0;g<u;g++){const y=h[g];y[0]=g,y[1]=c[g]}h.sort(eyt);for(let g=0;g<8;g++)g<u&&h[g][1]?(r[g][0]=h[g][0],r[g][1]=h[g][1]):(r[g][0]=Number.MAX_SAFE_INTEGER,r[g][1]=0);r.sort(Qgt);const f=a.morphTargets&&o.morphAttributes.position,d=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let g=0;g<8;g++){const y=r[g],b=y[0],x=y[1];b!==Number.MAX_SAFE_INTEGER&&x?(f&&o.getAttribute("morphTarget"+g)!==f[b]&&o.setAttribute("morphTarget"+g,f[b]),d&&o.getAttribute("morphNormal"+g)!==d[b]&&o.setAttribute("morphNormal"+g,d[b]),t[g]=x,p+=x):(f&&o.hasAttribute("morphTarget"+g)===!0&&o.deleteAttribute("morphTarget"+g),d&&o.hasAttribute("morphNormal"+g)===!0&&o.deleteAttribute("morphNormal"+g),t[g]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",m),l.getUniforms().setValue(n,"morphTargetInfluences",t)}return{update:s}}function nyt(n,e,t,r){let s=new WeakMap;function i(l){const c=r.render.frame,u=l.geometry,h=e.get(l,u);return s.get(h)!==c&&(e.update(h),s.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){s=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:i,dispose:o}}function yv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Ui,this.minFilter=Ui,this.wrapR=pa,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}yv.prototype=Object.create(Kr.prototype);yv.prototype.constructor=yv;yv.prototype.isDataTexture2DArray=!0;function bv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Ui,this.minFilter=Ui,this.wrapR=pa,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}bv.prototype=Object.create(Kr.prototype);bv.prototype.constructor=bv;bv.prototype.isDataTexture3D=!0;const kle=new Kr,ryt=new yv,syt=new bv,Tle=new Ih,A8=[],M8=[],N8=new Float32Array(16),$8=new Float32Array(9),R8=new Float32Array(4);function fx(n,e,t){const r=n[0];if(r<=0||r>0)return n;const s=e*t;let i=A8[s];if(i===void 0&&(i=new Float32Array(s),A8[s]=i),e!==0){r.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function Nc(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Ol(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function Ele(n,e){let t=M8[e];t===void 0&&(t=new Int32Array(e),M8[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function iyt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function oyt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Nc(t,e))return;n.uniform2fv(this.addr,e),Ol(t,e)}}function ayt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Nc(t,e))return;n.uniform3fv(this.addr,e),Ol(t,e)}}function lyt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Nc(t,e))return;n.uniform4fv(this.addr,e),Ol(t,e)}}function cyt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ol(t,e)}else{if(Nc(t,r))return;R8.set(r),n.uniformMatrix2fv(this.addr,!1,R8),Ol(t,r)}}function uyt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ol(t,e)}else{if(Nc(t,r))return;$8.set(r),n.uniformMatrix3fv(this.addr,!1,$8),Ol(t,r)}}function hyt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ol(t,e)}else{if(Nc(t,r))return;N8.set(r),n.uniformMatrix4fv(this.addr,!1,N8),Ol(t,r)}}function fyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTexture2D(e||kle,s)}function dyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture2DArray(e||ryt,s)}function pyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture3D(e||syt,s)}function myt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTextureCube(e||Tle,s)}function gyt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function yyt(n,e){const t=this.cache;Nc(t,e)||(n.uniform2iv(this.addr,e),Ol(t,e))}function byt(n,e){const t=this.cache;Nc(t,e)||(n.uniform3iv(this.addr,e),Ol(t,e))}function vyt(n,e){const t=this.cache;Nc(t,e)||(n.uniform4iv(this.addr,e),Ol(t,e))}function wyt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function xyt(n){switch(n){case 5126:return iyt;case 35664:return oyt;case 35665:return ayt;case 35666:return lyt;case 35674:return cyt;case 35675:return uyt;case 35676:return hyt;case 5124:case 35670:return gyt;case 35667:case 35671:return yyt;case 35668:case 35672:return byt;case 35669:case 35673:return vyt;case 5125:return wyt;case 35678:case 36198:case 36298:case 36306:case 35682:return fyt;case 35679:case 36299:case 36307:return pyt;case 35680:case 36300:case 36308:case 36293:return myt;case 36289:case 36303:case 36311:case 36292:return dyt}}function _yt(n,e){n.uniform1fv(this.addr,e)}function Syt(n,e){n.uniform1iv(this.addr,e)}function Cyt(n,e){n.uniform2iv(this.addr,e)}function kyt(n,e){n.uniform3iv(this.addr,e)}function Tyt(n,e){n.uniform4iv(this.addr,e)}function Eyt(n,e){const t=fx(e,this.size,2);n.uniform2fv(this.addr,t)}function Iyt(n,e){const t=fx(e,this.size,3);n.uniform3fv(this.addr,t)}function Ayt(n,e){const t=fx(e,this.size,4);n.uniform4fv(this.addr,t)}function Myt(n,e){const t=fx(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Nyt(n,e){const t=fx(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function $yt(n,e){const t=fx(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Ryt(n,e,t){const r=e.length,s=Ele(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTexture2D(e[i]||kle,s[i])}function Pyt(n,e,t){const r=e.length,s=Ele(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTextureCube(e[i]||Tle,s[i])}function Dyt(n){switch(n){case 5126:return _yt;case 35664:return Eyt;case 35665:return Iyt;case 35666:return Ayt;case 35674:return Myt;case 35675:return Nyt;case 35676:return $yt;case 5124:case 35670:return Syt;case 35667:case 35671:return Cyt;case 35668:case 35672:return kyt;case 35669:case 35673:return Tyt;case 35678:case 36198:case 36298:case 36306:case 35682:return Ryt;case 35680:case 36300:case 36308:case 36293:return Pyt}}function Oyt(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=xyt(e.type)}function Ile(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Dyt(e.type)}Ile.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Ol(e,n)};function Ale(n){this.id=n,this.seq=[],this.map={}}Ale.prototype.setValue=function(n,e,t){const r=this.seq;for(let s=0,i=r.length;s!==i;++s){const o=r[s];o.setValue(n,e[o.id],t)}};const PP=/(\w+)(\])?(\[|\.)?/g;function P8(n,e){n.seq.push(e),n.map[e.id]=e}function Fyt(n,e,t){const r=n.name,s=r.length;for(PP.lastIndex=0;;){const i=PP.exec(r),o=PP.lastIndex;let a=i[1];const l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===s){P8(t,c===void 0?new Oyt(a,n,e):new Ile(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new Ale(a),P8(t,h)),t=h}}}function np(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let r=0;r<t;++r){const s=n.getActiveUniform(e,r),i=n.getUniformLocation(e,s.name);Fyt(s,i,this)}}np.prototype.setValue=function(n,e,t,r){const s=this.map[e];s!==void 0&&s.setValue(n,t,r)};np.prototype.setOptional=function(n,e,t){const r=e[t];r!==void 0&&this.setValue(n,t,r)};np.upload=function(n,e,t,r){for(let s=0,i=e.length;s!==i;++s){const o=e[s],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,r)}};np.seqWithValue=function(n,e){const t=[];for(let r=0,s=n.length;r!==s;++r){const i=n[r];i.id in e&&t.push(i)}return t};function D8(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}let Lyt=0;function zyt(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function Mle(n){switch(n){case Ca:return["Linear","( value )"];case HC:return["sRGB","( value )"];case O$:return["RGBE","( value )"];case dV:return["RGBM","( value, 7.0 )"];case pV:return["RGBM","( value, 16.0 )"];case mV:return["RGBD","( value, 256.0 )"];case D$:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case gle:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function O8(n,e,t){const r=n.getShaderParameter(e,35713),s=n.getShaderInfoLog(e).trim();if(r&&s==="")return"";const i=n.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+s+zyt(i)}function c1(n,e){const t=Mle(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Byt(n,e){const t=Mle(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Vyt(n,e){let t;switch(e){case mae:t="Linear";break;case gae:t="Reinhard";break;case yae:t="OptimizedCineon";break;case bae:t="ACESFilmic";break;case vae:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Uyt(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(B1).join(`
`)}function Wyt(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function Gyt(n,e){const t={},r=n.getProgramParameter(e,35721);for(let s=0;s<r;s++){const o=n.getActiveAttrib(e,s).name;t[o]=n.getAttribLocation(e,o)}return t}function B1(n){return n!==""}function F8(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function L8(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Hyt=/^[ \t]*#include +<([\w\d./]+)>/gm;function HF(n){return n.replace(Hyt,jyt)}function jyt(n,e){const t=Jn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return HF(t)}const qyt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Xyt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function z8(n){return n.replace(Xyt,Nle).replace(qyt,Kyt)}function Kyt(n,e,t,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Nle(n,e,t,r)}function Nle(n,e,t,r){let s="";for(let i=parseInt(e);i<parseInt(t);i++)s+=r.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return s}function B8(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Yyt(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===aV?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===qoe?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Tb&&(e="SHADOWMAP_TYPE_VSM"),e}function Zyt(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case UC:case WC:e="ENVMAP_TYPE_CUBE";break;case ax:case GC:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Jyt(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case WC:case GC:e="ENVMAP_MODE_REFRACTION";break}return e}function Qyt(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case VC:e="ENVMAP_BLENDING_MULTIPLY";break;case dae:e="ENVMAP_BLENDING_MIX";break;case pae:e="ENVMAP_BLENDING_ADD";break}return e}function e0t(n,e,t,r){const s=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Yyt(t),c=Zyt(t),u=Jyt(t),h=Qyt(t),f=n.gammaFactor>0?n.gammaFactor:1,d=t.isWebGL2?"":Uyt(t),p=Wyt(i),m=s.createProgram();let g,y,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=[p].filter(B1).join(`
`),g.length>0&&(g+=`
`),y=[d,p].filter(B1).join(`
`),y.length>0&&(y+=`
`)):(g=[B8(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(B1).join(`
`),y=[d,B8(t),"#define SHADER_NAME "+t.shaderName,p,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==rg?"#define TONE_MAPPING":"",t.toneMapping!==rg?Jn.tonemapping_pars_fragment:"",t.toneMapping!==rg?Vyt("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",Jn.encodings_pars_fragment,t.map?c1("mapTexelToLinear",t.mapEncoding):"",t.matcap?c1("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?c1("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?c1("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?c1("lightMapTexelToLinear",t.lightMapEncoding):"",Byt("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(B1).join(`
`)),o=HF(o),o=F8(o,t),o=L8(o,t),a=HF(a),a=F8(a,t),a=L8(a,t),o=z8(o),a=z8(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,g=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,y=["#define varying in",t.glslVersion===GF?"":"out highp vec4 pc_fragColor;",t.glslVersion===GF?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const x=b+g+o,w=b+y+a,S=D8(s,35633,x),C=D8(s,35632,w);if(s.attachShader(m,S),s.attachShader(m,C),t.index0AttributeName!==void 0?s.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(m,0,"position"),s.linkProgram(m),n.debug.checkShaderErrors){const M=s.getProgramInfoLog(m).trim(),E=s.getShaderInfoLog(S).trim(),N=s.getShaderInfoLog(C).trim();let O=!0,R=!0;if(s.getProgramParameter(m,35714)===!1){O=!1;const D=O8(s,S,"vertex"),z=O8(s,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",s.getError(),"35715",s.getProgramParameter(m,35715),"gl.getProgramInfoLog",M,D,z)}else M!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",M):(E===""||N==="")&&(R=!1);R&&(this.diagnostics={runnable:O,programLog:M,vertexShader:{log:E,prefix:g},fragmentShader:{log:N,prefix:y}})}s.deleteShader(S),s.deleteShader(C);let k;this.getUniforms=function(){return k===void 0&&(k=new np(s,m)),k};let A;return this.getAttributes=function(){return A===void 0&&(A=Gyt(s,m)),A},this.destroy=function(){r.releaseStatesOfProgram(this),s.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Lyt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=C,this}function t0t(n,e,t,r,s,i){const o=[],a=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,h=r.vertexTextures;let f=r.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(C){const A=C.skeleton.bones;if(c)return 1024;{const E=Math.floor((u-20)/4),N=Math.min(E,A.length);return N<A.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+A.length+" bones. This GPU supports "+N+"."),0):N}}function g(C){let k;return C&&C.isTexture?k=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),k=C.texture.encoding):k=Ca,k}function y(C,k,A,M,E){const N=M.fog,O=C.isMeshStandardMaterial?M.environment:null,R=e.get(C.envMap||O),D=d[C.type],z=E.isSkinnedMesh?m(E):0;C.precision!==null&&(f=r.getMaxPrecision(C.precision),f!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",f,"instead."));let B,X;if(D){const ge=ou[D];B=ge.vertexShader,X=ge.fragmentShader}else B=C.vertexShader,X=C.fragmentShader;const G=n.getRenderTarget();return{isWebGL2:a,shaderID:D,shaderName:C.type,vertexShader:B,fragmentShader:X,defines:C.defines,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:f,instancing:E.isInstancedMesh===!0,instancingColor:E.isInstancedMesh===!0&&E.instanceColor!==null,supportsVertexTextures:h,outputEncoding:G!==null?g(G.texture):n.outputEncoding,map:!!C.map,mapEncoding:g(C.map),matcap:!!C.matcap,matcapEncoding:g(C.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:g(R),envMapCubeUV:!!R&&(R.mapping===ax||R.mapping===GC),lightMap:!!C.lightMap,lightMapEncoding:g(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:g(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===vle,tangentSpaceNormalMap:C.normalMapType===n0,clearcoatMap:!!C.clearcoatMap,clearcoatRoughnessMap:!!C.clearcoatRoughnessMap,clearcoatNormalMap:!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,alphaMap:!!C.alphaMap,gradientMap:!!C.gradientMap,sheen:!!C.sheen,transmissionMap:!!C.transmissionMap,combine:C.combine,vertexTangents:C.normalMap&&C.vertexTangents,vertexColors:C.vertexColors,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap,uvsVertexOnly:!(C.map||C.bumpMap||C.normalMap||C.specularMap||C.alphaMap||C.emissiveMap||C.roughnessMap||C.metalnessMap||C.clearcoatNormalMap||C.transmissionMap)&&!!C.displacementMap,fog:!!N,useFog:C.fog,fogExp2:N&&N.isFogExp2,flatShading:C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:l,skinning:C.skinning&&z>0,maxBones:z,useVertexTexture:c,morphTargets:C.morphTargets,morphNormals:C.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:C.dithering,shadowMapEnabled:n.shadowMap.enabled&&A.length>0,shadowMapType:n.shadowMap.type,toneMapping:C.toneMapped?n.toneMapping:rg,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,alphaTest:C.alphaTest,doubleSided:C.side===BC,flipSided:C.side===gi,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||t.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function b(C){const k=[];if(C.shaderID?k.push(C.shaderID):(k.push(C.fragmentShader),k.push(C.vertexShader)),C.defines!==void 0)for(const A in C.defines)k.push(A),k.push(C.defines[A]);if(C.isRawShaderMaterial===!1){for(let A=0;A<p.length;A++)k.push(C[p[A]]);k.push(n.outputEncoding),k.push(n.gammaFactor)}return k.push(C.customProgramCacheKey),k.join()}function x(C){const k=d[C.type];let A;if(k){const M=ou[k];A=Sle.clone(M.uniforms)}else A=C.uniforms;return A}function w(C,k){let A;for(let M=0,E=o.length;M<E;M++){const N=o[M];if(N.cacheKey===k){A=N,++A.usedTimes;break}}return A===void 0&&(A=new e0t(n,k,C,s),o.push(A)),A}function S(C){if(--C.usedTimes===0){const k=o.indexOf(C);o[k]=o[o.length-1],o.pop(),C.destroy()}}return{getParameters:y,getProgramCacheKey:b,getUniforms:x,acquireProgram:w,releaseProgram:S,programs:o}}function n0t(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function r(i,o,a){n.get(i)[o]=a}function s(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:s}}function r0t(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function s0t(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function V8(n){const e=[];let t=0;const r=[],s=[],i={id:-1};function o(){t=0,r.length=0,s.length=0}function a(f,d,p,m,g,y){let b=e[t];const x=n.get(p);return b===void 0?(b={id:f.id,object:f,geometry:d,material:p,program:x.program||i,groupOrder:m,renderOrder:f.renderOrder,z:g,group:y},e[t]=b):(b.id=f.id,b.object=f,b.geometry=d,b.material=p,b.program=x.program||i,b.groupOrder=m,b.renderOrder=f.renderOrder,b.z=g,b.group=y),t++,b}function l(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).push(b)}function c(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).unshift(b)}function u(f,d){r.length>1&&r.sort(f||r0t),s.length>1&&s.sort(d||s0t)}function h(){for(let f=t,d=e.length;f<d;f++){const p=e[f];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:r,transparent:s,init:o,push:l,unshift:c,finish:h,sort:u}}function i0t(n){let e=new WeakMap;function t(s,i){const o=e.get(s);let a;return o===void 0?(a=new V8(n),e.set(s,new WeakMap),e.get(s).set(i,a)):(a=o.get(i),a===void 0&&(a=new V8(n),o.set(i,a))),a}function r(){e=new WeakMap}return{get:t,dispose:r}}function o0t(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Q,color:new Ht};break;case"SpotLight":t={position:new Q,direction:new Q,color:new Ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Q,color:new Ht,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Q,skyColor:new Ht,groundColor:new Ht};break;case"RectAreaLight":t={color:new Ht,position:new Q,halfWidth:new Q,halfHeight:new Q};break}return n[e.id]=t,t}}}function a0t(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let l0t=0;function c0t(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function u0t(n,e){const t=new o0t,r=a0t(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)s.probe.push(new Q);const i=new Q,o=new Zn,a=new Zn;function l(u){let h=0,f=0,d=0;for(let k=0;k<9;k++)s.probe[k].set(0,0,0);let p=0,m=0,g=0,y=0,b=0,x=0,w=0,S=0;u.sort(c0t);for(let k=0,A=u.length;k<A;k++){const M=u[k],E=M.color,N=M.intensity,O=M.distance,R=M.shadow&&M.shadow.map?M.shadow.map.texture:null;if(M.isAmbientLight)h+=E.r*N,f+=E.g*N,d+=E.b*N;else if(M.isLightProbe)for(let D=0;D<9;D++)s.probe[D].addScaledVector(M.sh.coefficients[D],N);else if(M.isDirectionalLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.directionalShadow[p]=B,s.directionalShadowMap[p]=R,s.directionalShadowMatrix[p]=M.shadow.matrix,x++}s.directional[p]=D,p++}else if(M.isSpotLight){const D=t.get(M);if(D.position.setFromMatrixPosition(M.matrixWorld),D.color.copy(E).multiplyScalar(N),D.distance=O,D.coneCos=Math.cos(M.angle),D.penumbraCos=Math.cos(M.angle*(1-M.penumbra)),D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.spotShadow[g]=B,s.spotShadowMap[g]=R,s.spotShadowMatrix[g]=M.shadow.matrix,S++}s.spot[g]=D,g++}else if(M.isRectAreaLight){const D=t.get(M);D.color.copy(E).multiplyScalar(N),D.halfWidth.set(M.width*.5,0,0),D.halfHeight.set(0,M.height*.5,0),s.rectArea[y]=D,y++}else if(M.isPointLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),D.distance=M.distance,D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,B.shadowCameraNear=z.camera.near,B.shadowCameraFar=z.camera.far,s.pointShadow[m]=B,s.pointShadowMap[m]=R,s.pointShadowMatrix[m]=M.shadow.matrix,w++}s.point[m]=D,m++}else if(M.isHemisphereLight){const D=t.get(M);D.skyColor.copy(M.color).multiplyScalar(N),D.groundColor.copy(M.groundColor).multiplyScalar(N),s.hemi[b]=D,b++}}y>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Pt.LTC_FLOAT_1,s.rectAreaLTC2=Pt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Pt.LTC_HALF_1,s.rectAreaLTC2=Pt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=h,s.ambient[1]=f,s.ambient[2]=d;const C=s.hash;(C.directionalLength!==p||C.pointLength!==m||C.spotLength!==g||C.rectAreaLength!==y||C.hemiLength!==b||C.numDirectionalShadows!==x||C.numPointShadows!==w||C.numSpotShadows!==S)&&(s.directional.length=p,s.spot.length=g,s.rectArea.length=y,s.point.length=m,s.hemi.length=b,s.directionalShadow.length=x,s.directionalShadowMap.length=x,s.pointShadow.length=w,s.pointShadowMap.length=w,s.spotShadow.length=S,s.spotShadowMap.length=S,s.directionalShadowMatrix.length=x,s.pointShadowMatrix.length=w,s.spotShadowMatrix.length=S,C.directionalLength=p,C.pointLength=m,C.spotLength=g,C.rectAreaLength=y,C.hemiLength=b,C.numDirectionalShadows=x,C.numPointShadows=w,C.numSpotShadows=S,s.version=l0t++)}function c(u,h){let f=0,d=0,p=0,m=0,g=0;const y=h.matrixWorldInverse;for(let b=0,x=u.length;b<x;b++){const w=u[b];if(w.isDirectionalLight){const S=s.directional[f];S.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(i),S.direction.transformDirection(y),f++}else if(w.isSpotLight){const S=s.spot[p];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),S.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(i),S.direction.transformDirection(y),p++}else if(w.isRectAreaLight){const S=s.rectArea[m];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),a.identity(),o.copy(w.matrixWorld),o.premultiply(y),a.extractRotation(o),S.halfWidth.set(w.width*.5,0,0),S.halfHeight.set(0,w.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const S=s.point[d];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),d++}else if(w.isHemisphereLight){const S=s.hemi[g];S.direction.setFromMatrixPosition(w.matrixWorld),S.direction.transformDirection(y),S.direction.normalize(),g++}}}return{setup:l,setupView:c,state:s}}function U8(n,e){const t=new u0t(n,e),r=[],s=[];function i(){r.length=0,s.length=0}function o(h){r.push(h)}function a(h){s.push(h)}function l(){t.setup(r)}function c(h){t.setupView(r,h)}return{init:i,state:{lightsArray:r,shadowsArray:s,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function h0t(n,e){let t=new WeakMap;function r(i,o=0){let a;return t.has(i)===!1?(a=new U8(n,e),t.set(i,[]),t.get(i).push(a)):o>=t.get(i).length?(a=new U8(n,e),t.get(i).push(a)):a=t.get(i)[o],a}function s(){t=new WeakMap}return{get:r,dispose:s}}function wp(n){kn.call(this),this.type="MeshDepthMaterial",this.depthPacking=yle,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(n)}wp.prototype=Object.create(kn.prototype);wp.prototype.constructor=wp;wp.prototype.isMeshDepthMaterial=!0;wp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.depthPacking=n.depthPacking,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this};function xp(n){kn.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Q,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(n)}xp.prototype=Object.create(kn.prototype);xp.prototype.constructor=xp;xp.prototype.isMeshDistanceMaterial=!0;xp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this};var f0t=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,d0t=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function $le(n,e,t){let r=new qC;const s=new st,i=new st,o=new Hr,a=[],l=[],c={},u={0:gi,1:ox,2:BC},h=new ka({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new st},radius:{value:4}},vertexShader:d0t,fragmentShader:f0t}),f=h.clone();f.defines.HORIZONTAL_PASS=1;const d=new un;d.setAttribute("position",new Cn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new hs(d,h),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=aV,this.render=function(S,C,k){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||S.length===0)return;const A=n.getRenderTarget(),M=n.getActiveCubeFace(),E=n.getActiveMipmapLevel(),N=n.state;N.setBlending(Rf),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let O=0,R=S.length;O<R;O++){const D=S[O],z=D.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",D,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;s.copy(z.mapSize);const B=z.getFrameExtents();if(s.multiply(B),i.copy(z.mapSize),(s.x>t||s.y>t)&&(s.x>t&&(i.x=Math.floor(t/B.x),s.x=i.x*B.x,z.mapSize.x=i.x),s.y>t&&(i.y=Math.floor(t/B.y),s.y=i.y*B.y,z.mapSize.y=i.y)),z.map===null&&!z.isPointLightShadow&&this.type===Tb){const G={minFilter:lo,magFilter:lo,format:Al};z.map=new tp(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.mapPass=new tp(s.x,s.y,G),z.camera.updateProjectionMatrix()}if(z.map===null){const G={minFilter:Ui,magFilter:Ui,format:Al};z.map=new tp(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.camera.updateProjectionMatrix()}n.setRenderTarget(z.map),n.clear();const X=z.getViewportCount();for(let G=0;G<X;G++){const te=z.getViewport(G);o.set(i.x*te.x,i.y*te.y,i.x*te.z,i.y*te.w),N.viewport(o),z.updateMatrices(D,G),r=z.getFrustum(),w(C,k,z.camera,D,this.type)}!z.isPointLightShadow&&this.type===Tb&&g(z,k),z.needsUpdate=!1}m.needsUpdate=!1,n.setRenderTarget(A,M,E)};function g(S,C){const k=e.update(p);h.uniforms.shadow_pass.value=S.map.texture,h.uniforms.resolution.value=S.mapSize,h.uniforms.radius.value=S.radius,n.setRenderTarget(S.mapPass),n.clear(),n.renderBufferDirect(C,null,k,h,p,null),f.uniforms.shadow_pass.value=S.mapPass.texture,f.uniforms.resolution.value=S.mapSize,f.uniforms.radius.value=S.radius,n.setRenderTarget(S.map),n.clear(),n.renderBufferDirect(C,null,k,f,p,null)}function y(S,C,k){const A=S<<0|C<<1|k<<2;let M=a[A];return M===void 0&&(M=new wp({depthPacking:ble,morphTargets:S,skinning:C}),a[A]=M),M}function b(S,C,k){const A=S<<0|C<<1|k<<2;let M=l[A];return M===void 0&&(M=new xp({morphTargets:S,skinning:C}),l[A]=M),M}function x(S,C,k,A,M,E,N){let O=null,R=y,D=S.customDepthMaterial;if(A.isPointLight===!0&&(R=b,D=S.customDistanceMaterial),D===void 0){let z=!1;k.morphTargets===!0&&(z=C.morphAttributes&&C.morphAttributes.position&&C.morphAttributes.position.length>0);let B=!1;S.isSkinnedMesh===!0&&(k.skinning===!0?B=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",S));const X=S.isInstancedMesh===!0;O=R(z,B,X)}else O=D;if(n.localClippingEnabled&&k.clipShadows===!0&&k.clippingPlanes.length!==0){const z=O.uuid,B=k.uuid;let X=c[z];X===void 0&&(X={},c[z]=X);let G=X[B];G===void 0&&(G=O.clone(),X[B]=G),O=G}return O.visible=k.visible,O.wireframe=k.wireframe,N===Tb?O.side=k.shadowSide!==null?k.shadowSide:k.side:O.side=k.shadowSide!==null?k.shadowSide:u[k.side],O.clipShadows=k.clipShadows,O.clippingPlanes=k.clippingPlanes,O.clipIntersection=k.clipIntersection,O.wireframeLinewidth=k.wireframeLinewidth,O.linewidth=k.linewidth,A.isPointLight===!0&&O.isMeshDistanceMaterial===!0&&(O.referencePosition.setFromMatrixPosition(A.matrixWorld),O.nearDistance=M,O.farDistance=E),O}function w(S,C,k,A,M){if(S.visible===!1)return;if(S.layers.test(C.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&M===Tb)&&(!S.frustumCulled||r.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,S.matrixWorld);const O=e.update(S),R=S.material;if(Array.isArray(R)){const D=O.groups;for(let z=0,B=D.length;z<B;z++){const X=D[z],G=R[X.materialIndex];if(G&&G.visible){const te=x(S,O,G,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,te,S,X)}}}else if(R.visible){const D=x(S,O,R,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,D,S,null)}}const N=S.children;for(let O=0,R=N.length;O<R;O++)w(N[O],C,k,A,M)}}function p0t(n,e,t){const r=t.isWebGL2;function s(){let ye=!1;const Ze=new Hr;let yt=null;const Ct=new Hr(0,0,0,0);return{setMask:function(ft){yt!==ft&&!ye&&(n.colorMask(ft,ft,ft,ft),yt=ft)},setLocked:function(ft){ye=ft},setClear:function(ft,ce,nt,St,gt){gt===!0&&(ft*=St,ce*=St,nt*=St),Ze.set(ft,ce,nt,St),Ct.equals(Ze)===!1&&(n.clearColor(ft,ce,nt,St),Ct.copy(Ze))},reset:function(){ye=!1,yt=null,Ct.set(-1,0,0,0)}}}function i(){let ye=!1,Ze=null,yt=null,Ct=null;return{setTest:function(ft){ft?ge(2929):ae(2929)},setMask:function(ft){Ze!==ft&&!ye&&(n.depthMask(ft),Ze=ft)},setFunc:function(ft){if(yt!==ft){if(ft)switch(ft){case oae:n.depthFunc(512);break;case aae:n.depthFunc(519);break;case lae:n.depthFunc(513);break;case IA:n.depthFunc(515);break;case cae:n.depthFunc(514);break;case uae:n.depthFunc(518);break;case hae:n.depthFunc(516);break;case fae:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);yt=ft}},setLocked:function(ft){ye=ft},setClear:function(ft){Ct!==ft&&(n.clearDepth(ft),Ct=ft)},reset:function(){ye=!1,Ze=null,yt=null,Ct=null}}}function o(){let ye=!1,Ze=null,yt=null,Ct=null,ft=null,ce=null,nt=null,St=null,gt=null;return{setTest:function(Gt){ye||(Gt?ge(2960):ae(2960))},setMask:function(Gt){Ze!==Gt&&!ye&&(n.stencilMask(Gt),Ze=Gt)},setFunc:function(Gt,Mn,Cr){(yt!==Gt||Ct!==Mn||ft!==Cr)&&(n.stencilFunc(Gt,Mn,Cr),yt=Gt,Ct=Mn,ft=Cr)},setOp:function(Gt,Mn,Cr){(ce!==Gt||nt!==Mn||St!==Cr)&&(n.stencilOp(Gt,Mn,Cr),ce=Gt,nt=Mn,St=Cr)},setLocked:function(Gt){ye=Gt},setClear:function(Gt){gt!==Gt&&(n.clearStencil(Gt),gt=Gt)},reset:function(){ye=!1,Ze=null,yt=null,Ct=null,ft=null,ce=null,nt=null,St=null,gt=null}}}const a=new s,l=new i,c=new o;let u={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,S=null,C=null,k=null,A=null,M=null;const E=n.getParameter(35661);let N=!1,O=0;const R=n.getParameter(7938);R.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(R)[1]),N=O>=1):R.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),N=O>=2);let D=null,z={};const B=new Hr,X=new Hr;function G(ye,Ze,yt){const Ct=new Uint8Array(4),ft=n.createTexture();n.bindTexture(ye,ft),n.texParameteri(ye,10241,9728),n.texParameteri(ye,10240,9728);for(let ce=0;ce<yt;ce++)n.texImage2D(Ze+ce,0,6408,1,1,0,6408,5121,Ct);return ft}const te={};te[3553]=G(3553,3553,1),te[34067]=G(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ge(2929),l.setFunc(IA),Oe(!1),it(IF),ge(2884),be(Rf);function ge(ye){u[ye]!==!0&&(n.enable(ye),u[ye]=!0)}function ae(ye){u[ye]!==!1&&(n.disable(ye),u[ye]=!1)}function Ne(ye){return h!==ye?(n.useProgram(ye),h=ye,!0):!1}const ke={[Vm]:32774,[Koe]:32778,[Yoe]:32779};if(r)ke[$F]=32775,ke[RF]=32776;else{const ye=e.get("EXT_blend_minmax");ye!==null&&(ke[$F]=ye.MIN_EXT,ke[RF]=ye.MAX_EXT)}const De={[Zoe]:0,[Joe]:1,[Qoe]:768,[cV]:770,[iae]:776,[rae]:774,[tae]:772,[eae]:769,[uV]:771,[sae]:775,[nae]:773};function be(ye,Ze,yt,Ct,ft,ce,nt,St){if(ye===Rf){f&&(ae(3042),f=!1);return}if(f||(ge(3042),f=!0),ye!==Xoe){if(ye!==d||St!==w){if((p!==Vm||y!==Vm)&&(n.blendEquation(32774),p=Vm,y=Vm),St)switch(ye){case Lb:n.blendFuncSeparate(1,771,1,771);break;case AF:n.blendFunc(1,1);break;case MF:n.blendFuncSeparate(0,0,769,771);break;case NF:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}else switch(ye){case Lb:n.blendFuncSeparate(770,771,1,771);break;case AF:n.blendFunc(770,1);break;case MF:n.blendFunc(0,769);break;case NF:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}m=null,g=null,b=null,x=null,d=ye,w=St}return}ft=ft||Ze,ce=ce||yt,nt=nt||Ct,(Ze!==p||ft!==y)&&(n.blendEquationSeparate(ke[Ze],ke[ft]),p=Ze,y=ft),(yt!==m||Ct!==g||ce!==b||nt!==x)&&(n.blendFuncSeparate(De[yt],De[Ct],De[ce],De[nt]),m=yt,g=Ct,b=ce,x=nt),d=ye,w=null}function Xe(ye,Ze){ye.side===BC?ae(2884):ge(2884);let yt=ye.side===gi;Ze&&(yt=!yt),Oe(yt),ye.blending===Lb&&ye.transparent===!1?be(Rf):be(ye.blending,ye.blendEquation,ye.blendSrc,ye.blendDst,ye.blendEquationAlpha,ye.blendSrcAlpha,ye.blendDstAlpha,ye.premultipliedAlpha),l.setFunc(ye.depthFunc),l.setTest(ye.depthTest),l.setMask(ye.depthWrite),a.setMask(ye.colorWrite);const Ct=ye.stencilWrite;c.setTest(Ct),Ct&&(c.setMask(ye.stencilWriteMask),c.setFunc(ye.stencilFunc,ye.stencilRef,ye.stencilFuncMask),c.setOp(ye.stencilFail,ye.stencilZFail,ye.stencilZPass)),dt(ye.polygonOffset,ye.polygonOffsetFactor,ye.polygonOffsetUnits)}function Oe(ye){S!==ye&&(ye?n.frontFace(2304):n.frontFace(2305),S=ye)}function it(ye){ye!==Hoe?(ge(2884),ye!==C&&(ye===IF?n.cullFace(1029):ye===joe?n.cullFace(1028):n.cullFace(1032))):ae(2884),C=ye}function We(ye){ye!==k&&(N&&n.lineWidth(ye),k=ye)}function dt(ye,Ze,yt){ye?(ge(32823),(A!==Ze||M!==yt)&&(n.polygonOffset(Ze,yt),A=Ze,M=yt)):ae(32823)}function ct(ye){ye?ge(3089):ae(3089)}function Ve(ye){ye===void 0&&(ye=33984+E-1),D!==ye&&(n.activeTexture(ye),D=ye)}function ze(ye,Ze){D===null&&Ve();let yt=z[D];yt===void 0&&(yt={type:void 0,texture:void 0},z[D]=yt),(yt.type!==ye||yt.texture!==Ze)&&(n.bindTexture(ye,Ze||te[ye]),yt.type=ye,yt.texture=Ze)}function Be(){const ye=z[D];ye!==void 0&&ye.type!==void 0&&(n.bindTexture(ye.type,null),ye.type=void 0,ye.texture=void 0)}function ut(){try{n.compressedTexImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function Ke(){try{n.texImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function ee(){try{n.texImage3D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function J(ye){B.equals(ye)===!1&&(n.scissor(ye.x,ye.y,ye.z,ye.w),B.copy(ye))}function rt(ye){X.equals(ye)===!1&&(n.viewport(ye.x,ye.y,ye.z,ye.w),X.copy(ye))}function Ge(){u={},D=null,z={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,S=null,C=null,k=null,A=null,M=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:ge,disable:ae,useProgram:Ne,setBlending:be,setMaterial:Xe,setFlipSided:Oe,setCullFace:it,setLineWidth:We,setPolygonOffset:dt,setScissorTest:ct,activeTexture:Ve,bindTexture:ze,unbindTexture:Be,compressedTexImage2D:ut,texImage2D:Ke,texImage3D:ee,scissor:J,viewport:rt,reset:Ge}}function m0t(n,e,t,r,s,i,o){const a=s.isWebGL2,l=s.maxTextures,c=s.maxCubemapSize,u=s.maxTextureSize,h=s.maxSamples,f=new WeakMap;let d,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(ee,J){return p?new OffscreenCanvas(ee,J):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(ee,J,rt,Ge){let ye=1;if((ee.width>Ge||ee.height>Ge)&&(ye=Ge/Math.max(ee.width,ee.height)),ye<1||J===!0)if(typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ee instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ee instanceof ImageBitmap){const Ze=J?In.floorPowerOfTwo:Math.floor,yt=Ze(ye*ee.width),Ct=Ze(ye*ee.height);d===void 0&&(d=m(yt,Ct));const ft=rt?m(yt,Ct):d;return ft.width=yt,ft.height=Ct,ft.getContext("2d").drawImage(ee,0,0,yt,Ct),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ee.width+"x"+ee.height+") to ("+yt+"x"+Ct+")."),ft}else return"data"in ee&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ee.width+"x"+ee.height+")."),ee;return ee}function y(ee){return In.isPowerOfTwo(ee.width)&&In.isPowerOfTwo(ee.height)}function b(ee){return a?!1:ee.wrapS!==pa||ee.wrapT!==pa||ee.minFilter!==Ui&&ee.minFilter!==lo}function x(ee,J){return ee.generateMipmaps&&J&&ee.minFilter!==Ui&&ee.minFilter!==lo}function w(ee,J,rt,Ge){n.generateMipmap(ee);const ye=r.get(J);ye.__maxMipLevel=Math.log(Math.max(rt,Ge))*Math.LOG2E}function S(ee,J,rt){if(a===!1)return J;if(ee!==null){if(n[ee]!==void 0)return n[ee];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ee+"'")}let Ge=J;return J===6403&&(rt===5126&&(Ge=33326),rt===5131&&(Ge=33325),rt===5121&&(Ge=33321)),J===6407&&(rt===5126&&(Ge=34837),rt===5131&&(Ge=34843),rt===5121&&(Ge=32849)),J===6408&&(rt===5126&&(Ge=34836),rt===5131&&(Ge=34842),rt===5121&&(Ge=32856)),(Ge===33325||Ge===33326||Ge===34842||Ge===34836)&&e.get("EXT_color_buffer_float"),Ge}function C(ee){return ee===Ui||ee===NA||ee===$A?9728:9729}function k(ee){const J=ee.target;J.removeEventListener("dispose",k),M(J),J.isVideoTexture&&f.delete(J),o.memory.textures--}function A(ee){const J=ee.target;J.removeEventListener("dispose",A),E(J),o.memory.textures--}function M(ee){const J=r.get(ee);J.__webglInit!==void 0&&(n.deleteTexture(J.__webglTexture),r.remove(ee))}function E(ee){const J=r.get(ee),rt=r.get(ee.texture);if(ee){if(rt.__webglTexture!==void 0&&n.deleteTexture(rt.__webglTexture),ee.depthTexture&&ee.depthTexture.dispose(),ee.isWebGLCubeRenderTarget)for(let Ge=0;Ge<6;Ge++)n.deleteFramebuffer(J.__webglFramebuffer[Ge]),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer[Ge]);else n.deleteFramebuffer(J.__webglFramebuffer),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&n.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer&&n.deleteRenderbuffer(J.__webglColorRenderbuffer),J.__webglDepthRenderbuffer&&n.deleteRenderbuffer(J.__webglDepthRenderbuffer);r.remove(ee.texture),r.remove(ee)}}let N=0;function O(){N=0}function R(){const ee=N;return ee>=l&&console.warn("THREE.WebGLTextures: Trying to use "+ee+" texture units while this GPU supports only "+l),N+=1,ee}function D(ee,J){const rt=r.get(ee);if(ee.isVideoTexture&&Ve(ee),ee.version>0&&rt.__version!==ee.version){const Ge=ee.image;if(Ge===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ne(rt,ee,J);return}}t.activeTexture(33984+J),t.bindTexture(3553,rt.__webglTexture)}function z(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){Ne(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(35866,rt.__webglTexture)}function B(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){Ne(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(32879,rt.__webglTexture)}function X(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){ke(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(34067,rt.__webglTexture)}const G={[lS]:10497,[pa]:33071,[cS]:33648},te={[Ui]:9728,[NA]:9984,[$A]:9986,[lo]:9729,[hV]:9985,[lx]:9987};function ge(ee,J,rt){rt?(n.texParameteri(ee,10242,G[J.wrapS]),n.texParameteri(ee,10243,G[J.wrapT]),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,G[J.wrapR]),n.texParameteri(ee,10240,te[J.magFilter]),n.texParameteri(ee,10241,te[J.minFilter])):(n.texParameteri(ee,10242,33071),n.texParameteri(ee,10243,33071),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,33071),(J.wrapS!==pa||J.wrapT!==pa)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(ee,10240,C(J.magFilter)),n.texParameteri(ee,10241,C(J.minFilter)),J.minFilter!==Ui&&J.minFilter!==lo&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const Ge=e.get("EXT_texture_filter_anisotropic");if(Ge){if(J.type===If&&e.get("OES_texture_float_linear")===null||J.type===hS&&(a||e.get("OES_texture_half_float_linear"))===null)return;(J.anisotropy>1||r.get(J).__currentAnisotropy)&&(n.texParameterf(ee,Ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(J.anisotropy,s.getMaxAnisotropy())),r.get(J).__currentAnisotropy=J.anisotropy)}}function ae(ee,J){ee.__webglInit===void 0&&(ee.__webglInit=!0,J.addEventListener("dispose",k),ee.__webglTexture=n.createTexture(),o.memory.textures++)}function Ne(ee,J,rt){let Ge=3553;J.isDataTexture2DArray&&(Ge=35866),J.isDataTexture3D&&(Ge=32879),ae(ee,J),t.activeTexture(33984+rt),t.bindTexture(Ge,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const ye=b(J)&&y(J.image)===!1,Ze=g(J.image,ye,!1,u),yt=y(Ze)||a,Ct=i.convert(J.format);let ft=i.convert(J.type),ce=S(J.internalFormat,Ct,ft);ge(Ge,J,yt);let nt;const St=J.mipmaps;if(J.isDepthTexture)ce=6402,a?J.type===If?ce=36012:J.type===c_?ce=33190:J.type===zb?ce=35056:ce=33189:J.type===If&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),J.format===sg&&ce===6402&&J.type!==uS&&J.type!==c_&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),J.type=uS,ft=i.convert(J.type)),J.format===mv&&ce===6402&&(ce=34041,J.type!==zb&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),J.type=zb,ft=i.convert(J.type))),t.texImage2D(3553,0,ce,Ze.width,Ze.height,0,Ct,ft,null);else if(J.isDataTexture)if(St.length>0&&yt){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],t.texImage2D(3553,gt,ce,nt.width,nt.height,0,Ct,ft,nt.data);J.generateMipmaps=!1,ee.__maxMipLevel=St.length-1}else t.texImage2D(3553,0,ce,Ze.width,Ze.height,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(J.isCompressedTexture){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],J.format!==Al&&J.format!==ep?Ct!==null?t.compressedTexImage2D(3553,gt,ce,nt.width,nt.height,0,nt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,gt,ce,nt.width,nt.height,0,Ct,ft,nt.data);ee.__maxMipLevel=St.length-1}else if(J.isDataTexture2DArray)t.texImage3D(35866,0,ce,Ze.width,Ze.height,Ze.depth,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(J.isDataTexture3D)t.texImage3D(32879,0,ce,Ze.width,Ze.height,Ze.depth,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(St.length>0&&yt){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],t.texImage2D(3553,gt,ce,Ct,ft,nt);J.generateMipmaps=!1,ee.__maxMipLevel=St.length-1}else t.texImage2D(3553,0,ce,Ct,ft,Ze),ee.__maxMipLevel=0;x(J,yt)&&w(Ge,J,Ze.width,Ze.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function ke(ee,J,rt){if(J.image.length!==6)return;ae(ee,J),t.activeTexture(33984+rt),t.bindTexture(34067,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const Ge=J&&(J.isCompressedTexture||J.image[0].isCompressedTexture),ye=J.image[0]&&J.image[0].isDataTexture,Ze=[];for(let gt=0;gt<6;gt++)!Ge&&!ye?Ze[gt]=g(J.image[gt],!1,!0,c):Ze[gt]=ye?J.image[gt].image:J.image[gt];const yt=Ze[0],Ct=y(yt)||a,ft=i.convert(J.format),ce=i.convert(J.type),nt=S(J.internalFormat,ft,ce);ge(34067,J,Ct);let St;if(Ge){for(let gt=0;gt<6;gt++){St=Ze[gt].mipmaps;for(let Gt=0;Gt<St.length;Gt++){const Mn=St[Gt];J.format!==Al&&J.format!==ep?ft!==null?t.compressedTexImage2D(34069+gt,Gt,nt,Mn.width,Mn.height,0,Mn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+gt,Gt,nt,Mn.width,Mn.height,0,ft,ce,Mn.data)}}ee.__maxMipLevel=St.length-1}else{St=J.mipmaps;for(let gt=0;gt<6;gt++)if(ye){t.texImage2D(34069+gt,0,nt,Ze[gt].width,Ze[gt].height,0,ft,ce,Ze[gt].data);for(let Gt=0;Gt<St.length;Gt++){const Cr=St[Gt].image[gt].image;t.texImage2D(34069+gt,Gt+1,nt,Cr.width,Cr.height,0,ft,ce,Cr.data)}}else{t.texImage2D(34069+gt,0,nt,ft,ce,Ze[gt]);for(let Gt=0;Gt<St.length;Gt++){const Mn=St[Gt];t.texImage2D(34069+gt,Gt+1,nt,ft,ce,Mn.image[gt])}}ee.__maxMipLevel=St.length}x(J,Ct)&&w(34067,J,yt.width,yt.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function De(ee,J,rt,Ge){const ye=i.convert(J.texture.format),Ze=i.convert(J.texture.type),yt=S(J.texture.internalFormat,ye,Ze);t.texImage2D(Ge,0,yt,J.width,J.height,0,ye,Ze,null),n.bindFramebuffer(36160,ee),n.framebufferTexture2D(36160,rt,Ge,r.get(J.texture).__webglTexture,0),n.bindFramebuffer(36160,null)}function be(ee,J,rt){if(n.bindRenderbuffer(36161,ee),J.depthBuffer&&!J.stencilBuffer){let Ge=33189;if(rt){const ye=J.depthTexture;ye&&ye.isDepthTexture&&(ye.type===If?Ge=36012:ye.type===c_&&(Ge=33190));const Ze=ct(J);n.renderbufferStorageMultisample(36161,Ze,Ge,J.width,J.height)}else n.renderbufferStorage(36161,Ge,J.width,J.height);n.framebufferRenderbuffer(36160,36096,36161,ee)}else if(J.depthBuffer&&J.stencilBuffer){if(rt){const Ge=ct(J);n.renderbufferStorageMultisample(36161,Ge,35056,J.width,J.height)}else n.renderbufferStorage(36161,34041,J.width,J.height);n.framebufferRenderbuffer(36160,33306,36161,ee)}else{const Ge=i.convert(J.texture.format),ye=i.convert(J.texture.type),Ze=S(J.texture.internalFormat,Ge,ye);if(rt){const yt=ct(J);n.renderbufferStorageMultisample(36161,yt,Ze,J.width,J.height)}else n.renderbufferStorage(36161,Ze,J.width,J.height)}n.bindRenderbuffer(36161,null)}function Xe(ee,J){if(J&&J.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,ee),!(J.depthTexture&&J.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(J.depthTexture).__webglTexture||J.depthTexture.image.width!==J.width||J.depthTexture.image.height!==J.height)&&(J.depthTexture.image.width=J.width,J.depthTexture.image.height=J.height,J.depthTexture.needsUpdate=!0),D(J.depthTexture,0);const Ge=r.get(J.depthTexture).__webglTexture;if(J.depthTexture.format===sg)n.framebufferTexture2D(36160,36096,3553,Ge,0);else if(J.depthTexture.format===mv)n.framebufferTexture2D(36160,33306,3553,Ge,0);else throw new Error("Unknown depthTexture format")}function Oe(ee){const J=r.get(ee),rt=ee.isWebGLCubeRenderTarget===!0;if(ee.depthTexture){if(rt)throw new Error("target.depthTexture not supported in Cube render targets");Xe(J.__webglFramebuffer,ee)}else if(rt){J.__webglDepthbuffer=[];for(let Ge=0;Ge<6;Ge++)n.bindFramebuffer(36160,J.__webglFramebuffer[Ge]),J.__webglDepthbuffer[Ge]=n.createRenderbuffer(),be(J.__webglDepthbuffer[Ge],ee,!1)}else n.bindFramebuffer(36160,J.__webglFramebuffer),J.__webglDepthbuffer=n.createRenderbuffer(),be(J.__webglDepthbuffer,ee,!1);n.bindFramebuffer(36160,null)}function it(ee){const J=r.get(ee),rt=r.get(ee.texture);ee.addEventListener("dispose",A),rt.__webglTexture=n.createTexture(),o.memory.textures++;const Ge=ee.isWebGLCubeRenderTarget===!0,ye=ee.isWebGLMultisampleRenderTarget===!0,Ze=y(ee)||a;if(a&&ee.texture.format===ep&&(ee.texture.type===If||ee.texture.type===hS)&&(ee.texture.format=Al,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Ge){J.__webglFramebuffer=[];for(let yt=0;yt<6;yt++)J.__webglFramebuffer[yt]=n.createFramebuffer()}else if(J.__webglFramebuffer=n.createFramebuffer(),ye)if(a){J.__webglMultisampledFramebuffer=n.createFramebuffer(),J.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,J.__webglColorRenderbuffer);const yt=i.convert(ee.texture.format),Ct=i.convert(ee.texture.type),ft=S(ee.texture.internalFormat,yt,Ct),ce=ct(ee);n.renderbufferStorageMultisample(36161,ce,ft,ee.width,ee.height),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,J.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),ee.depthBuffer&&(J.__webglDepthRenderbuffer=n.createRenderbuffer(),be(J.__webglDepthRenderbuffer,ee,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Ge){t.bindTexture(34067,rt.__webglTexture),ge(34067,ee.texture,Ze);for(let yt=0;yt<6;yt++)De(J.__webglFramebuffer[yt],ee,36064,34069+yt);x(ee.texture,Ze)&&w(34067,ee.texture,ee.width,ee.height),t.bindTexture(34067,null)}else t.bindTexture(3553,rt.__webglTexture),ge(3553,ee.texture,Ze),De(J.__webglFramebuffer,ee,36064,3553),x(ee.texture,Ze)&&w(3553,ee.texture,ee.width,ee.height),t.bindTexture(3553,null);ee.depthBuffer&&Oe(ee)}function We(ee){const J=ee.texture,rt=y(ee)||a;if(x(J,rt)){const Ge=ee.isWebGLCubeRenderTarget?34067:3553,ye=r.get(J).__webglTexture;t.bindTexture(Ge,ye),w(Ge,J,ee.width,ee.height),t.bindTexture(Ge,null)}}function dt(ee){if(ee.isWebGLMultisampleRenderTarget)if(a){const J=r.get(ee);n.bindFramebuffer(36008,J.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,J.__webglFramebuffer);const rt=ee.width,Ge=ee.height;let ye=16384;ee.depthBuffer&&(ye|=256),ee.stencilBuffer&&(ye|=1024),n.blitFramebuffer(0,0,rt,Ge,0,0,rt,Ge,ye,9728),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function ct(ee){return a&&ee.isWebGLMultisampleRenderTarget?Math.min(h,ee.samples):0}function Ve(ee){const J=o.render.frame;f.get(ee)!==J&&(f.set(ee,J),ee.update())}let ze=!1,Be=!1;function ut(ee,J){ee&&ee.isWebGLRenderTarget&&(ze===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ze=!0),ee=ee.texture),D(ee,J)}function Ke(ee,J){ee&&ee.isWebGLCubeRenderTarget&&(Be===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Be=!0),ee=ee.texture),X(ee,J)}this.allocateTextureUnit=R,this.resetTextureUnits=O,this.setTexture2D=D,this.setTexture2DArray=z,this.setTexture3D=B,this.setTextureCube=X,this.setupRenderTarget=it,this.updateRenderTargetMipmap=We,this.updateMultisampleRenderTarget=dt,this.safeSetTexture2D=ut,this.safeSetTextureCube=Ke}function Rle(n,e,t){const r=t.isWebGL2;function s(i){let o;if(i===cx)return 5121;if(i===Sae)return 32819;if(i===Cae)return 32820;if(i===kae)return 33635;if(i===wae)return 5120;if(i===xae)return 5122;if(i===uS)return 5123;if(i===_ae)return 5124;if(i===c_)return 5125;if(i===If)return 5126;if(i===hS)return r?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===Tae)return 6406;if(i===ep)return 6407;if(i===Al)return 6408;if(i===Eae)return 6409;if(i===Iae)return 6410;if(i===sg)return 6402;if(i===mv)return 34041;if(i===Mae)return 6403;if(i===Nae)return 36244;if(i===$ae)return 33319;if(i===Rae)return 33320;if(i===Pae)return 36248;if(i===Dae)return 36249;if(i===PF||i===DF||i===OF||i===FF)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(i===PF)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===DF)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===OF)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===FF)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===LF||i===zF||i===BF||i===VF)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(i===LF)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===zF)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===BF)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===VF)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===Oae)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===UF||i===WF)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(i===UF)return o.COMPRESSED_RGB8_ETC2;if(i===WF)return o.COMPRESSED_RGBA8_ETC2_EAC}if(i===Fae||i===Lae||i===zae||i===Bae||i===Vae||i===Uae||i===Wae||i===Gae||i===Hae||i===jae||i===qae||i===Xae||i===Kae||i===Yae||i===Jae||i===Qae||i===ele||i===tle||i===nle||i===rle||i===sle||i===ile||i===ole||i===ale||i===lle||i===cle||i===ule||i===hle)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?i:null;if(i===Zae)return o=e.get("EXT_texture_compression_bptc"),o!==null?i:null;if(i===zb)return r?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:s}}function RA(n=[]){Si.call(this),this.cameras=n}RA.prototype=Object.assign(Object.create(Si.prototype),{constructor:RA,isArrayCamera:!0});function Gd(){rn.call(this),this.type="Group"}Gd.prototype=Object.assign(Object.create(rn.prototype),{constructor:Gd,isGroup:!0});function h_(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(h_.prototype,{constructor:h_,getHandSpace:function(){return this._hand===null&&(this._hand=new Gd,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Gd,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Gd,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,e,t){let r=null,s=null,i=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&e.session.visibilityState!=="visible-blurred")if(l&&n.hand){i=!0;for(const p of n.hand.values()){const m=e.getJointPose(p,t);if(l.joints[p.jointName]===void 0){const y=new Gd;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[p.jointName]=y,l.add(y)}const g=l.joints[p.jointName];m!==null&&(g.matrix.fromArray(m.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=m.radius),g.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),f=.02,d=.005;l.inputState.pinching&&h>f+d?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&h<=f-d&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(r=e.getPose(n.targetRaySpace,t),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(s=e.getPose(n.gripSpace,t),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=r!==null),a!==null&&(a.visible=s!==null),l!==null&&(l.visible=i!==null),this}});function Ple(n,e){const t=this;let r=null,s=1,i=null,o="local-floor",a=null;const l=[],c=new Map,u=new Si;u.layers.enable(1),u.viewport=new Hr;const h=new Si;h.layers.enable(2),h.viewport=new Hr;const f=[u,h],d=new RA;d.layers.enable(1),d.layers.enable(2);let p=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(E){let N=l[E];return N===void 0&&(N=new h_,l[E]=N),N.getTargetRaySpace()},this.getControllerGrip=function(E){let N=l[E];return N===void 0&&(N=new h_,l[E]=N),N.getGripSpace()},this.getHand=function(E){let N=l[E];return N===void 0&&(N=new h_,l[E]=N),N.getHandSpace()};function g(E){const N=c.get(E.inputSource);N&&N.dispatchEvent({type:E.type,data:E.inputSource})}function y(){c.forEach(function(E,N){E.disconnect(N)}),c.clear(),p=null,m=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),M.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(E){s=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(E){o=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return r},this.setSession=async function(E){if(r=E,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",y),r.addEventListener("inputsourceschange",b);const N=e.getContextAttributes();N.xrCompatible!==!0&&await e.makeXRCompatible();const O={antialias:N.antialias,alpha:N.alpha,depth:N.depth,stencil:N.stencil,framebufferScaleFactor:s},R=new XRWebGLLayer(r,e,O);r.updateRenderState({baseLayer:R}),i=await r.requestReferenceSpace(o),M.setContext(r),M.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}};function b(E){const N=r.inputSources;for(let O=0;O<l.length;O++)c.set(N[O],l[O]);for(let O=0;O<E.removed.length;O++){const R=E.removed[O],D=c.get(R);D&&(D.dispatchEvent({type:"disconnected",data:R}),c.delete(R))}for(let O=0;O<E.added.length;O++){const R=E.added[O],D=c.get(R);D&&D.dispatchEvent({type:"connected",data:R})}}const x=new Q,w=new Q;function S(E,N,O){x.setFromMatrixPosition(N.matrixWorld),w.setFromMatrixPosition(O.matrixWorld);const R=x.distanceTo(w),D=N.projectionMatrix.elements,z=O.projectionMatrix.elements,B=D[14]/(D[10]-1),X=D[14]/(D[10]+1),G=(D[9]+1)/D[5],te=(D[9]-1)/D[5],ge=(D[8]-1)/D[0],ae=(z[8]+1)/z[0],Ne=B*ge,ke=B*ae,De=R/(-ge+ae),be=De*-ge;N.matrixWorld.decompose(E.position,E.quaternion,E.scale),E.translateX(be),E.translateZ(De),E.matrixWorld.compose(E.position,E.quaternion,E.scale),E.matrixWorldInverse.copy(E.matrixWorld).invert();const Xe=B+De,Oe=X+De,it=Ne-be,We=ke+(R-be),dt=G*X/Oe*Xe,ct=te*X/Oe*Xe;E.projectionMatrix.makePerspective(it,We,dt,ct,Xe,Oe)}function C(E,N){N===null?E.matrixWorld.copy(E.matrix):E.matrixWorld.multiplyMatrices(N.matrixWorld,E.matrix),E.matrixWorldInverse.copy(E.matrixWorld).invert()}this.getCamera=function(E){d.near=h.near=u.near=E.near,d.far=h.far=u.far=E.far,(p!==d.near||m!==d.far)&&(r.updateRenderState({depthNear:d.near,depthFar:d.far}),p=d.near,m=d.far);const N=E.parent,O=d.cameras;C(d,N);for(let D=0;D<O.length;D++)C(O[D],N);E.matrixWorld.copy(d.matrixWorld),E.matrix.copy(d.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale);const R=E.children;for(let D=0,z=R.length;D<z;D++)R[D].updateMatrixWorld(!0);return O.length===2?S(d,u,h):d.projectionMatrix.copy(u.projectionMatrix),d};let k=null;function A(E,N){if(a=N.getViewerPose(i),a!==null){const R=a.views,D=r.renderState.baseLayer;n.setFramebuffer(D.framebuffer);let z=!1;R.length!==d.cameras.length&&(d.cameras.length=0,z=!0);for(let B=0;B<R.length;B++){const X=R[B],G=D.getViewport(X),te=f[B];te.matrix.fromArray(X.transform.matrix),te.projectionMatrix.fromArray(X.projectionMatrix),te.viewport.set(G.x,G.y,G.width,G.height),B===0&&d.matrix.copy(te.matrix),z===!0&&d.cameras.push(te)}}const O=r.inputSources;for(let R=0;R<l.length;R++){const D=l[R],z=O[R];D.update(z,N,i)}k&&k(E,N)}const M=new Cle;M.setAnimationLoop(A),this.setAnimationLoop=function(E){k=E},this.dispose=function(){}}Object.assign(Ple.prototype,Gu.prototype);function g0t(n){function e(y,b){y.fogColor.value.copy(b.color),b.isFog?(y.fogNear.value=b.near,y.fogFar.value=b.far):b.isFogExp2&&(y.fogDensity.value=b.density)}function t(y,b,x,w){b.isMeshBasicMaterial?r(y,b):b.isMeshLambertMaterial?(r(y,b),l(y,b)):b.isMeshToonMaterial?(r(y,b),u(y,b)):b.isMeshPhongMaterial?(r(y,b),c(y,b)):b.isMeshStandardMaterial?(r(y,b),b.isMeshPhysicalMaterial?f(y,b):h(y,b)):b.isMeshMatcapMaterial?(r(y,b),d(y,b)):b.isMeshDepthMaterial?(r(y,b),p(y,b)):b.isMeshDistanceMaterial?(r(y,b),m(y,b)):b.isMeshNormalMaterial?(r(y,b),g(y,b)):b.isLineBasicMaterial?(s(y,b),b.isLineDashedMaterial&&i(y,b)):b.isPointsMaterial?o(y,b,x,w):b.isSpriteMaterial?a(y,b):b.isShadowMaterial?(y.color.value.copy(b.color),y.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(y,b){y.opacity.value=b.opacity,b.color&&y.diffuse.value.copy(b.color),b.emissive&&y.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap),b.specularMap&&(y.specularMap.value=b.specularMap);const x=n.get(b).envMap;if(x){y.envMap.value=x,y.flipEnvMap.value=x.isCubeTexture&&x._needsFlipEnvMap?-1:1,y.reflectivity.value=b.reflectivity,y.refractionRatio.value=b.refractionRatio;const C=n.get(x).__maxMipLevel;C!==void 0&&(y.maxMipLevel.value=C)}b.lightMap&&(y.lightMap.value=b.lightMap,y.lightMapIntensity.value=b.lightMapIntensity),b.aoMap&&(y.aoMap.value=b.aoMap,y.aoMapIntensity.value=b.aoMapIntensity);let w;b.map?w=b.map:b.specularMap?w=b.specularMap:b.displacementMap?w=b.displacementMap:b.normalMap?w=b.normalMap:b.bumpMap?w=b.bumpMap:b.roughnessMap?w=b.roughnessMap:b.metalnessMap?w=b.metalnessMap:b.alphaMap?w=b.alphaMap:b.emissiveMap?w=b.emissiveMap:b.clearcoatMap?w=b.clearcoatMap:b.clearcoatNormalMap?w=b.clearcoatNormalMap:b.clearcoatRoughnessMap&&(w=b.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),y.uvTransform.value.copy(w.matrix));let S;b.aoMap?S=b.aoMap:b.lightMap&&(S=b.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uv2Transform.value.copy(S.matrix))}function s(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity}function i(y,b){y.dashSize.value=b.dashSize,y.totalSize.value=b.dashSize+b.gapSize,y.scale.value=b.scale}function o(y,b,x,w){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.size.value=b.size*x,y.scale.value=w*.5,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let S;b.map?S=b.map:b.alphaMap&&(S=b.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uvTransform.value.copy(S.matrix))}function a(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.rotation.value=b.rotation,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let x;b.map?x=b.map:b.alphaMap&&(x=b.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),y.uvTransform.value.copy(x.matrix))}function l(y,b){b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap)}function c(y,b){y.specular.value.copy(b.specular),y.shininess.value=Math.max(b.shininess,1e-4),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function u(y,b){b.gradientMap&&(y.gradientMap.value=b.gradientMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function h(y,b){y.roughness.value=b.roughness,y.metalness.value=b.metalness,b.roughnessMap&&(y.roughnessMap.value=b.roughnessMap),b.metalnessMap&&(y.metalnessMap.value=b.metalnessMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),n.get(b).envMap&&(y.envMapIntensity.value=b.envMapIntensity)}function f(y,b){h(y,b),y.reflectivity.value=b.reflectivity,y.clearcoat.value=b.clearcoat,y.clearcoatRoughness.value=b.clearcoatRoughness,b.sheen&&y.sheen.value.copy(b.sheen),b.clearcoatMap&&(y.clearcoatMap.value=b.clearcoatMap),b.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap),b.clearcoatNormalMap&&(y.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),y.clearcoatNormalMap.value=b.clearcoatNormalMap,b.side===gi&&y.clearcoatNormalScale.value.negate()),y.transmission.value=b.transmission,b.transmissionMap&&(y.transmissionMap.value=b.transmissionMap)}function d(y,b){b.matcap&&(y.matcap.value=b.matcap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function p(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function m(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),y.referencePosition.value.copy(b.referencePosition),y.nearDistance.value=b.nearDistance,y.farDistance.value=b.farDistance}function g(y,b){b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function y0t(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function XC(n){n=n||{};const e=n.canvas!==void 0?n.canvas:y0t(),t=n.context!==void 0?n.context:null,r=n.alpha!==void 0?n.alpha:!1,s=n.depth!==void 0?n.depth:!0,i=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,f=null;const d=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Ca,this.physicallyCorrectLights=!1,this.toneMapping=rg,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let m=!1,g=null,y=0,b=0,x=null,w=null,S=-1,C=null;const k=new Hr,A=new Hr;let M=null,E=e.width,N=e.height,O=1,R=null,D=null;const z=new Hr(0,0,E,N),B=new Hr(0,0,E,N);let X=!1;const G=new qC;let te=!1,ge=!1;const ae=new Zn,Ne=new Q,ke={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function De(){return x===null?O:1}let be=t;function Xe(re,Ue){for(let Fe=0;Fe<re.length;Fe++){const Je=re[Fe],vt=e.getContext(Je,Ue);if(vt!==null)return vt}return null}try{const re={alpha:r,depth:s,stencil:i,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",Mn,!1),e.addEventListener("webglcontextrestored",Cr,!1),be===null){const Ue=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&Ue.shift(),be=Xe(Ue,re),be===null)throw Xe(Ue)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}be.getShaderPrecisionFormat===void 0&&(be.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(re){throw console.error("THREE.WebGLRenderer: "+re.message),re}let Oe,it,We,dt,ct,Ve,ze,Be,ut,Ke,ee,J,rt,Ge,ye,Ze,yt,Ct,ft,ce,nt;function St(){Oe=new Kgt(be),it=new jgt(be,Oe,n),Oe.init(it),ce=new Rle(be,Oe,it),We=new p0t(be,Oe,it),We.scissor(A.copy(B).multiplyScalar(O).floor()),We.viewport(k.copy(z).multiplyScalar(O).floor()),dt=new Jgt,ct=new n0t,Ve=new m0t(be,Oe,We,ct,it,ce,dt),ze=new Xgt(p),Be=new xpt(be,it),nt=new Ggt(be,Oe,Be,it),ut=new Ygt(be,Be,dt,nt),Ke=new nyt(be,ut,Be,dt),yt=new tyt(be),ye=new qgt(ct),ee=new t0t(p,ze,Oe,it,nt,ye),J=new g0t(ct),rt=new i0t(ct),Ge=new h0t(Oe,it),Ze=new Wgt(p,ze,We,Ke,a),Ct=new Hgt(be,Oe,dt,it),ft=new Zgt(be,Oe,dt,it),dt.programs=ee.programs,p.capabilities=it,p.extensions=Oe,p.properties=ct,p.renderLists=rt,p.state=We,p.info=dt}St();const gt=new Ple(p,be);this.xr=gt;const Gt=new $le(p,Ke,it.maxTextureSize);this.shadowMap=Gt,this.getContext=function(){return be},this.getContextAttributes=function(){return be.getContextAttributes()},this.forceContextLoss=function(){const re=Oe.get("WEBGL_lose_context");re&&re.loseContext()},this.forceContextRestore=function(){const re=Oe.get("WEBGL_lose_context");re&&re.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(re){re!==void 0&&(O=re,this.setSize(E,N,!1))},this.getSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),re=new st),re.set(E,N)},this.setSize=function(re,Ue,Fe){if(gt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}E=re,N=Ue,e.width=Math.floor(re*O),e.height=Math.floor(Ue*O),Fe!==!1&&(e.style.width=re+"px",e.style.height=Ue+"px"),this.setViewport(0,0,re,Ue)},this.getDrawingBufferSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),re=new st),re.set(E*O,N*O).floor()},this.setDrawingBufferSize=function(re,Ue,Fe){E=re,N=Ue,O=Fe,e.width=Math.floor(re*Fe),e.height=Math.floor(Ue*Fe),this.setViewport(0,0,re,Ue)},this.getCurrentViewport=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),re=new Hr),re.copy(k)},this.getViewport=function(re){return re.copy(z)},this.setViewport=function(re,Ue,Fe,Je){re.isVector4?z.set(re.x,re.y,re.z,re.w):z.set(re,Ue,Fe,Je),We.viewport(k.copy(z).multiplyScalar(O).floor())},this.getScissor=function(re){return re.copy(B)},this.setScissor=function(re,Ue,Fe,Je){re.isVector4?B.set(re.x,re.y,re.z,re.w):B.set(re,Ue,Fe,Je),We.scissor(A.copy(B).multiplyScalar(O).floor())},this.getScissorTest=function(){return X},this.setScissorTest=function(re){We.setScissorTest(X=re)},this.setOpaqueSort=function(re){R=re},this.setTransparentSort=function(re){D=re},this.getClearColor=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),re=new Ht),re.copy(Ze.getClearColor())},this.setClearColor=function(){Ze.setClearColor.apply(Ze,arguments)},this.getClearAlpha=function(){return Ze.getClearAlpha()},this.setClearAlpha=function(){Ze.setClearAlpha.apply(Ze,arguments)},this.clear=function(re,Ue,Fe){let Je=0;(re===void 0||re)&&(Je|=16384),(Ue===void 0||Ue)&&(Je|=256),(Fe===void 0||Fe)&&(Je|=1024),be.clear(Je)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Mn,!1),e.removeEventListener("webglcontextrestored",Cr,!1),rt.dispose(),Ge.dispose(),ct.dispose(),ze.dispose(),Ke.dispose(),nt.dispose(),gt.dispose(),go.stop()};function Mn(re){re.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Cr(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,St()}function Bs(re){const Ue=re.target;Ue.removeEventListener("dispose",Bs),As(Ue)}function As(re){Ms(re),ct.remove(re)}function Ms(re){const Ue=ct.get(re).program;Ue!==void 0&&ee.releaseProgram(Ue)}function Vh(re,Ue){re.render(function(Fe){p.renderBufferImmediate(Fe,Ue)})}this.renderBufferImmediate=function(re,Ue){nt.initAttributes();const Fe=ct.get(re);re.hasPositions&&!Fe.position&&(Fe.position=be.createBuffer()),re.hasNormals&&!Fe.normal&&(Fe.normal=be.createBuffer()),re.hasUvs&&!Fe.uv&&(Fe.uv=be.createBuffer()),re.hasColors&&!Fe.color&&(Fe.color=be.createBuffer());const Je=Ue.getAttributes();re.hasPositions&&(be.bindBuffer(34962,Fe.position),be.bufferData(34962,re.positionArray,35048),nt.enableAttribute(Je.position),be.vertexAttribPointer(Je.position,3,5126,!1,0,0)),re.hasNormals&&(be.bindBuffer(34962,Fe.normal),be.bufferData(34962,re.normalArray,35048),nt.enableAttribute(Je.normal),be.vertexAttribPointer(Je.normal,3,5126,!1,0,0)),re.hasUvs&&(be.bindBuffer(34962,Fe.uv),be.bufferData(34962,re.uvArray,35048),nt.enableAttribute(Je.uv),be.vertexAttribPointer(Je.uv,2,5126,!1,0,0)),re.hasColors&&(be.bindBuffer(34962,Fe.color),be.bufferData(34962,re.colorArray,35048),nt.enableAttribute(Je.color),be.vertexAttribPointer(Je.color,3,5126,!1,0,0)),nt.disableUnusedAttributes(),be.drawArrays(4,0,re.count),re.count=0},this.renderBufferDirect=function(re,Ue,Fe,Je,vt,zn){Ue===null&&(Ue=ke);const sn=vt.isMesh&&vt.matrixWorld.determinant()<0,Tn=Uh(re,Ue,Je,vt);We.setMaterial(Je,sn);let En=Fe.index;const Nn=Fe.attributes.position;if(En===null){if(Nn===void 0||Nn.count===0)return}else if(En.count===0)return;let er=1;Je.wireframe===!0&&(En=ut.getWireframeAttribute(Fe),er=2),(Je.morphTargets||Je.morphNormals)&&yt.update(vt,Fe,Je,Tn),nt.setup(vt,Je,Tn,Fe,En);let _n,ur=Ct;En!==null&&(_n=Be.get(En),ur=ft,ur.setIndex(_n));const Oi=En!==null?En.count:Nn.count,xr=Fe.drawRange.start*er,Zi=Fe.drawRange.count*er,Ar=zn!==null?zn.start*er:0,Io=zn!==null?zn.count*er:1/0,rs=Math.max(xr,Ar),yo=Math.min(Oi,xr+Zi,Ar+Io)-1,Ao=Math.max(0,yo-rs+1);if(Ao!==0){if(vt.isMesh)Je.wireframe===!0?(We.setLineWidth(Je.wireframeLinewidth*De()),ur.setMode(1)):ur.setMode(4);else if(vt.isLine){let Ns=Je.linewidth;Ns===void 0&&(Ns=1),We.setLineWidth(Ns*De()),vt.isLineSegments?ur.setMode(1):vt.isLineLoop?ur.setMode(2):ur.setMode(3)}else vt.isPoints?ur.setMode(0):vt.isSprite&&ur.setMode(4);if(vt.isInstancedMesh)ur.renderInstances(rs,Ao,vt.count);else if(Fe.isInstancedBufferGeometry){const Ns=Math.min(Fe.instanceCount,Fe._maxInstanceCount);ur.renderInstances(rs,Ao,Ns)}else ur.render(rs,Ao)}},this.compile=function(re,Ue){f=Ge.get(re),f.init(),re.traverseVisible(function(Je){Je.isLight&&Je.layers.test(Ue.layers)&&(f.pushLight(Je),Je.castShadow&&f.pushShadow(Je))}),f.setupLights();const Fe=new WeakMap;re.traverse(function(Je){const vt=Je.material;if(vt)if(Array.isArray(vt))for(let zn=0;zn<vt.length;zn++){const sn=vt[zn];Fe.has(sn)===!1&&(Di(sn,re,Je),Fe.set(sn))}else Fe.has(vt)===!1&&(Di(vt,re,Je),Fe.set(vt))})};let Ul=null;function Wl(re){gt.isPresenting||Ul&&Ul(re)}const go=new Cle;go.setAnimationLoop(Wl),typeof window<"u"&&go.setContext(window),this.setAnimationLoop=function(re){Ul=re,gt.setAnimationLoop(re),re===null?go.stop():go.start()},this.render=function(re,Ue){let Fe,Je;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),Fe=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),Je=arguments[3]),Ue!==void 0&&Ue.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;nt.resetDefaultState(),S=-1,C=null,re.autoUpdate===!0&&re.updateMatrixWorld(),Ue.parent===null&&Ue.updateMatrixWorld(),gt.enabled===!0&&gt.isPresenting===!0&&(Ue=gt.getCamera(Ue)),re.isScene===!0&&re.onBeforeRender(p,re,Ue,Fe||x),f=Ge.get(re,d.length),f.init(),d.push(f),ae.multiplyMatrices(Ue.projectionMatrix,Ue.matrixWorldInverse),G.setFromProjectionMatrix(ae),ge=this.localClippingEnabled,te=ye.init(this.clippingPlanes,ge,Ue),h=rt.get(re,Ue),h.init(),Gl(re,Ue,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(R,D),te===!0&&ye.beginShadows();const vt=f.state.shadowsArray;Gt.render(vt,re,Ue),f.setupLights(),f.setupLightsView(Ue),te===!0&&ye.endShadows(),this.info.autoReset===!0&&this.info.reset(),Fe!==void 0&&this.setRenderTarget(Fe),Ze.render(h,re,Ue,Je);const zn=h.opaque,sn=h.transparent;zn.length>0&&Lc(zn,re,Ue),sn.length>0&&Lc(sn,re,Ue),re.isScene===!0&&re.onAfterRender(p,re,Ue),x!==null&&(Ve.updateRenderTargetMipmap(x),Ve.updateMultisampleRenderTarget(x)),We.buffers.depth.setTest(!0),We.buffers.depth.setMask(!0),We.buffers.color.setMask(!0),We.setPolygonOffset(!1),d.pop(),d.length>0?f=d[d.length-1]:f=null,h=null};function Gl(re,Ue,Fe,Je){if(re.visible===!1)return;if(re.layers.test(Ue.layers)){if(re.isGroup)Fe=re.renderOrder;else if(re.isLOD)re.autoUpdate===!0&&re.update(Ue);else if(re.isLight)f.pushLight(re),re.castShadow&&f.pushShadow(re);else if(re.isSprite){if(!re.frustumCulled||G.intersectsSprite(re)){Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ke.update(re),Tn=re.material;Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}else if(re.isImmediateRenderObject)Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae),h.push(re,null,re.material,Fe,Ne.z,null);else if((re.isMesh||re.isLine||re.isPoints)&&(re.isSkinnedMesh&&re.skeleton.frame!==dt.render.frame&&(re.skeleton.update(),re.skeleton.frame=dt.render.frame),!re.frustumCulled||G.intersectsObject(re))){Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ke.update(re),Tn=re.material;if(Array.isArray(Tn)){const En=sn.groups;for(let Nn=0,er=En.length;Nn<er;Nn++){const _n=En[Nn],ur=Tn[_n.materialIndex];ur&&ur.visible&&h.push(re,sn,ur,Fe,Ne.z,_n)}}else Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}const zn=re.children;for(let sn=0,Tn=zn.length;sn<Tn;sn++)Gl(zn[sn],Ue,Fe,Je)}function Lc(re,Ue,Fe){const Je=Ue.isScene===!0?Ue.overrideMaterial:null;for(let vt=0,zn=re.length;vt<zn;vt++){const sn=re[vt],Tn=sn.object,En=sn.geometry,Nn=Je===null?sn.material:Je,er=sn.group;if(Fe.isArrayCamera){const _n=Fe.cameras;for(let ur=0,Oi=_n.length;ur<Oi;ur++){const xr=_n[ur];Tn.layers.test(xr.layers)&&(We.viewport(k.copy(xr.viewport)),f.setupLightsView(xr),zc(Tn,Ue,xr,En,Nn,er))}}else zc(Tn,Ue,Fe,En,Nn,er)}}function zc(re,Ue,Fe,Je,vt,zn){if(re.onBeforeRender(p,Ue,Fe,Je,vt,zn),re.modelViewMatrix.multiplyMatrices(Fe.matrixWorldInverse,re.matrixWorld),re.normalMatrix.getNormalMatrix(re.modelViewMatrix),re.isImmediateRenderObject){const sn=Uh(Fe,Ue,vt,re);We.setMaterial(vt),nt.reset(),Vh(re,sn)}else p.renderBufferDirect(Fe,Ue,Je,vt,re,zn);re.onAfterRender(p,Ue,Fe,Je,vt,zn)}function Di(re,Ue,Fe){Ue.isScene!==!0&&(Ue=ke);const Je=ct.get(re),vt=f.state.lights,zn=f.state.shadowsArray,sn=vt.state.version,Tn=ee.getParameters(re,vt.state,zn,Ue,Fe),En=ee.getProgramCacheKey(Tn);let Nn=Je.program,er=!0;if(Je.environment=re.isMeshStandardMaterial?Ue.environment:null,Je.fog=Ue.fog,Je.envMap=ze.get(re.envMap||Je.environment),Nn===void 0)re.addEventListener("dispose",Bs);else if(Nn.cacheKey!==En)Ms(re);else if(Je.lightsStateVersion!==sn)er=!1;else{if(Tn.shaderID!==void 0)return;er=!1}er&&(Tn.uniforms=ee.getUniforms(re),re.onBeforeCompile(Tn,p),Nn=ee.acquireProgram(Tn,En),Je.program=Nn,Je.uniforms=Tn.uniforms,Je.outputEncoding=Tn.outputEncoding);const _n=Je.uniforms;(!re.isShaderMaterial&&!re.isRawShaderMaterial||re.clipping===!0)&&(Je.numClippingPlanes=ye.numPlanes,Je.numIntersection=ye.numIntersection,_n.clippingPlanes=ye.uniform),Je.needsLights=Wh(re),Je.lightsStateVersion=sn,Je.needsLights&&(_n.ambientLightColor.value=vt.state.ambient,_n.lightProbe.value=vt.state.probe,_n.directionalLights.value=vt.state.directional,_n.directionalLightShadows.value=vt.state.directionalShadow,_n.spotLights.value=vt.state.spot,_n.spotLightShadows.value=vt.state.spotShadow,_n.rectAreaLights.value=vt.state.rectArea,_n.ltc_1.value=vt.state.rectAreaLTC1,_n.ltc_2.value=vt.state.rectAreaLTC2,_n.pointLights.value=vt.state.point,_n.pointLightShadows.value=vt.state.pointShadow,_n.hemisphereLights.value=vt.state.hemi,_n.directionalShadowMap.value=vt.state.directionalShadowMap,_n.directionalShadowMatrix.value=vt.state.directionalShadowMatrix,_n.spotShadowMap.value=vt.state.spotShadowMap,_n.spotShadowMatrix.value=vt.state.spotShadowMatrix,_n.pointShadowMap.value=vt.state.pointShadowMap,_n.pointShadowMatrix.value=vt.state.pointShadowMatrix);const ur=Je.program.getUniforms(),Oi=np.seqWithValue(ur.seq,_n);Je.uniformsList=Oi}function Uh(re,Ue,Fe,Je){Ue.isScene!==!0&&(Ue=ke),Ve.resetTextureUnits();const vt=Ue.fog,zn=Fe.isMeshStandardMaterial?Ue.environment:null,sn=x===null?p.outputEncoding:x.texture.encoding,Tn=ze.get(Fe.envMap||zn),En=ct.get(Fe),Nn=f.state.lights;if(te===!0&&(ge===!0||re!==C)){const Ar=re===C&&Fe.id===S;ye.setState(Fe,re,Ar)}Fe.version===En.__version?(Fe.fog&&En.fog!==vt||En.environment!==zn||En.needsLights&&En.lightsStateVersion!==Nn.state.version||En.numClippingPlanes!==void 0&&(En.numClippingPlanes!==ye.numPlanes||En.numIntersection!==ye.numIntersection)||En.outputEncoding!==sn||En.envMap!==Tn)&&Di(Fe,Ue,Je):(Di(Fe,Ue,Je),En.__version=Fe.version);let er=!1,_n=!1,ur=!1;const Oi=En.program,xr=Oi.getUniforms(),Zi=En.uniforms;if(We.useProgram(Oi.program)&&(er=!0,_n=!0,ur=!0),Fe.id!==S&&(S=Fe.id,_n=!0),er||C!==re){if(xr.setValue(be,"projectionMatrix",re.projectionMatrix),it.logarithmicDepthBuffer&&xr.setValue(be,"logDepthBufFC",2/(Math.log(re.far+1)/Math.LN2)),C!==re&&(C=re,_n=!0,ur=!0),Fe.isShaderMaterial||Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshStandardMaterial||Fe.envMap){const Ar=xr.map.cameraPosition;Ar!==void 0&&Ar.setValue(be,Ne.setFromMatrixPosition(re.matrixWorld))}(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial)&&xr.setValue(be,"isOrthographic",re.isOrthographicCamera===!0),(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial||Fe.isShadowMaterial||Fe.skinning)&&xr.setValue(be,"viewMatrix",re.matrixWorldInverse)}if(Fe.skinning){xr.setOptional(be,Je,"bindMatrix"),xr.setOptional(be,Je,"bindMatrixInverse");const Ar=Je.skeleton;if(Ar){const Io=Ar.bones;if(it.floatVertexTextures){if(Ar.boneTexture===null){let rs=Math.sqrt(Io.length*4);rs=In.ceilPowerOfTwo(rs),rs=Math.max(rs,4);const yo=new Float32Array(rs*rs*4);yo.set(Ar.boneMatrices);const Ao=new zf(yo,rs,rs,Al,If);Ar.boneMatrices=yo,Ar.boneTexture=Ao,Ar.boneTextureSize=rs}xr.setValue(be,"boneTexture",Ar.boneTexture,Ve),xr.setValue(be,"boneTextureSize",Ar.boneTextureSize)}else xr.setOptional(be,Ar,"boneMatrices")}}return(_n||En.receiveShadow!==Je.receiveShadow)&&(En.receiveShadow=Je.receiveShadow,xr.setValue(be,"receiveShadow",Je.receiveShadow)),_n&&(xr.setValue(be,"toneMappingExposure",p.toneMappingExposure),En.needsLights&&il(Zi,ur),vt&&Fe.fog&&J.refreshFogUniforms(Zi,vt),J.refreshMaterialUniforms(Zi,Fe,O,N),np.upload(be,En.uniformsList,Zi,Ve)),Fe.isShaderMaterial&&Fe.uniformsNeedUpdate===!0&&(np.upload(be,En.uniformsList,Zi,Ve),Fe.uniformsNeedUpdate=!1),Fe.isSpriteMaterial&&xr.setValue(be,"center",Je.center),xr.setValue(be,"modelViewMatrix",Je.modelViewMatrix),xr.setValue(be,"normalMatrix",Je.normalMatrix),xr.setValue(be,"modelMatrix",Je.matrixWorld),Oi}function il(re,Ue){re.ambientLightColor.needsUpdate=Ue,re.lightProbe.needsUpdate=Ue,re.directionalLights.needsUpdate=Ue,re.directionalLightShadows.needsUpdate=Ue,re.pointLights.needsUpdate=Ue,re.pointLightShadows.needsUpdate=Ue,re.spotLights.needsUpdate=Ue,re.spotLightShadows.needsUpdate=Ue,re.rectAreaLights.needsUpdate=Ue,re.hemisphereLights.needsUpdate=Ue}function Wh(re){return re.isMeshLambertMaterial||re.isMeshToonMaterial||re.isMeshPhongMaterial||re.isMeshStandardMaterial||re.isShadowMaterial||re.isShaderMaterial&&re.lights===!0}this.setFramebuffer=function(re){g!==re&&x===null&&be.bindFramebuffer(36160,re),g=re},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderList=function(){return h},this.setRenderList=function(re){h=re},this.getRenderTarget=function(){return x},this.setRenderTarget=function(re,Ue=0,Fe=0){x=re,y=Ue,b=Fe,re&&ct.get(re).__webglFramebuffer===void 0&&Ve.setupRenderTarget(re);let Je=g,vt=!1;if(re){const zn=ct.get(re).__webglFramebuffer;re.isWebGLCubeRenderTarget?(Je=zn[Ue],vt=!0):re.isWebGLMultisampleRenderTarget?Je=ct.get(re).__webglMultisampledFramebuffer:Je=zn,k.copy(re.viewport),A.copy(re.scissor),M=re.scissorTest}else k.copy(z).multiplyScalar(O).floor(),A.copy(B).multiplyScalar(O).floor(),M=X;if(w!==Je&&(be.bindFramebuffer(36160,Je),w=Je),We.viewport(k),We.scissor(A),We.setScissorTest(M),vt){const zn=ct.get(re.texture);be.framebufferTexture2D(36160,36064,34069+Ue,zn.__webglTexture,Fe)}},this.readRenderTargetPixels=function(re,Ue,Fe,Je,vt,zn,sn){if(!(re&&re.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Tn=ct.get(re).__webglFramebuffer;if(re.isWebGLCubeRenderTarget&&sn!==void 0&&(Tn=Tn[sn]),Tn){let En=!1;Tn!==w&&(be.bindFramebuffer(36160,Tn),En=!0);try{const Nn=re.texture,er=Nn.format,_n=Nn.type;if(er!==Al&&ce.convert(er)!==be.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const ur=_n===hS&&(Oe.has("EXT_color_buffer_half_float")||it.isWebGL2&&Oe.has("EXT_color_buffer_float"));if(_n!==cx&&ce.convert(_n)!==be.getParameter(35738)&&!(_n===If&&(it.isWebGL2||Oe.has("OES_texture_float")||Oe.has("WEBGL_color_buffer_float")))&&!ur){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}be.checkFramebufferStatus(36160)===36053?Ue>=0&&Ue<=re.width-Je&&Fe>=0&&Fe<=re.height-vt&&be.readPixels(Ue,Fe,Je,vt,ce.convert(er),ce.convert(_n),zn):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{En&&be.bindFramebuffer(36160,w)}}},this.copyFramebufferToTexture=function(re,Ue,Fe=0){const Je=Math.pow(2,-Fe),vt=Math.floor(Ue.image.width*Je),zn=Math.floor(Ue.image.height*Je),sn=ce.convert(Ue.format);Ve.setTexture2D(Ue,0),be.copyTexImage2D(3553,Fe,sn,re.x,re.y,vt,zn,0),We.unbindTexture()},this.copyTextureToTexture=function(re,Ue,Fe,Je=0){const vt=Ue.image.width,zn=Ue.image.height,sn=ce.convert(Fe.format),Tn=ce.convert(Fe.type);Ve.setTexture2D(Fe,0),be.pixelStorei(37440,Fe.flipY),be.pixelStorei(37441,Fe.premultiplyAlpha),be.pixelStorei(3317,Fe.unpackAlignment),Ue.isDataTexture?be.texSubImage2D(3553,Je,re.x,re.y,vt,zn,sn,Tn,Ue.image.data):Ue.isCompressedTexture?be.compressedTexSubImage2D(3553,Je,re.x,re.y,Ue.mipmaps[0].width,Ue.mipmaps[0].height,sn,Ue.mipmaps[0].data):be.texSubImage2D(3553,Je,re.x,re.y,sn,Tn,Ue.image),Je===0&&Fe.generateMipmaps&&be.generateMipmap(3553),We.unbindTexture()},this.initTexture=function(re){Ve.setTexture2D(re,0),We.unbindTexture()},this.resetState=function(){We.reset(),nt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function jF(n){XC.call(this,n)}jF.prototype=Object.assign(Object.create(XC.prototype),{constructor:jF,isWebGL1Renderer:!0});class F${constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new Ht(e),this.density=t!==void 0?t:25e-5}clone(){return new F$(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class L${constructor(e,t,r){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new Ht(e),this.near=t!==void 0?t:1,this.far=r!==void 0?r:1e3}clone(){return new L$(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class vV extends rn{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function kl(n,e){this.array=n,this.stride=e,this.count=n!==void 0?n.length/e:0,this.usage=jC,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In.generateUUID()}Object.defineProperty(kl.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(kl.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.stride,t*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[n+r]=e.array[t+r];return this},set:function(n,e=0){return this.array.set(n,e),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new kl(e,this.stride);return t.setUsage(this.usage),t},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const bm=new Q;function _p(n,e,t,r){this.name="",this.data=n,this.itemSize=e,this.offset=t,this.normalized=r===!0}Object.defineProperties(_p.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(_p.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let e=0,t=this.data.count;e<t;e++)bm.x=this.getX(e),bm.y=this.getY(e),bm.z=this.getZ(e),bm.applyMatrix4(n),this.setXYZ(e,bm.x,bm.y,bm.z);return this},setX:function(n,e){return this.data.array[n*this.data.stride+this.offset]=e,this},setY:function(n,e){return this.data.array[n*this.data.stride+this.offset+1]=e,this},setZ:function(n,e){return this.data.array[n*this.data.stride+this.offset+2]=e,this},setW:function(n,e){return this.data.array[n*this.data.stride+this.offset+3]=e,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,e,t){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this.data.array[n+3]=s,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return new Cn(new this.array.constructor(e),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new _p(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function Sp(n){kn.call(this),this.type="SpriteMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(n)}Sp.prototype=Object.create(kn.prototype);Sp.prototype.constructor=Sp;Sp.prototype.isSpriteMaterial=!0;Sp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this};let ib;const u1=new Q,ob=new Q,ab=new Q,lb=new st,h1=new st,Dle=new Zn,rE=new Q,f1=new Q,sE=new Q,W8=new st,DP=new st,G8=new st;function _S(n){if(rn.call(this),this.type="Sprite",ib===void 0){ib=new un;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new kl(e,5);ib.setIndex([0,1,2,0,2,3]),ib.setAttribute("position",new _p(t,3,0,!1)),ib.setAttribute("uv",new _p(t,2,3,!1))}this.geometry=ib,this.material=n!==void 0?n:new Sp,this.center=new st(.5,.5)}_S.prototype=Object.assign(Object.create(rn.prototype),{constructor:_S,isSprite:!0,raycast:function(n,e){n.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ob.setFromMatrixScale(this.matrixWorld),Dle.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),ab.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&ob.multiplyScalar(-ab.z);const t=this.material.rotation;let r,s;t!==0&&(s=Math.cos(t),r=Math.sin(t));const i=this.center;iE(rE.set(-.5,-.5,0),ab,i,ob,r,s),iE(f1.set(.5,-.5,0),ab,i,ob,r,s),iE(sE.set(.5,.5,0),ab,i,ob,r,s),W8.set(0,0),DP.set(1,0),G8.set(1,1);let o=n.ray.intersectTriangle(rE,f1,sE,!1,u1);if(o===null&&(iE(f1.set(-.5,.5,0),ab,i,ob,r,s),DP.set(0,1),o=n.ray.intersectTriangle(rE,sE,f1,!1,u1),o===null))return;const a=n.ray.origin.distanceTo(u1);a<n.near||a>n.far||e.push({distance:a,point:u1.clone(),uv:jo.getUV(u1,rE,f1,sE,W8,DP,G8,new st),face:null,object:this})},copy:function(n){return rn.prototype.copy.call(this,n),n.center!==void 0&&this.center.copy(n.center),this.material=n.material,this}});function iE(n,e,t,r,s,i){lb.subVectors(n,t).addScalar(.5).multiply(r),s!==void 0?(h1.x=i*lb.x-s*lb.y,h1.y=s*lb.x+i*lb.y):h1.copy(lb),n.copy(e),n.x+=h1.x,n.y+=h1.y,n.applyMatrix4(Dle)}const oE=new Q,H8=new Q;function SS(){rn.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}SS.prototype=Object.assign(Object.create(rn.prototype),{constructor:SS,isLOD:!0,copy:function(n){rn.prototype.copy.call(this,n,!1);const e=n.levels;for(let t=0,r=e.length;t<r;t++){const s=e[t];this.addLevel(s.object.clone(),s.distance)}return this.autoUpdate=n.autoUpdate,this},addLevel:function(n,e=0){e=Math.abs(e);const t=this.levels;let r;for(r=0;r<t.length&&!(e<t[r].distance);r++);return t.splice(r,0,{distance:e,object:n}),this.add(n),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(n){const e=this.levels;if(e.length>0){let t,r;for(t=1,r=e.length;t<r&&!(n<e[t].distance);t++);return e[t-1].object}return null},raycast:function(n,e){if(this.levels.length>0){oE.setFromMatrixPosition(this.matrixWorld);const r=n.ray.origin.distanceTo(oE);this.getObjectForDistance(r).raycast(n,e)}},update:function(n){const e=this.levels;if(e.length>1){oE.setFromMatrixPosition(n.matrixWorld),H8.setFromMatrixPosition(this.matrixWorld);const t=oE.distanceTo(H8)/n.zoom;e[0].object.visible=!0;let r,s;for(r=1,s=e.length;r<s&&t>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<s;r++)e[r].object.visible=!1}},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const t=this.levels;for(let r=0,s=t.length;r<s;r++){const i=t[r];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}});const j8=new Q,q8=new Hr,X8=new Hr,b0t=new Q,K8=new Zn;function CS(n,e){n&&n.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),hs.call(this,n,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Zn,this.bindMatrixInverse=new Zn}CS.prototype=Object.assign(Object.create(hs.prototype),{constructor:CS,isSkinnedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,e){this.skeleton=n,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new Hr,e=this.geometry.attributes.skinWeight;for(let t=0,r=e.count;t<r;t++){n.x=e.getX(t),n.y=e.getY(t),n.z=e.getZ(t),n.w=e.getW(t);const s=1/n.manhattanLength();s!==1/0?n.multiplyScalar(s):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){hs.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,e){const t=this.skeleton,r=this.geometry;q8.fromBufferAttribute(r.attributes.skinIndex,n),X8.fromBufferAttribute(r.attributes.skinWeight,n),j8.fromBufferAttribute(r.attributes.position,n).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const i=X8.getComponent(s);if(i!==0){const o=q8.getComponent(s);K8.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector(b0t.copy(j8).applyMatrix4(K8),i)}}return e.applyMatrix4(this.bindMatrixInverse)}});function kS(){rn.call(this),this.type="Bone"}kS.prototype=Object.assign(Object.create(rn.prototype),{constructor:kS,isBone:!0});const Y8=new Zn,v0t=new Zn;function TS(n=[],e=[]){this.uuid=In.generateUUID(),this.bones=n.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(TS.prototype,{init:function(){const n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(n.length*16),e.length===0)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,r=this.bones.length;t<r;t++)this.boneInverses.push(new Zn)}},calculateInverses:function(){this.boneInverses.length=0;for(let n=0,e=this.bones.length;n<e;n++){const t=new Zn;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const n=this.bones,e=this.boneInverses,t=this.boneMatrices,r=this.boneTexture;for(let s=0,i=n.length;s<i;s++){const o=n[s]?n[s].matrixWorld:v0t;Y8.multiplyMatrices(o,e[s]),Y8.toArray(t,s*16)}r!==null&&(r.needsUpdate=!0)},clone:function(){return new TS(this.bones,this.boneInverses)},getBoneByName:function(n){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];if(r.name===n)return r}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(n,e){this.uuid=n.uuid;for(let t=0,r=n.bones.length;t<r;t++){const s=n.bones[t];let i=e[s];i===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),i=new kS),this.bones.push(i),this.boneInverses.push(new Zn().fromArray(n.boneInverses[t]))}return this.init(),this},toJSON:function(){const n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let r=0,s=e.length;r<s;r++){const i=e[r];n.bones.push(i.uuid);const o=t[r];n.boneInverses.push(o.toArray())}return n}});const Z8=new Zn,J8=new Zn,aE=[],d1=new hs;function PA(n,e,t){hs.call(this,n,e),this.instanceMatrix=new Cn(new Float32Array(t*16),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1}PA.prototype=Object.assign(Object.create(hs.prototype),{constructor:PA,isInstancedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,e){e.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,e){e.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,e){const t=this.matrixWorld,r=this.count;if(d1.geometry=this.geometry,d1.material=this.material,d1.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,Z8),J8.multiplyMatrices(t,Z8),d1.matrixWorld=J8,d1.raycast(n,aE);for(let i=0,o=aE.length;i<o;i++){const a=aE[i];a.instanceId=s,a.object=this,e.push(a)}aE.length=0}},setColorAt:function(n,e){this.instanceColor===null&&(this.instanceColor=new Cn(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,e){e.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Es(n){kn.call(this),this.type="LineBasicMaterial",this.color=new Ht(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(n)}Es.prototype=Object.create(kn.prototype);Es.prototype.constructor=Es;Es.prototype.isLineBasicMaterial=!0;Es.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.morphTargets=n.morphTargets,this};const Q8=new Q,eq=new Q,tq=new Zn,OP=new ux,lE=new Gp;function $c(n=new un,e=new Es){rn.call(this),this.type="Line",this.geometry=n,this.material=e,this.updateMorphTargets()}$c.prototype=Object.assign(Object.create(rn.prototype),{constructor:$c,isLine:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[0];for(let r=1,s=e.count;r<s;r++)Q8.fromBufferAttribute(e,r-1),eq.fromBufferAttribute(e,r),t[r]=t[r-1],t[r]+=Q8.distanceTo(eq);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),lE.copy(t.boundingSphere),lE.applyMatrix4(r),lE.radius+=s,n.ray.intersectsSphere(lE)===!1)return;tq.copy(r).invert(),OP.copy(n.ray).applyMatrix4(tq);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i,a=new Q,l=new Q,c=new Q,u=new Q,h=this.isLineSegments?2:1;if(t.isBufferGeometry){const f=t.index,p=t.attributes.position;if(f!==null){const m=f.array;for(let g=0,y=m.length-1;g<y;g+=h){const b=m[g],x=m[g+1];if(a.fromBufferAttribute(p,b),l.fromBufferAttribute(p,x),OP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const S=n.ray.origin.distanceTo(u);S<n.near||S>n.far||e.push({distance:S,point:c.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}}else for(let m=0,g=p.count-1;m<g;m+=h){if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,m+1),OP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const b=n.ray.origin.distanceTo(u);b<n.near||b>n.far||e.push({distance:b,point:c.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else t.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const nq=new Q,rq=new Q;function Ta(n,e){$c.call(this,n,e),this.type="LineSegments"}Ta.prototype=Object.assign(Object.create($c.prototype),{constructor:Ta,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[];for(let r=0,s=e.count;r<s;r+=2)nq.fromBufferAttribute(e,r),rq.fromBufferAttribute(e,r+1),t[r]=r===0?0:t[r-1],t[r+1]=t[r]+nq.distanceTo(rq);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});function DA(n,e){$c.call(this,n,e),this.type="LineLoop"}DA.prototype=Object.assign(Object.create($c.prototype),{constructor:DA,isLineLoop:!0});function Eu(n){kn.call(this),this.type="PointsMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(n)}Eu.prototype=Object.create(kn.prototype);Eu.prototype.constructor=Eu;Eu.prototype.isPointsMaterial=!0;Eu.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.morphTargets=n.morphTargets,this};const sq=new Zn,qF=new ux,cE=new Gp,uE=new Q;function vv(n=new un,e=new Eu){rn.call(this),this.type="Points",this.geometry=n,this.material=e,this.updateMorphTargets()}vv.prototype=Object.assign(Object.create(rn.prototype),{constructor:vv,isPoints:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),cE.copy(t.boundingSphere),cE.applyMatrix4(r),cE.radius+=s,n.ray.intersectsSphere(cE)===!1)return;sq.copy(r).invert(),qF.copy(n.ray).applyMatrix4(sq);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i;if(t.isBufferGeometry){const a=t.index,c=t.attributes.position;if(a!==null){const u=a.array;for(let h=0,f=u.length;h<f;h++){const d=u[h];uE.fromBufferAttribute(c,d),iq(uE,d,o,r,n,e,this)}}else for(let u=0,h=c.count;u<h;u++)uE.fromBufferAttribute(c,u),iq(uE,u,o,r,n,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function iq(n,e,t,r,s,i,o){const a=qF.distanceSqToPoint(n);if(a<t){const l=new Q;qF.closestPointToPoint(n,l),l.applyMatrix4(r);const c=s.ray.origin.distanceTo(l);if(c<s.near||c>s.far)return;i.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}function XF(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.format=o!==void 0?o:ep,this.minFilter=i!==void 0?i:lo,this.magFilter=s!==void 0?s:lo,this.generateMipmaps=!1;const c=this;function u(){c.needsUpdate=!0,n.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(u)}XF.prototype=Object.assign(Object.create(Kr.prototype),{constructor:XF,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const n=this.image;"requestVideoFrameCallback"in n===!1&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function wv(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={width:e,height:t},this.mipmaps=n,this.flipY=!1,this.generateMipmaps=!1}wv.prototype=Object.create(Kr.prototype);wv.prototype.constructor=wv;wv.prototype.isCompressedTexture=!0;function ES(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.needsUpdate=!0}ES.prototype=Object.create(Kr.prototype);ES.prototype.constructor=ES;ES.prototype.isCanvasTexture=!0;function IS(n,e,t,r,s,i,o,a,l,c){if(c=c!==void 0?c:sg,c!==sg&&c!==mv)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&c===sg&&(t=uS),t===void 0&&c===mv&&(t=zb),Kr.call(this,null,r,s,i,o,a,c,t,l),this.image={width:n,height:e},this.magFilter=o!==void 0?o:Ui,this.minFilter=a!==void 0?a:Ui,this.flipY=!1,this.generateMipmaps=!1}IS.prototype=Object.create(Kr.prototype);IS.prototype.constructor=IS;IS.prototype.isDepthTexture=!0;class OA extends un{constructor(e=1,t=8,r=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:s},t=Math.max(3,t);const i=[],o=[],a=[],l=[],c=new Q,u=new st;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,f=3;h<=t;h++,f+=3){const d=r+h/t*s;c.x=e*Math.cos(d),c.y=e*Math.sin(d),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[f]/e+1)/2,u.y=(o[f+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)i.push(h,h+1,0);this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("normal",new Xt(a,3)),this.setAttribute("uv",new Xt(l,2))}}class xv extends un{constructor(e=1,t=1,r=1,s=8,i=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:s,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l};const c=this;s=Math.floor(s),i=Math.floor(i);const u=[],h=[],f=[],d=[];let p=0;const m=[],g=r/2;let y=0;b(),o===!1&&(e>0&&x(!0),t>0&&x(!1)),this.setIndex(u),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function b(){const w=new Q,S=new Q;let C=0;const k=(t-e)/r;for(let A=0;A<=i;A++){const M=[],E=A/i,N=E*(t-e)+e;for(let O=0;O<=s;O++){const R=O/s,D=R*l+a,z=Math.sin(D),B=Math.cos(D);S.x=N*z,S.y=-E*r+g,S.z=N*B,h.push(S.x,S.y,S.z),w.set(z,k,B).normalize(),f.push(w.x,w.y,w.z),d.push(R,1-E),M.push(p++)}m.push(M)}for(let A=0;A<s;A++)for(let M=0;M<i;M++){const E=m[M][A],N=m[M+1][A],O=m[M+1][A+1],R=m[M][A+1];u.push(E,N,R),u.push(N,O,R),C+=6}c.addGroup(y,C,0),y+=C}function x(w){const S=p,C=new st,k=new Q;let A=0;const M=w===!0?e:t,E=w===!0?1:-1;for(let O=1;O<=s;O++)h.push(0,g*E,0),f.push(0,E,0),d.push(.5,.5),p++;const N=p;for(let O=0;O<=s;O++){const D=O/s*l+a,z=Math.cos(D),B=Math.sin(D);k.x=M*B,k.y=g*E,k.z=M*z,h.push(k.x,k.y,k.z),f.push(0,E,0),C.x=z*.5+.5,C.y=B*.5*E+.5,d.push(C.x,C.y),p++}for(let O=0;O<s;O++){const R=S+O,D=N+O;w===!0?u.push(D,D+1,R):u.push(D+1,D,R),A+=3}c.addGroup(y,A,w===!0?1:2),y+=A}}}class FA extends xv{constructor(e=1,t=1,r=8,s=1,i=!1,o=0,a=Math.PI*2){super(0,e,t,r,s,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:s,openEnded:i,thetaStart:o,thetaLength:a}}}class Cp extends un{constructor(e,t,r=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:s};const i=[],o=[];a(s),c(r),u(),this.setAttribute("position",new Xt(i,3)),this.setAttribute("normal",new Xt(i.slice(),3)),this.setAttribute("uv",new Xt(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const x=new Q,w=new Q,S=new Q;for(let C=0;C<t.length;C+=3)d(t[C+0],x),d(t[C+1],w),d(t[C+2],S),l(x,w,S,b)}function l(b,x,w,S){const C=S+1,k=[];for(let A=0;A<=C;A++){k[A]=[];const M=b.clone().lerp(w,A/C),E=x.clone().lerp(w,A/C),N=C-A;for(let O=0;O<=N;O++)O===0&&A===C?k[A][O]=M:k[A][O]=M.clone().lerp(E,O/N)}for(let A=0;A<C;A++)for(let M=0;M<2*(C-A)-1;M++){const E=Math.floor(M/2);M%2===0?(f(k[A][E+1]),f(k[A+1][E]),f(k[A][E])):(f(k[A][E+1]),f(k[A+1][E+1]),f(k[A+1][E]))}}function c(b){const x=new Q;for(let w=0;w<i.length;w+=3)x.x=i[w+0],x.y=i[w+1],x.z=i[w+2],x.normalize().multiplyScalar(b),i[w+0]=x.x,i[w+1]=x.y,i[w+2]=x.z}function u(){const b=new Q;for(let x=0;x<i.length;x+=3){b.x=i[x+0],b.y=i[x+1],b.z=i[x+2];const w=g(b)/2/Math.PI+.5,S=y(b)/Math.PI+.5;o.push(w,1-S)}p(),h()}function h(){for(let b=0;b<o.length;b+=6){const x=o[b+0],w=o[b+2],S=o[b+4],C=Math.max(x,w,S),k=Math.min(x,w,S);C>.9&&k<.1&&(x<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),S<.2&&(o[b+4]+=1))}}function f(b){i.push(b.x,b.y,b.z)}function d(b,x){const w=b*3;x.x=e[w+0],x.y=e[w+1],x.z=e[w+2]}function p(){const b=new Q,x=new Q,w=new Q,S=new Q,C=new st,k=new st,A=new st;for(let M=0,E=0;M<i.length;M+=9,E+=6){b.set(i[M+0],i[M+1],i[M+2]),x.set(i[M+3],i[M+4],i[M+5]),w.set(i[M+6],i[M+7],i[M+8]),C.set(o[E+0],o[E+1]),k.set(o[E+2],o[E+3]),A.set(o[E+4],o[E+5]),S.copy(b).add(x).add(w).divideScalar(3);const N=g(S);m(C,E+0,b,N),m(k,E+2,x,N),m(A,E+4,w,N)}}function m(b,x,w,S){S<0&&b.x===1&&(o[x]=b.x-1),w.x===0&&w.z===0&&(o[x]=S/2/Math.PI+.5)}function g(b){return Math.atan2(b.z,-b.x)}function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}}class LA extends Cp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=1/r,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-r,0,-s,r,0,s,-r,0,s,r,-s,-r,0,-s,r,0,s,-r,0,s,r,0,-r,0,-s,r,0,-s,-r,0,s,r,0,s],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const hE=new Q,fE=new Q,FP=new Q,dE=new jo;class wV extends un{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const s=Math.pow(10,4),i=Math.cos(In.DEG2RAD*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),f={},d=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:g,c:y}=dE;if(m.fromBufferAttribute(a,c[0]),g.fromBufferAttribute(a,c[1]),y.fromBufferAttribute(a,c[2]),dE.getNormal(FP),h[0]=`${Math.round(m.x*s)},${Math.round(m.y*s)},${Math.round(m.z*s)}`,h[1]=`${Math.round(g.x*s)},${Math.round(g.y*s)},${Math.round(g.z*s)}`,h[2]=`${Math.round(y.x*s)},${Math.round(y.y*s)},${Math.round(y.z*s)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let b=0;b<3;b++){const x=(b+1)%3,w=h[b],S=h[x],C=dE[u[b]],k=dE[u[x]],A=`${w}_${S}`,M=`${S}_${w}`;M in f&&f[M]?(FP.dot(f[M].normal)<=i&&(d.push(C.x,C.y,C.z),d.push(k.x,k.y,k.z)),f[M]=null):A in f||(f[A]={index0:c[b],index1:c[x],normal:FP.clone()})}}for(const p in f)if(f[p]){const{index0:m,index1:g}=f[p];hE.fromBufferAttribute(a,m),fE.fromBufferAttribute(a,g),d.push(hE.x,hE.y,hE.z),d.push(fE.x,fE.y,fE.z)}this.setAttribute("position",new Xt(d,3))}}const w0t={triangulate:function(n,e,t){t=t||2;const r=e&&e.length,s=r?e[0]*t:n.length;let i=Ole(n,0,s,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,c,u,h,f,d;if(r&&(i=k0t(n,e,i,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let p=t;p<s;p+=t)h=n[p],f=n[p+1],h<a&&(a=h),f<l&&(l=f),h>c&&(c=h),f>u&&(u=f);d=Math.max(c-a,u-l),d=d!==0?1/d:0}return AS(i,o,t,a,l,d),o}};function Ole(n,e,t,r,s){let i,o;if(s===O0t(n,e,t,r)>0)for(i=e;i<t;i+=r)o=oq(i,n[i],n[i+1],o);else for(i=t-r;i>=e;i-=r)o=oq(i,n[i],n[i+1],o);return o&&z$(o,o.next)&&(NS(o),o=o.next),o}function kp(n,e){if(!n)return n;e||(e=n);let t=n,r;do if(r=!1,!t.steiner&&(z$(t,t.next)||Os(t.prev,t,t.next)===0)){if(NS(t),t=e=t.prev,t===t.next)break;r=!0}else t=t.next;while(r||t!==e);return e}function AS(n,e,t,r,s,i,o){if(!n)return;!o&&i&&M0t(n,r,s,i);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,i?_0t(n,r,s,i):x0t(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),NS(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=S0t(kp(n),e,t),AS(n,e,t,r,s,i,2)):o===2&&C0t(n,e,t,r,s,i):AS(kp(n),e,t,r,s,i,1);break}}}function x0t(n){const e=n.prev,t=n,r=n.next;if(Os(e,t,r)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(Eb(e.x,e.y,t.x,t.y,r.x,r.y,s.x,s.y)&&Os(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function _0t(n,e,t,r){const s=n.prev,i=n,o=n.next;if(Os(s,i,o)>=0)return!1;const a=s.x<i.x?s.x<o.x?s.x:o.x:i.x<o.x?i.x:o.x,l=s.y<i.y?s.y<o.y?s.y:o.y:i.y<o.y?i.y:o.y,c=s.x>i.x?s.x>o.x?s.x:o.x:i.x>o.x?i.x:o.x,u=s.y>i.y?s.y>o.y?s.y:o.y:i.y>o.y?i.y:o.y,h=KF(a,l,e,t,r),f=KF(c,u,e,t,r);let d=n.prevZ,p=n.nextZ;for(;d&&d.z>=h&&p&&p.z<=f;){if(d!==n.prev&&d!==n.next&&Eb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Os(d.prev,d,d.next)>=0||(d=d.prevZ,p!==n.prev&&p!==n.next&&Eb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Os(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;d&&d.z>=h;){if(d!==n.prev&&d!==n.next&&Eb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Os(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;p&&p.z<=f;){if(p!==n.prev&&p!==n.next&&Eb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Os(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function S0t(n,e,t){let r=n;do{const s=r.prev,i=r.next.next;!z$(s,i)&&Fle(s,r,r.next,i)&&MS(s,i)&&MS(i,s)&&(e.push(s.i/t),e.push(r.i/t),e.push(i.i/t),NS(r),NS(r.next),r=n=i),r=r.next}while(r!==n);return kp(r)}function C0t(n,e,t,r,s,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&R0t(o,a)){let l=Lle(o,a);o=kp(o,o.next),l=kp(l,l.next),AS(o,e,t,r,s,i),AS(l,e,t,r,s,i);return}a=a.next}o=o.next}while(o!==n)}function k0t(n,e,t,r){const s=[];let i,o,a,l,c;for(i=0,o=e.length;i<o;i++)a=e[i]*r,l=i<o-1?e[i+1]*r:n.length,c=Ole(n,a,l,r,!1),c===c.next&&(c.steiner=!0),s.push($0t(c));for(s.sort(T0t),i=0;i<s.length;i++)E0t(s[i],t),t=kp(t,t.next);return t}function T0t(n,e){return n.x-e.x}function E0t(n,e){if(e=I0t(n,e),e){const t=Lle(e,n);kp(e,e.next),kp(t,t.next)}}function I0t(n,e){let t=e;const r=n.x,s=n.y;let i=-1/0,o;do{if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const f=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=r&&f>i){if(i=f,f===r){if(s===t.y)return t;if(s===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(r===i)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do r>=t.x&&t.x>=l&&r!==t.x&&Eb(s<c?r:i,s,l,c,s<c?i:r,s,t.x,t.y)&&(h=Math.abs(s-t.y)/(r-t.x),MS(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&A0t(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function A0t(n,e){return Os(n.prev,n,e.prev)<0&&Os(e.next,n,n.next)<0}function M0t(n,e,t,r){let s=n;do s.z===null&&(s.z=KF(s.x,s.y,e,t,r)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,N0t(s)}function N0t(n){let e,t,r,s,i,o,a,l,c=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,r=t,a=0,e=0;e<c&&(a++,r=r.nextZ,!!r);e++);for(l=c;a>0||l>0&&r;)a!==0&&(l===0||!r||t.z<=r.z)?(s=t,t=t.nextZ,a--):(s=r,r=r.nextZ,l--),i?i.nextZ=s:n=s,s.prevZ=i,i=s;t=r}i.nextZ=null,c*=2}while(o>1);return n}function KF(n,e,t,r,s){return n=32767*(n-t)*s,e=32767*(e-r)*s,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function $0t(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Eb(n,e,t,r,s,i,o,a){return(s-o)*(e-a)-(n-o)*(i-a)>=0&&(n-o)*(r-a)-(t-o)*(e-a)>=0&&(t-o)*(i-a)-(s-o)*(r-a)>=0}function R0t(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!P0t(n,e)&&(MS(n,e)&&MS(e,n)&&D0t(n,e)&&(Os(n.prev,n,e.prev)||Os(n,e.prev,e))||z$(n,e)&&Os(n.prev,n,n.next)>0&&Os(e.prev,e,e.next)>0)}function Os(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function z$(n,e){return n.x===e.x&&n.y===e.y}function Fle(n,e,t,r){const s=mE(Os(n,e,t)),i=mE(Os(n,e,r)),o=mE(Os(t,r,n)),a=mE(Os(t,r,e));return!!(s!==i&&o!==a||s===0&&pE(n,t,e)||i===0&&pE(n,r,e)||o===0&&pE(t,n,r)||a===0&&pE(t,e,r))}function pE(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function mE(n){return n>0?1:n<0?-1:0}function P0t(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Fle(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function MS(n,e){return Os(n.prev,n,n.next)<0?Os(n,e,n.next)>=0&&Os(n,n.prev,e)>=0:Os(n,e,n.prev)<0||Os(n,n.next,e)<0}function D0t(n,e){let t=n,r=!1;const s=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&s<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==n);return r}function Lle(n,e){const t=new YF(n.i,n.x,n.y),r=new YF(e.i,e.x,e.y),s=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function oq(n,e,t,r){const s=new YF(n,e,t);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function NS(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function YF(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O0t(n,e,t,r){let s=0;for(let i=e,o=t-r;i<t;i+=r)s+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return s}const Pf={area:function(n){const e=n.length;let t=0;for(let r=e-1,s=0;s<e;r=s++)t+=n[r].x*n[s].y-n[s].x*n[r].y;return t*.5},isClockWise:function(n){return Pf.area(n)<0},triangulateShape:function(n,e){const t=[],r=[],s=[];aq(n),lq(t,n);let i=n.length;e.forEach(aq);for(let a=0;a<e.length;a++)r.push(i),i+=e[a].length,lq(t,e[a]);const o=w0t.triangulate(t,r);for(let a=0;a<o.length;a+=3)s.push(o.slice(a,a+3));return s}};function aq(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function lq(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Ig extends un{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,s=[],i=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new Xt(s,3)),this.setAttribute("uv",new Xt(i,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:100,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:6,p=t.bevelSize!==void 0?t.bevelSize:d-2,m=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const y=t.extrudePath,b=t.UVGenerator!==void 0?t.UVGenerator:F0t;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let x,w=!1,S,C,k,A;y&&(x=y.getSpacedPoints(u),w=!0,f=!1,S=y.computeFrenetFrames(u,!1),C=new Q,k=new Q,A=new Q),f||(g=0,d=0,p=0,m=0);const M=a.extractPoints(c);let E=M.shape;const N=M.holes;if(!Pf.isClockWise(E)){E=E.reverse();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];Pf.isClockWise(Be)&&(N[Ve]=Be.reverse())}}const R=Pf.triangulateShape(E,N),D=E;for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];E=E.concat(Be)}function z(Ve,ze,Be){return ze||console.error("THREE.ExtrudeGeometry: vec does not exist"),ze.clone().multiplyScalar(Be).add(Ve)}const B=E.length,X=R.length;function G(Ve,ze,Be){let ut,Ke,ee;const J=Ve.x-ze.x,rt=Ve.y-ze.y,Ge=Be.x-Ve.x,ye=Be.y-Ve.y,Ze=J*J+rt*rt,yt=J*ye-rt*Ge;if(Math.abs(yt)>Number.EPSILON){const Ct=Math.sqrt(Ze),ft=Math.sqrt(Ge*Ge+ye*ye),ce=ze.x-rt/Ct,nt=ze.y+J/Ct,St=Be.x-ye/ft,gt=Be.y+Ge/ft,Gt=((St-ce)*ye-(gt-nt)*Ge)/(J*ye-rt*Ge);ut=ce+J*Gt-Ve.x,Ke=nt+rt*Gt-Ve.y;const Mn=ut*ut+Ke*Ke;if(Mn<=2)return new st(ut,Ke);ee=Math.sqrt(Mn/2)}else{let Ct=!1;J>Number.EPSILON?Ge>Number.EPSILON&&(Ct=!0):J<-Number.EPSILON?Ge<-Number.EPSILON&&(Ct=!0):Math.sign(rt)===Math.sign(ye)&&(Ct=!0),Ct?(ut=-rt,Ke=J,ee=Math.sqrt(Ze)):(ut=J,Ke=rt,ee=Math.sqrt(Ze/2))}return new st(ut/ee,Ke/ee)}const te=[];for(let Ve=0,ze=D.length,Be=ze-1,ut=Ve+1;Ve<ze;Ve++,Be++,ut++)Be===ze&&(Be=0),ut===ze&&(ut=0),te[Ve]=G(D[Ve],D[Be],D[ut]);const ge=[];let ae,Ne=te.concat();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];ae=[];for(let ut=0,Ke=Be.length,ee=Ke-1,J=ut+1;ut<Ke;ut++,ee++,J++)ee===Ke&&(ee=0),J===Ke&&(J=0),ae[ut]=G(Be[ut],Be[ee],Be[J]);ge.push(ae),Ne=Ne.concat(ae)}for(let Ve=0;Ve<g;Ve++){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ut=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,ee=D.length;Ke<ee;Ke++){const J=z(D[Ke],te[Ke],ut);Oe(J.x,J.y,-Be)}for(let Ke=0,ee=N.length;Ke<ee;Ke++){const J=N[Ke];ae=ge[Ke];for(let rt=0,Ge=J.length;rt<Ge;rt++){const ye=z(J[rt],ae[rt],ut);Oe(ye.x,ye.y,-Be)}}}const ke=p+m;for(let Ve=0;Ve<B;Ve++){const ze=f?z(E[Ve],Ne[Ve],ke):E[Ve];w?(k.copy(S.normals[0]).multiplyScalar(ze.x),C.copy(S.binormals[0]).multiplyScalar(ze.y),A.copy(x[0]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(ze.x,ze.y,0)}for(let Ve=1;Ve<=u;Ve++)for(let ze=0;ze<B;ze++){const Be=f?z(E[ze],Ne[ze],ke):E[ze];w?(k.copy(S.normals[Ve]).multiplyScalar(Be.x),C.copy(S.binormals[Ve]).multiplyScalar(Be.y),A.copy(x[Ve]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(Be.x,Be.y,h/u*Ve)}for(let Ve=g-1;Ve>=0;Ve--){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ut=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,ee=D.length;Ke<ee;Ke++){const J=z(D[Ke],te[Ke],ut);Oe(J.x,J.y,h+Be)}for(let Ke=0,ee=N.length;Ke<ee;Ke++){const J=N[Ke];ae=ge[Ke];for(let rt=0,Ge=J.length;rt<Ge;rt++){const ye=z(J[rt],ae[rt],ut);w?Oe(ye.x,ye.y+x[u-1].y,x[u-1].x+Be):Oe(ye.x,ye.y,h+Be)}}}De(),be();function De(){const Ve=s.length/3;if(f){let ze=0,Be=B*ze;for(let ut=0;ut<X;ut++){const Ke=R[ut];it(Ke[2]+Be,Ke[1]+Be,Ke[0]+Be)}ze=u+g*2,Be=B*ze;for(let ut=0;ut<X;ut++){const Ke=R[ut];it(Ke[0]+Be,Ke[1]+Be,Ke[2]+Be)}}else{for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[2],Be[1],Be[0])}for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[0]+B*u,Be[1]+B*u,Be[2]+B*u)}}r.addGroup(Ve,s.length/3-Ve,0)}function be(){const Ve=s.length/3;let ze=0;Xe(D,ze),ze+=D.length;for(let Be=0,ut=N.length;Be<ut;Be++){const Ke=N[Be];Xe(Ke,ze),ze+=Ke.length}r.addGroup(Ve,s.length/3-Ve,1)}function Xe(Ve,ze){let Be=Ve.length;for(;--Be>=0;){const ut=Be;let Ke=Be-1;Ke<0&&(Ke=Ve.length-1);for(let ee=0,J=u+g*2;ee<J;ee++){const rt=B*ee,Ge=B*(ee+1),ye=ze+ut+rt,Ze=ze+Ke+rt,yt=ze+Ke+Ge,Ct=ze+ut+Ge;We(ye,Ze,yt,Ct)}}}function Oe(Ve,ze,Be){l.push(Ve),l.push(ze),l.push(Be)}function it(Ve,ze,Be){dt(Ve),dt(ze),dt(Be);const ut=s.length/3,Ke=b.generateTopUV(r,s,ut-3,ut-2,ut-1);ct(Ke[0]),ct(Ke[1]),ct(Ke[2])}function We(Ve,ze,Be,ut){dt(Ve),dt(ze),dt(ut),dt(ze),dt(Be),dt(ut);const Ke=s.length/3,ee=b.generateSideWallUV(r,s,Ke-6,Ke-3,Ke-2,Ke-1);ct(ee[0]),ct(ee[1]),ct(ee[3]),ct(ee[1]),ct(ee[2]),ct(ee[3])}function dt(Ve){s.push(l[Ve*3+0]),s.push(l[Ve*3+1]),s.push(l[Ve*3+2])}function ct(Ve){i.push(Ve.x),i.push(Ve.y)}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes,r=this.parameters.options;return L0t(t,r,e)}}const F0t={generateTopUV:function(n,e,t,r,s){const i=e[t*3],o=e[t*3+1],a=e[r*3],l=e[r*3+1],c=e[s*3],u=e[s*3+1];return[new st(i,o),new st(a,l),new st(c,u)]},generateSideWallUV:function(n,e,t,r,s,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[r*3],u=e[r*3+1],h=e[r*3+2],f=e[s*3],d=e[s*3+1],p=e[s*3+2],m=e[i*3],g=e[i*3+1],y=e[i*3+2];return Math.abs(a-u)<.01?[new st(o,1-l),new st(c,1-h),new st(f,1-p),new st(m,1-y)]:[new st(a,1-l),new st(u,1-h),new st(d,1-p),new st(g,1-y)]}};function L0t(n,e,t){if(t.shapes=[],Array.isArray(n))for(let r=0,s=n.length;r<s;r++){const i=n[r];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class zA extends Cp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,i,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class BA extends un{constructor(e,t=12,r=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:s},t=Math.floor(t),s=In.clamp(s,0,Math.PI*2);const i=[],o=[],a=[],l=1/t,c=new Q,u=new st;for(let h=0;h<=t;h++){const f=r+h*l*s,d=Math.sin(f),p=Math.cos(f);for(let m=0;m<=e.length-1;m++)c.x=e[m].x*d,c.y=e[m].y,c.z=e[m].x*p,o.push(c.x,c.y,c.z),u.x=h/t,u.y=m/(e.length-1),a.push(u.x,u.y)}for(let h=0;h<t;h++)for(let f=0;f<e.length-1;f++){const d=f+h*e.length,p=d,m=d+e.length,g=d+e.length+1,y=d+1;i.push(p,m,y),i.push(m,g,y)}if(this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("uv",new Xt(a,2)),this.computeVertexNormals(),s===Math.PI*2){const h=this.attributes.normal.array,f=new Q,d=new Q,p=new Q,m=t*e.length*3;for(let g=0,y=0;g<e.length;g++,y+=3)f.x=h[y+0],f.y=h[y+1],f.z=h[y+2],d.x=h[m+y+0],d.y=h[m+y+1],d.z=h[m+y+2],p.addVectors(f,d).normalize(),h[y+0]=h[m+y+0]=p.x,h[y+1]=h[m+y+1]=p.y,h[y+2]=h[m+y+2]=p.z}}}class $S extends Cp{constructor(e=1,t=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function Ag(n,e,t){un.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:e,stacks:t};const r=[],s=[],i=[],o=[],a=1e-5,l=new Q,c=new Q,u=new Q,h=new Q,f=new Q;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const d=e+1;for(let p=0;p<=t;p++){const m=p/t;for(let g=0;g<=e;g++){const y=g/e;n(y,m,c),s.push(c.x,c.y,c.z),y-a>=0?(n(y-a,m,u),h.subVectors(c,u)):(n(y+a,m,u),h.subVectors(u,c)),m-a>=0?(n(y,m-a,u),f.subVectors(c,u)):(n(y,m+a,u),f.subVectors(u,c)),l.crossVectors(h,f).normalize(),i.push(l.x,l.y,l.z),o.push(y,m)}}for(let p=0;p<t;p++)for(let m=0;m<e;m++){const g=p*d+m,y=p*d+m+1,b=(p+1)*d+m+1,x=(p+1)*d+m;r.push(g,y,x),r.push(y,b,x)}this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2))}Ag.prototype=Object.create(un.prototype);Ag.prototype.constructor=Ag;class VA extends un{constructor(e=.5,t=1,r=8,s=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:s,thetaStart:i,thetaLength:o},r=Math.max(3,r),s=Math.max(1,s);const a=[],l=[],c=[],u=[];let h=e;const f=(t-e)/s,d=new Q,p=new st;for(let m=0;m<=s;m++){for(let g=0;g<=r;g++){const y=i+g/r*o;d.x=h*Math.cos(y),d.y=h*Math.sin(y),l.push(d.x,d.y,d.z),c.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,u.push(p.x,p.y)}h+=f}for(let m=0;m<s;m++){const g=m*(r+1);for(let y=0;y<r;y++){const b=y+g,x=b,w=b+r+1,S=b+r+2,C=b+1;a.push(x,w,C),a.push(w,S,C)}}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2))}}class RS extends un{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],s=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2));function c(u){const h=s.length/3,f=u.extractPoints(t);let d=f.shape;const p=f.holes;Pf.isClockWise(d)===!1&&(d=d.reverse());for(let g=0,y=p.length;g<y;g++){const b=p[g];Pf.isClockWise(b)===!0&&(p[g]=b.reverse())}const m=Pf.triangulateShape(d,p);for(let g=0,y=p.length;g<y;g++){const b=p[g];d=d.concat(b)}for(let g=0,y=d.length;g<y;g++){const b=d[g];s.push(b.x,b.y,0),i.push(0,0,1),o.push(b.x,b.y)}for(let g=0,y=m.length;g<y;g++){const b=m[g],x=b[0]+h,w=b[1]+h,S=b[2]+h;r.push(x,w,S),l+=3}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes;return z0t(t,e)}}function z0t(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const s=n[t];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return e}class PS extends un{constructor(e=1,t=8,r=6,s=0,i=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:s,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new Q,f=new Q,d=[],p=[],m=[],g=[];for(let y=0;y<=r;y++){const b=[],x=y/r;let w=0;y==0&&o==0?w=.5/t:y==r&&l==Math.PI&&(w=-.5/t);for(let S=0;S<=t;S++){const C=S/t;h.x=-e*Math.cos(s+C*i)*Math.sin(o+x*a),h.y=e*Math.cos(o+x*a),h.z=e*Math.sin(s+C*i)*Math.sin(o+x*a),p.push(h.x,h.y,h.z),f.copy(h).normalize(),m.push(f.x,f.y,f.z),g.push(C+w,1-x),b.push(c++)}u.push(b)}for(let y=0;y<r;y++)for(let b=0;b<t;b++){const x=u[y][b+1],w=u[y][b],S=u[y+1][b],C=u[y+1][b+1];(y!==0||o>0)&&d.push(x,w,C),(y!==r-1||l<Math.PI)&&d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}class UA extends Cp{constructor(e=1,t=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,s,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class WA extends Ig{constructor(e,t={}){const r=t.font;if(!(r&&r.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new un;const s=r.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(s,t),this.type="TextGeometry"}}class GA extends un{constructor(e=1,t=.4,r=8,s=6,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:s,arc:i},r=Math.floor(r),s=Math.floor(s);const o=[],a=[],l=[],c=[],u=new Q,h=new Q,f=new Q;for(let d=0;d<=r;d++)for(let p=0;p<=s;p++){const m=p/s*i,g=d/r*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(m),h.y=(e+t*Math.cos(g))*Math.sin(m),h.z=t*Math.sin(g),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),f.subVectors(h,u).normalize(),l.push(f.x,f.y,f.z),c.push(p/s),c.push(d/r)}for(let d=1;d<=r;d++)for(let p=1;p<=s;p++){const m=(s+1)*d+p-1,g=(s+1)*(d-1)+p-1,y=(s+1)*(d-1)+p,b=(s+1)*d+p;o.push(m,g,b),o.push(g,y,b)}this.setIndex(o),this.setAttribute("position",new Xt(a,3)),this.setAttribute("normal",new Xt(l,3)),this.setAttribute("uv",new Xt(c,2))}}class HA extends un{constructor(e=1,t=.4,r=64,s=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:s,p:i,q:o},r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[],h=new Q,f=new Q,d=new Q,p=new Q,m=new Q,g=new Q,y=new Q;for(let x=0;x<=r;++x){const w=x/r*i*Math.PI*2;b(w,i,o,e,d),b(w+.01,i,o,e,p),g.subVectors(p,d),y.addVectors(p,d),m.crossVectors(g,y),y.crossVectors(m,g),m.normalize(),y.normalize();for(let S=0;S<=s;++S){const C=S/s*Math.PI*2,k=-t*Math.cos(C),A=t*Math.sin(C);h.x=d.x+(k*y.x+A*m.x),h.y=d.y+(k*y.y+A*m.y),h.z=d.z+(k*y.z+A*m.z),l.push(h.x,h.y,h.z),f.subVectors(h,d).normalize(),c.push(f.x,f.y,f.z),u.push(x/r),u.push(S/s)}}for(let x=1;x<=r;x++)for(let w=1;w<=s;w++){const S=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;a.push(S,C,A),a.push(C,k,A)}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2));function b(x,w,S,C,k){const A=Math.cos(x),M=Math.sin(x),E=S/w*x,N=Math.cos(E);k.x=C*(2+N)*.5*A,k.y=C*(2+N)*M*.5,k.z=C*Math.sin(E)*.5}}}class jA extends un{constructor(e,t=64,r=1,s=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:s,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new Q,l=new Q,c=new st;let u=new Q;const h=[],f=[],d=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function m(){for(let x=0;x<t;x++)g(x);g(i===!1?t:0),b(),y()}function g(x){u=e.getPointAt(x/t,u);const w=o.normals[x],S=o.binormals[x];for(let C=0;C<=s;C++){const k=C/s*Math.PI*2,A=Math.sin(k),M=-Math.cos(k);l.x=M*w.x+A*S.x,l.y=M*w.y+A*S.y,l.z=M*w.z+A*S.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=u.x+r*l.x,a.y=u.y+r*l.y,a.z=u.z+r*l.z,h.push(a.x,a.y,a.z)}}function y(){for(let x=1;x<=t;x++)for(let w=1;w<=s;w++){const S=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;p.push(S,C,A),p.push(C,k,A)}}function b(){for(let x=0;x<=t;x++)for(let w=0;w<=s;w++)c.x=x/t,c.y=w/s,d.push(c.x,c.y)}}toJSON(){const e=un.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class xV extends un{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const t=[],r=[0,0],s={},i=new Q;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],f=h.start,d=h.count;for(let p=f,m=f+d;p<m;p+=3)for(let g=0;g<3;g++){const y=a.getX(p+g),b=a.getX(p+(g+1)%3);r[0]=Math.min(y,b),r[1]=Math.max(y,b);const x=r[0]+","+r[1];s[x]===void 0&&(s[x]={index1:r[0],index2:r[1]})}}for(const c in s){const u=s[c];i.fromBufferAttribute(o,u.index1),t.push(i.x,i.y,i.z),i.fromBufferAttribute(o,u.index2),t.push(i.x,i.y,i.z)}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c;i.fromBufferAttribute(o,u),t.push(i.x,i.y,i.z);const h=3*a+(c+1)%3;i.fromBufferAttribute(o,h),t.push(i.x,i.y,i.z)}}this.setAttribute("position",new Xt(t,3))}}var ua=Object.freeze({__proto__:null,BoxGeometry:Tg,BoxBufferGeometry:Tg,CircleGeometry:OA,CircleBufferGeometry:OA,ConeGeometry:FA,ConeBufferGeometry:FA,CylinderGeometry:xv,CylinderBufferGeometry:xv,DodecahedronGeometry:LA,DodecahedronBufferGeometry:LA,EdgesGeometry:wV,ExtrudeGeometry:Ig,ExtrudeBufferGeometry:Ig,IcosahedronGeometry:zA,IcosahedronBufferGeometry:zA,LatheGeometry:BA,LatheBufferGeometry:BA,OctahedronGeometry:$S,OctahedronBufferGeometry:$S,ParametricGeometry:Ag,ParametricBufferGeometry:Ag,PlaneGeometry:xS,PlaneBufferGeometry:xS,PolyhedronGeometry:Cp,PolyhedronBufferGeometry:Cp,RingGeometry:VA,RingBufferGeometry:VA,ShapeGeometry:RS,ShapeBufferGeometry:RS,SphereGeometry:PS,SphereBufferGeometry:PS,TetrahedronGeometry:UA,TetrahedronBufferGeometry:UA,TextGeometry:WA,TextBufferGeometry:WA,TorusGeometry:GA,TorusBufferGeometry:GA,TorusKnotGeometry:HA,TorusKnotBufferGeometry:HA,TubeGeometry:jA,TubeBufferGeometry:jA,WireframeGeometry:xV});function Mg(n){kn.call(this),this.type="ShadowMaterial",this.color=new Ht(0),this.transparent=!0,this.setValues(n)}Mg.prototype=Object.create(kn.prototype);Mg.prototype.constructor=Mg;Mg.prototype.isShadowMaterial=!0;Mg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this};function Bf(n){ka.call(this,n),this.type="RawShaderMaterial"}Bf.prototype=Object.create(ka.prototype);Bf.prototype.constructor=Bf;Bf.prototype.isRawShaderMaterial=!0;function Ah(n){kn.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ht(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=n0,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(n)}Ah.prototype=Object.create(kn.prototype);Ah.prototype.constructor=Ah;Ah.prototype.isMeshStandardMaterial=!0;Ah.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.vertexTangents=n.vertexTangents,this};function Tp(n){Ah.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new st(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=In.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}Tp.prototype=Object.create(Ah.prototype);Tp.prototype.constructor=Tp;Tp.prototype.isMeshPhysicalMaterial=!0;Tp.prototype.copy=function(n){return Ah.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new Ht).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};function Ep(n){kn.call(this),this.type="MeshPhongMaterial",this.color=new Ht(16777215),this.specular=new Ht(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=n0,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=VC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ep.prototype=Object.create(kn.prototype);Ep.prototype.constructor=Ep;Ep.prototype.isMeshPhongMaterial=!0;Ep.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ng(n){kn.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ht(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=n0,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ng.prototype=Object.create(kn.prototype);Ng.prototype.constructor=Ng;Ng.prototype.isMeshToonMaterial=!0;Ng.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function $g(n){kn.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=n0,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}$g.prototype=Object.create(kn.prototype);$g.prototype.constructor=$g;$g.prototype.isMeshNormalMaterial=!0;$g.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Rg(n){kn.call(this),this.type="MeshLambertMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=VC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Rg.prototype=Object.create(kn.prototype);Rg.prototype.constructor=Rg;Rg.prototype.isMeshLambertMaterial=!0;Rg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Pg(n){kn.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ht(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=n0,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Pg.prototype=Object.create(kn.prototype);Pg.prototype.constructor=Pg;Pg.prototype.isMeshMatcapMaterial=!0;Pg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Dg(n){Es.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}Dg.prototype=Object.create(Es.prototype);Dg.prototype.constructor=Dg;Dg.prototype.isLineDashedMaterial=!0;Dg.prototype.copy=function(n){return Es.prototype.copy.call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this};var B0t=Object.freeze({__proto__:null,ShadowMaterial:Mg,SpriteMaterial:Sp,RawShaderMaterial:Bf,ShaderMaterial:ka,PointsMaterial:Eu,MeshPhysicalMaterial:Tp,MeshStandardMaterial:Ah,MeshPhongMaterial:Ep,MeshToonMaterial:Ng,MeshNormalMaterial:$g,MeshLambertMaterial:Rg,MeshDepthMaterial:wp,MeshDistanceMaterial:xp,MeshBasicMaterial:Dl,MeshMatcapMaterial:Pg,LineDashedMaterial:Dg,LineBasicMaterial:Es,Material:kn});const ps={arraySlice:function(n,e,t){return ps.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(s,i){return n[s]-n[i]}const t=n.length,r=new Array(t);for(let s=0;s!==t;++s)r[s]=s;return r.sort(e),r},sortedArray:function(n,e,t){const r=n.length,s=new n.constructor(r);for(let i=0,o=0;o!==r;++i){const a=t[i]*e;for(let l=0;l!==e;++l)s[o++]=n[a+l]}return s},flattenJSON:function(n,e,t,r){let s=1,i=n[0];for(;i!==void 0&&i[r]===void 0;)i=n[s++];if(i===void 0)return;let o=i[r];if(o!==void 0)if(Array.isArray(o))do o=i[r],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[s++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[r],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[s++];while(i!==void 0);else do o=i[r],o!==void 0&&(e.push(i.time),t.push(o)),i=n[s++];while(i!==void 0)},subclip:function(n,e,t,r,s=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const c=i.tracks[l],u=c.getValueSize(),h=[],f=[];for(let d=0;d<c.times.length;++d){const p=c.times[d]*s;if(!(p<t||p>=r)){h.push(c.times[d]);for(let m=0;m<u;++m)f.push(c.values[d*u+m])}}h.length!==0&&(c.times=ps.convertArray(h,c.times.constructor),c.values=ps.convertArray(f,c.values.constructor),o.push(c))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i},makeClipAdditive:function(n,e=0,t=n,r=30){r<=0&&(r=30);const s=t.tracks.length,i=e/r;for(let o=0;o<s;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let f=0;const d=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const p=a.times.length-1;let m;if(i<=a.times[0]){const y=u,b=h-u;m=ps.arraySlice(a.values,y,b)}else if(i>=a.times[p]){const y=p*h+u,b=y+h-u;m=ps.arraySlice(a.values,y,b)}else{const y=a.createInterpolant(),b=u,x=h-u;y.evaluate(i),m=ps.arraySlice(y.resultBuffer,b,x)}l==="quaternion"&&new co().fromArray(m).normalize().conjugate().toArray(m);const g=c.times.length;for(let y=0;y<g;++y){const b=y*d+f;if(l==="quaternion")co.multiplyQuaternionsFlat(c.values,b,m,0,c.values,b);else{const x=d-f*2;for(let w=0;w<x;++w)c.values[b+w]-=m[w]}}}return n.blendMode=fV,n}};function Ml(n,e,t,r){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(t),this.sampleValues=e,this.valueSize=t}Object.assign(Ml.prototype,{evaluate:function(n){const e=this.parameterPositions;let t=this._cachedIndex,r=e[t],s=e[t-1];e:{t:{let i;n:{r:if(!(n<r)){for(let o=t+2;;){if(r===void 0){if(n<s)break r;return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,n,s)}if(t===o)break;if(s=r,r=e[++t],n<r)break t}i=e.length;break n}if(!(n>=s)){const o=e[1];n<o&&(t=2,s=o);for(let a=t-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(t===a)break;if(r=s,s=e[--t-1],n>=s)break t}i=t,t=0;break n}break e}for(;t<i;){const o=t+i>>>1;n<e[o]?i=o:t=o+1}if(r=e[t],s=e[t-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(r===void 0)return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,s,n)}this._cachedIndex=t,this.intervalChanged_(t,s,r)}return this.interpolate_(t,s,n,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const e=this.resultBuffer,t=this.sampleValues,r=this.valueSize,s=n*r;for(let i=0;i!==r;++i)e[i]=t[s+i];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Ml.prototype,{beforeStart_:Ml.prototype.copySampleValue_,afterEnd_:Ml.prototype.copySampleValue_});function qA(n,e,t,r){Ml.call(this,n,e,t,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}qA.prototype=Object.assign(Object.create(Ml.prototype),{constructor:qA,DefaultSettings_:{endingStart:Xm,endingEnd:Xm},intervalChanged_:function(n,e,t){const r=this.parameterPositions;let s=n-2,i=n+1,o=r[s],a=r[i];if(o===void 0)switch(this.getSettings_().endingStart){case Km:s=n,o=2*e-t;break;case dS:s=r.length-2,o=e+r[s]-r[s+1];break;default:s=n,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Km:i=n,a=2*t-e;break;case dS:i=1,a=t+r[1]-r[0];break;default:i=n-1,a=e}const l=(t-e)*.5,c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-t),this._offsetPrev=s*c,this._offsetNext=i*c},interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,f=this._weightNext,d=(t-e)/(r-e),p=d*d,m=p*d,g=-h*m+2*h*p-h*d,y=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*d+1,b=(-1-f)*m+(1.5+f)*p+.5*d,x=f*m-f*p;for(let w=0;w!==o;++w)s[w]=g*i[c+w]+y*i[l+w]+b*i[a+w]+x*i[u+w];return s}});function DS(n,e,t,r){Ml.call(this,n,e,t,r)}DS.prototype=Object.assign(Object.create(Ml.prototype),{constructor:DS,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(t-e)/(r-e),u=1-c;for(let h=0;h!==o;++h)s[h]=i[l+h]*u+i[a+h]*c;return s}});function XA(n,e,t,r){Ml.call(this,n,e,t,r)}XA.prototype=Object.assign(Object.create(Ml.prototype),{constructor:XA,interpolate_:function(n){return this.copySampleValue_(n-1)}});function Co(n,e,t,r){if(n===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=ps.convertArray(e,this.TimeBufferType),this.values=ps.convertArray(t,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}Object.assign(Co,{toJSON:function(n){const e=n.constructor;let t;if(e.toJSON!==void 0)t=e.toJSON(n);else{t={name:n.name,times:ps.convertArray(n.times,Array),values:ps.convertArray(n.values,Array)};const r=n.getInterpolation();r!==n.DefaultInterpolation&&(t.interpolation=r)}return t.type=n.ValueTypeName,t}});Object.assign(Co.prototype,{constructor:Co,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:u_,InterpolantFactoryMethodDiscrete:function(n){return new XA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodLinear:function(n){return new DS(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:function(n){return new qA(this.times,this.values,this.getValueSize(),n)},setInterpolation:function(n){let e;switch(n){case fS:e=this.InterpolantFactoryMethodDiscrete;break;case u_:e=this.InterpolantFactoryMethodLinear;break;case iI:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return fS;case this.InterpolantFactoryMethodLinear:return u_;case this.InterpolantFactoryMethodSmooth:return iI}},getValueSize:function(){return this.values.length/this.times.length},shift:function(n){if(n!==0){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]+=n}return this},scale:function(n){if(n!==1){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]*=n}return this},trim:function(n,e){const t=this.times,r=t.length;let s=0,i=r-1;for(;s!==r&&t[s]<n;)++s;for(;i!==-1&&t[i]>e;)--i;if(++i,s!==0||i!==r){s>=i&&(i=Math.max(i,1),s=i-1);const o=this.getValueSize();this.times=ps.arraySlice(t,s,i),this.values=ps.arraySlice(this.values,s*o,i*o)}return this},validate:function(){let n=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);const t=this.times,r=this.values,s=t.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let i=null;for(let o=0;o!==s;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),n=!1;break}if(i!==null&&i>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,i),n=!1;break}i=a}if(r!==void 0&&ps.isTypedArray(r))for(let o=0,a=r.length;o!==a;++o){const l=r[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),n=!1;break}}return n},optimize:function(){const n=ps.arraySlice(this.times),e=ps.arraySlice(this.values),t=this.getValueSize(),r=this.getInterpolation()===iI,s=n.length-1;let i=1;for(let o=1;o<s;++o){let a=!1;const l=n[o],c=n[o+1];if(l!==c&&(o!==1||l!==n[0]))if(r)a=!0;else{const u=o*t,h=u-t,f=u+t;for(let d=0;d!==t;++d){const p=e[u+d];if(p!==e[h+d]||p!==e[f+d]){a=!0;break}}}if(a){if(o!==i){n[i]=n[o];const u=o*t,h=i*t;for(let f=0;f!==t;++f)e[h+f]=e[u+f]}++i}}if(s>0){n[i]=n[s];for(let o=s*t,a=i*t,l=0;l!==t;++l)e[a+l]=e[o+l];++i}return i!==n.length?(this.times=ps.arraySlice(n,0,i),this.values=ps.arraySlice(e,0,i*t)):(this.times=n,this.values=e),this},clone:function(){const n=ps.arraySlice(this.times,0),e=ps.arraySlice(this.values,0),t=this.constructor,r=new t(this.name,n,e);return r.createInterpolant=this.createInterpolant,r}});function KA(n,e,t){Co.call(this,n,e,t)}KA.prototype=Object.assign(Object.create(Co.prototype),{constructor:KA,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:fS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function YA(n,e,t,r){Co.call(this,n,e,t,r)}YA.prototype=Object.assign(Object.create(Co.prototype),{constructor:YA,ValueTypeName:"color"});function _v(n,e,t,r){Co.call(this,n,e,t,r)}_v.prototype=Object.assign(Object.create(Co.prototype),{constructor:_v,ValueTypeName:"number"});function ZA(n,e,t,r){Ml.call(this,n,e,t,r)}ZA.prototype=Object.assign(Object.create(Ml.prototype),{constructor:ZA,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=(t-e)/(r-e);let l=n*o;for(let c=l+o;l!==c;l+=4)co.slerpFlat(s,0,i,l-o,i,l,a);return s}});function OS(n,e,t,r){Co.call(this,n,e,t,r)}OS.prototype=Object.assign(Object.create(Co.prototype),{constructor:OS,ValueTypeName:"quaternion",DefaultInterpolation:u_,InterpolantFactoryMethodLinear:function(n){return new ZA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:void 0});function JA(n,e,t,r){Co.call(this,n,e,t,r)}JA.prototype=Object.assign(Object.create(Co.prototype),{constructor:JA,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:fS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Sv(n,e,t,r){Co.call(this,n,e,t,r)}Sv.prototype=Object.assign(Object.create(Co.prototype),{constructor:Sv,ValueTypeName:"vector"});function _l(n,e=-1,t,r=P$){this.name=n,this.tracks=t,this.duration=e,this.blendMode=r,this.uuid=In.generateUUID(),this.duration<0&&this.resetDuration()}function V0t(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return _v;case"vector":case"vector2":case"vector3":case"vector4":return Sv;case"color":return YA;case"quaternion":return OS;case"bool":case"boolean":return KA;case"string":return JA}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function U0t(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=V0t(n.type);if(n.times===void 0){const t=[],r=[];ps.flattenJSON(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}Object.assign(_l,{parse:function(n){const e=[],t=n.tracks,r=1/(n.fps||1);for(let i=0,o=t.length;i!==o;++i)e.push(U0t(t[i]).scale(r));const s=new _l(n.name,n.duration,e,n.blendMode);return s.uuid=n.uuid,s},toJSON:function(n){const e=[],t=n.tracks,r={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode};for(let s=0,i=t.length;s!==i;++s)e.push(Co.toJSON(t[s]));return r},CreateFromMorphTargetSequence:function(n,e,t,r){const s=e.length,i=[];for(let o=0;o<s;o++){let a=[],l=[];a.push((o+s-1)%s,o,(o+1)%s),l.push(0,1,0);const c=ps.getKeyframeOrder(a);a=ps.sortedArray(a,1,c),l=ps.sortedArray(l,1,c),!r&&a[0]===0&&(a.push(s),l.push(l[0])),i.push(new _v(".morphTargetInfluences["+e[o].name+"]",a,l).scale(1/t))}return new _l(n,-1,i)},findByName:function(n,e){let t=n;if(!Array.isArray(n)){const r=n;t=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null},CreateClipsFromMorphTargetSequences:function(n,e,t){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.name.match(s);if(c&&c.length>1){const u=c[1];let h=r[u];h||(r[u]=h=[]),h.push(l)}}const i=[];for(const o in r)i.push(_l.CreateFromMorphTargetSequence(o,r[o],e,t));return i},parseAnimation:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(u,h,f,d,p){if(f.length!==0){const m=[],g=[];ps.flattenJSON(f,m,g,d),m.length!==0&&p.push(new u(h,m,g))}},r=[],s=n.name||"default",i=n.fps||30,o=n.blendMode;let a=n.length||-1;const l=n.hierarchy||[];for(let u=0;u<l.length;u++){const h=l[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const f={};let d;for(d=0;d<h.length;d++)if(h[d].morphTargets)for(let p=0;p<h[d].morphTargets.length;p++)f[h[d].morphTargets[p]]=-1;for(const p in f){const m=[],g=[];for(let y=0;y!==h[d].morphTargets.length;++y){const b=h[d];m.push(b.time),g.push(b.morphTarget===p?1:0)}r.push(new _v(".morphTargetInfluence["+p+"]",m,g))}a=f.length*(i||1)}else{const f=".bones["+e[u].name+"]";t(Sv,f+".position",h,"pos",r),t(OS,f+".quaternion",h,"rot",r),t(Sv,f+".scale",h,"scl",r)}}return r.length===0?null:new _l(s,a,r,o)}});Object.assign(_l.prototype,{resetDuration:function(){const n=this.tracks;let e=0;for(let t=0,r=n.length;t!==r;++t){const s=this.tracks[t];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this},trim:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this},validate:function(){let n=!0;for(let e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n},optimize:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this},clone:function(){const n=[];for(let e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new _l(this.name,this.duration,n,this.blendMode)},toJSON:function(){return _l.toJSON(this)}});const Og={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function _V(n,e,t){const r=this;let s=!1,i=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=e,this.onError=t,this.itemStart=function(c){o++,s===!1&&r.onStart!==void 0&&r.onStart(c,i,o),s=!0},this.itemEnd=function(c){i++,r.onProgress!==void 0&&r.onProgress(c,i,o),i===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,u){return l.push(c,u),this},this.removeHandler=function(c){const u=l.indexOf(c);return u!==-1&&l.splice(u,2),this},this.getHandler=function(c){for(let u=0,h=l.length;u<h;u+=2){const f=l[u],d=l[u+1];if(f.global&&(f.lastIndex=0),f.test(c))return d}return null}}const zle=new _V;function zr(n){this.manager=n!==void 0?n:zle,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(zr.prototype,{load:function(){},loadAsync:function(n,e){const t=this;return new Promise(function(r,s){t.load(n,r,e,s)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const eu={};function Rc(n){zr.call(this,n)}Rc.prototype=Object.assign(Object.create(zr.prototype),{constructor:Rc,load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Og.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;if(eu[n]!==void 0){eu[n].push({onLoad:e,onProgress:t,onError:r});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],u=!!a[2];let h=a[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let f;const d=(this.responseType||"").toLowerCase();switch(d){case"arraybuffer":case"blob":const p=new Uint8Array(h.length);for(let g=0;g<h.length;g++)p[g]=h.charCodeAt(g);d==="blob"?f=new Blob([p.buffer],{type:c}):f=p.buffer;break;case"document":f=new DOMParser().parseFromString(h,c);break;case"json":f=JSON.parse(h);break;default:f=h;break}setTimeout(function(){e&&e(f),s.manager.itemEnd(n)},0)}catch(f){setTimeout(function(){r&&r(f),s.manager.itemError(n),s.manager.itemEnd(n)},0)}}else{eu[n]=[],eu[n].push({onLoad:e,onProgress:t,onError:r}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const u=this.response,h=eu[n];if(delete eu[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Og.add(n,u);for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onLoad&&p.onLoad(u)}s.manager.itemEnd(n)}else{for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onError&&p.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const u=eu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onProgress&&d.onProgress(c)}},!1),l.addEventListener("error",function(c){const u=eu[n];delete eu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const u=eu[n];delete eu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return s.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function ZF(n){zr.call(this,n)}ZF.prototype=Object.assign(Object.create(zr.prototype),{constructor:ZF,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=[];for(let t=0;t<n.length;t++){const r=_l.parse(n[t]);e.push(r)}return e}});function JF(n){zr.call(this,n)}JF.prototype=Object.assign(Object.create(zr.prototype),{constructor:JF,load:function(n,e,t,r){const s=this,i=[],o=new wv,a=new Rc(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(s.withCredentials);let l=0;function c(u){a.load(n[u],function(h){const f=s.parse(h,!0);i[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},l+=1,l===6&&(f.mipmapCount===1&&(o.minFilter=lo),o.image=i,o.format=f.format,o.needsUpdate=!0,e&&e(o))},t,r)}if(Array.isArray(n))for(let u=0,h=n.length;u<h;++u)c(u);else a.load(n,function(u){const h=s.parse(u,!0);if(h.isCubemap){const f=h.mipmaps.length/h.mipmapCount;for(let d=0;d<f;d++){i[d]={mipmaps:[]};for(let p=0;p<h.mipmapCount;p++)i[d].mipmaps.push(h.mipmaps[d*h.mipmapCount+p]),i[d].format=h.format,i[d].width=h.width,i[d].height=h.height}o.image=i}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=lo),o.format=h.format,o.needsUpdate=!0,e&&e(o)},t,r);return o}});function Cv(n){zr.call(this,n)}Cv.prototype=Object.assign(Object.create(zr.prototype),{constructor:Cv,load:function(n,e,t,r){this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Og.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Og.add(n,this),e&&e(this),s.manager.itemEnd(n)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),r&&r(c),s.manager.itemError(n),s.manager.itemEnd(n)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),n.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(n),o.src=n,o}});function QA(n){zr.call(this,n)}QA.prototype=Object.assign(Object.create(zr.prototype),{constructor:QA,load:function(n,e,t,r){const s=new Ih,i=new Cv(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let o=0;function a(l){i.load(n[l],function(c){s.images[l]=c,o++,o===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let l=0;l<n.length;++l)a(l);return s}});function eM(n){zr.call(this,n)}eM.prototype=Object.assign(Object.create(zr.prototype),{constructor:eM,load:function(n,e,t,r){const s=this,i=new zf,o=new Rc(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(s.withCredentials),o.load(n,function(a){const l=s.parse(a);l&&(l.image!==void 0?i.image=l.image:l.data!==void 0&&(i.image.width=l.width,i.image.height=l.height,i.image.data=l.data),i.wrapS=l.wrapS!==void 0?l.wrapS:pa,i.wrapT=l.wrapT!==void 0?l.wrapT:pa,i.magFilter=l.magFilter!==void 0?l.magFilter:lo,i.minFilter=l.minFilter!==void 0?l.minFilter:lo,i.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(i.encoding=l.encoding),l.flipY!==void 0&&(i.flipY=l.flipY),l.format!==void 0&&(i.format=l.format),l.type!==void 0&&(i.type=l.type),l.mipmaps!==void 0&&(i.mipmaps=l.mipmaps,i.minFilter=lx),l.mipmapCount===1&&(i.minFilter=lo),i.needsUpdate=!0,e&&e(i,l))},t,r),i}});function tM(n){zr.call(this,n)}tM.prototype=Object.assign(Object.create(zr.prototype),{constructor:tM,load:function(n,e,t,r){const s=new Kr,i=new Cv(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(n,function(o){s.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;s.format=a?ep:Al,s.needsUpdate=!0,e!==void 0&&e(s)},t,r),s}});function on(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(on.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,e){const t=this.getUtoTmapping(n);return this.getPoint(t,e)},getPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return e},getSpacedPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let t,r=this.getPoint(0),s=0;e.push(0);for(let i=1;i<=n;i++)t=this.getPoint(i/n),s+=t.distanceTo(r),e.push(s),r=t;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,e){const t=this.getLengths();let r=0;const s=t.length;let i;e?i=e:i=n*t[s-1];let o=0,a=s-1,l;for(;o<=a;)if(r=Math.floor(o+(a-o)/2),l=t[r]-i,l<0)o=r+1;else if(l>0)a=r-1;else{a=r;break}if(r=a,t[r]===i)return r/(s-1);const c=t[r],h=t[r+1]-c,f=(i-c)/h;return(r+f)/(s-1)},getTangent:function(n,e){let r=n-1e-4,s=n+1e-4;r<0&&(r=0),s>1&&(s=1);const i=this.getPoint(r),o=this.getPoint(s),a=e||(i.isVector2?new st:new Q);return a.copy(o).sub(i).normalize(),a},getTangentAt:function(n,e){const t=this.getUtoTmapping(n);return this.getTangent(t,e)},computeFrenetFrames:function(n,e){const t=new Q,r=[],s=[],i=[],o=new Q,a=new Zn;for(let f=0;f<=n;f++){const d=f/n;r[f]=this.getTangentAt(d,new Q),r[f].normalize()}s[0]=new Q,i[0]=new Q;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,t.set(1,0,0)),u<=l&&(l=u,t.set(0,1,0)),h<=l&&t.set(0,0,1),o.crossVectors(r[0],t).normalize(),s[0].crossVectors(r[0],o),i[0].crossVectors(r[0],s[0]);for(let f=1;f<=n;f++){if(s[f]=s[f-1].clone(),i[f]=i[f-1].clone(),o.crossVectors(r[f-1],r[f]),o.length()>Number.EPSILON){o.normalize();const d=Math.acos(In.clamp(r[f-1].dot(r[f]),-1,1));s[f].applyMatrix4(a.makeRotationAxis(o,d))}i[f].crossVectors(r[f],s[f])}if(e===!0){let f=Math.acos(In.clamp(s[0].dot(s[n]),-1,1));f/=n,r[0].dot(o.crossVectors(s[0],s[n]))>0&&(f=-f);for(let d=1;d<=n;d++)s[d].applyMatrix4(a.makeRotationAxis(r[d],f*d)),i[d].crossVectors(r[d],s[d])}return{tangents:r,normals:s,binormals:i}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});function Fl(n,e,t,r,s,i,o,a){on.call(this),this.type="EllipseCurve",this.aX=n||0,this.aY=e||0,this.xRadius=t||1,this.yRadius=r||1,this.aStartAngle=s||0,this.aEndAngle=i||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}Fl.prototype=Object.create(on.prototype);Fl.prototype.constructor=Fl;Fl.prototype.isEllipseCurve=!0;Fl.prototype.getPoint=function(n,e){const t=e||new st,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const i=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(i?s=0:s=r),this.aClockwise===!0&&!i&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+n*s;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=a-this.aX,f=l-this.aY;a=h*c-f*u+this.aX,l=h*u+f*c+this.aY}return t.set(a,l)};Fl.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};Fl.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n};Fl.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};function kv(n,e,t,r,s,i){Fl.call(this,n,e,t,t,r,s,i),this.type="ArcCurve"}kv.prototype=Object.create(Fl.prototype);kv.prototype.constructor=kv;kv.prototype.isArcCurve=!0;function SV(){let n=0,e=0,t=0,r=0;function s(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,r=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,c){s(o,a,c*(a-i),c*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,c,u,h){let f=(o-i)/c-(a-i)/(c+u)+(a-o)/u,d=(a-o)/u-(l-o)/(u+h)+(l-a)/h;f*=u,d*=u,s(o,a,f,d)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+r*a}}}const gE=new Q,LP=new SV,zP=new SV,BP=new SV;function Qo(n=[],e=!1,t="centripetal",r=.5){on.call(this),this.type="CatmullRomCurve3",this.points=n,this.closed=e,this.curveType=t,this.tension=r}Qo.prototype=Object.create(on.prototype);Qo.prototype.constructor=Qo;Qo.prototype.isCatmullRomCurve3=!0;Qo.prototype.getPoint=function(n,e=new Q){const t=e,r=this.points,s=r.length,i=(s-(this.closed?0:1))*n;let o=Math.floor(i),a=i-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:a===0&&o===s-1&&(o=s-2,a=1);let l,c;this.closed||o>0?l=r[(o-1)%s]:(gE.subVectors(r[0],r[1]).add(r[0]),l=gE);const u=r[o%s],h=r[(o+1)%s];if(this.closed||o+2<s?c=r[(o+2)%s]:(gE.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=gE),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let d=Math.pow(l.distanceToSquared(u),f),p=Math.pow(u.distanceToSquared(h),f),m=Math.pow(h.distanceToSquared(c),f);p<1e-4&&(p=1),d<1e-4&&(d=p),m<1e-4&&(m=p),LP.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,d,p,m),zP.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,d,p,m),BP.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,d,p,m)}else this.curveType==="catmullrom"&&(LP.initCatmullRom(l.x,u.x,h.x,c.x,this.tension),zP.initCatmullRom(l.y,u.y,h.y,c.y,this.tension),BP.initCatmullRom(l.z,u.z,h.z,c.z,this.tension));return t.set(LP.calc(a),zP.calc(a),BP.calc(a)),t};Qo.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};Qo.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n};Qo.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new Q().fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};function cq(n,e,t,r,s){const i=(r-e)*.5,o=(s-t)*.5,a=n*n,l=n*a;return(2*t-2*r+i+o)*l+(-3*t+3*r-2*i-o)*a+i*n+t}function W0t(n,e){const t=1-n;return t*t*e}function G0t(n,e){return 2*(1-n)*n*e}function H0t(n,e){return n*n*e}function f_(n,e,t,r){return W0t(n,e)+G0t(n,t)+H0t(n,r)}function j0t(n,e){const t=1-n;return t*t*t*e}function q0t(n,e){const t=1-n;return 3*t*t*n*e}function X0t(n,e){return 3*(1-n)*n*n*e}function K0t(n,e){return n*n*n*e}function d_(n,e,t,r,s){return j0t(n,e)+q0t(n,t)+X0t(n,r)+K0t(n,s)}function Iu(n=new st,e=new st,t=new st,r=new st){on.call(this),this.type="CubicBezierCurve",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Iu.prototype=Object.create(on.prototype);Iu.prototype.constructor=Iu;Iu.prototype.isCubicBezierCurve=!0;Iu.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(d_(n,r.x,s.x,i.x,o.x),d_(n,r.y,s.y,i.y,o.y)),t};Iu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Iu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Iu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Mh(n=new Q,e=new Q,t=new Q,r=new Q){on.call(this),this.type="CubicBezierCurve3",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Mh.prototype=Object.create(on.prototype);Mh.prototype.constructor=Mh;Mh.prototype.isCubicBezierCurve3=!0;Mh.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(d_(n,r.x,s.x,i.x,o.x),d_(n,r.y,s.y,i.y,o.y),d_(n,r.z,s.z,i.z,o.z)),t};Mh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Mh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Mh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Ja(n=new st,e=new st){on.call(this),this.type="LineCurve",this.v1=n,this.v2=e}Ja.prototype=Object.create(on.prototype);Ja.prototype.constructor=Ja;Ja.prototype.isLineCurve=!0;Ja.prototype.getPoint=function(n,e=new st){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Ja.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Ja.prototype.getTangent=function(n,e){const t=e||new st;return t.copy(this.v2).sub(this.v1).normalize(),t};Ja.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Ja.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Ja.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Au(n=new Q,e=new Q){on.call(this),this.type="LineCurve3",this.v1=n,this.v2=e}Au.prototype=Object.create(on.prototype);Au.prototype.constructor=Au;Au.prototype.isLineCurve3=!0;Au.prototype.getPoint=function(n,e=new Q){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Au.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Au.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Au.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Au.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Mu(n=new st,e=new st,t=new st){on.call(this),this.type="QuadraticBezierCurve",this.v0=n,this.v1=e,this.v2=t}Mu.prototype=Object.create(on.prototype);Mu.prototype.constructor=Mu;Mu.prototype.isQuadraticBezierCurve=!0;Mu.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(f_(n,r.x,s.x,i.x),f_(n,r.y,s.y,i.y)),t};Mu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Mu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Mu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nh(n=new Q,e=new Q,t=new Q){on.call(this),this.type="QuadraticBezierCurve3",this.v0=n,this.v1=e,this.v2=t}Nh.prototype=Object.create(on.prototype);Nh.prototype.constructor=Nh;Nh.prototype.isQuadraticBezierCurve3=!0;Nh.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(f_(n,r.x,s.x,i.x),f_(n,r.y,s.y,i.y),f_(n,r.z,s.z,i.z)),t};Nh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Nh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Nh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nu(n=[]){on.call(this),this.type="SplineCurve",this.points=n}Nu.prototype=Object.create(on.prototype);Nu.prototype.constructor=Nu;Nu.prototype.isSplineCurve=!0;Nu.prototype.getPoint=function(n,e=new st){const t=e,r=this.points,s=(r.length-1)*n,i=Math.floor(s),o=s-i,a=r[i===0?i:i-1],l=r[i],c=r[i>r.length-2?r.length-1:i+1],u=r[i>r.length-3?r.length-1:i+2];return t.set(cq(o,a.x,l.x,c.x,u.x),cq(o,a.y,l.y,c.y,u.y)),t};Nu.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this};Nu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n};Nu.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new st().fromArray(r))}return this};var QF=Object.freeze({__proto__:null,ArcCurve:kv,CatmullRomCurve3:Qo,CubicBezierCurve:Iu,CubicBezierCurve3:Mh,EllipseCurve:Fl,LineCurve:Ja,LineCurve3:Au,QuadraticBezierCurve:Mu,QuadraticBezierCurve3:Nh,SplineCurve:Nu});function Hd(){on.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}Hd.prototype=Object.assign(Object.create(on.prototype),{constructor:Hd,add:function(n){this.curves.push(n)},closePath:function(){const n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new Ja(e,n))},getPoint:function(n){const e=n*this.getLength(),t=this.getCurveLengths();let r=0;for(;r<t.length;){if(t[r]>=e){const s=t[r]-e,i=this.curves[r],o=i.getLength(),a=o===0?0:1-s/o;return i.getPointAt(a)}r++}return null},getLength:function(){const n=this.getCurveLengths();return n[n.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const n=[];let e=0;for(let t=0,r=this.curves.length;t<r;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n},getSpacedPoints:function(n=40){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e},getPoints:function(n=12){const e=[];let t;for(let r=0,s=this.curves;r<s.length;r++){const i=s[r],o=i&&i.isEllipseCurve?n*2:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?n*i.points.length:n,a=i.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];t&&t.equals(c)||(e.push(c),t=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(n){on.prototype.copy.call(this,n),this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this},toJSON:function(){const n=on.prototype.toJSON.call(this);n.autoClose=this.autoClose,n.curves=[];for(let e=0,t=this.curves.length;e<t;e++){const r=this.curves[e];n.curves.push(r.toJSON())}return n},fromJSON:function(n){on.prototype.fromJSON.call(this,n),this.autoClose=n.autoClose,this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(new QF[r.type]().fromJSON(r))}return this}});function lu(n){Hd.call(this),this.type="Path",this.currentPoint=new st,n&&this.setFromPoints(n)}lu.prototype=Object.assign(Object.create(Hd.prototype),{constructor:lu,setFromPoints:function(n){this.moveTo(n[0].x,n[0].y);for(let e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this},moveTo:function(n,e){return this.currentPoint.set(n,e),this},lineTo:function(n,e){const t=new Ja(this.currentPoint.clone(),new st(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this},quadraticCurveTo:function(n,e,t,r){const s=new Mu(this.currentPoint.clone(),new st(n,e),new st(t,r));return this.curves.push(s),this.currentPoint.set(t,r),this},bezierCurveTo:function(n,e,t,r,s,i){const o=new Iu(this.currentPoint.clone(),new st(n,e),new st(t,r),new st(s,i));return this.curves.push(o),this.currentPoint.set(s,i),this},splineThru:function(n){const e=[this.currentPoint.clone()].concat(n),t=new Nu(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this},arc:function(n,e,t,r,s,i){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(n+o,e+a,t,r,s,i),this},absarc:function(n,e,t,r,s,i){return this.absellipse(n,e,t,t,r,s,i),this},ellipse:function(n,e,t,r,s,i,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(n+l,e+c,t,r,s,i,o,a),this},absellipse:function(n,e,t,r,s,i,o,a){const l=new Fl(n,e,t,r,s,i,o,a);if(this.curves.length>0){const u=l.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(n){return Hd.prototype.copy.call(this,n),this.currentPoint.copy(n.currentPoint),this},toJSON:function(){const n=Hd.prototype.toJSON.call(this);return n.currentPoint=this.currentPoint.toArray(),n},fromJSON:function(n){return Hd.prototype.fromJSON.call(this,n),this.currentPoint.fromArray(n.currentPoint),this}});function rp(n){lu.call(this,n),this.uuid=In.generateUUID(),this.type="Shape",this.holes=[]}rp.prototype=Object.assign(Object.create(lu.prototype),{constructor:rp,getPointsHoles:function(n){const e=[];for(let t=0,r=this.holes.length;t<r;t++)e[t]=this.holes[t].getPoints(n);return e},extractPoints:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}},copy:function(n){lu.prototype.copy.call(this,n),this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(r.clone())}return this},toJSON:function(){const n=lu.prototype.toJSON.call(this);n.uuid=this.uuid,n.holes=[];for(let e=0,t=this.holes.length;e<t;e++){const r=this.holes[e];n.holes.push(r.toJSON())}return n},fromJSON:function(n){lu.prototype.fromJSON.call(this,n),this.uuid=n.uuid,this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(new lu().fromJSON(r))}return this}});function fs(n,e=1){rn.call(this),this.type="Light",this.color=new Ht(n),this.intensity=e}fs.prototype=Object.assign(Object.create(rn.prototype),{constructor:fs,isLight:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.color.copy(n.color),this.intensity=n.intensity,this},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}});function nM(n,e,t){fs.call(this,n,t),this.type="HemisphereLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.groundColor=new Ht(e)}nM.prototype=Object.assign(Object.create(fs.prototype),{constructor:nM,isHemisphereLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.groundColor.copy(n.groundColor),this}});function Vf(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new st(512,512),this.map=null,this.mapPass=null,this.matrix=new Zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new qC,this._frameExtents=new st(1,1),this._viewportCount=1,this._viewports=[new Hr(0,0,1,1)]}Object.assign(Vf.prototype,{_projScreenMatrix:new Zn,_lightPositionWorld:new Q,_lookTarget:new Q,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(n){const e=this.camera,t=this.matrix,r=this._projScreenMatrix,s=this._lookTarget,i=this._lightPositionWorld;i.setFromMatrixPosition(n.matrixWorld),e.position.copy(i),s.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(s),e.updateMatrixWorld(),r.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.matrixWorldInverse)},getViewport:function(n){return this._viewports[n]},getFrameExtents:function(){return this._frameExtents},copy:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n={};return this.bias!==0&&(n.bias=this.bias),this.normalBias!==0&&(n.normalBias=this.normalBias),this.radius!==1&&(n.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}});function eL(){Vf.call(this,new Si(50,1,.5,500)),this.focus=1}eL.prototype=Object.assign(Object.create(Vf.prototype),{constructor:eL,isSpotLightShadow:!0,updateMatrices:function(n){const e=this.camera,t=In.RAD2DEG*2*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=n.distance||e.far;(t!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=t,e.aspect=r,e.far=s,e.updateProjectionMatrix()),Vf.prototype.updateMatrices.call(this,n)}});function rM(n,e,t,r,s,i){fs.call(this,n,e),this.type="SpotLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=r!==void 0?r:Math.PI/3,this.penumbra=s!==void 0?s:0,this.decay=i!==void 0?i:1,this.shadow=new eL}rM.prototype=Object.assign(Object.create(fs.prototype),{constructor:rM,isSpotLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function tL(){Vf.call(this,new Si(90,1,.5,500)),this._frameExtents=new st(4,2),this._viewportCount=6,this._viewports=[new Hr(2,1,1,1),new Hr(0,1,1,1),new Hr(3,1,1,1),new Hr(1,1,1,1),new Hr(3,0,1,1),new Hr(1,0,1,1)],this._cubeDirections=[new Q(1,0,0),new Q(-1,0,0),new Q(0,0,1),new Q(0,0,-1),new Q(0,1,0),new Q(0,-1,0)],this._cubeUps=[new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,0,1),new Q(0,0,-1)]}tL.prototype=Object.assign(Object.create(Vf.prototype),{constructor:tL,isPointLightShadow:!0,updateMatrices:function(n,e=0){const t=this.camera,r=this.matrix,s=this._lightPositionWorld,i=this._lookTarget,o=this._projScreenMatrix;s.setFromMatrixPosition(n.matrixWorld),t.position.copy(s),i.copy(t.position),i.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(i),t.updateMatrixWorld(),r.makeTranslation(-s.x,-s.y,-s.z),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function sM(n,e,t,r){fs.call(this,n,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(s){this.intensity=s/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=r!==void 0?r:1,this.shadow=new tL}sM.prototype=Object.assign(Object.create(fs.prototype),{constructor:sM,isPointLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}});function Tv(n=-1,e=1,t=1,r=-1,s=.1,i=2e3){Eh.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=e,this.top=t,this.bottom=r,this.near=s,this.far=i,this.updateProjectionMatrix()}Tv.prototype=Object.assign(Object.create(Eh.prototype),{constructor:Tv,isOrthographicCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=n.view===null?null:Object.assign({},n.view),this},setViewOffset:function(n,e,t,r,s,i){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=t-n,i=t+n,o=r+e,a=r-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,i=s+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(s,i,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}});function nL(){Vf.call(this,new Tv(-5,5,5,-5,.5,500))}nL.prototype=Object.assign(Object.create(Vf.prototype),{constructor:nL,isDirectionalLightShadow:!0,updateMatrices:function(n){Vf.prototype.updateMatrices.call(this,n)}});function iM(n,e){fs.call(this,n,e),this.type="DirectionalLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.shadow=new nL}iM.prototype=Object.assign(Object.create(fs.prototype),{constructor:iM,isDirectionalLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function oM(n,e){fs.call(this,n,e),this.type="AmbientLight"}oM.prototype=Object.assign(Object.create(fs.prototype),{constructor:oM,isAmbientLight:!0});function aM(n,e,t,r){fs.call(this,n,e),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=r!==void 0?r:10}aM.prototype=Object.assign(Object.create(fs.prototype),{constructor:aM,isRectAreaLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.width=n.width,this.height=n.height,this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.width=this.width,e.object.height=this.height,e}});class Ble{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Q)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*s),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],1.092548*(r*s)),t.addScaledVector(o[5],1.092548*(s*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(r*i)),t.addScaledVector(o[8],.546274*(r*r-s*s)),t}getIrradianceAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*s),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*r),t.addScaledVector(o[4],2*.429043*r*s),t.addScaledVector(o[5],2*.429043*s*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*r*i),t.addScaledVector(o[8],.429043*(r*r-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const r=e.x,s=e.y,i=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*i,t[3]=.488603*r,t[4]=1.092548*r*s,t[5]=1.092548*s*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*r*i,t[8]=.546274*(r*r-s*s)}}function Sc(n,e){fs.call(this,void 0,e),this.type="LightProbe",this.sh=n!==void 0?n:new Ble}Sc.prototype=Object.assign(Object.create(fs.prototype),{constructor:Sc,isLightProbe:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.sh.copy(n.sh),this},fromJSON:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.sh=this.sh.toArray(),e}});function lM(n){zr.call(this,n),this.textures={}}lM.prototype=Object.assign(Object.create(zr.prototype),{constructor:lM,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=this.textures;function t(s){return e[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),e[s]}const r=new B0t[n.type];if(n.uuid!==void 0&&(r.uuid=n.uuid),n.name!==void 0&&(r.name=n.name),n.color!==void 0&&r.color!==void 0&&r.color.setHex(n.color),n.roughness!==void 0&&(r.roughness=n.roughness),n.metalness!==void 0&&(r.metalness=n.metalness),n.sheen!==void 0&&(r.sheen=new Ht().setHex(n.sheen)),n.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(n.emissive),n.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(n.specular),n.shininess!==void 0&&(r.shininess=n.shininess),n.clearcoat!==void 0&&(r.clearcoat=n.clearcoat),n.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=n.clearcoatRoughness),n.fog!==void 0&&(r.fog=n.fog),n.flatShading!==void 0&&(r.flatShading=n.flatShading),n.blending!==void 0&&(r.blending=n.blending),n.combine!==void 0&&(r.combine=n.combine),n.side!==void 0&&(r.side=n.side),n.opacity!==void 0&&(r.opacity=n.opacity),n.transparent!==void 0&&(r.transparent=n.transparent),n.alphaTest!==void 0&&(r.alphaTest=n.alphaTest),n.depthTest!==void 0&&(r.depthTest=n.depthTest),n.depthWrite!==void 0&&(r.depthWrite=n.depthWrite),n.colorWrite!==void 0&&(r.colorWrite=n.colorWrite),n.stencilWrite!==void 0&&(r.stencilWrite=n.stencilWrite),n.stencilWriteMask!==void 0&&(r.stencilWriteMask=n.stencilWriteMask),n.stencilFunc!==void 0&&(r.stencilFunc=n.stencilFunc),n.stencilRef!==void 0&&(r.stencilRef=n.stencilRef),n.stencilFuncMask!==void 0&&(r.stencilFuncMask=n.stencilFuncMask),n.stencilFail!==void 0&&(r.stencilFail=n.stencilFail),n.stencilZFail!==void 0&&(r.stencilZFail=n.stencilZFail),n.stencilZPass!==void 0&&(r.stencilZPass=n.stencilZPass),n.wireframe!==void 0&&(r.wireframe=n.wireframe),n.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=n.wireframeLinewidth),n.wireframeLinecap!==void 0&&(r.wireframeLinecap=n.wireframeLinecap),n.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=n.wireframeLinejoin),n.rotation!==void 0&&(r.rotation=n.rotation),n.linewidth!==1&&(r.linewidth=n.linewidth),n.dashSize!==void 0&&(r.dashSize=n.dashSize),n.gapSize!==void 0&&(r.gapSize=n.gapSize),n.scale!==void 0&&(r.scale=n.scale),n.polygonOffset!==void 0&&(r.polygonOffset=n.polygonOffset),n.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=n.polygonOffsetFactor),n.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=n.polygonOffsetUnits),n.skinning!==void 0&&(r.skinning=n.skinning),n.morphTargets!==void 0&&(r.morphTargets=n.morphTargets),n.morphNormals!==void 0&&(r.morphNormals=n.morphNormals),n.dithering!==void 0&&(r.dithering=n.dithering),n.vertexTangents!==void 0&&(r.vertexTangents=n.vertexTangents),n.visible!==void 0&&(r.visible=n.visible),n.toneMapped!==void 0&&(r.toneMapped=n.toneMapped),n.userData!==void 0&&(r.userData=n.userData),n.vertexColors!==void 0&&(typeof n.vertexColors=="number"?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),n.uniforms!==void 0)for(const s in n.uniforms){const i=n.uniforms[s];switch(r.uniforms[s]={},i.type){case"t":r.uniforms[s].value=t(i.value);break;case"c":r.uniforms[s].value=new Ht().setHex(i.value);break;case"v2":r.uniforms[s].value=new st().fromArray(i.value);break;case"v3":r.uniforms[s].value=new Q().fromArray(i.value);break;case"v4":r.uniforms[s].value=new Hr().fromArray(i.value);break;case"m3":r.uniforms[s].value=new Cl().fromArray(i.value);break;case"m4":r.uniforms[s].value=new Zn().fromArray(i.value);break;default:r.uniforms[s].value=i.value}}if(n.defines!==void 0&&(r.defines=n.defines),n.vertexShader!==void 0&&(r.vertexShader=n.vertexShader),n.fragmentShader!==void 0&&(r.fragmentShader=n.fragmentShader),n.extensions!==void 0)for(const s in n.extensions)r.extensions[s]=n.extensions[s];if(n.shading!==void 0&&(r.flatShading=n.shading===1),n.size!==void 0&&(r.size=n.size),n.sizeAttenuation!==void 0&&(r.sizeAttenuation=n.sizeAttenuation),n.map!==void 0&&(r.map=t(n.map)),n.matcap!==void 0&&(r.matcap=t(n.matcap)),n.alphaMap!==void 0&&(r.alphaMap=t(n.alphaMap)),n.bumpMap!==void 0&&(r.bumpMap=t(n.bumpMap)),n.bumpScale!==void 0&&(r.bumpScale=n.bumpScale),n.normalMap!==void 0&&(r.normalMap=t(n.normalMap)),n.normalMapType!==void 0&&(r.normalMapType=n.normalMapType),n.normalScale!==void 0){let s=n.normalScale;Array.isArray(s)===!1&&(s=[s,s]),r.normalScale=new st().fromArray(s)}return n.displacementMap!==void 0&&(r.displacementMap=t(n.displacementMap)),n.displacementScale!==void 0&&(r.displacementScale=n.displacementScale),n.displacementBias!==void 0&&(r.displacementBias=n.displacementBias),n.roughnessMap!==void 0&&(r.roughnessMap=t(n.roughnessMap)),n.metalnessMap!==void 0&&(r.metalnessMap=t(n.metalnessMap)),n.emissiveMap!==void 0&&(r.emissiveMap=t(n.emissiveMap)),n.emissiveIntensity!==void 0&&(r.emissiveIntensity=n.emissiveIntensity),n.specularMap!==void 0&&(r.specularMap=t(n.specularMap)),n.envMap!==void 0&&(r.envMap=t(n.envMap)),n.envMapIntensity!==void 0&&(r.envMapIntensity=n.envMapIntensity),n.reflectivity!==void 0&&(r.reflectivity=n.reflectivity),n.refractionRatio!==void 0&&(r.refractionRatio=n.refractionRatio),n.lightMap!==void 0&&(r.lightMap=t(n.lightMap)),n.lightMapIntensity!==void 0&&(r.lightMapIntensity=n.lightMapIntensity),n.aoMap!==void 0&&(r.aoMap=t(n.aoMap)),n.aoMapIntensity!==void 0&&(r.aoMapIntensity=n.aoMapIntensity),n.gradientMap!==void 0&&(r.gradientMap=t(n.gradientMap)),n.clearcoatMap!==void 0&&(r.clearcoatMap=t(n.clearcoatMap)),n.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=t(n.clearcoatRoughnessMap)),n.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=t(n.clearcoatNormalMap)),n.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new st().fromArray(n.clearcoatNormalScale)),n.transmission!==void 0&&(r.transmission=n.transmission),n.transmissionMap!==void 0&&(r.transmissionMap=t(n.transmissionMap)),r},setTextures:function(n){return this.textures=n,this}});const CV={decodeText:function(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,r=n.length;t<r;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}},extractUrlBase:function(n){const e=n.lastIndexOf("/");return e===-1?"./":n.substr(0,e+1)}};function FS(){un.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}FS.prototype=Object.assign(Object.create(un.prototype),{constructor:FS,isInstancedBufferGeometry:!0,copy:function(n){return un.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=un.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function cM(n,e,t,r){typeof t=="number"&&(r=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Cn.call(this,n,e,t),this.meshPerAttribute=r||1}cM.prototype=Object.assign(Object.create(Cn.prototype),{constructor:cM,isInstancedBufferAttribute:!0,copy:function(n){return Cn.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=Cn.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function uM(n){zr.call(this,n)}uM.prototype=Object.assign(Object.create(zr.prototype),{constructor:uM,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e={},t={};function r(f,d){if(e[d]!==void 0)return e[d];const m=f.interleavedBuffers[d],g=s(f,m.buffer),y=z1(m.type,g),b=new kl(y,m.stride);return b.uuid=m.uuid,e[d]=b,b}function s(f,d){if(t[d]!==void 0)return t[d];const m=f.arrayBuffers[d],g=new Uint32Array(m).buffer;return t[d]=g,g}const i=n.isInstancedBufferGeometry?new FS:new un,o=n.data.index;if(o!==void 0){const f=z1(o.type,o.array);i.setIndex(new Cn(f,1))}const a=n.data.attributes;for(const f in a){const d=a[f];let p;if(d.isInterleavedBufferAttribute){const m=r(n.data,d.data);p=new _p(m,d.itemSize,d.offset,d.normalized)}else{const m=z1(d.type,d.array),g=d.isInstancedBufferAttribute?cM:Cn;p=new g(m,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),i.setAttribute(f,p)}const l=n.data.morphAttributes;if(l)for(const f in l){const d=l[f],p=[];for(let m=0,g=d.length;m<g;m++){const y=d[m];let b;if(y.isInterleavedBufferAttribute){const x=r(n.data,y.data);b=new _p(x,y.itemSize,y.offset,y.normalized)}else{const x=z1(y.type,y.array);b=new Cn(x,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),p.push(b)}i.morphAttributes[f]=p}n.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const u=n.data.groups||n.data.drawcalls||n.data.offsets;if(u!==void 0)for(let f=0,d=u.length;f!==d;++f){const p=u[f];i.addGroup(p.start,p.count,p.materialIndex)}const h=n.data.boundingSphere;if(h!==void 0){const f=new Q;h.center!==void 0&&f.fromArray(h.center),i.boundingSphere=new Gp(f,h.radius)}return n.name&&(i.name=n.name),n.userData&&(i.userData=n.userData),i}});class Y0t extends zr{constructor(e){super(e)}load(e,t,r,s){const i=this,o=this.path===""?CV.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Rc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){s!==void 0&&s(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}i.parse(c,t)},r,s)}parse(e,t){const r=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,i,l,r),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const f in o)if(o[f]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let r=0,s=e.length;r<s;r++){const i=new rp().fromJSON(e[r]);t[i.uuid]=i}return t}parseSkeletons(e,t){const r={},s={};if(t.traverse(function(i){i.isBone&&(s[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new TS().fromJSON(e[i],s);r[a.uuid]=a}return r}parseGeometries(e,t){const r={};let s;if(e!==void 0){const i=new uM;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":l=new ua[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":l=new ua[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":l=new ua[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":l=new ua[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":l=new ua[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":l=new ua[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":l=new ua[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":l=new ua[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":l=new ua[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":l=new ua[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":l=new ua[c.type](new QF[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":l=new ua[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":l=new ua[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}l=new ua[c.type](s,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new QF[u.type]().fromJSON(u)),l=new ua[c.type](s,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":l=i.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),r[c.uuid]=l}}return r}parseMaterials(e,t){const r={},s={};if(e!==void 0){const i=new lM;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];r[h.uuid]===void 0&&(r[h.uuid]=i.parse(h)),c.push(r[h.uuid])}s[l.uuid]=c}else r[l.uuid]===void 0&&(r[l.uuid]=i.parse(l)),s[l.uuid]=r[l.uuid]}}return s}parseAnimations(e){const t={};if(e!==void 0)for(let r=0;r<e.length;r++){const s=e[r],i=_l.parse(s);t[i.uuid]=i}return t}parseImages(e,t){const r=this,s={};let i;function o(l){return r.manager.itemStart(l),i.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:r.resourcePath+c;return o(u)}else return l.data?{data:z1(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new _V(t);i=new Cv(l),i.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],f=h.url;if(Array.isArray(f)){s[h.uuid]=[];for(let d=0,p=f.length;d<p;d++){const m=f[d],g=a(m);g!==null&&(g instanceof HTMLImageElement?s[h.uuid].push(g):s[h.uuid].push(new zf(g.data,g.width,g.height)))}}else{const d=a(h.url);d!==null&&(s[h.uuid]=d)}}}return s}parseTextures(e,t){function r(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const s={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=t[a.image];Array.isArray(c)?(l=new Ih(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new zf(c.data,c.width,c.height):l=new Kr(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=r(a.mapping,Z0t)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=r(a.wrap[0],uq),l.wrapT=r(a.wrap[1],uq)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=r(a.minFilter,hq)),a.magFilter!==void 0&&(l.magFilter=r(a.magFilter,hq)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),s[a.uuid]=l}return s}parseObject(e,t,r,s){let i;function o(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const h=[];for(let f=0,d=u.length;f<d;f++){const p=u[f];r[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),h.push(r[p])}return h}return r[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),r[u]}}let l,c;switch(e.type){case"Scene":i=new vV,e.background!==void 0&&Number.isInteger(e.background)&&(i.background=new Ht(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?i.fog=new L$(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(i.fog=new F$(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":i=new Si(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(i.focus=e.focus),e.zoom!==void 0&&(i.zoom=e.zoom),e.filmGauge!==void 0&&(i.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(i.filmOffset=e.filmOffset),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"OrthographicCamera":i=new Tv(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(i.zoom=e.zoom),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"AmbientLight":i=new oM(e.color,e.intensity);break;case"DirectionalLight":i=new iM(e.color,e.intensity);break;case"PointLight":i=new sM(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":i=new aM(e.color,e.intensity,e.width,e.height);break;case"SpotLight":i=new rM(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":i=new nM(e.color,e.groundColor,e.intensity);break;case"LightProbe":i=new Sc().fromJSON(e);break;case"SkinnedMesh":l=o(e.geometry),c=a(e.material),i=new CS(l,c),e.bindMode!==void 0&&(i.bindMode=e.bindMode),e.bindMatrix!==void 0&&i.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(i.skeleton=e.skeleton);break;case"Mesh":l=o(e.geometry),c=a(e.material),i=new hs(l,c);break;case"InstancedMesh":l=o(e.geometry),c=a(e.material);const u=e.count,h=e.instanceMatrix;i=new PA(l,c,u),i.instanceMatrix=new Cn(new Float32Array(h.array),16);break;case"LOD":i=new SS;break;case"Line":i=new $c(o(e.geometry),a(e.material));break;case"LineLoop":i=new DA(o(e.geometry),a(e.material));break;case"LineSegments":i=new Ta(o(e.geometry),a(e.material));break;case"PointCloud":case"Points":i=new vv(o(e.geometry),a(e.material));break;case"Sprite":i=new _S(a(e.material));break;case"Group":i=new Gd;break;case"Bone":i=new kS;break;default:i=new rn}if(i.uuid=e.uuid,e.name!==void 0&&(i.name=e.name),e.matrix!==void 0?(i.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=e.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(e.position!==void 0&&i.position.fromArray(e.position),e.rotation!==void 0&&i.rotation.fromArray(e.rotation),e.quaternion!==void 0&&i.quaternion.fromArray(e.quaternion),e.scale!==void 0&&i.scale.fromArray(e.scale)),e.castShadow!==void 0&&(i.castShadow=e.castShadow),e.receiveShadow!==void 0&&(i.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(i.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(i.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(i.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(i.visible=e.visible),e.frustumCulled!==void 0&&(i.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(i.renderOrder=e.renderOrder),e.userData!==void 0&&(i.userData=e.userData),e.layers!==void 0&&(i.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let h=0;h<u.length;h++)i.add(this.parseObject(u[h],t,r,s))}if(e.animations!==void 0){const u=e.animations;for(let h=0;h<u.length;h++){const f=u[h];i.animations.push(s[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(i.autoUpdate=e.autoUpdate);const u=e.levels;for(let h=0;h<u.length;h++){const f=u[h],d=i.getObjectByProperty("uuid",f.object);d!==void 0&&i.addLevel(d,f.distance)}}return i}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const s=t[r.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(s,r.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const Z0t={UVMapping:R$,CubeReflectionMapping:UC,CubeRefractionMapping:WC,EquirectangularReflectionMapping:AA,EquirectangularRefractionMapping:MA,CubeUVReflectionMapping:ax,CubeUVRefractionMapping:GC},uq={RepeatWrapping:lS,ClampToEdgeWrapping:pa,MirroredRepeatWrapping:cS},hq={NearestFilter:Ui,NearestMipmapNearestFilter:NA,NearestMipmapLinearFilter:$A,LinearFilter:lo,LinearMipmapNearestFilter:hV,LinearMipmapLinearFilter:lx};function rL(n){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),zr.call(this,n),this.options={premultiplyAlpha:"none"}}rL.prototype=Object.assign(Object.create(zr.prototype),{constructor:rL,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Og.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,s.options)}).then(function(a){Og.add(n,a),e&&e(a),s.manager.itemEnd(n)}).catch(function(a){r&&r(a),s.manager.itemError(n),s.manager.itemEnd(n)}),s.manager.itemStart(n)}});function kV(){this.type="ShapePath",this.color=new Ht,this.subPaths=[],this.currentPath=null}Object.assign(kV.prototype,{moveTo:function(n,e){return this.currentPath=new lu,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this},lineTo:function(n,e){return this.currentPath.lineTo(n,e),this},quadraticCurveTo:function(n,e,t,r){return this.currentPath.quadraticCurveTo(n,e,t,r),this},bezierCurveTo:function(n,e,t,r,s,i){return this.currentPath.bezierCurveTo(n,e,t,r,s,i),this},splineThru:function(n){return this.currentPath.splineThru(n),this},toShapes:function(n,e){function t(y){const b=[];for(let x=0,w=y.length;x<w;x++){const S=y[x],C=new rp;C.curves=S.curves,b.push(C)}return b}function r(y,b){const x=b.length;let w=!1;for(let S=x-1,C=0;C<x;S=C++){let k=b[S],A=b[C],M=A.x-k.x,E=A.y-k.y;if(Math.abs(E)>Number.EPSILON){if(E<0&&(k=b[C],M=-M,A=b[S],E=-E),y.y<k.y||y.y>A.y)continue;if(y.y===k.y){if(y.x===k.x)return!0}else{const N=E*(y.x-k.x)-M*(y.y-k.y);if(N===0)return!0;if(N<0)continue;w=!w}}else{if(y.y!==k.y)continue;if(A.x<=y.x&&y.x<=k.x||k.x<=y.x&&y.x<=A.x)return!0}}return w}const s=Pf.isClockWise,i=this.subPaths;if(i.length===0)return[];if(e===!0)return t(i);let o,a,l;const c=[];if(i.length===1)return a=i[0],l=new rp,l.curves=a.curves,c.push(l),c;let u=!s(i[0].getPoints());u=n?!u:u;const h=[],f=[];let d=[],p=0,m;f[p]=void 0,d[p]=[];for(let y=0,b=i.length;y<b;y++)a=i[y],m=a.getPoints(),o=s(m),o=n?!o:o,o?(!u&&f[p]&&p++,f[p]={s:new rp,p:m},f[p].s.curves=a.curves,u&&p++,d[p]=[]):d[p].push({h:a,p:m[0]});if(!f[0])return t(i);if(f.length>1){let y=!1;const b=[];for(let x=0,w=f.length;x<w;x++)h[x]=[];for(let x=0,w=f.length;x<w;x++){const S=d[x];for(let C=0;C<S.length;C++){const k=S[C];let A=!0;for(let M=0;M<f.length;M++)r(k.p,f[M].p)&&(x!==M&&b.push({froms:x,tos:M,hole:C}),A?(A=!1,h[M].push(k)):y=!0);A&&h[x].push(k)}}b.length>0&&(y||(d=h))}let g;for(let y=0,b=f.length;y<b;y++){l=f[y].s,c.push(l),g=d[y];for(let x=0,w=g.length;x<w;x++)l.holes.push(g[x].h)}return c}});class Vle{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const r=[],s=J0t(e,t,this.data);for(let i=0,o=s.length;i<o;i++)Array.prototype.push.apply(r,s[i].toShapes());return r}}function J0t(n,e,t){const r=Array.from?Array.from(n):String(n).split(""),s=e/t.resolution,i=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*s,o=[];let a=0,l=0;for(let c=0;c<r.length;c++){const u=r[c];if(u===`
`)a=0,l-=i;else{const h=Q0t(u,s,a,l,t);a+=h.offsetX,o.push(h.path)}}return o}function Q0t(n,e,t,r,s){const i=s.glyphs[n]||s.glyphs["?"];if(!i){console.error('THREE.Font: character "'+n+'" does not exists in font family '+s.familyName+".");return}const o=new kV;let a,l,c,u,h,f,d,p;if(i.o){const m=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let g=0,y=m.length;g<y;)switch(m[g++]){case"m":a=m[g++]*e+t,l=m[g++]*e+r,o.moveTo(a,l);break;case"l":a=m[g++]*e+t,l=m[g++]*e+r,o.lineTo(a,l);break;case"q":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,o.quadraticCurveTo(h,f,c,u);break;case"b":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,d=m[g++]*e+t,p=m[g++]*e+r,o.bezierCurveTo(h,f,d,p,c,u);break}}return{offsetX:i.ha*e,path:o}}function sL(n){zr.call(this,n)}sL.prototype=Object.assign(Object.create(zr.prototype),{constructor:sL,load:function(n,e,t,r){const s=this,i=new Rc(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=s.parse(a);e&&e(l)},t,r)},parse:function(n){return new Vle(n)}});let yE;const TV={getContext:function(){return yE===void 0&&(yE=new(window.AudioContext||window.webkitAudioContext)),yE},setContext:function(n){yE=n}};function hM(n){zr.call(this,n)}hM.prototype=Object.assign(Object.create(zr.prototype),{constructor:hM,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setResponseType("arraybuffer"),i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{const a=o.slice(0);TV.getContext().decodeAudioData(a,function(c){e(c)})}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)}});function iL(n,e,t){Sc.call(this,void 0,t);const r=new Ht().set(n),s=new Ht().set(e),i=new Q(r.r,r.g,r.b),o=new Q(s.r,s.g,s.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(i).sub(o).multiplyScalar(l)}iL.prototype=Object.assign(Object.create(Sc.prototype),{constructor:iL,isHemisphereLightProbe:!0,copy:function(n){return Sc.prototype.copy.call(this,n),this},toJSON:function(n){return Sc.prototype.toJSON.call(this,n)}});function oL(n,e){Sc.call(this,void 0,e);const t=new Ht().set(n);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}oL.prototype=Object.assign(Object.create(Sc.prototype),{constructor:oL,isAmbientLightProbe:!0,copy:function(n){return Sc.prototype.copy.call(this,n),this},toJSON:function(n){return Sc.prototype.toJSON.call(this,n)}});const fq=new Zn,dq=new Zn;function Ule(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Si,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Si,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(Ule.prototype,{update:function(n){const e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep;const r=n.projectionMatrix.clone(),s=e.eyeSep/2,i=s*e.near/e.focus,o=e.near*Math.tan(In.DEG2RAD*e.fov*.5)/e.zoom;let a,l;dq.elements[12]=-s,fq.elements[12]=s,a=-o*e.aspect+i,l=o*e.aspect+i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(r),a=-o*e.aspect-i,l=o*e.aspect-i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(r)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(dq),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(fq)}});class Wle{constructor(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=pq(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=pq();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function pq(){return(typeof performance>"u"?Date:performance).now()}const vm=new Q,mq=new co,ebt=new Q,wm=new Q;class tbt extends rn{constructor(){super(),this.type="AudioListener",this.context=TV.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Wle}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(vm,mq,ebt),wm.set(0,0,-1).applyQuaternion(mq),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(vm.x,s),t.positionY.linearRampToValueAtTime(vm.y,s),t.positionZ.linearRampToValueAtTime(vm.z,s),t.forwardX.linearRampToValueAtTime(wm.x,s),t.forwardY.linearRampToValueAtTime(wm.y,s),t.forwardZ.linearRampToValueAtTime(wm.z,s),t.upX.linearRampToValueAtTime(r.x,s),t.upY.linearRampToValueAtTime(r.y,s),t.upZ.linearRampToValueAtTime(r.z,s)}else t.setPosition(vm.x,vm.y,vm.z),t.setOrientation(wm.x,wm.y,wm.z,r.x,r.y,r.z)}}class EV extends rn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const xm=new Q,gq=new co,nbt=new Q,_m=new Q;class rbt extends EV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(xm,gq,nbt),_m.set(0,0,1).applyQuaternion(gq);const t=this.panner;if(t.positionX){const r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(xm.x,r),t.positionY.linearRampToValueAtTime(xm.y,r),t.positionZ.linearRampToValueAtTime(xm.z,r),t.orientationX.linearRampToValueAtTime(_m.x,r),t.orientationY.linearRampToValueAtTime(_m.y,r),t.orientationZ.linearRampToValueAtTime(_m.z,r)}else t.setPosition(xm.x,xm.y,xm.z),t.setOrientation(_m.x,_m.y,_m.z)}}class Gle{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}function IV(n,e,t){this.binding=n,this.valueSize=t;let r,s,i;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:r=this._lerp,s=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(IV.prototype,{accumulate:function(n,e){const t=this.buffer,r=this.valueSize,s=n*r+r;let i=this.cumulativeWeight;if(i===0){for(let o=0;o!==r;++o)t[s+o]=t[o];i=e}else{i+=e;const o=e/i;this._mixBufferRegion(t,s,0,o,r)}this.cumulativeWeight=i},accumulateAdditive:function(n){const e=this.buffer,t=this.valueSize,r=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,n,t),this.cumulativeWeightAdditive+=n},apply:function(n){const e=this.valueSize,t=this.buffer,r=n*e+e,s=this.cumulativeWeight,i=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const a=e*this._origIndex;this._mixBufferRegion(t,r,a,1-s,e)}i>0&&this._mixBufferRegionAdditive(t,r,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(t[a]!==t[a+e]){o.setValue(t,r);break}},saveOriginalState:function(){const n=this.binding,e=this.buffer,t=this.valueSize,r=t*this._origIndex;n.getValue(e,r);for(let s=t,i=r;s!==i;++s)e[s]=e[r+s%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const n=this.valueSize*3;this.binding.setValue(this.buffer,n)},_setAdditiveIdentityNumeric:function(){const n=this._addIndex*this.valueSize,e=n+this.valueSize;for(let t=n;t<e;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]},_select:function(n,e,t,r,s){if(r>=.5)for(let i=0;i!==s;++i)n[e+i]=n[t+i]},_slerp:function(n,e,t,r){co.slerpFlat(n,e,n,e,n,t,r)},_slerpAdditive:function(n,e,t,r,s){const i=this._workIndex*s;co.multiplyQuaternionsFlat(n,i,n,e,n,t),co.slerpFlat(n,e,n,e,n,i,r)},_lerp:function(n,e,t,r,s){const i=1-r;for(let o=0;o!==s;++o){const a=e+o;n[a]=n[a]*i+n[t+o]*r}},_lerpAdditive:function(n,e,t,r,s){for(let i=0;i!==s;++i){const o=e+i;n[o]=n[o]+n[t+i]*r}}});const AV="\\[\\]\\.:\\/",sbt=new RegExp("["+AV+"]","g"),MV="[^"+AV+"]",ibt="[^"+AV.replace("\\.","")+"]",obt=/((?:WC+[\/:])*)/.source.replace("WC",MV),abt=/(WCOD+)?/.source.replace("WCOD",ibt),lbt=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",MV),cbt=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",MV),ubt=new RegExp("^"+obt+abt+lbt+cbt+"$"),hbt=["material","materials","bones"];function Hle(n,e,t){const r=t||Ko.parseTrackName(e);this._targetGroup=n,this._bindings=n.subscribe_(e,r)}Object.assign(Hle.prototype,{getValue:function(n,e){this.bind();const t=this._targetGroup.nCachedObjects_,r=this._bindings[t];r!==void 0&&r.getValue(n,e)},setValue:function(n,e){const t=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=t.length;r!==s;++r)t[r].setValue(n,e)},bind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()},unbind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}});function Ko(n,e,t){this.path=e,this.parsedPath=t||Ko.parseTrackName(e),this.node=Ko.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(Ko,{Composite:Hle,create:function(n,e,t){return n&&n.isAnimationObjectGroup?new Ko.Composite(n,e,t):new Ko(n,e,t)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace(sbt,"")},parseTrackName:function(n){const e=ubt.exec(n);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=t.nodeName&&t.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=t.nodeName.substring(r+1);hbt.indexOf(s)!==-1&&(t.nodeName=t.nodeName.substring(0,r),t.objectName=s)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t},findNode:function(n,e){if(!e||e===""||e==="."||e===-1||e===n.name||e===n.uuid)return n;if(n.skeleton){const t=n.skeleton.getBoneByName(e);if(t!==void 0)return t}if(n.children){const t=function(s){for(let i=0;i<s.length;i++){const o=s[i];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},r=t(n.children);if(r)return r}return null}});Object.assign(Ko.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)e[t++]=r[s]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let n=this.node;const e=this.parsedPath,t=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(n||(n=Ko.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=e.objectIndex;switch(t){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[t]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const i=n[r];if(i===void 0){const l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+r+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[s]!==void 0&&(s=n.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=s}else i.fromArray!==void 0&&i.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(a=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=r;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(Ko.prototype,{_getValue_unbound:Ko.prototype.getValue,_setValue_unbound:Ko.prototype.setValue});function jle(){this.uuid=In.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let t=0,r=arguments.length;t!==r;++t)n[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(jle.prototype,{isAnimationObjectGroup:!0,add:function(){const n=this._objects,e=this._indicesByUUID,t=this._paths,r=this._parsedPaths,s=this._bindings,i=s.length;let o,a=n.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],f=h.uuid;let d=e[f];if(d===void 0){d=a++,e[f]=d,n.push(h);for(let p=0,m=i;p!==m;++p)s[p].push(new Ko(h,t[p],r[p]))}else if(d<l){o=n[d];const p=--l,m=n[p];e[m.uuid]=d,n[d]=m,e[f]=p,n[p]=h;for(let g=0,y=i;g!==y;++g){const b=s[g],x=b[p];let w=b[d];b[d]=x,w===void 0&&(w=new Ko(h,t[g],r[g])),b[p]=w}}else n[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_;for(let i=0,o=arguments.length;i!==o;++i){const a=arguments[i],l=a.uuid,c=e[l];if(c!==void 0&&c>=s){const u=s++,h=n[u];e[h.uuid]=c,n[c]=h,e[l]=u,n[u]=a;for(let f=0,d=r;f!==d;++f){const p=t[f],m=p[u],g=p[c];p[c]=m,p[u]=g}}}this.nCachedObjects_=s},uncache:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_,i=n.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=e[c];if(u!==void 0)if(delete e[c],u<s){const h=--s,f=n[h],d=--i,p=n[d];e[f.uuid]=u,n[u]=f,e[p.uuid]=h,n[h]=p,n.pop();for(let m=0,g=r;m!==g;++m){const y=t[m],b=y[h],x=y[d];y[u]=b,y[h]=x,y.pop()}}else{const h=--i,f=n[h];h>0&&(e[f.uuid]=u),n[u]=f,n.pop();for(let d=0,p=r;d!==p;++d){const m=t[d];m[u]=m[h],m.pop()}}}this.nCachedObjects_=s},subscribe_:function(n,e){const t=this._bindingsIndicesByPath;let r=t[n];const s=this._bindings;if(r!==void 0)return s[r];const i=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);r=s.length,t[n]=r,i.push(n),o.push(e),s.push(u);for(let h=c,f=a.length;h!==f;++h){const d=a[h];u[h]=new Ko(d,n,e)}return u},unsubscribe_:function(n){const e=this._bindingsIndicesByPath,t=e[n];if(t!==void 0){const r=this._paths,s=this._parsedPaths,i=this._bindings,o=i.length-1,a=i[o],l=n[o];e[l]=t,i[t]=a,i.pop(),s[t]=s[o],s.pop(),r[t]=r[o],r.pop()}}});class fbt{constructor(e,t,r=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=s;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:Xm,endingEnd:Xm};for(let c=0;c!==o;++c){const u=i[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=dle,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const s=this._clip.duration,i=e._clip.duration,o=i/s,a=s/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const s=this._mixer,i=s.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=i,l[1]=i+r,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,s){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*r;if(l<0||r===0)return;this._startTime=null,t=r*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case fV:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case P$:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(s,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let s=this.time+e,i=this._loopCount;const o=r===ple;if(e===0)return i===-1?s:o&&(i&1)===1?t-s:s;if(r===fle){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=t||s<0){const a=Math.floor(s/t);s-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(o&&(i&1)===1)return t-s}return s}_setEndings(e,t,r){const s=this._interpolantSettings;r?(s.endingStart=Km,s.endingEnd=Km):(e?s.endingStart=this.zeroSlopeAtStart?Km:Xm:s.endingStart=dS,t?s.endingEnd=this.zeroSlopeAtEnd?Km:Xm:s.endingEnd=dS)}_scheduleFading(e,t,r){const s=this._mixer,i=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=r,this}}function aL(n){this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}aL.prototype=Object.assign(Object.create(Gu.prototype),{constructor:aL,_bindAction:function(n,e){const t=n._localRoot||this._root,r=n._clip.tracks,s=r.length,i=n._propertyBindings,o=n._interpolants,a=t.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let u=0;u!==s;++u){const h=r[u],f=h.name;let d=c[f];if(d!==void 0)i[u]=d;else{if(d=i[u],d!==void 0){d._cacheIndex===null&&(++d.referenceCount,this._addInactiveBinding(d,a,f));continue}const p=e&&e._propertyBindings[u].binding.parsedPath;d=new IV(Ko.create(t,f,p),h.ValueTypeName,h.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,a,f),i[u]=d}o[u].resultBuffer=d.buffer}},_activateAction:function(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const t=(n._localRoot||this._root).uuid,r=n._clip.uuid,s=this._actionsByClip[r];this._bindAction(n,s&&s.knownActions[0]),this._addInactiveAction(n,r,t)}const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(n)}},_deactivateAction:function(n){if(this._isActiveAction(n)){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(n)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}},_isActiveAction:function(n){const e=n._cacheIndex;return e!==null&&e<this._nActiveActions},_addInactiveAction:function(n,e,t){const r=this._actions,s=this._actionsByClip;let i=s[e];if(i===void 0)i={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,s[e]=i;else{const o=i.knownActions;n._byClipCacheIndex=o.length,o.push(n)}n._cacheIndex=r.length,r.push(n),i.actionByRoot[t]=n},_removeInactiveAction:function(n){const e=this._actions,t=e[e.length-1],r=n._cacheIndex;t._cacheIndex=r,e[r]=t,e.pop(),n._cacheIndex=null;const s=n._clip.uuid,i=this._actionsByClip,o=i[s],a=o.knownActions,l=a[a.length-1],c=n._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),n._byClipCacheIndex=null;const u=o.actionByRoot,h=(n._localRoot||this._root).uuid;delete u[h],a.length===0&&delete i[s],this._removeInactiveBindingsForAction(n)},_removeInactiveBindingsForAction:function(n){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.referenceCount===0&&this._removeInactiveBinding(s)}},_lendAction:function(n){const e=this._actions,t=n._cacheIndex,r=this._nActiveActions++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackAction:function(n){const e=this._actions,t=n._cacheIndex,r=--this._nActiveActions,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_addInactiveBinding:function(n,e,t){const r=this._bindingsByRootAndName,s=this._bindings;let i=r[e];i===void 0&&(i={},r[e]=i),i[t]=n,n._cacheIndex=s.length,s.push(n)},_removeInactiveBinding:function(n){const e=this._bindings,t=n.binding,r=t.rootNode.uuid,s=t.path,i=this._bindingsByRootAndName,o=i[r],a=e[e.length-1],l=n._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[s],Object.keys(o).length===0&&delete i[r]},_lendBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=this._nActiveBindings++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=--this._nActiveBindings,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_lendControlInterpolant:function(){const n=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=n[e];return t===void 0&&(t=new DS(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=e,n[e]=t),t},_takeBackControlInterpolant:function(n){const e=this._controlInterpolants,t=n.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];n.__cacheIndex=r,e[r]=n,s.__cacheIndex=t,e[t]=s},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(n,e,t){const r=e||this._root,s=r.uuid;let i=typeof n=="string"?_l.findByName(r,n):n;const o=i!==null?i.uuid:n,a=this._actionsByClip[o];let l=null;if(t===void 0&&(i!==null?t=i.blendMode:t=P$),a!==void 0){const u=a.actionByRoot[s];if(u!==void 0&&u.blendMode===t)return u;l=a.knownActions[0],i===null&&(i=l._clip)}if(i===null)return null;const c=new fbt(this,i,e,t);return this._bindAction(c,l),this._addInactiveAction(c,o,s),c},existingAction:function(n,e){const t=e||this._root,r=t.uuid,s=typeof n=="string"?_l.findByName(t,n):n,i=s?s.uuid:n,o=this._actionsByClip[i];return o!==void 0&&o.actionByRoot[r]||null},stopAllAction:function(){const n=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)n[t].stop();return this},update:function(n){n*=this.timeScale;const e=this._actions,t=this._nActiveActions,r=this.time+=n,s=Math.sign(n),i=this._accuIndex^=1;for(let l=0;l!==t;++l)e[l]._update(r,n,s,i);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(i);return this},setTime:function(n){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)},getRoot:function(){return this._root},uncacheClip:function(n){const e=this._actions,t=n.uuid,r=this._actionsByClip,s=r[t];if(s!==void 0){const i=s.knownActions;for(let o=0,a=i.length;o!==a;++o){const l=i[o];this._deactivateAction(l);const c=l._cacheIndex,u=e[e.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(l)}delete r[t]}},uncacheRoot:function(n){const e=n.uuid,t=this._actionsByClip;for(const i in t){const o=t[i].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const i in s){const o=s[i];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(n,e){const t=this.existingAction(n,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});class B${constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new B$(this.value.clone===void 0?this.value:this.value.clone())}}function lL(n,e,t){kl.call(this,n,e),this.meshPerAttribute=t||1}lL.prototype=Object.assign(Object.create(kl.prototype),{constructor:lL,isInstancedInterleavedBuffer:!0,copy:function(n){return kl.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const e=kl.prototype.clone.call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(n){const e=kl.prototype.toJSON.call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}});function NV(n,e,t,r,s){this.buffer=n,this.type=e,this.itemSize=t,this.elementSize=r,this.count=s,this.version=0}Object.defineProperty(NV.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(NV.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,e){return this.type=n,this.elementSize=e,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function $V(n,e,t,r){this.ray=new ux(n,e),this.near=t||0,this.far=r||1/0,this.camera=null,this.layers=new gV,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function yq(n,e){return n.distance-e.distance}function cL(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),r===!0){const s=n.children;for(let i=0,o=s.length;i<o;i++)cL(s[i],e,t,!0)}}Object.assign($V.prototype,{set:function(n,e){this.ray.set(n,e)},setFromCamera:function(n,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(n,e,t){const r=t||[];return cL(n,this,r,e),r.sort(yq),r},intersectObjects:function(n,e,t){const r=t||[];if(Array.isArray(n)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let s=0,i=n.length;s<i;s++)cL(n[s],this,r,e);return r.sort(yq),r}});class uL{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(In.clamp(t/this.radius,-1,1))),this}}class dbt{constructor(e,t,r){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=r!==void 0?r:0,this}set(e,t,r){return this.radius=e,this.theta=t,this.y=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}}const bq=new st;class qle{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new st(1/0,1/0),this.max=t!==void 0?t:new st(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=bq.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new st),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new st),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return bq.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const vq=new Q,bE=new Q;class Xle{constructor(e,t){this.start=e!==void 0?e:new Q,this.end=t!==void 0?t:new Q}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Q),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Q),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new Q),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){vq.subVectors(e,this.start),bE.subVectors(this.end,this.start);const r=bE.dot(bE);let i=bE.dot(vq)/r;return t&&(i=In.clamp(i,0,1)),i}closestPointToPoint(e,t,r){const s=this.closestPointToPointParameter(e,t);return r===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new Q),this.delta(r).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function LS(n){rn.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}LS.prototype=Object.create(rn.prototype);LS.prototype.constructor=LS;LS.prototype.isImmediateRenderObject=!0;const wq=new Q;class pbt extends rn{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const r=new un,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;s.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}r.setAttribute("position",new Xt(s,3));const i=new Es({fog:!1,toneMapped:!1});this.cone=new Ta(r,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),wq.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(wq),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const kd=new Q,vE=new Zn,VP=new Zn;class Kle extends Ta{constructor(e){const t=Yle(e),r=new un,s=[],i=[],o=new Ht(0,0,1),a=new Ht(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}r.setAttribute("position",new Xt(s,3)),r.setAttribute("color",new Xt(i,3));const l=new Es({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,s=r.getAttribute("position");VP.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(vE.multiplyMatrices(VP,a.matrixWorld),kd.setFromMatrixPosition(vE),s.setXYZ(o,kd.x,kd.y,kd.z),vE.multiplyMatrices(VP,a.parent.matrixWorld),kd.setFromMatrixPosition(vE),s.setXYZ(o+1,kd.x,kd.y,kd.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Yle(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,Yle(n.children[t]));return e}class mbt extends hs{constructor(e,t,r){const s=new PS(t,4,2),i=new Dl({wireframe:!0,fog:!1,toneMapped:!1});super(s,i),this.light=e,this.light.updateMatrixWorld(),this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const gbt=new Q,xq=new Ht,_q=new Ht;class ybt extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;const s=new $S(t);s.rotateY(Math.PI*.5),this.material=new Dl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=s.getAttribute("position"),o=new Float32Array(i.count*3);s.setAttribute("color",new Cn(o,3)),this.add(new hs(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");xq.copy(this.light.color),_q.copy(this.light.groundColor);for(let r=0,s=t.count;r<s;r++){const i=r<s/2?xq:_q;t.setXYZ(r,i.r,i.g,i.b)}t.needsUpdate=!0}e.lookAt(gbt.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Zle extends Ta{constructor(e=10,t=10,r=4473924,s=8947848){r=new Ht(r),s=new Ht(s);const i=t/2,o=e/t,a=e/2,l=[],c=[];for(let f=0,d=0,p=-a;f<=t;f++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=f===i?r:s;m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3}const u=new un;u.setAttribute("position",new Xt(l,3)),u.setAttribute("color",new Xt(c,3));const h=new Es({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class bbt extends Ta{constructor(e=10,t=16,r=8,s=64,i=4473924,o=8947848){i=new Ht(i),o=new Ht(o);const a=[],l=[];for(let h=0;h<=t;h++){const f=h/t*(Math.PI*2),d=Math.sin(f)*e,p=Math.cos(f)*e;a.push(0,0,0),a.push(d,0,p);const m=h&1?i:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=r;h++){const f=h&1?i:o,d=e-e/r*h;for(let p=0;p<s;p++){let m=p/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d;a.push(g,0,y),l.push(f.r,f.g,f.b),m=(p+1)/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d,a.push(g,0,y),l.push(f.r,f.g,f.b)}}const c=new un;c.setAttribute("position",new Xt(a,3)),c.setAttribute("color",new Xt(l,3));const u=new Es({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const Sq=new Q,wE=new Q,Cq=new Q;class vbt extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,t===void 0&&(t=1);let s=new un;s.setAttribute("position",new Xt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Es({fog:!1,toneMapped:!1});this.lightPlane=new $c(s,i),this.add(this.lightPlane),s=new un,s.setAttribute("position",new Xt([0,0,0,0,0,1],3)),this.targetLine=new $c(s,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Sq.setFromMatrixPosition(this.light.matrixWorld),wE.setFromMatrixPosition(this.light.target.matrixWorld),Cq.subVectors(wE,Sq),this.lightPlane.lookAt(wE),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(wE),this.targetLine.scale.z=Cq.length()}}const xE=new Q,Gs=new Eh;class wbt extends Ta{constructor(e){const t=new un,r=new Es({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],i=[],o={},a=new Ht(16755200),l=new Ht(16711680),c=new Ht(43775),u=new Ht(16777215),h=new Ht(3355443);f("n1","n2",a),f("n2","n4",a),f("n4","n3",a),f("n3","n1",a),f("f1","f2",a),f("f2","f4",a),f("f4","f3",a),f("f3","f1",a),f("n1","f1",a),f("n2","f2",a),f("n3","f3",a),f("n4","f4",a),f("p","n1",l),f("p","n2",l),f("p","n3",l),f("p","n4",l),f("u1","u2",c),f("u2","u3",c),f("u3","u1",c),f("c","t",u),f("p","c",h),f("cn1","cn2",h),f("cn3","cn4",h),f("cf1","cf2",h),f("cf3","cf4",h);function f(p,m,g){d(p,g),d(m,g)}function d(p,m){s.push(0,0,0),i.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(s.length/3-1)}t.setAttribute("position",new Xt(s,3)),t.setAttribute("color",new Xt(i,3)),super(t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap,r=1,s=1;Gs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),si("c",t,e,Gs,0,0,-1),si("t",t,e,Gs,0,0,1),si("n1",t,e,Gs,-r,-s,-1),si("n2",t,e,Gs,r,-s,-1),si("n3",t,e,Gs,-r,s,-1),si("n4",t,e,Gs,r,s,-1),si("f1",t,e,Gs,-r,-s,1),si("f2",t,e,Gs,r,-s,1),si("f3",t,e,Gs,-r,s,1),si("f4",t,e,Gs,r,s,1),si("u1",t,e,Gs,r*.7,s*1.1,-1),si("u2",t,e,Gs,-r*.7,s*1.1,-1),si("u3",t,e,Gs,0,s*2,-1),si("cf1",t,e,Gs,-r,0,1),si("cf2",t,e,Gs,r,0,1),si("cf3",t,e,Gs,0,-s,1),si("cf4",t,e,Gs,0,s,1),si("cn1",t,e,Gs,-r,0,-1),si("cn2",t,e,Gs,r,0,-1),si("cn3",t,e,Gs,0,-s,-1),si("cn4",t,e,Gs,0,s,-1),e.getAttribute("position").needsUpdate=!0}}function si(n,e,t,r,s,i,o){xE.set(s,i,o).unproject(r);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],xE.x,xE.y,xE.z)}}const _E=new Qf;class Jle extends Ta{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),i=new un;i.setIndex(new Cn(r,1)),i.setAttribute("position",new Cn(s,3)),super(i,new Es({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_E.setFromObject(this.object),_E.isEmpty())return;const t=_E.min,r=_E.max,s=this.geometry.attributes.position,i=s.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=t.x,i[4]=r.y,i[5]=r.z,i[6]=t.x,i[7]=t.y,i[8]=r.z,i[9]=r.x,i[10]=t.y,i[11]=r.z,i[12]=r.x,i[13]=r.y,i[14]=t.z,i[15]=t.x,i[16]=r.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=r.x,i[22]=t.y,i[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return Ta.prototype.copy.call(this,e),this.object=e.object,this}}class xbt extends Ta{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new un;i.setIndex(new Cn(r,1)),i.setAttribute("position",new Xt(s,3)),super(i,new Es({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class _bt extends $c{constructor(e,t=1,r=16776960){const s=r,i=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new un;o.setAttribute("position",new Xt(i,3)),o.computeBoundingSphere(),super(o,new Es({color:s,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new un;l.setAttribute("position",new Xt(a,3)),l.computeBoundingSphere(),this.add(new hs(l,new Dl({color:s,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?gi:ox,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const kq=new Q;let SE,UP;class Sbt extends rn{constructor(e,t,r,s,i,o){super(),this.type="ArrowHelper",e===void 0&&(e=new Q(0,0,1)),t===void 0&&(t=new Q(0,0,0)),r===void 0&&(r=1),s===void 0&&(s=16776960),i===void 0&&(i=.2*r),o===void 0&&(o=.2*i),SE===void 0&&(SE=new un,SE.setAttribute("position",new Xt([0,0,0,0,1,0],3)),UP=new xv(0,.5,1,5,1),UP.translate(0,-.5,0)),this.position.copy(t),this.line=new $c(SE,new Es({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new hs(UP,new Dl({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{kq.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(kq,t)}}setLength(e,t,r){t===void 0&&(t=.2*e),r===void 0&&(r=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class Qle extends Ta{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new un;s.setAttribute("position",new Xt(t,3)),s.setAttribute("color",new Xt(r,3));const i=new Es({vertexColors:!0,toneMapped:!1});super(s,i),this.type="AxesHelper"}}const ece=new Float32Array(1),Cbt=new Int32Array(ece.buffer),kbt={toHalfFloat:function(n){ece[0]=n;const e=Cbt[0];let t=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&e&8388607,t):s<113?(r|=2048,t|=(r>>114-s)+(r>>113-s&1),t):(t|=s-112<<10|r>>1,t+=r&1,t)}},Bb=4,sp=8,ih=Math.pow(2,sp),tce=[.125,.215,.35,.446,.526,.582],nce=sp-Bb+1+tce.length,cb=20,dh={[Ca]:0,[HC]:1,[O$]:2,[dV]:3,[pV]:4,[mV]:5,[D$]:6},Am=new Dl({side:gi,depthWrite:!1,depthTest:!1}),Tbt=new hs(new Tg,Am),WP=new Tv,{_lodPlanes:p1,_sizeLods:Tq,_sigmas:CE}=Abt(),Eq=new Ht;let GP=null;const Mm=(1+Math.sqrt(5))/2,ub=1/Mm,Iq=[new Q(1,1,1),new Q(-1,1,1),new Q(1,1,-1),new Q(-1,1,-1),new Q(0,Mm,ub),new Q(0,Mm,-ub),new Q(ub,0,Mm),new Q(-ub,0,Mm),new Q(Mm,ub,0),new Q(-Mm,ub,0)];function Aq(n){const e=Math.max(n.r,n.g,n.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return n.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class Ebt{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=Mbt(cb),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,s=100){GP=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,r,s,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=$q(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Nq(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<p1.length;e++)p1[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(GP),e.scissorTest=!1,kE(e,0,0,e.width,e.height)}_fromTexture(e){GP=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Ui,minFilter:Ui,generateMipmaps:!1,type:cx,format:Aae,encoding:Ibt(e)?e.encoding:O$,depthBuffer:!1},r=Mq(t);return r.depthBuffer=!e,this._pingPongRenderTarget=Mq(t),r}_compileMaterial(e){const t=new hs(p1[0],e);this._renderer.compile(t,WP)}_sceneToCubeUV(e,t,r,s){const a=new Si(90,1,t,r),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,f=u.outputEncoding,d=u.toneMapping;u.getClearColor(Eq),u.toneMapping=rg,u.outputEncoding=Ca,u.autoClear=!1;let p=!1;const m=e.background;if(m){if(m.isColor){Am.color.copy(m).convertSRGBToLinear(),e.background=null;const g=Aq(Am.color);Am.opacity=g,p=!0}}else{Am.color.copy(Eq).convertSRGBToLinear();const g=Aq(Am.color);Am.opacity=g,p=!0}for(let g=0;g<6;g++){const y=g%3;y==0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):y==1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g])),kE(s,y*ih,g>2?ih:0,ih,ih),u.setRenderTarget(s),p&&u.render(Tbt,a),u.render(e,a)}u.toneMapping=d,u.outputEncoding=f,u.autoClear=h}_textureToCubeUV(e,t){const r=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=$q()):this._equirectShader==null&&(this._equirectShader=Nq());const s=e.isCubeTexture?this._cubemapShader:this._equirectShader,i=new hs(p1[0],s),o=s.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=dh[e.encoding],o.outputEncoding.value=dh[t.texture.encoding],kE(t,0,0,3*ih,2*ih),r.setRenderTarget(t),r.render(i,WP)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let s=1;s<nce;s++){const i=Math.sqrt(CE[s]*CE[s]-CE[s-1]*CE[s-1]),o=Iq[(s-1)%Iq.length];this._blur(e,s-1,s,i,o)}t.autoClear=r}_blur(e,t,r,s,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,s,"latitudinal",i),this._halfBlur(o,e,r,r,s,"longitudinal",i)}_halfBlur(e,t,r,s,i,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new hs(p1[s],c),f=c.uniforms,d=Tq[r]-1,p=isFinite(i)?Math.PI/(2*d):2*Math.PI/(2*cb-1),m=i/p,g=isFinite(i)?1+Math.floor(u*m):cb;g>cb&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${cb}`);const y=[];let b=0;for(let C=0;C<cb;++C){const k=C/m,A=Math.exp(-k*k/2);y.push(A),C==0?b+=A:C<g&&(b+=2*A)}for(let C=0;C<y.length;C++)y[C]=y[C]/b;f.envMap.value=e.texture,f.samples.value=g,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a),f.dTheta.value=p,f.mipInt.value=sp-r,f.inputEncoding.value=dh[e.texture.encoding],f.outputEncoding.value=dh[e.texture.encoding];const x=Tq[s],w=3*Math.max(0,ih-2*x),S=(s===0?0:2*ih)+2*x*(s>sp-Bb?s-sp+Bb:0);kE(t,w,S,3*x,2*x),l.setRenderTarget(t),l.render(h,WP)}}function Ibt(n){return n===void 0||n.type!==cx?!1:n.encoding===Ca||n.encoding===HC||n.encoding===D$}function Abt(){const n=[],e=[],t=[];let r=sp;for(let s=0;s<nce;s++){const i=Math.pow(2,r);e.push(i);let o=1/i;s>sp-Bb?o=tce[s-sp+Bb-1]:s==0&&(o=0),t.push(o);const a=1/(i-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,f=6,d=3,p=2,m=1,g=new Float32Array(d*f*h),y=new Float32Array(p*f*h),b=new Float32Array(m*f*h);for(let w=0;w<h;w++){const S=w%3*2/3-1,C=w>2?0:-1,k=[S,C,0,S+2/3,C,0,S+2/3,C+1,0,S,C,0,S+2/3,C+1,0,S,C+1,0];g.set(k,d*f*w),y.set(u,p*f*w);const A=[w,w,w,w,w,w];b.set(A,m*f*w)}const x=new un;x.setAttribute("position",new Cn(g,d)),x.setAttribute("uv",new Cn(y,p)),x.setAttribute("faceIndex",new Cn(b,m)),n.push(x),r>Bb&&r--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function Mq(n){const e=new tp(3*ih,3*ih,n);return e.texture.mapping=ax,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function kE(n,e,t,r,s){n.viewport.set(e,t,r,s),n.scissor.set(e,t,r,s)}function Mbt(n){const e=new Float32Array(n),t=new Q(0,1,0);return new Bf({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:dh[Ca]},outputEncoding:{value:dh[Ca]}},vertexShader:RV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${PV()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Rf,depthTest:!1,depthWrite:!1})}function Nq(){const n=new st(1,1);return new Bf({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:dh[Ca]},outputEncoding:{value:dh[Ca]}},vertexShader:RV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${PV()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Rf,depthTest:!1,depthWrite:!1})}function $q(){return new Bf({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:dh[Ca]},outputEncoding:{value:dh[Ca]}},vertexShader:RV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${PV()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Rf,depthTest:!1,depthWrite:!1})}function RV(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function PV(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Nbt(n,e,t,r,s,i,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new yV(n,e,t,s,i,o)}const $bt=0,Rbt=1,Pbt=0,Dbt=1,Obt=2;function Fbt(n){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),n}function Lbt(n=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),n.isMultiMaterial=!0,n.materials=n,n.clone=function(){return n.slice()},n}function zbt(n,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new vv(n,e)}function Bbt(n){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new _S(n)}function Vbt(n,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new vv(n,e)}function Ubt(n){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Eu(n)}function Wbt(n){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Eu(n)}function Gbt(n){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Eu(n)}function Hbt(n,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Q(n,e,t)}function jbt(n,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Cn(n,e).setUsage(Sg)}function qbt(n,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new pS(n,e)}function Xbt(n,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new mS(n,e)}function Kbt(n,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new gS(n,e)}function Ybt(n,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new yS(n,e)}function Zbt(n,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Cg(n,e)}function Jbt(n,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new bS(n,e)}function Qbt(n,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new kg(n,e)}function evt(n,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Xt(n,e)}function tvt(n,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new wS(n,e)}on.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(on.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};Object.assign(lu.prototype,{fromPoints:function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)}});function rce(n){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom",this.closed=!0}rce.prototype=Object.create(Qo.prototype);function sce(n){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom"}sce.prototype=Object.create(Qo.prototype);function DV(n){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom"}DV.prototype=Object.create(Qo.prototype);Object.assign(DV.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});function nvt(n){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Qle(n)}function rvt(n,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Jle(n,e)}function svt(n,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Ta(new wV(n.geometry),new Es({color:e!==void 0?e:16777215}))}Zle.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Kle.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function ivt(n,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Ta(new xV(n.geometry),new Es({color:e!==void 0?e:16777215}))}Object.assign(zr.prototype,{extractUrlBase:function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),CV.extractUrlBase(n)}});zr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function ovt(n){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Rc(n)}function avt(n){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new eM(n)}Object.assign(qle.prototype,{center:function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},size:function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Qf.prototype,{center:function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionSphere:function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)},size:function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Gp.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});qC.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};Xle.prototype.center=function(n){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Object.assign(In,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),In.floorPowerOfTwo(n)},nextPowerOfTwo:function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),In.ceilPowerOfTwo(n)}});Object.assign(Cl.prototype,{flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},multiplyVector3:function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});Object.assign(Zn.prototype,{extractPosition:function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)},flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new Q().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector4:function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)},crossVector:function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(n,e,t,r,s,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,r,t,s,i)},getInverse:function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});ch.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Object.assign(co.prototype,{multiplyVector3:function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(ux.prototype,{isIntersectionBox:function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionPlane:function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)},isIntersectionSphere:function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)}});Object.assign(jo.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)},midpoint:function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)},normal:function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)},plane:function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)}});Object.assign(jo,{barycoordFromPoint:function(n,e,t,r,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),jo.getBarycoord(n,e,t,r,s)},normal:function(n,e,t,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),jo.getNormal(n,e,t,r)}});Object.assign(rp.prototype,{extractAllPoints:function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)},extrude:function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Ig(this,n)},makeGeometry:function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new RS(this,n)}});Object.assign(st.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Q.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)},getScaleFromMatrix:function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)},getColumnFromMatrix:function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)},applyProjection:function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)},fromAttribute:function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Hr.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(rn.prototype,{getChildByName:function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(rn.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(hs.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(hs.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),mle},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(SS.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(TS.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});CS.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(on.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});Si.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(fs.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Cn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Sg},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Sg)}}});Object.assign(Cn.prototype,{setDynamic:function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Sg:jC),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(un.prototype,{addIndex:function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)},addAttribute:function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Cn(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)},addDrawCall:function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)},applyMatrix:function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(un.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(FS.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties($V.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(kl.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Sg},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Object.assign(kl.prototype,{setDynamic:function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Sg:jC),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(Ig.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}});Object.assign(vV.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(B$.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}});Object.defineProperties(kn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ht}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===lV}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(Ep.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(Tp.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(ka.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Object.assign(XC.prototype,{clearTarget:function(n,e,t,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,r)},animate:function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(XC.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?HC:Ca}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties($le.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function lvt(n,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new bV(n,t)}Object.defineProperties(tp.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});Object.defineProperties(EV.prototype,{load:{value:function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new hM().load(n,function(r){e.setBuffer(r)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}});Gle.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};Eg.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};Eg.prototype.clear=function(n,e,t,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,r)};const cvt={merge:function(n,e,t){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");let r;e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),r=e.matrix,e=e.geometry),n.merge(e,r,t)},center:function(n){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),n.center()}};r0.crossOrigin=void 0;r0.loadTexture=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new tM;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};r0.loadTextureCube=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new QA;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};r0.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};r0.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function uvt(){console.error("THREE.CanvasRenderer has been removed")}function hvt(){console.error("THREE.JSONLoader has been removed.")}const fvt={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function dvt(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:oV}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=oV);const pvt=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:bae,AddEquation:Vm,AddOperation:pae,AdditiveAnimationBlendMode:fV,AdditiveBlending:AF,AlphaFormat:Tae,AlwaysDepth:aae,AlwaysStencilFunc:wle,AmbientLight:oM,AmbientLightProbe:oL,AnimationClip:_l,AnimationLoader:ZF,AnimationMixer:aL,AnimationObjectGroup:jle,AnimationUtils:ps,ArcCurve:kv,ArrayCamera:RA,ArrowHelper:Sbt,Audio:EV,AudioAnalyser:Gle,AudioContext:TV,AudioListener:tbt,AudioLoader:hM,AxesHelper:Qle,AxisHelper:nvt,BackSide:gi,BasicDepthPacking:yle,BasicShadowMap:Idt,BinaryTextureLoader:avt,Bone:kS,BooleanKeyframeTrack:KA,BoundingBoxHelper:rvt,Box2:qle,Box3:Qf,Box3Helper:xbt,BoxBufferGeometry:Tg,BoxGeometry:Tg,BoxHelper:Jle,BufferAttribute:Cn,BufferGeometry:un,BufferGeometryLoader:uM,ByteType:wae,Cache:Og,Camera:Eh,CameraHelper:wbt,CanvasRenderer:uvt,CanvasTexture:ES,CatmullRomCurve3:Qo,CineonToneMapping:yae,CircleBufferGeometry:OA,CircleGeometry:OA,ClampToEdgeWrapping:pa,Clock:Wle,ClosedSplineCurve3:rce,Color:Ht,ColorKeyframeTrack:YA,CompressedTexture:wv,CompressedTextureLoader:JF,ConeBufferGeometry:FA,ConeGeometry:FA,CubeCamera:Eg,CubeReflectionMapping:UC,CubeRefractionMapping:WC,CubeTexture:Ih,CubeTextureLoader:QA,CubeUVReflectionMapping:ax,CubeUVRefractionMapping:GC,CubicBezierCurve:Iu,CubicBezierCurve3:Mh,CubicInterpolant:qA,CullFaceBack:IF,CullFaceFront:joe,CullFaceFrontBack:Edt,CullFaceNone:Hoe,Curve:on,CurvePath:Hd,CustomBlending:Xoe,CustomToneMapping:vae,CylinderBufferGeometry:xv,CylinderGeometry:xv,Cylindrical:dbt,DataTexture:zf,DataTexture2DArray:yv,DataTexture3D:bv,DataTextureLoader:eM,DataUtils:kbt,DecrementStencilOp:zdt,DecrementWrapStencilOp:Vdt,DefaultLoadingManager:zle,DepthFormat:sg,DepthStencilFormat:mv,DepthTexture:IS,DirectionalLight:iM,DirectionalLightHelper:vbt,DiscreteInterpolant:XA,DodecahedronBufferGeometry:LA,DodecahedronGeometry:LA,DoubleSide:BC,DstAlphaFactor:tae,DstColorFactor:rae,DynamicBufferAttribute:jbt,DynamicCopyUsage:tpt,DynamicDrawUsage:Sg,DynamicReadUsage:Jdt,EdgesGeometry:wV,EdgesHelper:svt,EllipseCurve:Fl,EqualDepth:cae,EqualStencilFunc:Hdt,EquirectangularReflectionMapping:AA,EquirectangularRefractionMapping:MA,Euler:hx,EventDispatcher:Gu,ExtrudeBufferGeometry:Ig,ExtrudeGeometry:Ig,Face3:yV,Face4:Nbt,FaceColors:Dbt,FileLoader:Rc,FlatShading:lV,Float16BufferAttribute:vS,Float32Attribute:evt,Float32BufferAttribute:Xt,Float64Attribute:tvt,Float64BufferAttribute:wS,FloatType:If,Fog:L$,FogExp2:F$,Font:Vle,FontLoader:sL,FrontSide:ox,Frustum:qC,GLBufferAttribute:NV,GLSL1:rpt,GLSL3:GF,GammaEncoding:D$,GeometryUtils:cvt,GreaterDepth:hae,GreaterEqualDepth:uae,GreaterEqualStencilFunc:Kdt,GreaterStencilFunc:qdt,GridHelper:Zle,Group:Gd,HalfFloatType:hS,HemisphereLight:nM,HemisphereLightHelper:ybt,HemisphereLightProbe:iL,IcosahedronBufferGeometry:zA,IcosahedronGeometry:zA,ImageBitmapLoader:rL,ImageLoader:Cv,ImageUtils:r0,ImmediateRenderObject:LS,IncrementStencilOp:Ldt,IncrementWrapStencilOp:Bdt,InstancedBufferAttribute:cM,InstancedBufferGeometry:FS,InstancedInterleavedBuffer:lL,InstancedMesh:PA,Int16Attribute:Ybt,Int16BufferAttribute:yS,Int32Attribute:Jbt,Int32BufferAttribute:bS,Int8Attribute:qbt,Int8BufferAttribute:pS,IntType:_ae,InterleavedBuffer:kl,InterleavedBufferAttribute:_p,Interpolant:Ml,InterpolateDiscrete:fS,InterpolateLinear:u_,InterpolateSmooth:iI,InvertStencilOp:Udt,JSONLoader:hvt,KeepStencilOp:oI,KeyframeTrack:Co,LOD:SS,LatheBufferGeometry:BA,LatheGeometry:BA,Layers:gV,LensFlare:dvt,LessDepth:lae,LessEqualDepth:IA,LessEqualStencilFunc:jdt,LessStencilFunc:Gdt,Light:fs,LightProbe:Sc,Line:$c,Line3:Xle,LineBasicMaterial:Es,LineCurve:Ja,LineCurve3:Au,LineDashedMaterial:Dg,LineLoop:DA,LinePieces:Rbt,LineSegments:Ta,LineStrip:$bt,LinearEncoding:Ca,LinearFilter:lo,LinearInterpolant:DS,LinearMipMapLinearFilter:Rdt,LinearMipMapNearestFilter:$dt,LinearMipmapLinearFilter:lx,LinearMipmapNearestFilter:hV,LinearToneMapping:mae,Loader:zr,LoaderUtils:CV,LoadingManager:_V,LogLuvEncoding:gle,LoopOnce:fle,LoopPingPong:ple,LoopRepeat:dle,LuminanceAlphaFormat:Iae,LuminanceFormat:Eae,MOUSE:Cf,Material:kn,MaterialLoader:lM,Math:In,MathUtils:In,Matrix3:Cl,Matrix4:Zn,MaxEquation:RF,Mesh:hs,MeshBasicMaterial:Dl,MeshDepthMaterial:wp,MeshDistanceMaterial:xp,MeshFaceMaterial:Fbt,MeshLambertMaterial:Rg,MeshMatcapMaterial:Pg,MeshNormalMaterial:$g,MeshPhongMaterial:Ep,MeshPhysicalMaterial:Tp,MeshStandardMaterial:Ah,MeshToonMaterial:Ng,MinEquation:$F,MirroredRepeatWrapping:cS,MixOperation:dae,MultiMaterial:Lbt,MultiplyBlending:NF,MultiplyOperation:VC,NearestFilter:Ui,NearestMipMapLinearFilter:Ndt,NearestMipMapNearestFilter:Mdt,NearestMipmapLinearFilter:$A,NearestMipmapNearestFilter:NA,NeverDepth:oae,NeverStencilFunc:Wdt,NoBlending:Rf,NoColors:Pbt,NoToneMapping:rg,NormalAnimationBlendMode:P$,NormalBlending:Lb,NotEqualDepth:fae,NotEqualStencilFunc:Xdt,NumberKeyframeTrack:_v,Object3D:rn,ObjectLoader:Y0t,ObjectSpaceNormalMap:vle,OctahedronBufferGeometry:$S,OctahedronGeometry:$S,OneFactor:Joe,OneMinusDstAlphaFactor:nae,OneMinusDstColorFactor:sae,OneMinusSrcAlphaFactor:uV,OneMinusSrcColorFactor:eae,OrthographicCamera:Tv,PCFShadowMap:aV,PCFSoftShadowMap:qoe,PMREMGenerator:Ebt,ParametricBufferGeometry:Ag,ParametricGeometry:Ag,Particle:Bbt,ParticleBasicMaterial:Wbt,ParticleSystem:Vbt,ParticleSystemMaterial:Gbt,Path:lu,PerspectiveCamera:Si,Plane:ch,PlaneBufferGeometry:xS,PlaneGeometry:xS,PlaneHelper:_bt,PointCloud:zbt,PointCloudMaterial:Ubt,PointLight:sM,PointLightHelper:mbt,Points:vv,PointsMaterial:Eu,PolarGridHelper:bbt,PolyhedronBufferGeometry:Cp,PolyhedronGeometry:Cp,PositionalAudio:rbt,PropertyBinding:Ko,PropertyMixer:IV,QuadraticBezierCurve:Mu,QuadraticBezierCurve3:Nh,Quaternion:co,QuaternionKeyframeTrack:OS,QuaternionLinearInterpolant:ZA,REVISION:oV,RGBADepthPacking:ble,RGBAFormat:Al,RGBAIntegerFormat:Dae,RGBA_ASTC_10x10_Format:Xae,RGBA_ASTC_10x5_Format:Hae,RGBA_ASTC_10x6_Format:jae,RGBA_ASTC_10x8_Format:qae,RGBA_ASTC_12x10_Format:Kae,RGBA_ASTC_12x12_Format:Yae,RGBA_ASTC_4x4_Format:Fae,RGBA_ASTC_5x4_Format:Lae,RGBA_ASTC_5x5_Format:zae,RGBA_ASTC_6x5_Format:Bae,RGBA_ASTC_6x6_Format:Vae,RGBA_ASTC_8x5_Format:Uae,RGBA_ASTC_8x6_Format:Wae,RGBA_ASTC_8x8_Format:Gae,RGBA_BPTC_Format:Zae,RGBA_ETC2_EAC_Format:WF,RGBA_PVRTC_2BPPV1_Format:VF,RGBA_PVRTC_4BPPV1_Format:BF,RGBA_S3TC_DXT1_Format:DF,RGBA_S3TC_DXT3_Format:OF,RGBA_S3TC_DXT5_Format:FF,RGBDEncoding:mV,RGBEEncoding:O$,RGBEFormat:Aae,RGBFormat:ep,RGBIntegerFormat:Pae,RGBM16Encoding:pV,RGBM7Encoding:dV,RGB_ETC1_Format:Oae,RGB_ETC2_Format:UF,RGB_PVRTC_2BPPV1_Format:zF,RGB_PVRTC_4BPPV1_Format:LF,RGB_S3TC_DXT1_Format:PF,RGFormat:$ae,RGIntegerFormat:Rae,RawShaderMaterial:Bf,Ray:ux,Raycaster:$V,RectAreaLight:aM,RedFormat:Mae,RedIntegerFormat:Nae,ReinhardToneMapping:gae,RepeatWrapping:lS,ReplaceStencilOp:Fdt,ReverseSubtractEquation:Yoe,RingBufferGeometry:VA,RingGeometry:VA,SRGB8_ALPHA8_ASTC_10x10_Format:cle,SRGB8_ALPHA8_ASTC_10x5_Format:ole,SRGB8_ALPHA8_ASTC_10x6_Format:ale,SRGB8_ALPHA8_ASTC_10x8_Format:lle,SRGB8_ALPHA8_ASTC_12x10_Format:ule,SRGB8_ALPHA8_ASTC_12x12_Format:hle,SRGB8_ALPHA8_ASTC_4x4_Format:Jae,SRGB8_ALPHA8_ASTC_5x4_Format:Qae,SRGB8_ALPHA8_ASTC_5x5_Format:ele,SRGB8_ALPHA8_ASTC_6x5_Format:tle,SRGB8_ALPHA8_ASTC_6x6_Format:nle,SRGB8_ALPHA8_ASTC_8x5_Format:rle,SRGB8_ALPHA8_ASTC_8x6_Format:sle,SRGB8_ALPHA8_ASTC_8x8_Format:ile,Scene:vV,SceneUtils:fvt,ShaderChunk:Jn,ShaderLib:ou,ShaderMaterial:ka,ShadowMaterial:Mg,Shape:rp,ShapeBufferGeometry:RS,ShapeGeometry:RS,ShapePath:kV,ShapeUtils:Pf,ShortType:xae,Skeleton:TS,SkeletonHelper:Kle,SkinnedMesh:CS,SmoothShading:Adt,Sphere:Gp,SphereBufferGeometry:PS,SphereGeometry:PS,Spherical:uL,SphericalHarmonics3:Ble,Spline:DV,SplineCurve:Nu,SplineCurve3:sce,SpotLight:rM,SpotLightHelper:pbt,Sprite:_S,SpriteMaterial:Sp,SrcAlphaFactor:cV,SrcAlphaSaturateFactor:iae,SrcColorFactor:Qoe,StaticCopyUsage:ept,StaticDrawUsage:jC,StaticReadUsage:Zdt,StereoCamera:Ule,StreamCopyUsage:npt,StreamDrawUsage:Ydt,StreamReadUsage:Qdt,StringKeyframeTrack:JA,SubtractEquation:Koe,SubtractiveBlending:MF,TOUCH:kf,TangentSpaceNormalMap:n0,TetrahedronBufferGeometry:UA,TetrahedronGeometry:UA,TextBufferGeometry:WA,TextGeometry:WA,Texture:Kr,TextureLoader:tM,TorusBufferGeometry:GA,TorusGeometry:GA,TorusKnotBufferGeometry:HA,TorusKnotGeometry:HA,Triangle:jo,TriangleFanDrawMode:Ddt,TriangleStripDrawMode:Pdt,TrianglesDrawMode:mle,TubeBufferGeometry:jA,TubeGeometry:jA,UVMapping:R$,Uint16Attribute:Zbt,Uint16BufferAttribute:Cg,Uint32Attribute:Qbt,Uint32BufferAttribute:kg,Uint8Attribute:Xbt,Uint8BufferAttribute:mS,Uint8ClampedAttribute:Kbt,Uint8ClampedBufferAttribute:gS,Uniform:B$,UniformsLib:Pt,UniformsUtils:Sle,UnsignedByteType:cx,UnsignedInt248Type:zb,UnsignedIntType:c_,UnsignedShort4444Type:Sae,UnsignedShort5551Type:Cae,UnsignedShort565Type:kae,UnsignedShortType:uS,VSMShadowMap:Tb,Vector2:st,Vector3:Q,Vector4:Hr,VectorKeyframeTrack:Sv,Vertex:Hbt,VertexColors:Obt,VideoTexture:XF,WebGL1Renderer:jF,WebGLCubeRenderTarget:bV,WebGLMultisampleRenderTarget:ipt,WebGLRenderTarget:tp,WebGLRenderTargetCube:lvt,WebGLRenderer:XC,WebGLUtils:Rle,WireframeGeometry:xV,WireframeHelper:ivt,WrapAroundEnding:dS,XHRLoader:ovt,ZeroCurvatureEnding:Xm,ZeroFactor:Zoe,ZeroSlopeEnding:Km,ZeroStencilOp:Odt,sRGBEncoding:HC},Symbol.toStringTag,{value:"Module"})),s0=Gf(pvt);var zS=function(n,e){e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=n,this.domElement=e,this.enabled=!0,this.target=new Q,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:Cf.ROTATE,MIDDLE:Cf.DOLLY,RIGHT:Cf.PAN},this.touches={ONE:kf.ROTATE,TWO:kf.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(ce){ce.addEventListener("keydown",ye),this._domElementKeyEvents=ce},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(r),t.update(),a=o.NONE},this.update=function(){var ce=new Q,nt=new co().setFromUnitVectors(n.up,new Q(0,1,0)),St=nt.clone().invert(),gt=new Q,Gt=new co,Mn=2*Math.PI;return function(){var Bs=t.object.position;ce.copy(Bs).sub(t.target),ce.applyQuaternion(nt),c.setFromVector3(ce),t.autoRotate&&a===o.NONE&&M(k()),t.enableDamping?(c.theta+=u.theta*t.dampingFactor,c.phi+=u.phi*t.dampingFactor):(c.theta+=u.theta,c.phi+=u.phi);var As=t.minAzimuthAngle,Ms=t.maxAzimuthAngle;return isFinite(As)&&isFinite(Ms)&&(As<-Math.PI?As+=Mn:As>Math.PI&&(As-=Mn),Ms<-Math.PI?Ms+=Mn:Ms>Math.PI&&(Ms-=Mn),As<=Ms?c.theta=Math.max(As,Math.min(Ms,c.theta)):c.theta=c.theta>(As+Ms)/2?Math.max(As,c.theta):Math.min(Ms,c.theta)),c.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=h,c.radius=Math.max(t.minDistance,Math.min(t.maxDistance,c.radius)),t.enableDamping===!0?t.target.addScaledVector(f,t.dampingFactor):t.target.add(f),ce.setFromSpherical(c),ce.applyQuaternion(St),Bs.copy(t.target).add(ce),t.object.lookAt(t.target),t.enableDamping===!0?(u.theta*=1-t.dampingFactor,u.phi*=1-t.dampingFactor,f.multiplyScalar(1-t.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),h=1,d||gt.distanceToSquared(t.object.position)>l||8*(1-Gt.dot(t.object.quaternion))>l?(t.dispatchEvent(r),gt.copy(t.object.position),Gt.copy(t.object.quaternion),d=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",ft),t.domElement.removeEventListener("pointerdown",Be),t.domElement.removeEventListener("wheel",Ge),t.domElement.removeEventListener("touchstart",Ze),t.domElement.removeEventListener("touchend",Ct),t.domElement.removeEventListener("touchmove",yt),t.domElement.ownerDocument.removeEventListener("pointermove",ut),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t._domElementKeyEvents!==null&&t._domElementKeyEvents.removeEventListener("keydown",ye)};var t=this,r={type:"change"},s={type:"start"},i={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=o.NONE,l=1e-6,c=new uL,u=new uL,h=1,f=new Q,d=!1,p=new st,m=new st,g=new st,y=new st,b=new st,x=new st,w=new st,S=new st,C=new st;function k(){return 2*Math.PI/60/60*t.autoRotateSpeed}function A(){return Math.pow(.95,t.zoomSpeed)}function M(ce){u.theta-=ce}function E(ce){u.phi-=ce}var N=function(){var ce=new Q;return function(St,gt){ce.setFromMatrixColumn(gt,0),ce.multiplyScalar(-St),f.add(ce)}}(),O=function(){var ce=new Q;return function(St,gt){t.screenSpacePanning===!0?ce.setFromMatrixColumn(gt,1):(ce.setFromMatrixColumn(gt,0),ce.crossVectors(t.object.up,ce)),ce.multiplyScalar(St),f.add(ce)}}(),R=function(){var ce=new Q;return function(St,gt){var Gt=t.domElement;if(t.object.isPerspectiveCamera){var Mn=t.object.position;ce.copy(Mn).sub(t.target);var Cr=ce.length();Cr*=Math.tan(t.object.fov/2*Math.PI/180),N(2*St*Cr/Gt.clientHeight,t.object.matrix),O(2*gt*Cr/Gt.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(N(St*(t.object.right-t.object.left)/t.object.zoom/Gt.clientWidth,t.object.matrix),O(gt*(t.object.top-t.object.bottom)/t.object.zoom/Gt.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function D(ce){t.object.isPerspectiveCamera?h/=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom*ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function z(ce){t.object.isPerspectiveCamera?h*=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function B(ce){p.set(ce.clientX,ce.clientY)}function X(ce){w.set(ce.clientX,ce.clientY)}function G(ce){y.set(ce.clientX,ce.clientY)}function te(ce){m.set(ce.clientX,ce.clientY),g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var nt=t.domElement;M(2*Math.PI*g.x/nt.clientHeight),E(2*Math.PI*g.y/nt.clientHeight),p.copy(m),t.update()}function ge(ce){S.set(ce.clientX,ce.clientY),C.subVectors(S,w),C.y>0?D(A()):C.y<0&&z(A()),w.copy(S),t.update()}function ae(ce){b.set(ce.clientX,ce.clientY),x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b),t.update()}function Ne(ce){ce.deltaY<0?z(A()):ce.deltaY>0&&D(A()),t.update()}function ke(ce){var nt=!1;switch(ce.keyCode){case t.keys.UP:R(0,t.keyPanSpeed),nt=!0;break;case t.keys.BOTTOM:R(0,-t.keyPanSpeed),nt=!0;break;case t.keys.LEFT:R(t.keyPanSpeed,0),nt=!0;break;case t.keys.RIGHT:R(-t.keyPanSpeed,0),nt=!0;break}nt&&(ce.preventDefault(),t.update())}function De(ce){if(ce.touches.length==1)p.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);p.set(nt,St)}}function be(ce){if(ce.touches.length==1)y.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);y.set(nt,St)}}function Xe(ce){var nt=ce.touches[0].pageX-ce.touches[1].pageX,St=ce.touches[0].pageY-ce.touches[1].pageY,gt=Math.sqrt(nt*nt+St*St);w.set(0,gt)}function Oe(ce){t.enableZoom&&Xe(ce),t.enablePan&&be(ce)}function it(ce){t.enableZoom&&Xe(ce),t.enableRotate&&De(ce)}function We(ce){if(ce.touches.length==1)m.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);m.set(nt,St)}g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var gt=t.domElement;M(2*Math.PI*g.x/gt.clientHeight),E(2*Math.PI*g.y/gt.clientHeight),p.copy(m)}function dt(ce){if(ce.touches.length==1)b.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);b.set(nt,St)}x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b)}function ct(ce){var nt=ce.touches[0].pageX-ce.touches[1].pageX,St=ce.touches[0].pageY-ce.touches[1].pageY,gt=Math.sqrt(nt*nt+St*St);S.set(0,gt),C.set(0,Math.pow(S.y/w.y,t.zoomSpeed)),D(C.y),w.copy(S)}function Ve(ce){t.enableZoom&&ct(ce),t.enablePan&&dt(ce)}function ze(ce){t.enableZoom&&ct(ce),t.enableRotate&&We(ce)}function Be(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":ee(ce);break}}function ut(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":J(ce);break}}function Ke(ce){switch(ce.pointerType){case"mouse":case"pen":rt();break}}function ee(ce){ce.preventDefault(),t.domElement.focus?t.domElement.focus():window.focus();var nt;switch(ce.button){case 0:nt=t.mouseButtons.LEFT;break;case 1:nt=t.mouseButtons.MIDDLE;break;case 2:nt=t.mouseButtons.RIGHT;break;default:nt=-1}switch(nt){case Cf.DOLLY:if(t.enableZoom===!1)return;X(ce),a=o.DOLLY;break;case Cf.ROTATE:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enablePan===!1)return;G(ce),a=o.PAN}else{if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}break;case Cf.PAN:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}else{if(t.enablePan===!1)return;G(ce),a=o.PAN}break;default:a=o.NONE}a!==o.NONE&&(t.domElement.ownerDocument.addEventListener("pointermove",ut),t.domElement.ownerDocument.addEventListener("pointerup",Ke),t.dispatchEvent(s))}function J(ce){if(t.enabled!==!1)switch(ce.preventDefault(),a){case o.ROTATE:if(t.enableRotate===!1)return;te(ce);break;case o.DOLLY:if(t.enableZoom===!1)return;ge(ce);break;case o.PAN:if(t.enablePan===!1)return;ae(ce);break}}function rt(ce){t.domElement.ownerDocument.removeEventListener("pointermove",ut),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function Ge(ce){t.enabled===!1||t.enableZoom===!1||a!==o.NONE&&a!==o.ROTATE||(ce.preventDefault(),ce.stopPropagation(),t.dispatchEvent(s),Ne(ce),t.dispatchEvent(i))}function ye(ce){t.enabled===!1||t.enablePan===!1||ke(ce)}function Ze(ce){if(t.enabled!==!1){switch(ce.preventDefault(),ce.touches.length){case 1:switch(t.touches.ONE){case kf.ROTATE:if(t.enableRotate===!1)return;De(ce),a=o.TOUCH_ROTATE;break;case kf.PAN:if(t.enablePan===!1)return;be(ce),a=o.TOUCH_PAN;break;default:a=o.NONE}break;case 2:switch(t.touches.TWO){case kf.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Oe(ce),a=o.TOUCH_DOLLY_PAN;break;case kf.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;it(ce),a=o.TOUCH_DOLLY_ROTATE;break;default:a=o.NONE}break;default:a=o.NONE}a!==o.NONE&&t.dispatchEvent(s)}}function yt(ce){if(t.enabled!==!1)switch(ce.preventDefault(),ce.stopPropagation(),a){case o.TOUCH_ROTATE:if(t.enableRotate===!1)return;We(ce),t.update();break;case o.TOUCH_PAN:if(t.enablePan===!1)return;dt(ce),t.update();break;case o.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ve(ce),t.update();break;case o.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ze(ce),t.update();break;default:a=o.NONE}}function Ct(ce){t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function ft(ce){t.enabled!==!1&&ce.preventDefault()}t.domElement.addEventListener("contextmenu",ft),t.domElement.addEventListener("pointerdown",Be),t.domElement.addEventListener("wheel",Ge),t.domElement.addEventListener("touchstart",Ze),t.domElement.addEventListener("touchend",Ct),t.domElement.addEventListener("touchmove",yt),this.update()};zS.prototype=Object.create(Gu.prototype);zS.prototype.constructor=zS;var fM=function(n,e){zS.call(this,n,e),this.screenSpacePanning=!1,this.mouseButtons.LEFT=Cf.PAN,this.mouseButtons.RIGHT=Cf.ROTATE,this.touches.ONE=kf.PAN,this.touches.TWO=kf.DOLLY_ROTATE};fM.prototype=Object.create(Gu.prototype);fM.prototype.constructor=fM;const mvt=Object.freeze(Object.defineProperty({__proto__:null,MapControls:fM,OrbitControls:zS},Symbol.toStringTag,{value:"Module"})),gvt=Gf(mvt);var KC={};(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(s,i,o,a,l,c,u){this.pointIndices=s,this.labelStrings=i,this.scaleFactors=o,this.useSceneOpacityFlags=a,this.defaultFontSize=l,this.fillColors=c,this.strokeColors=u}return r}();n.LabelRenderParams=e,function(r){r[r.Perspective=0]="Perspective",r[r.Orthographic=1]="Orthographic"}(n.CameraType||(n.CameraType={}));var t=function(){function r(s,i,o,a,l,c,u,h,f,d,p,m,g,y){this.camera=s,this.cameraType=i,this.cameraTarget=o,this.screenWidth=a,this.screenHeight=l,this.nearestCameraSpacePointZ=c,this.farthestCameraSpacePointZ=u,this.backgroundColor=h,this.pointColors=f,this.pointScaleFactors=d,this.labels=p,this.polylineColors=m,this.polylineOpacities=g,this.polylineWidths=y}return r}();n.RenderContext=t})(KC);var Yi={};Object.defineProperty(Yi,"__esModule",{value:!0});var pu=s0;function yvt(n,e,t,r){var s=window.devicePixelRatio,i=new pu.Vector3().copy(r).project(n),o=[(i.x+1)/2*e*s,-((i.y-1)/2*t)*s];return o}Yi.vector3DToScreenCoords=yvt;function bvt(n,e){var t=e*3;return new pu.Vector3(n[t],n[t+1],n[t+2])}Yi.vector3FromPackedArray=bvt;function vvt(n,e,t){for(var r=1/0,s=0,i=new pu.Vector3().copy(t).sub(e),o=new pu.Vector3().copy(i).normalize(),a=n.length/3,l=0,c=new pu.Vector3,u=new pu.Vector3,h=0;h<a;h++){c.x=n[l],c.y=n[l+1],c.z=n[l+2],l+=3,u.copy(c).sub(e);var f=o.dot(u);f<0||(s=f>s?f:s,r=f<r?f:r)}return[r,s]}Yi.getNearFarPoints=vvt;function ice(n,e){return e===void 0&&(e=!0),n.needsUpdate=e,n.minFilter=pu.LinearFilter,n.generateMipmaps=!1,n.flipY=!1,n}function wvt(n){var e=new pu.Texture(n);return ice(e)}Yi.createTextureFromCanvas=wvt;function xvt(n,e){var t=new pu.Texture(n);return n.complete?(t.needsUpdate=!0,e()):n.onload=function(){t.needsUpdate=!0,e()},ice(t,!1)}Yi.createTextureFromImage=xvt;function _vt(){try{var n=document.createElement("canvas"),e=n.getContext("webgl")||n.getContext("experimental-webgl");return e!=null}catch{return!1}}Yi.hasWebGLSupport=_vt;function Svt(n){for(var e=1/0,t=-1/0,r=0;r<n.length;r++){var s=n[r];s<e&&(e=s),s>t&&(t=s)}return[e,t]}Yi.extent=Svt;function Cvt(n,e,t){var r=e[1]-e[0],s=t[1]-t[0],i=(n-e[0])/r;return i*s+t[0]}Yi.scaleLinear=Cvt;function kvt(n,e,t){var r=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),s=t[1]-t[0],i=(Math.pow(n,Math.E)-e[0])/r;return i*s+t[0]}Yi.scaleExponential=kvt;function Tvt(n,e,t,r,s){n[e*3]=t,n[e*3+1]=r,n[e*3+2]=s}Yi.packRgbIntoUint8Array=Tvt;function Evt(n){var e=new pu.Color(n);return[e.r*255|0,e.g*255|0,e.b*255|0]}Yi.styleRgbFromHexColor=Evt;var Rq=function(n){return 100*n+"%"};function Ivt(n,e,t,r,s,i){var o=t+(r-t)*n/e,a="hsl("+o+", "+Rq(s)+", "+Rq(i)+")";return new pu.Color(a)}Yi.getDefaultPointInPolylineColor=Ivt;var OV={};Object.defineProperty(OV,"__esModule",{value:!0});var Avt=function(){function n(e,t,r){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",e.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=r.select.stroke,this.rectElement.style.strokeDasharray=r.select.strokeDashArray,this.rectElement.style.strokeWidth=""+r.select.strokeWidth,this.rectElement.style.fill=r.select.fill,this.rectElement.style.fillOpacity=""+r.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=t,this.isMouseDown=!1}return n.prototype.onMouseDown=function(e,t){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[e,t],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},n.prototype.onMouseMove=function(e,t){this.isMouseDown&&(this.lastBoundingBox.x=Math.min(e,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(t,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(e,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(t,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},n.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},n}();OV.ScatterPlotRectangleSelector=Avt;var dM=pt&&pt.__assign||function(){return dM=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++){e=arguments[t];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s])}return n},dM.apply(this,arguments)},HP=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Pq=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(iV,"__esModule",{value:!0});var _r=s0,Mvt=gvt,jP=KC,Nvt=Yi,$vt=OV,oce=2,Rvt=5*oce,Pvt=.025*oce,Dvt=70,Ovt=.01,Fvt=100,TE=1.2,Dq="Shift",Oq="Control",Lvt=new _r.Vector3(.45,.9,1.6),zvt=new _r.Vector3(0,0,0),Bvt=new _r.Vector3(0,0,4),Vvt=new _r.Vector3(0,0,0),Uvt={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},Wvt=function(){function n(e,t){var r=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new _r.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=e,this.styles=t.styles,this.setParameters(t),this.computeLayoutValues(),this.scene=new _r.Scene,this.renderer=new _r.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new _r.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=dM(dM({},Uvt),t.orbitControlParams),this.rectangleSelector=new $vt.ScatterPlotRectangleSelector(this.container,function(s){r.selectBoundingBox(s)},this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(t.camera),this.resize()}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled)},n.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},n.prototype.addCameraControlsEventListeners=function(e){var t=this;e.addEventListener("start",function(){t.stopOrbitAnimation(),t.onCameraMoveListeners.forEach(function(r){return r(t.camera.position,e.target)})}),e.addEventListener("change",function(){t.render()}),e.addEventListener("end",function(){})},n.prototype.makeOrbitControls=function(e,t){this.orbitCameraControls!=null&&this.orbitCameraControls.dispose();var r=new Mvt.OrbitControls(e,this.renderer.domElement);r.zoomSpeed=this.orbitControlParams.zoomSpeed,r.enableRotate=t,r.autoRotate=!1,r.enableKeys=!1,r.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,t?(r.mouseButtons.LEFT=_r.MOUSE.LEFT,r.mouseButtons.RIGHT=_r.MOUSE.RIGHT):(r.mouseButtons.LEFT=_r.MOUSE.RIGHT,r.mouseButtons.RIGHT=_r.MOUSE.LEFT),r.reset(),this.camera=e,this.orbitCameraControls=r,this.addCameraControlsEventListeners(this.orbitCameraControls)},n.prototype.makeCamera=function(e){e===void 0&&(e={});var t=this.makeDefaultCameraDef(this.dimensions,e);this.recreateCamera(t),this.dimensions===3&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},n.prototype.makeCamera3D=function(e,t,r){var s;{var i=t/r;s=new _r.PerspectiveCamera(Dvt,i,Ovt,Fvt),s.position.set(e.position[0],e.position[1],e.position[2]);var o=new _r.Vector3(e.target[0],e.target[1],e.target[2]);s.lookAt(o),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!0)},n.prototype.makeCamera2D=function(e,t,r){var s,i=new _r.Vector3(e.target[0],e.target[1],e.target[2]);{var o=t/r,a=-TE,l=TE,c=-TE,u=TE;o>1?(a*=o,l*=o):(u/=o,c/=o),s=new _r.OrthographicCamera(a,l,u,c,-1e3,1e3),s.position.set(e.position[0],e.position[1],e.position[2]),s.up=new _r.Vector3(0,0,1),s.lookAt(i),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!1)},n.prototype.makeDefaultCameraDef=function(e,t){t===void 0&&(t={});var r=e===2,s=r?Bvt:Lvt,i=r?Vvt:zvt,o={orthographic:r,zoom:1,position:[s.x,s.y,s.z],target:[i.x,i.y,i.z]};return t.zoom&&(o.zoom=t.zoom),t.position&&(o.position=t.position),t.target&&(o.target=t.target),o},n.prototype.recreateCamera=function(e){e.orthographic?this.makeCamera2D(e,this.width,this.height):this.makeCamera3D(e,this.width,this.height),this.orbitCameraControls.minDistance=Pvt,this.orbitCameraControls.maxDistance=Rvt,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},n.prototype.setInteractionMode=function(e){this.interactionMode=e,e==="SELECT"?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},n.prototype.onClick=function(e,t){if(t===void 0&&(t=!0),!(e&&this.selecting)){if(!this.isDragSequence&&t){if(this.selectEnabled){var r=this.nearestPoint!=null?[this.nearestPoint]:[];this.selectCallback(r)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},n.prototype.onMouseDown=function(e){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(e.offsetX,e.offsetY),this.setNearestPointToMouse(e)):!e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT):e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT)},n.prototype.onMouseUp=function(e){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},n.prototype.onMouseMove=function(e){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(e.offsetX,e.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(e),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},n.prototype.onKeyDown=function(e){e.key===Oq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT),e.key===Dq&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},n.prototype.onKeyUp=function(e){e.key===Oq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT),e.key===Dq&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},n.prototype.getPointIndicesFromBoundingBox=function(e){if(this.worldSpacePointPositions==null)return[];this.camera.updateMatrixWorld();var t=window.devicePixelRatio||1,r=Math.floor(e.x*t),s=Math.floor(e.y*t),i=Math.max(Math.floor(e.width*t),1),o=Math.max(Math.floor(e.height*t),1);if(i<=2&&o<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(e);for(var a=this.renderer.domElement,l=a.width,c=a.height,u=[],h=new _r.Vector3,f=0;f<this.worldSpacePointPositions.length;f++){var d=f*3,p=HP(this.worldSpacePointPositions.slice(d,d+3),3),m=p[0],g=p[1],y=p[2];h.x=m,h.y=g,h.z=y;var b=h.project(this.camera),x=(b.x+1)*l/2,w=-(b.y-1)*c/2;x>=r&&x<=r+i&&w<=s&&w>=s-o&&u.push(f)}return u},n.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(e){if(this.worldSpacePointPositions==null)return[];var t=this.worldSpacePointPositions.length/3,r=window.devicePixelRatio||1,s=Math.floor(e.x*r),i=Math.floor(e.y*r),o=Math.max(Math.floor(e.width*r),1),a=Math.max(Math.floor(e.height*r),1),l=new Uint8Array(o*a*4);this.renderer.readRenderTargetPixels(this.pickingTexture,s,this.pickingTexture.height-i,o,a,l);for(var c=new Uint8Array(this.worldSpacePointPositions.length),u=0;u<o*a;u++){var h=l[u*4]<<16|l[u*4+1]<<8|l[u*4+2];h!==16777215&&h<t&&(c[h]=1)}for(var f=[],u=0;u<c.length;u++)c[u]===1&&f.push(u);return f},n.prototype.selectBoundingBox=function(e){var t=this.getPointIndicesFromBoundingBox(e);this.selectCallback(t)},n.prototype.setNearestPointToMouse=function(e){if(this.pickingTexture==null){this.nearestPoint=null;return}var t={x:e.offsetX,y:e.offsetY,width:1,height:1},r=this.getPointIndicesFromBoundingBoxPickingTexture(t);this.nearestPoint=r.length?r[0]:null},n.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},n.prototype.sceneIs3D=function(){return this.dimensions===3},n.prototype.remove3dAxesFromScene=function(){var e=this.scene.getObjectByName("axes");return e!=null&&this.scene.remove(e),e},n.prototype.add3dAxes=function(){var e=new _r.AxesHelper;e.name="axes",this.scene.add(e)},n.prototype.setDimensions=function(e){if(e!==2&&e!==3)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==e&&(this.dimensions=e,this.makeCamera())},n.prototype.getCameraPosition=function(){var e=this.camera.position;return[e.x,e.y,e.z]},n.prototype.getCameraTarget=function(){var e=this.orbitCameraControls.target;return[e.x,e.y,e.z]},n.prototype.setCameraPositionAndTarget=function(e,t){this.stopOrbitAnimation(),this.camera.position.set(e[0],e[1],e[2]),this.orbitCameraControls.target.set(t[0],t[1],t[2]),this.orbitCameraControls.update(),this.render()},n.prototype.startOrbitAnimation=function(){this.sceneIs3D()&&(this.orbitAnimationId!=null&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},n.prototype.orbitIsAnimating=function(){return this.orbitAnimationId!=null},n.prototype.updateOrbitAnimation=function(){var e=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame(function(){return e.updateOrbitAnimation()})},n.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,this.orbitAnimationId!=null&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},n.prototype.setActiveVisualizers=function(e){var t,r,s,i,o=new Set(e.map(function(f){return f.id}));try{for(var a=Pq(this.visualizers.values()),l=a.next();!l.done;l=a.next()){var c=l.value;o.has(c.id)||(c.dispose(),this.visualizers.delete(c.id))}}catch(f){t={error:f}}finally{try{l&&!l.done&&(r=a.return)&&r.call(a)}finally{if(t)throw t.error}}try{for(var u=Pq(e),h=u.next();!h.done;h=u.next()){var c=h.value;this.visualizers.set(c.id,c),c.setScene(this.scene),c.onResize(this.width,this.height),this.worldSpacePointPositions&&c.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(f){s={error:f}}finally{try{h&&!h.done&&(i=u.return)&&i.call(u)}finally{if(s)throw s.error}}},n.prototype.disposeAllVisualizers=function(){this.visualizers.forEach(function(e){return e.dispose()}),this.visualizers.clear()},n.prototype.setPointPositions=function(e){this.worldSpacePointPositions=e,this.visualizers.forEach(function(t){return t.onPointPositionsChanged(e)})},n.prototype.render=function(){{var e=this.camera.position.clone();e.x+=1,e.y+=1,this.light.position.set(e.x,e.y,e.z)}var t=this.camera instanceof _r.PerspectiveCamera?jP.CameraType.Perspective:jP.CameraType.Orthographic,r=[0,0];this.worldSpacePointPositions!=null&&(r=Nvt.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var s=new jP.RenderContext(this.camera,t,this.orbitCameraControls.target,this.width,this.height,r[0],r[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach(function(o){return o.onPickingRender(s)});{var i=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),i!=null&&this.scene.add(i)}this.visualizers.forEach(function(o){return o.onRender(s)}),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},n.prototype.setPointColors=function(e){this.pointColors=e},n.prototype.setPointScaleFactors=function(e){this.pointScaleFactors=e},n.prototype.setLabels=function(e){this.labels=e},n.prototype.setPolylineColors=function(e){this.polylineColors=e},n.prototype.setPolylineOpacities=function(e){this.polylineOpacities=e},n.prototype.setPolylineWidths=function(e){this.polylineWidths=e},n.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},n.prototype.setDayNightMode=function(e){for(var t=this.container.querySelectorAll("canvas"),r=e?"invert(100%)":"",s=0;s<t.length;s++)t[s].style.filter=r},n.prototype.resize=function(e){e===void 0&&(e=!0);var t=HP([this.width,this.height],2),r=t[0],s=t[1],i=HP(this.computeLayoutValues(),2),o=i[0],a=i[1];if(this.dimensions===3){var l=this.camera;l.aspect=o/a,l.updateProjectionMatrix()}else{var l=this.camera,c=o/r,u=a/s,h=(l.right-l.left)*c/2,f=(l.top-l.bottom)*u/2;l.top=f,l.bottom=-f,l.left=-h,l.right=h,l.updateProjectionMatrix()}var d=window.devicePixelRatio||1;this.renderer.setPixelRatio(d),this.renderer.setSize(o,a);{var p=new _r.Vector2;this.renderer.getSize(p);var m=this.renderer.getPixelRatio();this.pickingTexture=new _r.WebGLRenderTarget(p.width*m,p.height*m),this.pickingTexture.texture.minFilter=_r.LinearFilter}this.visualizers.forEach(function(g){return g.onResize(o,a)}),e&&this.render()},n.prototype.onCameraMove=function(e){this.onCameraMoveListeners.push(e)},n.prototype.clickOnPoint=function(e){this.nearestPoint=e,this.onClick(null,!1)},n}();iV.ScatterPlot=Wvt;var FV={},Gvt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(FV,"__esModule",{value:!0});var Hvt=s0,qP=new Map,jvt=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;function qvt(n){var e=jvt.exec(n);if(e){var t=Gvt(e,6);t[0];var r=t[1],s=t[2],i=t[3],o=t[4],a=t[5],l=r.replace("a","")+"("+s+","+i+","+o+")";return{colorString:l,opacity:parseFloat(a)}}return{colorString:n,opacity:1}}function Xvt(n){if(qP.has(n))return qP.get(n);var e=qvt(n),t=e.colorString,r=e.opacity,s=new Hvt.Color(t),i=s.r,o=s.g,a=s.b,l={r:i,g:o,b:a,opacity:r};return qP.set(n,l),l}FV.parseColor=Xvt;var V$={},Kvt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(V$,"__esModule",{value:!0});var Fq="Points must be an array of either 2 or 3 dimensional number arrays",Yvt=function(){function n(e,t){var r,s;t===void 0&&(t=[]),this.points=e,this.metadata=t;var i=e[0].length;if(!(i===2||i===3))throw new Error(Fq);try{for(var o=Kvt(e),a=o.next();!a.done;a=o.next()){var l=a.value;if(i!==l.length)throw new Error(Fq)}}catch(c){r={error:c}}finally{try{a&&!a.done&&(s=o.return)&&s.call(o)}finally{if(r)throw r.error}}this.dimensions=i}return n.prototype.setSpriteMetadata=function(e){this.spriteMetadata=e},n}();V$.Dataset=Yvt;var LV={};Object.defineProperty(LV,"__esModule",{value:!0});var Zvt=function(){var n={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};return n};function Jvt(n){var e=Zvt();if(n===void 0)return e;for(var t in e){var r=t;typeof e[r]=="object"&&typeof n[r]=="object"?e[r]=Object.assign(e[r],n[r]):n[r]!==void 0&&(e[r]=n[r])}return e}LV.makeStyles=Jvt;var Hu={};Object.defineProperty(Hu,"__esModule",{value:!0});Hu.RGB_NUM_ELEMENTS=3;Hu.RGBA_NUM_ELEMENTS=4;Hu.XYZ_NUM_ELEMENTS=3;Hu.UV_NUM_ELEMENTS=2;Hu.INDEX_NUM_ELEMENTS=1;Hu.SCATTER_PLOT_CUBE_LENGTH=2;var zV={};Object.defineProperty(zV,"__esModule",{value:!0});var df=s0,Lq=Yi,ro=Hu,XP=8192,KP=256,ha=2*3,Qvt=function(n,e){return`
      attribute vec2 posObj;
      attribute vec4 color;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        vUv = uv;
        vColor = color;

        // Rotate label to face camera.

        vec4 vRight = vec4(
          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);

        vec4 vUp = vec4(
          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);

        vec4 vAt = -vec4(
          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);

        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));

        vec2 scaledPos = posObj * `+1/n+" * "+e+`;

        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);
        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);
        gl_Position = projectionMatrix * mvPosition;
      }`},ewt=`
      uniform sampler2D glyphTexture;
      uniform bool picking;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        if (picking) {
          gl_FragColor = vColor;
        } else {
          vec4 fromTexture = texture(glyphTexture, vUv);
          gl_FragColor = vColor * fromTexture;
        }
      }`,twt=function(){function n(e){this.styles=e,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return n.prototype.createGlyphTexture=function(){var e=this.styles.label3D,t=e.fontSize,r=e.backgroundColor,s=e.color,i=document.createElement("canvas");i.width=XP,i.height=t;var o=i.getContext("2d");o.font="bold "+t+"px roboto",o.textBaseline="top",o.fillStyle=r,o.rect(0,0,i.width,i.height),o.fill(),o.fillStyle=s;for(var a=o.measureText(" ").width,l=new Float32Array(KP),c=new Float32Array(KP),u=0,h=0;h<KP;h++){var f=" "+String.fromCharCode(h),d=o.measureText(f).width;l[h]=d-a,c[h]=u,o.fillText(f,u-a,0),u+=d}var p=Lq.createTextureFromCanvas(i);return{texture:p,lengths:l,offsets:c}},n.prototype.processLabelVerts=function(e){var t=0;this.labelVertexMap=[];for(var r=0;r<e;r++){for(var s=this.labelStrings[r],i=[],o=0;o<s.length;o++){for(var a=0;a<ha;a++)i.push(t*ha+a);t++}this.labelVertexMap.push(i)}this.totalVertexCount=t*ha},n.prototype.createColorBuffers=function(e){var t=this;this.pickingColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS);for(var r=function(o){var a=new df.Color(o);s.labelVertexMap[o].forEach(function(l){t.pickingColors[ro.RGB_NUM_ELEMENTS*l]=a.r,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+1]=a.g,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+2]=a.b,t.renderColors[ro.RGB_NUM_ELEMENTS*l]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+1]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+2]=1})},s=this,i=0;i<e;i++)r(i)},n.prototype.createLabels=function(){var e=this,t=this.styles.label3D,r=t.fontSize,s=t.scale;if(!(this.labelStrings==null||this.worldSpacePointPositions==null)){var i=this.worldSpacePointPositions.length/ro.XYZ_NUM_ELEMENTS;if(i===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new df.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:Qvt(r,s),fragmentShader:ewt}),this.processLabelVerts(i),this.createColorBuffers(i);var o=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS);this.positions=new df.BufferAttribute(o,ro.XYZ_NUM_ELEMENTS);var a=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*ro.UV_NUM_ELEMENTS),c=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),u=new df.BufferAttribute(a,2),h=new df.BufferAttribute(l,ro.UV_NUM_ELEMENTS),f=new df.BufferAttribute(c,ro.RGB_NUM_ELEMENTS);this.geometry=new df.BufferGeometry,this.geometry.setAttribute("posObj",u),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",h),this.geometry.setAttribute("color",f);for(var d=0,p=0;p<i;p++){for(var m=this.labelStrings[p],g=0,y=0;y<m.length;y++){var b=m.charCodeAt(y);g+=this.glyphTexture.lengths[b]}g/=-2;for(var y=0;y<m.length;y++){var b=m.charCodeAt(y),x=this.glyphTexture.lengths[b],w=r,S=(g+x)/w,C=g/w,k=r/w;u.setXY(d*ha+0,C,0),u.setXY(d*ha+1,S,0),u.setXY(d*ha+2,C,k),u.setXY(d*ha+3,C,k),u.setXY(d*ha+4,S,0),u.setXY(d*ha+5,S,k);var A=this.glyphTexture.offsets[b],M=this.glyphTexture.offsets[b]+x;A/=XP,M/=XP;var E=1,N=0;h.setXY(d*ha+0,A,E),h.setXY(d*ha+1,M,E),h.setXY(d*ha+2,A,N),h.setXY(d*ha+3,A,N),h.setXY(d*ha+4,M,E),h.setXY(d*ha+5,M,N),d++,g+=x}}for(var O=function(D){var z=Lq.vector3FromPackedArray(R.worldSpacePointPositions,D);R.labelVertexMap[D].forEach(function(B){e.positions.setXYZ(B,z.x,z.y,z.z)})},R=this,p=0;p<i;p++)O(p);this.labelsMesh=new df.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},n.prototype.colorLabels=function(e){if(!(this.labelStrings==null||this.geometry==null||e==null)){var t=this.geometry.getAttribute("color");t.array=this.renderColors;for(var r=e.length/ro.RGBA_NUM_ELEMENTS,s=0,i=0;i<r;++i){for(var o=new df.Color(e[s],e[s+1],e[s+2]),a=this.labelVertexMap[i].length,l=0;l<a;++l)t.setXYZ(this.labelVertexMap[i][l],o.r,o.g,o.b);s+=ro.RGBA_NUM_ELEMENTS}t.needsUpdate=!0}},n.prototype.setScene=function(e){this.scene=e},n.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),this.glyphTexture!=null&&this.glyphTexture.texture!=null&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},n.prototype.onPickingRender=function(e){if(this.geometry==null){this.createLabels();return}this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var t=this.geometry.getAttribute("color");t.array=this.pickingColors,t.needsUpdate=!0},n.prototype.onRender=function(e){if(this.geometry==null){this.createLabels();return}this.colorLabels(e.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var t=this.geometry.getAttribute("color");t.array=this.renderColors,t.needsUpdate=!0},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.dispose()},n.prototype.setLabelStrings=function(e){this.labelStrings=e,this.dispose()},n.prototype.onResize=function(e,t){},n}();zV.ScatterPlotVisualizer3DLabels=twt;var BV={};Object.defineProperty(BV,"__esModule",{value:!0});var Oo=s0,nwt=KC,zq=Yi,nc=Hu,Bq=function(n){return`
    // Index of the specific vertex (passed in as bufferAttribute), and the
    // variable that will be used to pass it to the fragment shader.
    attribute float spriteIndex;
    attribute vec4 color;
    attribute float scaleFactor;

    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform bool sizeAttenuation;
    uniform float pointSize;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;

    varying float fogDepth;

    void main() {
      // Pass index and color values to fragment shader.
      vColor = color;
      xyIndex = vec2(mod(spriteIndex, spritesPerRow),
                floor(spriteIndex / spritesPerColumn));

      // Transform current vertex by modelViewMatrix (model world position and
      // camera world position matrix).
      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);

      // Project vertex in camera-space to screen coordinates using the camera's
      // projection matrix.
      gl_Position = projectionMatrix * cameraSpacePos;

      // Create size attenuation (if we're in 3D mode) by making the size of
      // each point inversly proportional to its distance to the camera.
      float outputPointSize = pointSize;
      if (sizeAttenuation) {
        outputPointSize = -pointSize / cameraSpacePos.z;
        fogDepth = pointSize / outputPointSize * 1.2;
      } else {  // Create size attenuation (if we're in 2D mode)
        const float PI = 3.1415926535897932384626433832795;
        const float minScale = 0.1;  // minimum scaling factor
        const float outSpeed = 2.0;  // shrink speed when zooming out
        const float outNorm = (1. - minScale) / atan(outSpeed);
        const float maxScale = 15.0;  // maximum scaling factor
        const float inSpeed = 0.02;  // enlarge speed when zooming in
        const float zoomOffset = 0.3;  // offset zoom pivot
        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot
        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :
                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));
        outputPointSize = pointSize * scale;
      }

      gl_PointSize =
        max(outputPointSize * scaleFactor, `+n.toFixed(1)+`);
    }`},ace=`
    bool point_in_unit_circle(vec2 spriteCoord) {
      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);
      return dot(centerToP, centerToP) < (0.5 * 0.5);
    }

    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {
      vec3 v0 = vec3(0, 1, 0);
      vec3 v1 = vec3(0.5, 0, 0);
      vec3 v2 = vec3(1, 1, 0);
      vec3 p = vec3(spriteCoord, 0);
      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;
      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;
      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);
    }

    bool point_in_unit_square(vec2 spriteCoord) {
      return true;
    }
  `,rwt=`
    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform sampler2D spriteTexture;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;
    uniform bool isImage;

    `+Oo.ShaderChunk.common+`
    `+ace+`
    uniform vec3 fogColor;
    varying float fogDepth;
		uniform float fogNear;
    uniform float fogFar;

    void main() {
      if (isImage) {
        // Coordinates of the vertex within the entire sprite image.
        vec2 coords =
          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);
        gl_FragColor = vColor * texture(spriteTexture, coords);
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    }`,swt=`
    varying vec2 xyIndex;
    varying vec4 vColor;
    uniform bool isImage;

    `+ace+`

    varying float fogDepth;

    void main() {
      xyIndex; // Silence 'unused variable' warning.
      fogDepth; // Silence 'unused variable' warning.
      if (isImage) {
        gl_FragColor = vColor;
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
    }`,iwt=function(){function n(e,t){this.styles=e,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=zq.createTextureFromCanvas(document.createElement("canvas")),t&&(this.spriteSheetParams=t,this.setSpriteSheet(t),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return n.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},n.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var e=this.createUniforms();return new Oo.ShaderMaterial({uniforms:e,vertexShader:Bq(this.styles.sprites.minPointSize),fragmentShader:rwt,transparent:!0,depthFunc:Oo.LessDepth,fog:this.styles.fog.enabled,blending:Oo.NormalBlending})},n.prototype.createPickingMaterial=function(){var e=this.createUniforms();return new Oo.ShaderMaterial({uniforms:e,vertexShader:Bq(this.styles.sprites.minPointSize),fragmentShader:swt,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:Oo.NormalBlending})},n.prototype.createPointSprites=function(e,t){var r=t!=null?t.length/nc.XYZ_NUM_ELEMENTS:0,s=this.createGeometry(r);this.fog=new Oo.Fog(16777215),this.points=new Oo.Points(s,this.renderMaterial),this.points.frustumCulled=!1,this.spriteIndexBufferAttribute!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),e.add(this.points)},n.prototype.calculatePointSize=function(e){var t=this.styles.sprites.imageSize;if(this.texture)return e?t:this.spriteDimensions[0];var r=this.worldSpacePointPositions!=null?this.worldSpacePointPositions.length/nc.XYZ_NUM_ELEMENTS:1,s=200,i=8,o=1.5,a=s/Math.log(r)/Math.log(i);return e?a:a/o},n.prototype.createGeometry=function(e){var t=e;this.pickingColors=new Float32Array(t*nc.RGBA_NUM_ELEMENTS);for(var r=0,s=0;s<t;s++){var i=new Oo.Color(s);this.pickingColors[r++]=i.r,this.pickingColors[r++]=i.g,this.pickingColors[r++]=i.b,this.pickingColors[r++]=1}var o=new Oo.BufferGeometry;return o.setAttribute("position",new Oo.BufferAttribute(new Float32Array([]),nc.XYZ_NUM_ELEMENTS)),o.setAttribute("color",new Oo.BufferAttribute(new Float32Array([]),nc.RGBA_NUM_ELEMENTS)),o.setAttribute("scaleFactor",new Oo.BufferAttribute(new Float32Array([]),nc.INDEX_NUM_ELEMENTS)),o.computeVertexNormals(),o},n.prototype.setFogDistances=function(e,t,r){var s=this.styles.fog,i=s.threshold,o=s.enabled;if(e&&o){this.fog.near=t;var a=t-r;this.fog.far=t-i*a}else this.fog.near=1/0,this.fog.far=1/0},n.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},n.prototype.disposeGeometry=function(){this.points!=null&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},n.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSpriteSheet=function(e){var t=this,r=e.spriteDimensions,s=e.onImageLoad,i=e.spritesheetImage;if(typeof i=="string"){var o=i;i=new Image,i.src=o}this.spriteSheetImage=i,this.texture=zq.createTextureFromImage(this.spriteSheetImage,function(){t.spritesPerRow=t.spriteSheetImage.width/r[0],t.spritesPerColumn=t.spriteSheetImage.height/r[1],s()}),this.spriteDimensions=r,this.setSpriteIndexBuffer()},n.prototype.setSpriteIndexBuffer=function(){var e=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new Oo.BufferAttribute(e,nc.INDEX_NUM_ELEMENTS),this.points!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},n.prototype.onPointPositionsChanged=function(e){this.points!=null&&this.worldSpacePointPositions.length!==e.length&&this.disposeGeometry(),this.worldSpacePointPositions=e,this.points==null&&this.createPointSprites(this.scene,e),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var t=this.points.geometry.getAttribute("position");t.array=e,t.count=e.length/nc.XYZ_NUM_ELEMENTS,t.needsUpdate=!0},n.prototype.onPickingRender=function(e){var t=e.cameraType===nwt.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=t,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.pickingMaterial;var r=this.points.geometry.getAttribute("color");r.array=this.pickingColors,r.count=this.pickingColors.length/nc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length,s.count=e.pointScaleFactors.length/nc.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onRender=function(e){var t=e.camera instanceof Oo.PerspectiveCamera;this.setFogDistances(t,e.nearestCameraSpacePointZ,e.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new Oo.Color(e.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=this.texture!=null,this.renderMaterial.uniforms.spriteTexture.value=this.texture!=null?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=t,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.renderMaterial;var r=this.points.geometry.getAttribute("color");this.renderColors=e.pointColors,r.array=this.renderColors,r.count=this.renderColors.length/nc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length/nc.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onResize=function(e,t){},n}();BV.ScatterPlotVisualizerSprites=iwt;var VV={},UV={};Object.defineProperty(UV,"__esModule",{value:!0});var owt=function(){function n(e,t,r){this.bound=e,this.cellWidth=t,this.cellHeight=r,this.numHorizCells=Math.ceil(this.boundWidth(e)/t),this.numVertCells=Math.ceil(this.boundHeight(e)/r),this.grid=new Array(this.numHorizCells*this.numVertCells)}return n.prototype.boundWidth=function(e){return e.hiX-e.loX},n.prototype.boundHeight=function(e){return e.hiY-e.loY},n.prototype.boundsIntersect=function(e,t){return!(e.loX>t.hiX||e.loY>t.hiY||e.hiX<t.loX||e.hiY<t.loY)},n.prototype.insert=function(e,t){if(t===void 0&&(t=!1),e.hiX<this.bound.loX||e.loX>this.bound.hiX||e.hiY<this.bound.loY||e.loY>this.bound.hiY)return!1;for(var r=this.getCellX(e.loX),s=this.getCellX(e.hiX),i=this.getCellY(e.loY),o=this.getCellY(e.hiY),a=i*this.numHorizCells+r,l=a,c=i;c<=o;c++){for(var u=r;u<=s;u++){var h=this.grid[l++];if(h){for(var f=0;f<h.length;f++)if(this.boundsIntersect(e,h[f]))return!1}}l+=this.numHorizCells-(s-r+1)}if(t)return!0;l=a;for(var c=i;c<=o;c++){for(var u=r;u<=s;u++)this.grid[l]?this.grid[l].push(e):this.grid[l]=[e],l++;l+=this.numHorizCells-(s-r+1)}return!0},n.prototype.getCellX=function(e){return Math.floor((e-this.bound.loX)/this.cellWidth)},n.prototype.getCellY=function(e){return Math.floor((e-this.bound.loY)/this.cellHeight)},n}();UV.CollisionGrid=owt;var awt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(VV,"__esModule",{value:!0});var lwt=s0,cwt=KC,uwt=UV,YP=Yi,hwt=1e4,fwt=function(){function n(e,t){this.styles=t,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return n.prototype.removeAllLabels=function(){var e=this.canvas.width*window.devicePixelRatio,t=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,e,t)},n.prototype.makeLabels=function(e){if(!(e.labels==null||e.labels.pointIndices.length===0)&&this.worldSpacePointPositions!=null){var t=e.labels,r=e.cameraType===cwt.CameraType.Perspective,s=parseInt(this.gc.font,10),i=window.devicePixelRatio,o;{var a=this.canvas.width*i,l=this.canvas.height*i,c={loX:0,hiX:a,loY:0,hiY:l};o=new uwt.CollisionGrid(c,a/25,l/50)}var u=[e.farthestCameraSpacePointZ,e.nearestCameraSpacePointZ],h=function(O){return YP.scaleExponential(O,u,[.1,1])},f=e.camera.position,d=f.clone().sub(e.cameraTarget),p=new lwt.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var m=2,g=4,y=Math.min(hwt,t.pointIndices.length),b=0;b<y;++b){var x=void 0;{var w=t.pointIndices[b];x=YP.vector3FromPackedArray(this.worldSpacePointPositions,w)}if(p.copy(f).sub(x),!(d.dot(p)<0)){var S=awt(YP.vector3DToScreenCoords(e.camera,e.screenWidth,e.screenHeight,x),2),C=S[0],k=S[1];C+=g;var A={loX:C-m,hiX:C+1+m,loY:k-s/2-m,hiY:k+s/2+m};if(o.insert(A,!0)){var M=t.labelStrings[b],E=t.defaultFontSize*t.scaleFactors[b]*i;if(this.gc.font=E+"px roboto",A.hiX+=this.gc.measureText(M).width-1,o.insert(A)){var N=1;r&&t.useSceneOpacityFlags[b]===1&&(N=h(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(t.fillColors,b,N),this.gc.strokeStyle=this.styleStringFromPackedRgba(t.strokeColors,b,N),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(M,C,k),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(M,C,k)}}}}}},n.prototype.styleStringFromPackedRgba=function(e,t,r){var s=t*3,i=e[s],o=e[s+1],a=e[s+2];return"rgba("+i+","+o+","+a+","+r+")"},n.prototype.onResize=function(e,t){var r=window.devicePixelRatio;this.canvas.width=e*r,this.canvas.height=t*r,this.canvas.style.width=e+"px",this.canvas.style.height=t+"px"},n.prototype.dispose=function(){this.removeAllLabels()},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.removeAllLabels()},n.prototype.onRender=function(e){this.labelsActive&&(this.removeAllLabels(),this.makeLabels(e))},n.prototype.setScene=function(e){},n.prototype.onPickingRender=function(e){},n}();VV.ScatterPlotVisualizerCanvasLabels=fwt;var WV={},Vq=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(WV,"__esModule",{value:!0});var m1=s0,Uq=Yi,EE=Hu,dwt=function(){function n(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return n.prototype.getPointSequenceIndex=function(e){return this.pointSequenceIndices.get(e)},n.prototype.updateSequenceIndices=function(){for(var e=0;e<this.sequences.length;e++)for(var t=this.sequences[e],r=0;r<t.indices.length-1;r++){var s=t.indices[r];this.pointSequenceIndices.set(s,e),this.pointSequenceIndices.set(s+1,e)}},n.prototype.createPolylines=function(){var e,t;this.updateSequenceIndices();try{for(var r=Vq(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(c){e={error:c}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[];for(var o=0;o<this.sequences.length;o++){var a=new m1.BufferGeometry;a.addAttribute("position",this.polylinePositionBuffer[o]),a.addAttribute("color",this.polylineColorBuffer[o]);var l=new m1.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0}),i=new m1.LineSegments(a,l);i.frustumCulled=!1,this.polylines.push(i),this.scene.add(i)}},n.prototype.dispose=function(){var e,t;try{for(var r=Vq(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(o){e={error:o}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSequences=function(e){this.sequences=e},n.prototype.onPointPositionsChanged=function(e){if(e==null&&this.dispose(),!(e==null||this.sequences.length===0)){for(var t=0;t<this.sequences.length;t++){var r=this.sequences[t],s=2*(r.indices.length-1),i=new Float32Array(s*EE.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[t]=new m1.BufferAttribute(i,EE.XYZ_NUM_ELEMENTS);var o=new Float32Array(s*EE.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[t]=new m1.BufferAttribute(o,EE.RGBA_NUM_ELEMENTS)}for(var t=0;t<this.sequences.length;t++){for(var r=this.sequences[t],a=0,l=0;l<r.indices.length-1;l++){var c=r.indices[l],u=r.indices[l+1],h=Uq.vector3FromPackedArray(e,c),f=Uq.vector3FromPackedArray(e,u);this.polylinePositionBuffer[t].setXYZ(a,h.x,h.y,h.z),this.polylinePositionBuffer[t].setXYZ(a+1,f.x,f.y,f.z),a+=2}this.polylinePositionBuffer[t].needsUpdate=!0}this.createPolylines()}},n.prototype.onRender=function(e){for(var t=0;t<this.polylines.length;t++){var r=this.polylines[t].material;r.opacity=e.polylineOpacities[t],r.linewidth=e.polylineWidths[t],this.polylineColorBuffer[t].array=e.polylineColors[t],this.polylineColorBuffer[t].needsUpdate=!0}},n.prototype.onPickingRender=function(e){},n.prototype.onResize=function(e,t){},n}();WV.ScatterPlotVisualizerPolylines=dwt;var pwt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},ZP=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(pwt(arguments[e]));return n},Wq=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(sV,"__esModule",{value:!0});var mwt=iV,Sm=FV,gwt=V$,ywt=KC,bwt=LV,Do=Yi,IE=Hu,vwt=zV,Gq=BV,wwt=VV,xwt=WV,_wt=function(){function n(e,t){var r=this;t===void 0&&(t={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(s){r.hoverCallback(s),r.hoverPointIndex=s,r.updateScatterPlotAttributes(),r.renderScatterPlot()},this.onClick=function(s){r.clickCallback(s)},this.select=function(s){r.selectEnabled&&(r.selectedPointIndices=new Set(s),r.updateScatterPlotAttributes(),r.renderScatterPlot())},this.onSelect=function(s){r.selectEnabled&&(r.selectCallback(s),r.select(s))},this.containerElement=e,this.styles=bwt.makeStyles(t.styles),this.setParameters(t),this.scatterPlot=new mwt.ScatterPlot(e,{camera:t.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:t.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.onCameraMove!==void 0&&(this.cameraMoveCallback=e.onCameraMove),e.pointColorer!==void 0&&(this.pointColorer=e.pointColorer),e.renderMode!==void 0&&(this.renderMode=e.renderMode),e.rotateOnStart!==void 0&&(this.rotateOnStart=e.rotateOnStart),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled),e.showLabelsOnHover!==void 0&&(this.showLabelsOnHover=e.showLabelsOnHover)},n.prototype.render=function(e){this.updateDataset(e),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},n.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},n.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},n.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},n.prototype.setRenderMode=function(e){this.renderMode=e,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},n.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},n.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},n.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},n.prototype.setSequences=function(e){this.sequences=e,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},n.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},n.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},n.prototype.setDimensions=function(e){var t=e<2||e>3,r=this.dataset&&e>this.dataset.dimensions;if(t||r)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(e),this.renderScatterPlot()},n.prototype.setPointColorer=function(e){this.pointColorer=e,this.updateScatterPlotAttributes(),this.renderScatterPlot()},n.prototype.callPointColorer=function(e,t){return e(t,this.selectedPointIndices,this.hoverPointIndex)},n.prototype.setHoverPointIndex=function(e){this.hoverPointIndex=e,this.updateScatterPlotAttributes(),!this.scatterPlot.orbitIsAnimating()&&this.renderScatterPlot()},n.prototype.resize=function(){this.scatterPlot.resize()},n.prototype.updateDataset=function(e){this.setDataset(e),this.scatterPlot.setDimensions(e.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},n.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},n.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},n.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},n.prototype.setDataset=function(e){this.dataset=e,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},n.prototype.updateScatterPlotPositions=function(){var e=this.dataset;if(e){var t=this.generatePointPositionArray(e);this.scatterPlot.setPointPositions(t)}},n.prototype.updateScatterPlotAttributes=function(){var e=this.dataset;if(e){var t=this.generatePointColorArray(e),r=this.generatePointScaleFactorArray(e),s=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(t),this.scatterPlot.setPointScaleFactors(r),this.scatterPlot.setLabels(s)}},n.prototype.updatePolylineAttributes=function(){var e=this.dataset;if(e){var t=this.generateLineSegmentColorMap(e),r=this.generateLineSegmentOpacityArray(e),s=this.generateLineSegmentWidthArray(e);this.scatterPlot.setPolylineColors(t),this.scatterPlot.setPolylineOpacities(r),this.scatterPlot.setPolylineWidths(s)}},n.prototype.generatePointPositionArray=function(e){var t=[0,0],r=[0,0],s=[0,0];t=Do.extent(e.points.map(function(y){return y[0]})),r=Do.extent(e.points.map(function(y){return y[1]})),e.dimensions===3&&(s=Do.extent(e.points.map(function(y){return y[2]})));var i=function(y){return Math.abs(y[1]-y[0])},o=i(t),a=i(r),l=i(s),c=Math.max(o,a,l),u=IE.SCATTER_PLOT_CUBE_LENGTH/2,h=function(y,b){return[-b*(y/c),b*(y/c)]},f=h(o,u),d=h(a,u),p=h(l,u),m=new Float32Array(e.points.length*3),g=0;return e.points.forEach(function(y,b){var x=e.points[b];m[g++]=Do.scaleLinear(x[0],t,f),m[g++]=Do.scaleLinear(x[1],r,d),e.dimensions===3?m[g++]=Do.scaleLinear(x[2],s,p):m[g++]=0}),m},n.prototype.generateVisibleLabelRenderParams=function(){var e=this,t=e.hoverPointIndex,r=e.selectedPointIndices,s=e.styles,i=t!==null?1:0,o=new Uint32Array(i),a=new Float32Array(i),l=new Int8Array(i),c=new Uint8Array(i*3),u=new Uint8Array(i*3),h=[];a.fill(s.label.scaleDefault),l.fill(1);var f=0;if(t!==null){h.push(this.getLabelText(t)),o[f]=t,a[f]=s.label.scaleLarge,l[f]=0;var d=Do.styleRgbFromHexColor(s.label.fillColorHover);Do.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]);var p=Do.styleRgbFromHexColor(s.label.strokeColorHover);Do.packRgbIntoUint8Array(u,f,p[0],p[1],p[1]),++f}{var d=Do.styleRgbFromHexColor(s.label.fillColorSelected),p=Do.styleRgbFromHexColor(s.label.strokeColorSelected);if(r.size===1){var m=ZP(r)[0];h.push(this.getLabelText(m)),o[f]=m,a[f]=s.label.scaleLarge,l[f]=0,Do.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]),Do.packRgbIntoUint8Array(u,f,p[0],p[1],p[2])}}return new ywt.LabelRenderParams(new Float32Array(o),h,a,l,s.label.fontSize,c,u)},n.prototype.generatePointScaleFactorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.selectedPointIndices,a=s.styles,l=a.point,c=l.scaleDefault,u=l.scaleSelected,h=l.scaleHover,f=new Float32Array(e.points.length);f.fill(c),o.size;try{for(var d=Wq(o.values()),p=d.next();!p.done;p=d.next()){var m=p.value;f[m]=u}}catch(g){t={error:g}}finally{try{p&&!p.done&&(r=d.return)&&r.call(d)}finally{if(t)throw t.error}}return i!=null&&(f[i]=h),f},n.prototype.generatePointColorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.pointColorer,a=s.selectedPointIndices,l=s.styles,c=l.point,u=c.colorHover,h=c.colorNoSelection,f=c.colorSelected,d=c.colorUnselected,p=new Float32Array(e.points.length*IE.RGBA_NUM_ELEMENTS),m=d,g=h;this.renderMode==="TEXT"&&(m=this.styles.label3D.colorUnselected,g=this.styles.label3D.colorNoSelection),this.renderMode==="SPRITE"&&(m=this.styles.sprites.colorUnselected,g=this.styles.sprites.colorNoSelection);var y=e.points.length,b=this.selectedPointIndices.size;if(o)for(var x=0,w=0;w<y;++w){var S=Sm.parseColor(this.callPointColorer(o,w)||g);p[x++]=S.r,p[x++]=S.g,p[x++]=S.b,p[x++]=S.opacity}else{for(var x=0,S=b>0?Sm.parseColor(m):Sm.parseColor(g),w=0;w<y;++w)p[x++]=S.r,p[x++]=S.g,p[x++]=S.b,p[x++]=S.opacity;S=Sm.parseColor(f);try{for(var C=Wq(a.values()),k=C.next();!k.done;k=C.next()){var A=k.value,M=A*IE.RGBA_NUM_ELEMENTS;p[M++]=S.r,p[M++]=S.g,p[M++]=S.b,p[M++]=S.opacity}}catch(D){t={error:D}}finally{try{k&&!k.done&&(r=C.return)&&r.call(C)}finally{if(t)throw t.error}}if(i!=null){var E=Sm.parseColor(u),N=i*IE.RGBA_NUM_ELEMENTS;p[N++]=E.r,p[N++]=E.g,p[N++]=E.b,p[N++]=E.opacity}}return p},n.prototype.generate3DLabelsArray=function(){var e=this.dataset;if(!e)return[];for(var t=[],r=e.points.length,s=0;s<r;++s)t.push(this.getLabelText(s));return t},n.prototype.generateLineSegmentColorMap=function(e){for(var t=this,r=t.pointColorer,s=t.styles,i={},o=0;o<this.sequences.length;o++){var a=this.sequences[o],l=new Float32Array(2*(a.indices.length-1)*3),c=0;if(r)for(var u=0;u<a.indices.length-1;u++){var h=Sm.parseColor(this.callPointColorer(r,a.indices[u])),f=Sm.parseColor(this.callPointColorer(r,a.indices[u+1]));l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}else for(var u=0;u<a.indices.length-1;u++){var h=Do.getDefaultPointInPolylineColor(u,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness),f=Do.getDefaultPointInPolylineColor(u+1,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness);l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}i[o]=l}return i},n.prototype.generateLineSegmentOpacityArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length),o=r.size;if(o>0){i.fill(s.polyline.deselectedOpacity);var a=this.polylineVisualizer.getPointSequenceIndex(ZP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedOpacity)}else i.fill(s.polyline.defaultOpacity);return i},n.prototype.generateLineSegmentWidthArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length);i.fill(s.polyline.defaultLineWidth);var o=r.size;if(o>0){var a=this.polylineVisualizer.getPointSequenceIndex(ZP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedLineWidth)}return i},n.prototype.getLabelText=function(e){var t=this.dataset;if(!t)return"";var r=t.metadata[e];return r&&r.label!=null?""+r.label:""},n.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new wwt.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},n.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new vwt.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},n.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new Gq.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},n.prototype.initializeSpritesheetVisualizer=function(){var e=this,t=this.styles,r=this.dataset,s=r.spriteMetadata;if(!this.spritesheetVisualizer&&s){if(!s.spriteImage||!s.singleSpriteSize)return;var i=r.points.length,o=void 0;if(s.spriteIndices)o=new Float32Array(s.spriteIndices);else{o=new Float32Array(i);for(var a=0;a<i;++a)o[a]=a}var l=function(){return e.renderScatterPlot()},c=new Gq.ScatterPlotVisualizerSprites(t,{spritesheetImage:s.spriteImage,spriteDimensions:s.singleSpriteSize,spriteIndices:o,onImageLoad:l});c.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=c}return this.spritesheetVisualizer},n.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new xwt.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},n.prototype.setVisualizers=function(){var e=this,t=e.dataset,r=e.renderMode,s=[];if(r==="TEXT"){var i=this.initialize3DLabelsVisualizer();s.push(i)}else if(r==="POINT"){var i=this.initializePointVisualizer();s.push(i)}else if(r==="SPRITE"&&t.spriteMetadata){var i=this.initializeSpritesheetVisualizer();i&&s.push(i)}if(this.sequences.length>0){var i=this.initializePolylineVisualizer();s.push(i)}var o=r==="POINT"||r==="SPRITE";if(o&&this.showLabelsOnHover){var i=this.initializeCanvasLabelsVisualizer();s.push(i)}this.scatterPlot.setActiveVisualizers(s)},n.Dataset=gwt.Dataset,n}();sV.ScatterGL=_wt;Object.defineProperty(rV,"__esModule",{value:!0});var Swt=sV;rV.ScatterGL=Swt.ScatterGL;var Cwt=V$;rV.Dataset=Cwt.Dataset;var lce={},ed={},Bh={},di={},kwt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}};Object.defineProperty(di,"__esModule",{value:!0});function cce(n,e){return Math.floor(e()*n)}di.tauRandInt=cce;function Twt(n){return n()}di.tauRand=Twt;function Ewt(n){var e,t,r=0;try{for(var s=kwt(n),i=s.next();!i.done;i=s.next()){var o=i.value;r+=Math.pow(o,2)}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return Math.sqrt(r)}di.norm=Ewt;function U$(n){for(var e=[],t=0;t<n;t++)e.push(void 0);return e}di.empty=U$;function Iwt(n){return U$(n).map(function(e,t){return t})}di.range=Iwt;function GV(n,e){return U$(n).map(function(){return e})}di.filled=GV;function uce(n){return GV(n,0)}di.zeros=uce;function Awt(n){return GV(n,1)}di.ones=Awt;function Mwt(n,e,t){return U$(t).map(function(r,s){return n+s*((e-n)/(t-1))})}di.linear=Mwt;function hce(n){return n.reduce(function(e,t){return e+t})}di.sum=hce;function Nwt(n){return hce(n)/n.length}di.mean=Nwt;function $wt(n){for(var e=0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return e}di.max=$wt;function Rwt(n){for(var e=0,t=0;t<n.length;t++)for(var r=0;r<n[t].length;r++)e=n[t][r]>e?n[t][r]:e;return e}di.max2d=Rwt;function Pwt(n,e,t){for(var r=uce(n),s=0;s<n;s++)for(var i=!0;i;){for(var o=cce(e,t),a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1),r[s]=o}return r}di.rejectionSample=Pwt;function Dwt(n,e,t){var r=[],s=0;if(n.length!==e*t)throw new Error("Array dimensions must match input length.");for(var i=0;i<e;i++){for(var o=[],a=0;a<t;a++)o.push(n[s]),s+=1;r.push(o)}return r}di.reshape2d=Dwt;var Owt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(Bh,"__esModule",{value:!0});var BS=Owt(di);function fce(n,e){var t=function(s){return BS.empty(n).map(function(){return BS.filled(e,s)})},r=[];return r.push(t(-1)),r.push(t(1/0)),r.push(t(0)),r}Bh.makeHeap=fce;function Fwt(n,e,t){for(var r=BS.zeros(n),s=0;s<n;s++){for(var i=!0,o=0;i;){o=BS.tauRandInt(e,t);for(var a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1)}r[s]=o}return r}Bh.rejectionSample=Fwt;function hL(n,e,t,r,s){e=Math.floor(e);var i=n[0][e],o=n[1][e];if(n[2][e],t>=o[0])return 0;for(var a=0;a<i.length;a++)if(r===i[a])return 0;return dce(n,e,t,r,s)}Bh.heapPush=hL;function dce(n,e,t,r,s){var i=n[0][e],o=n[1][e],a=n[2][e];if(t>=o[0])return 0;o[0]=t,i[0]=r,a[0]=s;for(var l=0,c=0;;){var u=2*l+1,h=u+1,f=n[0][0].length;if(u>=f)break;if(h>=f)if(o[u]>t)c=u;else break;else if(o[u]>=o[h])if(t<o[u])c=u;else break;else if(t<o[h])c=h;else break;o[l]=o[c],i[l]=i[c],a[l]=a[c],l=c}return o[l]=t,i[l]=r,a[l]=s,1}Bh.uncheckedHeapPush=dce;function Lwt(n,e,t,r,s){for(var i=fce(e,r),o=0;o<e;o++)for(var a=0;a<t;a++)if(!(n[0][o][a]<0)){var l=n[0][o][a],c=n[2][o][a],u=BS.tauRand(s);hL(i,o,u,l,c),hL(i,l,u,o,c),n[2][o][a]=0}return i}Bh.buildCandidates=Lwt;function zwt(n){for(var e=n[0],t=n[1],r=0;r<e.length;r++)for(var s=e[r],i=t[r],o=0;o<s.length-1;o++){var a=s.length-o-1,l=i.length-o-1,c=s[0];s[0]=s[a],s[a]=c;var u=i[0];i[0]=i[l],i[l]=u,Bwt(i,s,l,0)}return{indices:e,weights:t}}Bh.deheapSort=zwt;function Bwt(n,e,t,r){for(;r*2+1<t;){var s=r*2+1,i=s+1,o=r;if(n[o]<n[s]&&(o=s),i<t&&n[o]<n[i]&&(o=i),o===r)break;var a=n[r];n[r]=n[o],n[o]=a;var l=e[r];e[r]=e[o],e[o]=l,r=o}}function Vwt(n,e){for(var t=n[0][e],r=n[1][e],s=n[2][e],i=1/0,o=-1,a=0;a>t.length;a++)s[a]===1&&r[a]<i&&(i=r[a],o=a);return o>=0?(s[o]=0,Math.floor(t[o])):-1}Bh.smallestFlagged=Vwt;var sl={},aI=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Uwt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},Wwt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(sl,"__esModule",{value:!0});var g1,Hq=Wwt(di),dx=function(){function n(e,t,r,s){if(this.entries=new Map,this.nRows=0,this.nCols=0,e.length!==t.length||e.length!==r.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=s[0],this.nCols=s[1];for(var i=0;i<r.length;i++){var o=e[i],a=t[i];this.checkDims(o,a);var l=this.makeKey(o,a);this.entries.set(l,{value:r[i],row:o,col:a})}}return n.prototype.makeKey=function(e,t){return e+":"+t},n.prototype.checkDims=function(e,t){var r=e<this.nRows&&t<this.nCols;if(!r)throw new Error("row and/or col specified outside of matrix dimensions")},n.prototype.set=function(e,t,r){this.checkDims(e,t);var s=this.makeKey(e,t);this.entries.has(s)?this.entries.get(s).value=r:this.entries.set(s,{value:r,row:e,col:t})},n.prototype.get=function(e,t,r){r===void 0&&(r=0),this.checkDims(e,t);var s=this.makeKey(e,t);return this.entries.has(s)?this.entries.get(s).value:r},n.prototype.getAll=function(e){e===void 0&&(e=!0);var t=[];return this.entries.forEach(function(r){t.push(r)}),e&&t.sort(function(r,s){return r.row===s.row?r.col-s.col:r.row-s.row}),t},n.prototype.getDims=function(){return[this.nRows,this.nCols]},n.prototype.getRows=function(){return Array.from(this.entries,function(e){var t=aI(e,2);t[0];var r=t[1];return r.row})},n.prototype.getCols=function(){return Array.from(this.entries,function(e){var t=aI(e,2);t[0];var r=t[1];return r.col})},n.prototype.getValues=function(){return Array.from(this.entries,function(e){var t=aI(e,2);t[0];var r=t[1];return r.value})},n.prototype.forEach=function(e){this.entries.forEach(function(t){return e(t.value,t.row,t.col)})},n.prototype.map=function(e){var t=[];this.entries.forEach(function(s){t.push(e(s.value,s.row,s.col))});var r=[this.nRows,this.nCols];return new n(this.getRows(),this.getCols(),t,r)},n.prototype.toArray=function(){var e=this,t=Hq.empty(this.nRows),r=t.map(function(){return Hq.zeros(e.nCols)});return this.entries.forEach(function(s){r[s.row][s.col]=s.value}),r},n}();sl.SparseMatrix=dx;function Gwt(n){var e=[],t=[],r=[];n.forEach(function(i,o,a){e.push(o),t.push(a),r.push(i)});var s=[n.nCols,n.nRows];return new dx(t,e,r,s)}sl.transpose=Gwt;function Hwt(n){for(var e=aI(n,1),t=e[0],r=new dx([],[],[],n),s=0;s<t;s++)r.set(s,s,1);return r}sl.identity=Hwt;function jwt(n,e){return W$(n,e,function(t,r){return t*r})}sl.pairwiseMultiply=jwt;function qwt(n,e){return W$(n,e,function(t,r){return t+r})}sl.add=qwt;function Xwt(n,e){return W$(n,e,function(t,r){return t-r})}sl.subtract=Xwt;function Kwt(n,e){return W$(n,e,function(t,r){return t>r?t:r})}sl.maximum=Kwt;function Ywt(n,e){return n.map(function(t){return t*e})}sl.multiplyScalar=Ywt;function Zwt(n){for(var e=new Set,t=n.getValues(),r=n.getRows(),s=n.getCols(),i=0;i<t.length;i++)t[i]===0&&e.add(i);var o=function(u,h){return!e.has(h)},a=t.filter(o),l=r.filter(o),c=s.filter(o);return new dx(l,c,a,n.getDims())}sl.eliminateZeros=Zwt;function Jwt(n,e){e===void 0&&(e="l2");var t,r,s=Qwt[e],i=new Map;n.forEach(function(h,f,d){var p=i.get(f)||[];p.push(d),i.set(f,p)});var o=new dx([],[],[],n.getDims()),a=function(h){for(var f=i.get(h).sort(),d=f.map(function(g){return n.get(h,g)}),p=s(d),m=0;m<p.length;m++)o.set(h,f[m],p[m])};try{for(var l=Uwt(i.keys()),c=l.next();!c.done;c=l.next()){var u=c.value;a(u)}}catch(h){t={error:h}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}return o}sl.normalize=Jwt;var Qwt=(g1={},g1.max=function(n){for(var e=-1/0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return n.map(function(r){return r/e})},g1.l1=function(n){for(var e=0,t=0;t<n.length;t++)e+=n[t];return n.map(function(r){return r/e})},g1.l2=function(n){for(var e=0,t=0;t<n.length;t++)e+=Math.pow(n[t],2);return n.map(function(r){return Math.sqrt(Math.pow(r,2)/e)})},g1);function W$(n,e,t){for(var r=new Set,s=[],i=[],o=[],a=function(x,w){s.push(x),i.push(w);var S=t(n.get(x,w),e.get(x,w));o.push(S)},l=n.getValues(),c=n.getRows(),u=n.getCols(),h=0;h<l.length;h++){var f=c[h],d=u[h],p=f+":"+d;r.add(p),a(f,d)}for(var m=e.getValues(),g=e.getRows(),y=e.getCols(),h=0;h<m.length;h++){var f=g[h],d=y[h],p=f+":"+d;r.has(p)||a(f,d)}var b=[n.nRows,n.nCols];return new dx(s,i,o,b)}function ext(n){var e=[];n.forEach(function(h,f,d){e.push({value:h,row:f,col:d})}),e.sort(function(h,f){return h.row===f.row?h.col-f.col:h.row-f.row});for(var t=[],r=[],s=[],i=-1,o=0;o<e.length;o++){var a=e[o],l=a.row,c=a.col,u=a.value;l!==i&&(i=l,s.push(o)),t.push(c),r.push(u)}return{indices:t,values:r,indptr:s}}sl.getCSR=ext;var px={},i0={},txt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},pce=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(txt(arguments[e]));return n},nxt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},rxt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(i0,"__esModule",{value:!0});var Bo=rxt(di),mce=function(){function n(e,t,r,s){this.hyperplanes=e,this.offsets=t,this.children=r,this.indices=s}return n}();i0.FlatTree=mce;function sxt(n,e,t,r){var s=Math.max(10,e),i=Bo.range(t).map(function(a,l){return ixt(n,s,l,r)}),o=i.map(function(a){return axt(a,s)});return o}i0.makeForest=sxt;function ixt(n,e,t,r){e===void 0&&(e=30);var s=Bo.range(n.length),i=fL(n,s,e,t,r);return i}function fL(n,e,t,r,s){if(t===void 0&&(t=30),e.length>t){var i=oxt(n,e,s),o=i.indicesLeft,a=i.indicesRight,l=i.hyperplane,c=i.offset,u=fL(n,o,t,r+1,s),h=fL(n,a,t,r+1,s),f={leftChild:u,rightChild:h,isLeaf:!1,hyperplane:l,offset:c};return f}else{var f={indices:e,isLeaf:!0};return f}}function oxt(n,e,t){var r=n[0].length,s=Bo.tauRandInt(e.length,t),i=Bo.tauRandInt(e.length,t);i+=s===i?1:0,i=i%e.length;for(var o=e[s],a=e[i],l=0,c=Bo.zeros(r),u=0;u<c.length;u++)c[u]=n[o][u]-n[a][u],l-=c[u]*(n[o][u]+n[a][u])/2;for(var h=0,f=0,d=Bo.zeros(e.length),u=0;u<e.length;u++){for(var p=l,m=0;m<r;m++)p+=c[m]*n[e[u]][m];p===0?(d[u]=Bo.tauRandInt(2,t),d[u]===0?h+=1:f+=1):p>0?(d[u]=0,h+=1):(d[u]=1,f+=1)}var g=Bo.zeros(h),y=Bo.zeros(f);h=0,f=0;for(var u=0;u<d.length;u++)d[u]===0?(g[h]=e[u],h+=1):(y[f]=e[u],f+=1);return{indicesLeft:g,indicesRight:y,hyperplane:c,offset:l}}function axt(n,e){var t=pL(n),r=mL(n),s=Bo.range(t).map(function(){return Bo.zeros(n.hyperplane?n.hyperplane.length:0)}),i=Bo.zeros(t),o=Bo.range(t).map(function(){return[-1,-1]}),a=Bo.range(r).map(function(){return Bo.range(e).map(function(){return-1})});return dL(n,s,i,o,a,0,0),new mce(s,i,o,a)}function dL(n,e,t,r,s,i,o){var a;if(n.isLeaf)return r[i][0]=-o,(a=s[o]).splice.apply(a,pce([0,n.indices.length],n.indices)),o+=1,{nodeNum:i,leafNum:o};e[i]=n.hyperplane,t[i]=n.offset,r[i][0]=i+1;var l=i,c=dL(n.leftChild,e,t,r,s,i+1,o);return i=c.nodeNum,o=c.leafNum,r[l][1]=i+1,c=dL(n.rightChild,e,t,r,s,i+1,o),{nodeNum:c.nodeNum,leafNum:c.leafNum}}function pL(n){return n.isLeaf?1:1+pL(n.leftChild)+pL(n.rightChild)}function mL(n){return n.isLeaf?1:mL(n.leftChild)+mL(n.rightChild)}function lxt(n){var e,t;if(n.length>0){var r=[];try{for(var s=nxt(n),i=s.next();!i.done;i=s.next()){var o=i.value;r.push.apply(r,pce(o.indices))}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return r}else return[[-1]]}i0.makeLeafArray=lxt;function cxt(n,e,t,r){for(var s=e,i=0;i<t.length;i++)s+=n[i]*t[i];if(s===0){var o=Bo.tauRandInt(2,r);return o}else return s>0?0:1}function uxt(n,e,t){for(var r=0;e.children[r][0]>0;){var s=cxt(e.hyperplanes[r],e.offsets[r],n,t);s===0?r=e.children[r][0]:r=e.children[r][1]}var i=-1*e.children[r][0];return e.indices[i]}i0.searchFlatTree=uxt;var gce=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},G$=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(px,"__esModule",{value:!0});var fa=G$(Bh),hxt=G$(sl),fxt=G$(i0),yce=G$(di);function dxt(n,e){return function(r,s,i,o,a,l,c,u){o===void 0&&(o=10),a===void 0&&(a=50),l===void 0&&(l=.001),c===void 0&&(c=.5),u===void 0&&(u=!0);for(var h=r.length,f=fa.makeHeap(r.length,i),d=0;d<r.length;d++)for(var p=fa.rejectionSample(i,r.length,e),m=0;m<p.length;m++){var g=n(r[d],r[p[m]]);fa.heapPush(f,d,g,p[m],1),fa.heapPush(f,p[m],g,d,1)}if(u)for(var y=0;y<s.length;y++)for(var d=0;d<s[y].length&&!(s[y][d]<0);d++)for(var m=d+1;m<s[y].length&&!(s[y][m]<0);m++){var g=n(r[s[y][d]],r[s[y][m]]);fa.heapPush(f,s[y][d],g,s[y][m],1),fa.heapPush(f,s[y][m],g,s[y][d],1)}for(var y=0;y<o;y++){for(var b=fa.buildCandidates(f,h,i,a,e),x=0,d=0;d<h;d++)for(var m=0;m<a;m++){var w=Math.floor(b[0][d][m]);if(!(w<0||yce.tauRand(e)<c))for(var S=0;S<a;S++){var C=Math.floor(b[0][d][S]),k=b[2][d][m],A=b[2][d][S];if(!(C<0||!k&&!A)){var g=n(r[w],r[C]);x+=fa.heapPush(f,w,g,C,1),x+=fa.heapPush(f,C,g,w,1)}}}if(x<=l*i*r.length)break}var M=fa.deheapSort(f);return M}}px.makeNNDescent=dxt;function pxt(n){function e(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=yce.rejectionSample(r,s.length,a),u=0;u<c.length;u++)if(!(c[u]<0)){var h=n(s[c[u]],i[l]);fa.heapPush(o,l,h,c[u],1)}}function t(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=fxt.searchFlatTree(i[l],r,a),u=0;u<c.length;u++){if(c[u]<0)return;var h=n(s[c[u]],i[l]);fa.heapPush(o,l,h,c[u],1)}}return{initFromRandom:e,initFromTree:t}}px.makeInitializations=pxt;function mxt(n){return function(t,r,s,i){for(var o,a,l=hxt.getCSR(r),c=l.indices,u=l.indptr,h=0;h<i.length;h++)for(var f=new Set(s[0][h]);;){var d=fa.smallestFlagged(s,h);if(d===-1)break;var p=c.slice(u[d],u[d+1]);try{for(var m=gce(p),g=m.next();!g.done;g=m.next()){var y=g.value;if(!(y===d||y===-1||f.has(y))){var b=n(t[y],i[h]);fa.uncheckedHeapPush(s,h,b,y,1),f.add(y)}}}catch(x){o={error:x}}finally{try{g&&!g.done&&(a=m.return)&&a.call(m)}finally{if(o)throw o.error}}}return s}}px.makeInitializedNNSearch=mxt;function gxt(n,e,t,r,s,i,o){var a,l,c=fa.makeHeap(t.length,r);if(s(r,e,t,c,o),n)try{for(var u=gce(n),h=u.next();!h.done;h=u.next()){var f=h.value;i(f,e,t,c,o)}}catch(d){a={error:d}}finally{try{h&&!h.done&&(l=u.return)&&l.call(u)}finally{if(a)throw a.error}}return c}px.initializeSearch=gxt;const yxt=Object.prototype.toString;function JP(n){return yxt.call(n).endsWith("Array]")}function jq(n,e,t){let r=0;const s=t(e);for(let i=0;i<n.x.length;i++)r+=Math.abs(n.y[i]-s(n.x[i]));return r}function bxt(n,e,t,r,s){const i=t.length,o=n.x.length;let a=new Array(i);for(let l=0;l<i;l++){a[l]=new Array(o);let c=t.slice();c[l]+=r;let u=s(c);for(let h=0;h<o;h++)a[l][h]=e[h]-u(n.x[h])}return new hh(a)}function vxt(n,e){const t=n.x.length;let r=new Array(t);for(let s=0;s<t;s++)r[s]=[n.y[s]-e[s]];return new hh(r)}function wxt(n,e,t,r,s){let i=t*r*r,o=hh.eye(e.length,e.length,i);const a=s(e);let l=new Float64Array(n.x.length);for(let f=0;f<n.x.length;f++)l[f]=a(n.x[f]);let c=bxt(n,l,e,r,s),u=vxt(n,l),h=eft(o.add(c.mmul(c.transpose())));return e=new hh([e]),e=e.sub(h.mmul(c).mmul(u).mul(r).transpose()),e.to1DArray()}function xxt(n,e,t={}){let{maxIterations:r=100,gradientDifference:s=.1,damping:i=0,errorTolerance:o=.01,minValues:a,maxValues:l,initialValues:c}=t;if(i<=0)throw new Error("The damping option must be a positive number");if(!n.x||!n.y)throw new Error("The data parameter must have x and y elements");if(!JP(n.x)||n.x.length<2||!JP(n.y)||n.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(n.x.length!==n.y.length)throw new Error("The data parameter elements must have the same size");let u=c||new Array(e.length).fill(1),h=u.length;if(l=l||new Array(h).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(h).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!JP(u))throw new Error("initialValues must be an array");let f=jq(n,u,e),d=f<=o,p;for(p=0;p<r&&!d;p++){u=wxt(n,u,i,s,e);for(let m=0;m<h;m++)u[m]=Math.min(Math.max(a[m],u[m]),l[m]);if(f=jq(n,u,e),isNaN(f))break;d=f<=o}return{parameterValues:u,parameterError:f,iterations:p}}const _xt=Object.freeze(Object.defineProperty({__proto__:null,default:xxt},Symbol.toStringTag,{value:"Module"})),Sxt=Gf(_xt);var qq=pt&&pt.__awaiter||function(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){c.done?s(c.value):new t(function(u){u(c.value)}).then(o,a)}l((r=r.apply(n,e||[])).next())})},Xq=pt&&pt.__generator||function(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},gL=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Kq=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(gL(arguments[e]));return n},YC=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e},Cxt=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(ed,"__esModule",{value:!0});var kxt=YC(Bh),js=YC(sl),AE=YC(px),Yq=YC(i0),ii=YC(di),Txt=Cxt(Sxt),Zq=1e-5,ME=.001,Ext=function(){function n(e){e===void 0&&(e={});var t=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=bce,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new Axt;var r=function(s){e[s]!==void 0&&(t[s]=e[s])};r("distanceFn"),r("learningRate"),r("localConnectivity"),r("minDist"),r("nComponents"),r("nEpochs"),r("nNeighbors"),r("negativeSampleRate"),r("random"),r("repulsionStrength"),r("setOpMixRatio"),r("spread"),r("transformQueueSize")}return n.prototype.fit=function(e){return this.initializeFit(e),this.optimizeLayout(),this.embedding},n.prototype.fitAsync=function(e,t){return t===void 0&&(t=function(){return!0}),qq(this,void 0,void 0,function(){return Xq(this,function(r){switch(r.label){case 0:return this.initializeFit(e),[4,this.optimizeLayoutAsync(t)];case 1:return r.sent(),[2,this.embedding]}})})},n.prototype.setSupervisedProjection=function(e,t){t===void 0&&(t={}),this.Y=e,this.targetMetric=t.targetMetric||this.targetMetric,this.targetWeight=t.targetWeight||this.targetWeight,this.targetNNeighbors=t.targetNNeighbors||this.targetNNeighbors},n.prototype.setPrecomputedKNN=function(e,t){this.knnIndices=e,this.knnDistances=t},n.prototype.initializeFit=function(e){if(e.length<=this.nNeighbors)throw new Error("Not enough data points ("+e.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===e&&this.isInitialized)return this.getNEpochs();if(this.X=e,!this.knnIndices&&!this.knnDistances){var t=this.nearestNeighbors(e);this.knnIndices=t.knnIndices,this.knnDistances=t.knnDistances}this.graph=this.fuzzySimplicialSet(e,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(e),this.processGraphForSupervisedProjection();var r=this.initializeSimplicialSetEmbedding(),s=r.head,i=r.tail,o=r.epochsPerSample;return this.optimizationState.head=s,this.optimizationState.tail=i,this.optimizationState.epochsPerSample=o,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},n.prototype.makeSearchFns=function(){var e=AE.makeInitializations(this.distanceFn),t=e.initFromTree,r=e.initFromRandom;this.initFromTree=t,this.initFromRandom=r,this.search=AE.makeInitializedNNSearch(this.distanceFn)},n.prototype.makeSearchGraph=function(e){for(var t=this.knnIndices,r=this.knnDistances,s=[e.length,e.length],i=new js.SparseMatrix([],[],[],s),o=0;o<t.length;o++)for(var a=t[o],l=r[o],c=0;c<a.length;c++){var u=a[c],h=l[c];h>0&&i.set(o,u,h)}var f=js.transpose(i);return js.maximum(i,f)},n.prototype.transform=function(e){var t=this,r=this.X;if(r===void 0||r.length===0)throw new Error("No data has been fit.");var s=Math.floor(this.nNeighbors*this.transformQueueSize);s=Math.min(r.length,s);var i=AE.initializeSearch(this.rpForest,r,e,s,this.initFromRandom,this.initFromTree,this.random),o=this.search(r,this.searchGraph,i,e),a=kxt.deheapSort(o),l=a.indices,c=a.weights;l=l.map(function(z){return z.slice(0,t.nNeighbors)}),c=c.map(function(z){return z.slice(0,t.nNeighbors)});var u=Math.max(0,this.localConnectivity-1),h=this.smoothKNNDistance(c,this.nNeighbors,u),f=h.sigmas,d=h.rhos,p=this.computeMembershipStrengths(l,c,f,d),m=p.rows,g=p.cols,y=p.vals,b=[e.length,r.length],x=new js.SparseMatrix(m,g,y,b),w=js.normalize(x,"l1"),S=js.getCSR(w),C=e.length,k=ii.reshape2d(S.indices,C,this.nNeighbors),A=ii.reshape2d(S.values,C,this.nNeighbors),M=_ce(k,A,this.embedding),E=this.nEpochs?this.nEpochs/3:x.nRows<=1e4?100:30,N=x.getValues().reduce(function(z,B){return B>z?B:z},0);x=x.map(function(z){return z<N/E?0:z}),x=js.eliminateZeros(x);var O=this.makeEpochsPerSample(x.getValues(),E),R=x.getRows(),D=x.getCols();return this.assignOptimizationStateParameters({headEmbedding:M,tailEmbedding:this.embedding,head:R,tail:D,currentEpoch:0,nEpochs:E,nVertices:x.getDims()[1],epochsPerSample:O}),this.prepareForOptimizationLoop(),this.optimizeLayout()},n.prototype.processGraphForSupervisedProjection=function(){var e=this,t=e.Y,r=e.X;if(t){if(t.length!==r.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var s=this.targetWeight<1,i=s?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,t,i)}}},n.prototype.step=function(){var e=this.optimizationState.currentEpoch;return e<this.getNEpochs()&&this.optimizeLayoutStep(e),this.optimizationState.currentEpoch},n.prototype.getEmbedding=function(){return this.embedding},n.prototype.nearestNeighbors=function(e){var t=this,r=t.distanceFn,s=t.nNeighbors,i=function(p){return Math.log(p)/Math.log(2)},o=AE.makeNNDescent(r,this.random),a=function(p){return p===.5?0:Math.round(p)},l=5+Math.floor(a(Math.pow(e.length,.5)/20)),c=Math.max(5,Math.floor(Math.round(i(e.length))));this.rpForest=Yq.makeForest(e,s,l,this.random);var u=Yq.makeLeafArray(this.rpForest),h=o(e,u,s,c),f=h.indices,d=h.weights;return{knnIndices:f,knnDistances:d}},n.prototype.fuzzySimplicialSet=function(e,t,r){r===void 0&&(r=1);var s=this,i=s.knnIndices,o=i===void 0?[]:i,a=s.knnDistances,l=a===void 0?[]:a,c=s.localConnectivity,u=this.smoothKNNDistance(l,t,c),h=u.sigmas,f=u.rhos,d=this.computeMembershipStrengths(o,l,h,f),p=d.rows,m=d.cols,g=d.vals,y=[e.length,e.length],b=new js.SparseMatrix(p,m,g,y),x=js.transpose(b),w=js.pairwiseMultiply(b,x),S=js.subtract(js.add(b,x),w),C=js.multiplyScalar(S,r),k=js.multiplyScalar(w,1-r),A=js.add(C,k);return A},n.prototype.categoricalSimplicialSetIntersection=function(e,t,r,s){s===void 0&&(s=1);var i=wce(e,t,s,r);return i=js.eliminateZeros(i),xce(i)},n.prototype.smoothKNNDistance=function(e,t,r,s,i){r===void 0&&(r=1),s===void 0&&(s=64),i===void 0&&(i=1);for(var o=Math.log(t)/Math.log(2)*i,a=ii.zeros(e.length),l=ii.zeros(e.length),c=0;c<e.length;c++){var u=0,h=1/0,f=1,d=e[c],p=d.filter(function(k){return k>0});if(p.length>=r){var m=Math.floor(r),g=r-m;m>0?(a[c]=p[m-1],g>Zq&&(a[c]+=g*(p[m]-p[m-1]))):a[c]=g*p[0]}else p.length>0&&(a[c]=ii.max(p));for(var y=0;y<s;y++){for(var b=0,x=1;x<e[c].length;x++){var w=e[c][x]-a[c];w>0?b+=Math.exp(-(w/f)):b+=1}if(Math.abs(b-o)<Zq)break;b>o?(h=f,f=(u+h)/2):(u=f,h===1/0?f*=2:f=(u+h)/2)}if(l[c]=f,a[c]>0){var S=ii.mean(d);l[c]<ME*S&&(l[c]=ME*S)}else{var C=ii.mean(e.map(ii.mean));l[c]<ME*C&&(l[c]=ME*C)}}return{sigmas:l,rhos:a}},n.prototype.computeMembershipStrengths=function(e,t,r,s){for(var i=e.length,o=e[0].length,a=ii.zeros(i*o),l=ii.zeros(i*o),c=ii.zeros(i*o),u=0;u<i;u++)for(var h=0;h<o;h++){var f=0;e[u][h]!==-1&&(e[u][h]===u?f=0:t[u][h]-s[u]<=0?f=1:f=Math.exp(-((t[u][h]-s[u])/r[u])),a[u*o+h]=u,l[u*o+h]=e[u][h],c[u*o+h]=f)}return{rows:a,cols:l,vals:c}},n.prototype.initializeSimplicialSetEmbedding=function(){for(var e=this,t=this.getNEpochs(),r=this.nComponents,s=this.graph.getValues(),i=0,o=0;o<s.length;o++){var a=s[o];i<s[o]&&(i=a)}var l=this.graph.map(function(m){return m<i/t?0:m});this.embedding=ii.zeros(l.nRows).map(function(){return ii.zeros(r).map(function(){return ii.tauRand(e.random)*20+-10})});for(var c=[],u=[],h=[],f=l.getAll(),o=0;o<f.length;o++){var d=f[o];d.value&&(c.push(d.value),h.push(d.row),u.push(d.col))}var p=this.makeEpochsPerSample(c,t);return{head:u,tail:h,epochsPerSample:p}},n.prototype.makeEpochsPerSample=function(e,t){var r=ii.filled(e.length,-1),s=ii.max(e),i=e.map(function(o){return o/s*t});return i.forEach(function(o,a){o>0&&(r[a]=t/i[a])}),r},n.prototype.assignOptimizationStateParameters=function(e){Object.assign(this.optimizationState,e)},n.prototype.prepareForOptimizationLoop=function(){var e=this,t=e.repulsionStrength,r=e.learningRate,s=e.negativeSampleRate,i=this.optimizationState,o=i.epochsPerSample,a=i.headEmbedding,l=i.tailEmbedding,c=a[0].length,u=a.length===l.length,h=o.map(function(p){return p/s}),f=Kq(h),d=Kq(o);this.assignOptimizationStateParameters({epochOfNextSample:d,epochOfNextNegativeSample:f,epochsPerNegativeSample:h,moveOther:u,initialAlpha:r,alpha:r,gamma:t,dim:c})},n.prototype.initializeOptimization=function(){var e=this.embedding,t=this.embedding,r=this.optimizationState,s=r.head,i=r.tail,o=r.epochsPerSample,a=this.getNEpochs(),l=this.graph.nCols,c=vce(this.spread,this.minDist),u=c.a,h=c.b;this.assignOptimizationStateParameters({headEmbedding:e,tailEmbedding:t,head:s,tail:i,epochsPerSample:o,a:u,b:h,nEpochs:a,nVertices:l})},n.prototype.optimizeLayoutStep=function(e){for(var t=this.optimizationState,r=t.head,s=t.tail,i=t.headEmbedding,o=t.tailEmbedding,a=t.epochsPerSample,l=t.epochOfNextSample,c=t.epochOfNextNegativeSample,u=t.epochsPerNegativeSample,h=t.moveOther,f=t.initialAlpha,d=t.alpha,p=t.gamma,m=t.a,g=t.b,y=t.dim,b=t.nEpochs,x=t.nVertices,w=4,S=0;S<a.length;S++)if(!(l[S]>e)){var C=r[S],k=s[S],A=i[C],M=o[k],E=Qq(A,M),N=0;E>0&&(N=-2*m*g*Math.pow(E,g-1),N/=m*Math.pow(E,g)+1);for(var O=0;O<y;O++){var R=Jq(N*(A[O]-M[O]),w);A[O]+=R*d,h&&(M[O]+=-R*d)}l[S]+=a[S];for(var D=Math.floor((e-c[S])/u[S]),z=0;z<D;z++){var B=ii.tauRandInt(x,this.random),X=o[B],G=Qq(A,X),te=0;if(G>0)te=2*p*g,te/=(.001+G)*(m*Math.pow(G,g)+1);else if(C===B)continue;for(var O=0;O<y;O++){var R=4;te>0&&(R=Jq(te*(A[O]-X[O]),w)),A[O]+=R*d}}c[S]+=D*u[S]}return t.alpha=f*(1-e/b),t.currentEpoch+=1,i},n.prototype.optimizeLayoutAsync=function(e){var t=this;return e===void 0&&(e=function(){return!0}),new Promise(function(r,s){var i=function(){return qq(t,void 0,void 0,function(){var o,a,l,c,u,h;return Xq(this,function(f){try{if(o=this.optimizationState,a=o.nEpochs,l=o.currentEpoch,this.embedding=this.optimizeLayoutStep(l),c=this.optimizationState.currentEpoch,u=e(c)===!1,h=c===a,!u&&!h)setTimeout(function(){return i()},0);else return[2,r(h)]}catch(d){s(d)}return[2]})})};setTimeout(function(){return i()},0)})},n.prototype.optimizeLayout=function(e){e===void 0&&(e=function(){return!0});for(var t=!1,r=[];!t;){var s=this.optimizationState,i=s.nEpochs,o=s.currentEpoch;r=this.optimizeLayoutStep(o);var a=this.optimizationState.currentEpoch,l=e(a)===!1;t=a===i||l}return r},n.prototype.getNEpochs=function(){var e=this.graph;if(this.nEpochs>0)return this.nEpochs;var t=e.nRows;return t<=2500?500:t<=5e3?400:t<=7500?300:200},n}();ed.UMAP=Ext;function bce(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return Math.sqrt(t)}ed.euclidean=bce;function Ixt(n,e){for(var t=0,r=0,s=0,i=0;i<n.length;i++)t+=n[i]*e[i],r+=Math.pow(n[i],2),s+=Math.pow(e[i],2);return r===0&&s===0?0:r===0||s===0?1:1-t/Math.sqrt(r*s)}ed.cosine=Ixt;var Axt=function(){function n(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return n}();function Jq(n,e){return n>e?e:n<-e?-e:n}function Qq(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return t}function vce(n,e){var t=function(f){var d=gL(f,2),p=d[0],m=d[1];return function(g){return 1/(1+p*Math.pow(g,2*m))}},r=ii.linear(0,n*3,300).map(function(f){return f<e?1:f}),s=ii.zeros(r.length).map(function(f,d){var p=r[d]>=e;return p?Math.exp(-(r[d]-e)/n):f}),i=[.5,.5],o={x:r,y:s},a={damping:1.5,initialValues:i,gradientDifference:.1,maxIterations:100,errorTolerance:.01},l=Txt.default(o,t,a).parameterValues,c=gL(l,2),u=c[0],h=c[1];return{a:u,b:h}}ed.findABParams=vce;function wce(n,e,t,r){return t===void 0&&(t=1),r===void 0&&(r=5),n.map(function(s,i,o){return e[i]===-1||e[o]===-1?s*Math.exp(-t):e[i]!==e[o]?s*Math.exp(-r):s})}ed.fastIntersection=wce;function xce(n){n=js.normalize(n,"max");var e=js.transpose(n),t=js.pairwiseMultiply(e,n);return n=js.add(n,js.subtract(e,t)),js.eliminateZeros(n)}ed.resetLocalConnectivity=xce;function _ce(n,e,t){for(var r=ii.zeros(n.length).map(function(l){return ii.zeros(t[0].length)}),s=0;s<n.length;s++)for(var i=0;i<n[0].length;i++)for(var o=0;o<t[0].length;o++){var a=n[s][i];r[s][o]+=e[s][i]*t[a][o]}return r}ed.initTransform=_ce;Object.defineProperty(lce,"__esModule",{value:!0});var Mxt=ed;lce.UMAP=Mxt.UMAP;function tt(){}const H$=n=>n;function Nxt(n,e){for(const t in e)n[t]=e[t];return n}function $xt(n){return!!n&&(typeof n=="object"||typeof n=="function")&&typeof n.then=="function"}function Sce(n){return n()}function e9(){return Object.create(null)}function po(n){n.forEach(Sce)}function o0(n){return typeof n=="function"}function pn(n,e){return n!=n?e==e:n!==e||n&&typeof n=="object"||typeof n=="function"}let NE;function Ev(n,e){return NE||(NE=document.createElement("a")),NE.href=e,n===NE.href}function Rxt(n){return Object.keys(n).length===0}function os(n,...e){if(n==null)return tt;const t=n.subscribe(...e);return t.unsubscribe?()=>t.unsubscribe():t}function p_(n){let e;return os(n,t=>e=t)(),e}function HV(n,e,t){n.$$.on_destroy.push(os(e,t))}function Hp(n,e,t,r){if(n){const s=Cce(n,e,t,r);return n[0](s)}}function Cce(n,e,t,r){return n[1]&&r?Nxt(t.ctx.slice(),n[1](r(e))):t.ctx}function jp(n,e,t,r){if(n[2]&&r){const s=n[2](r(t));if(e.dirty===void 0)return s;if(typeof s=="object"){const i=[],o=Math.max(e.dirty.length,s.length);for(let a=0;a<o;a+=1)i[a]=e.dirty[a]|s[a];return i}return e.dirty|s}return e.dirty}function qp(n,e,t,r,s,i){if(s){const o=Cce(e,t,r,i);n.p(o,s)}}function Xp(n){if(n.ctx.length>32){const e=[],t=n.ctx.length/32;for(let r=0;r<t;r++)e[r]=-1;return e}return-1}function Pxt(n){return n&&o0(n.destroy)?n.destroy:tt}function Dxt(n){const e=typeof n=="string"&&n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return e?[parseFloat(e[1]),e[2]||"px"]:[n,"px"]}const kce=typeof window<"u";let j$=kce?()=>window.performance.now():()=>Date.now(),jV=kce?n=>requestAnimationFrame(n):tt;const Vb=new Set;function Tce(n){Vb.forEach(e=>{e.c(n)||(Vb.delete(e),e.f())}),Vb.size!==0&&jV(Tce)}function q$(n){let e;return Vb.size===0&&jV(Tce),{promise:new Promise(t=>{Vb.add(e={c:n,f:t})}),abort(){Vb.delete(e)}}}const Oxt=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global;function se(n,e){n.appendChild(e)}function Ece(n){if(!n)return document;const e=n.getRootNode?n.getRootNode():n.ownerDocument;return e&&e.host?e:n.ownerDocument}function Fxt(n){const e=we("style");return Lxt(Ece(n),e),e.sheet}function Lxt(n,e){return se(n.head||n,e),e.sheet}function me(n,e,t){n.insertBefore(e,t||null)}function de(n){n.parentNode&&n.parentNode.removeChild(n)}function qs(n,e){for(let t=0;t<n.length;t+=1)n[t]&&n[t].d(e)}function we(n){return document.createElement(n)}function Fs(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function He(n){return document.createTextNode(n)}function Ye(){return He(" ")}function mo(){return He("")}function qn(n,e,t,r){return n.addEventListener(e,t,r),()=>n.removeEventListener(e,t,r)}function ZC(n){return function(e){return e.preventDefault(),n.call(this,e)}}function zxt(n){return function(e){return e.stopPropagation(),n.call(this,e)}}function Z(n,e,t){t==null?n.removeAttribute(e):n.getAttribute(e)!==t&&n.setAttribute(e,t)}function Ib(n,e,t){e in n?n[e]=typeof n[e]=="boolean"&&t===""?!0:t:Z(n,e,t)}function Bxt(n){return Array.from(n.childNodes)}function cn(n,e){e=""+e,n.data!==e&&(n.data=e)}function cu(n,e,t,r){t==null?n.style.removeProperty(e):n.style.setProperty(e,t,r?"important":"")}function t9(n,e,t){for(let r=0;r<n.options.length;r+=1){const s=n.options[r];if(s.__value===e){s.selected=!0;return}}(!t||e!==void 0)&&(n.selectedIndex=-1)}function Vxt(n){const e=n.querySelector(":checked");return e&&e.__value}function qt(n,e,t){n.classList[t?"add":"remove"](e)}function Ice(n,e,{bubbles:t=!1,cancelable:r=!1}={}){const s=document.createEvent("CustomEvent");return s.initCustomEvent(n,t,r,e),s}class Uxt{constructor(e=!1){this.is_svg=!1,this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,r=null){this.e||(this.is_svg?this.e=Fs(t.nodeName):this.e=we(t.nodeType===11?"TEMPLATE":t.nodeName),this.t=t.tagName!=="TEMPLATE"?t:t.content,this.c(e)),this.i(r)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.nodeName==="TEMPLATE"?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)me(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(de)}}const pM=new Map;let mM=0;function Wxt(n){let e=5381,t=n.length;for(;t--;)e=(e<<5)-e^n.charCodeAt(t);return e>>>0}function Gxt(n,e){const t={stylesheet:Fxt(e),rules:{}};return pM.set(n,t),t}function VS(n,e,t,r,s,i,o,a=0){const l=16.666/r;let c=`{
`;for(let g=0;g<=1;g+=l){const y=e+(t-e)*i(g);c+=g*100+`%{${o(y,1-y)}}
`}const u=c+`100% {${o(t,1-t)}}
}`,h=`__svelte_${Wxt(u)}_${a}`,f=Ece(n),{stylesheet:d,rules:p}=pM.get(f)||Gxt(f,n);p[h]||(p[h]=!0,d.insertRule(`@keyframes ${h} ${u}`,d.cssRules.length));const m=n.style.animation||"";return n.style.animation=`${m?`${m}, `:""}${h} ${r}ms linear ${s}ms 1 both`,mM+=1,h}function US(n,e){const t=(n.style.animation||"").split(", "),r=t.filter(e?i=>i.indexOf(e)<0:i=>i.indexOf("__svelte")===-1),s=t.length-r.length;s&&(n.style.animation=r.join(", "),mM-=s,mM||Hxt())}function Hxt(){jV(()=>{mM||(pM.forEach(n=>{const{ownerNode:e}=n.stylesheet;e&&de(e)}),pM.clear())})}function jxt(n,e,t,r){if(!e)return tt;const s=n.getBoundingClientRect();if(e.left===s.left&&e.right===s.right&&e.top===s.top&&e.bottom===s.bottom)return tt;const{delay:i=0,duration:o=300,easing:a=H$,start:l=j$()+i,end:c=l+o,tick:u=tt,css:h}=t(n,{from:e,to:s},r);let f=!0,d=!1,p;function m(){h&&(p=VS(n,0,1,o,i,a,h)),i||(d=!0)}function g(){h&&US(n,p),f=!1}return q$(y=>{if(!d&&y>=l&&(d=!0),d&&y>=c&&(u(1,0),g()),!f)return!1;if(d){const b=y-l,x=0+1*a(b/o);u(x,1-x)}return!0}),m(),u(0,1),g}function qxt(n){const e=getComputedStyle(n);if(e.position!=="absolute"&&e.position!=="fixed"){const{width:t,height:r}=e,s=n.getBoundingClientRect();n.style.position="absolute",n.style.width=t,n.style.height=r,Ace(n,s)}}function Ace(n,e){const t=n.getBoundingClientRect();if(e.left!==t.left||e.top!==t.top){const r=getComputedStyle(n),s=r.transform==="none"?"":r.transform;n.style.transform=`${s} translate(${e.left-t.left}px, ${e.top-t.top}px)`}}let WS;function Nf(n){WS=n}function a0(){if(!WS)throw new Error("Function called outside component initialization");return WS}function $u(n){a0().$$.on_mount.push(n)}function Mce(n){a0().$$.after_update.push(n)}function Fg(n){a0().$$.on_destroy.push(n)}function Oc(){const n=a0();return(e,t,{cancelable:r=!1}={})=>{const s=n.$$.callbacks[e];if(s){const i=Ice(e,t,{cancelable:r});return s.slice().forEach(o=>{o.call(n,i)}),!i.defaultPrevented}return!0}}function Xxt(n,e){return a0().$$.context.set(n,e),e}function Nce(n){return a0().$$.context.get(n)}function gM(n,e){const t=n.$$.callbacks[e.type];t&&t.slice().forEach(r=>r.call(this,e))}const xb=[],hi=[];let Ub=[];const yL=[],$ce=Promise.resolve();let bL=!1;function Rce(){bL||(bL=!0,$ce.then(Lg))}function ea(){return Rce(),$ce}function Ru(n){Ub.push(n)}function td(n){yL.push(n)}const QP=new Set;let hb=0;function Lg(){if(hb!==0)return;const n=WS;do{try{for(;hb<xb.length;){const e=xb[hb];hb++,Nf(e),Kxt(e.$$)}}catch(e){throw xb.length=0,hb=0,e}for(Nf(null),xb.length=0,hb=0;hi.length;)hi.pop()();for(let e=0;e<Ub.length;e+=1){const t=Ub[e];QP.has(t)||(QP.add(t),t())}Ub.length=0}while(xb.length);for(;yL.length;)yL.pop()();bL=!1,QP.clear(),Nf(n)}function Kxt(n){if(n.fragment!==null){n.update(),po(n.before_update);const e=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,e),n.after_update.forEach(Ru)}}function Yxt(n){const e=[],t=[];Ub.forEach(r=>n.indexOf(r)===-1?e.push(r):t.push(r)),t.forEach(r=>r()),Ub=e}let y1;function qV(){return y1||(y1=Promise.resolve(),y1.then(()=>{y1=null})),y1}function ig(n,e,t){n.dispatchEvent(Ice(`${e?"intro":"outro"}${t}`))}const lI=new Set;let ph;function dr(){ph={r:0,c:[],p:ph}}function pr(){ph.r||po(ph.c),ph=ph.p}function Ie(n,e){n&&n.i&&(lI.delete(n),n.i(e))}function $e(n,e,t,r){if(n&&n.o){if(lI.has(n))return;lI.add(n),ph.c.push(()=>{lI.delete(n),r&&(t&&n.d(1),r())}),n.o(e)}else r&&r()}const XV={duration:0};function Zxt(n,e,t){const r={direction:"in"};let s=e(n,t,r),i=!1,o,a,l=0;function c(){o&&US(n,o)}function u(){const{delay:f=0,duration:d=300,easing:p=H$,tick:m=tt,css:g}=s||XV;g&&(o=VS(n,0,1,d,f,p,g,l++)),m(0,1);const y=j$()+f,b=y+d;a&&a.abort(),i=!0,Ru(()=>ig(n,!0,"start")),a=q$(x=>{if(i){if(x>=b)return m(1,0),ig(n,!0,"end"),c(),i=!1;if(x>=y){const w=p((x-y)/d);m(w,1-w)}}return i})}let h=!1;return{start(){h||(h=!0,US(n),o0(s)?(s=s(r),qV().then(u)):u())},invalidate(){h=!1},end(){i&&(c(),i=!1)}}}function Jxt(n,e,t){const r={direction:"out"};let s=e(n,t,r),i=!0,o;const a=ph;a.r+=1;function l(){const{delay:c=0,duration:u=300,easing:h=H$,tick:f=tt,css:d}=s||XV;d&&(o=VS(n,1,0,u,c,h,d));const p=j$()+c,m=p+u;Ru(()=>ig(n,!1,"start")),q$(g=>{if(i){if(g>=m)return f(0,1),ig(n,!1,"end"),--a.r||po(a.c),!1;if(g>=p){const y=h((g-p)/u);f(1-y,y)}}return i})}return o0(s)?qV().then(()=>{s=s(r),l()}):l(),{end(c){c&&s.tick&&s.tick(1,0),i&&(o&&US(n,o),i=!1)}}}function Iv(n,e,t,r){const s={direction:"both"};let i=e(n,t,s),o=r?0:1,a=null,l=null,c=null;function u(){c&&US(n,c)}function h(d,p){const m=d.b-o;return p*=Math.abs(m),{a:o,b:d.b,d:m,duration:p,start:d.start,end:d.start+p,group:d.group}}function f(d){const{delay:p=0,duration:m=300,easing:g=H$,tick:y=tt,css:b}=i||XV,x={start:j$()+p,b:d};d||(x.group=ph,ph.r+=1),a||l?l=x:(b&&(u(),c=VS(n,o,d,m,p,g,b)),d&&y(0,1),a=h(x,m),Ru(()=>ig(n,d,"start")),q$(w=>{if(l&&w>l.start&&(a=h(l,m),l=null,ig(n,a.b,"start"),b&&(u(),c=VS(n,o,a.b,a.duration,0,g,i.css))),a){if(w>=a.end)y(o=a.b,1-o),ig(n,a.b,"end"),l||(a.b?u():--a.group.r||po(a.group.c)),a=null;else if(w>=a.start){const S=w-a.start;o=a.a+a.d*g(S/a.duration),y(o,1-o)}}return!!(a||l)}))}return{run(d){o0(i)?qV().then(()=>{i=i(s),f(d)}):f(d)},end(){u(),a=l=null}}}function n9(n,e){const t=e.token={};function r(s,i,o,a){if(e.token!==t)return;e.resolved=a;let l=e.ctx;o!==void 0&&(l=l.slice(),l[o]=a);const c=s&&(e.current=s)(l);let u=!1;e.block&&(e.blocks?e.blocks.forEach((h,f)=>{f!==i&&h&&(dr(),$e(h,1,1,()=>{e.blocks[f]===h&&(e.blocks[f]=null)}),pr())}):e.block.d(1),c.c(),Ie(c,1),c.m(e.mount(),e.anchor),u=!0),e.block=c,e.blocks&&(e.blocks[i]=c),u&&Lg()}if($xt(n)){const s=a0();if(n.then(i=>{Nf(s),r(e.then,1,e.value,i),Nf(null)},i=>{if(Nf(s),r(e.catch,2,e.error,i),Nf(null),!e.hasCatch)throw i}),e.current!==e.pending)return r(e.pending,0),!0}else{if(e.current!==e.then)return r(e.then,1,e.value,n),!0;e.resolved=n}}function Qxt(n,e,t){const r=e.slice(),{resolved:s}=n;n.current===n.then&&(r[n.value]=s),n.current===n.catch&&(r[n.error]=s),n.block.p(r,t)}function Pce(n,e){$e(n,1,1,()=>{e.delete(n.key)})}function e1t(n,e){n.f(),Pce(n,e)}function Dce(n,e,t,r,s,i,o,a,l,c,u,h){let f=n.length,d=i.length,p=f;const m={};for(;p--;)m[n[p].key]=p;const g=[],y=new Map,b=new Map,x=[];for(p=d;p--;){const k=h(s,i,p),A=t(k);let M=o.get(A);M?r&&x.push(()=>M.p(k,e)):(M=c(A,k),M.c()),y.set(A,g[p]=M),A in m&&b.set(A,Math.abs(p-m[A]))}const w=new Set,S=new Set;function C(k){Ie(k,1),k.m(a,u),o.set(k.key,k),u=k.first,d--}for(;f&&d;){const k=g[d-1],A=n[f-1],M=k.key,E=A.key;k===A?(u=k.first,f--,d--):y.has(E)?!o.has(M)||w.has(M)?C(k):S.has(E)?f--:b.get(M)>b.get(E)?(S.add(M),C(k)):(w.add(E),f--):(l(A,o),f--)}for(;f--;){const k=n[f];y.has(k.key)||l(k,o)}for(;d;)C(g[d-1]);return po(x),g}function nd(n,e,t){const r=n.$$.props[e];r!==void 0&&(n.$$.bound[r]=t,t(n.$$.ctx[r]))}function It(n){n&&n.c()}function kt(n,e,t,r){const{fragment:s,after_update:i}=n.$$;s&&s.m(e,t),r||Ru(()=>{const o=n.$$.on_mount.map(Sce).filter(o0);n.$$.on_destroy?n.$$.on_destroy.push(...o):po(o),n.$$.on_mount=[]}),i.forEach(Ru)}function Tt(n,e){const t=n.$$;t.fragment!==null&&(Yxt(t.after_update),po(t.on_destroy),t.fragment&&t.fragment.d(e),t.on_destroy=t.fragment=null,t.ctx=[])}function t1t(n,e){n.$$.dirty[0]===-1&&(xb.push(n),Rce(),n.$$.dirty.fill(0)),n.$$.dirty[e/31|0]|=1<<e%31}function wn(n,e,t,r,s,i,o,a=[-1]){const l=WS;Nf(n);const c=n.$$={fragment:null,ctx:[],props:i,update:tt,not_equal:s,bound:e9(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(l?l.$$.context:[])),callbacks:e9(),dirty:a,skip_bound:!1,root:e.target||l.$$.root};o&&o(c.root);let u=!1;if(c.ctx=t?t(n,e.props||{},(h,f,...d)=>{const p=d.length?d[0]:f;return c.ctx&&s(c.ctx[h],c.ctx[h]=p)&&(!c.skip_bound&&c.bound[h]&&c.bound[h](p),u&&t1t(n,h)),f}):[],c.update(),u=!0,po(c.before_update),c.fragment=r?r(c.ctx):!1,e.target){if(e.hydrate){const h=Bxt(e.target);c.fragment&&c.fragment.l(h),h.forEach(de)}else c.fragment&&c.fragment.c();e.intro&&Ie(n.$$.fragment),kt(n,e.target,e.anchor,e.customElement),Lg()}Nf(l)}class xn{$destroy(){Tt(this,1),this.$destroy=tt}$on(e,t){if(!o0(t))return tt;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(t),()=>{const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}$set(e){this.$$set&&!Rxt(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}function n1t(n){let e,t,r,s,i;const o=n[10].default,a=Hp(o,n,n[9],null);return{c(){e=Ye(),t=we("button"),a&&a.c(),Z(t,"class","marcelle svelte-2j0fl0"),t.disabled=n[1],qt(t,"outline",n[0]==="outline"),qt(t,"filled",n[0]==="filled"),qt(t,"light",n[0]==="light"),qt(t,"success",n[2]==="success"),qt(t,"warning",n[2]==="warning"),qt(t,"danger",n[2]==="danger"),qt(t,"size-small",n[3]==="small"),qt(t,"size-large",n[3]==="large"),qt(t,"round",n[4])},m(l,c){me(l,e,c),me(l,t,c),a&&a.m(t,null),r=!0,s||(i=[qn(document.body,"mouseup",n[6]),qn(document.body,"touchend",n[6]),qn(t,"click",n[11]),qn(t,"mousedown",n[5]),qn(t,"touchstart",ZC(n[5])),qn(t,"touchend",n[7])],s=!0)},p(l,[c]){a&&a.p&&(!r||c&512)&&qp(a,o,l,l[9],r?jp(o,l[9],c,null):Xp(l[9]),null),(!r||c&2)&&(t.disabled=l[1]),(!r||c&1)&&qt(t,"outline",l[0]==="outline"),(!r||c&1)&&qt(t,"filled",l[0]==="filled"),(!r||c&1)&&qt(t,"light",l[0]==="light"),(!r||c&4)&&qt(t,"success",l[2]==="success"),(!r||c&4)&&qt(t,"warning",l[2]==="warning"),(!r||c&4)&&qt(t,"danger",l[2]==="danger"),(!r||c&8)&&qt(t,"size-small",l[3]==="small"),(!r||c&8)&&qt(t,"size-large",l[3]==="large"),(!r||c&16)&&qt(t,"round",l[4])},i(l){r||(Ie(a,l),r=!0)},o(l){$e(a,l),r=!1},d(l){l&&de(e),l&&de(t),a&&a.d(l),s=!1,po(i)}}}function r1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{variant:i="outline"}=e,{disabled:o=!1}=e,{type:a="default"}=e,{size:l="medium"}=e,{round:c=!1}=e,{pressed:u=!1}=e;const h=Oc();function f(){t(8,u=!0),h("pressed",u)}function d(){u&&(t(8,u=!1),h("pressed",u))}function p(g){h("click",g)}function m(g){gM.call(this,n,g)}return n.$$set=g=>{"variant"in g&&t(0,i=g.variant),"disabled"in g&&t(1,o=g.disabled),"type"in g&&t(2,a=g.type),"size"in g&&t(3,l=g.size),"round"in g&&t(4,c=g.round),"pressed"in g&&t(8,u=g.pressed),"$$scope"in g&&t(9,s=g.$$scope)},[i,o,a,l,c,f,d,p,u,s,r,m]}let zs=class extends xn{constructor(e){super(),wn(this,e,r1t,n1t,pn,{variant:0,disabled:1,type:2,size:3,round:4,pressed:8})}};function s1t(n){let e,t,r;return{c(){e=we("input"),Z(e,"class","marcelle svelte-1mutsa0"),e.disabled=n[2],Z(e,"type",n[3]),Z(e,"placeholder",n[1]),e.value=n[0]},m(s,i){me(s,e,i),t||(r=qn(e,"input",n[4]),t=!0)},p(s,[i]){i&4&&(e.disabled=s[2]),i&8&&Z(e,"type",s[3]),i&2&&Z(e,"placeholder",s[1]),i&1&&e.value!==s[0]&&(e.value=s[0])},i:tt,o:tt,d(s){s&&de(e),t=!1,r()}}}function i1t(n,e,t){let{placeholder:r=""}=e,{disabled:s=!1}=e,{type:i="text"}=e,{value:o=null}=e;function a(l){t(0,o=l.currentTarget.value)}return n.$$set=l=>{"placeholder"in l&&t(1,r=l.placeholder),"disabled"in l&&t(2,s=l.disabled),"type"in l&&t(3,i=l.type),"value"in l&&t(0,o=l.value)},[o,r,s,i,a]}class o1t extends xn{constructor(e){super(),wn(this,e,i1t,s1t,pn,{placeholder:1,disabled:2,type:3,value:0})}}function a1t(n){let e,t,r,s,i,o,a,l;const c=n[2].default,u=Hp(c,n,n[1],null);return{c(){e=we("div"),t=we("div"),r=we("div"),s=Ye(),i=we("div"),u&&u.c(),Z(r,"class","absolute inset-0 bg-gray-500 opacity-50"),Z(t,"class","overlay svelte-1sg0y6b"),Z(i,"class","modal svelte-1sg0y6b"),Z(e,"class","modal-container svelte-1sg0y6b")},m(h,f){me(h,e,f),se(e,t),se(t,r),se(e,s),se(e,i),u&&u.m(i,null),o=!0,a||(l=[qn(r,"click",n[0]),qn(r,"keypress",ZC(n[3]))],a=!0)},p(h,[f]){u&&u.p&&(!o||f&2)&&qp(u,c,h,h[1],o?jp(c,h[1],f,null):Xp(h[1]),null)},i(h){o||(Ie(u,h),o=!0)},o(h){$e(u,h),o=!1},d(h){h&&de(e),u&&u.d(h),a=!1,po(l)}}}function l1t(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=Oc();function o(){i("quit")}const a=l=>l.key==="Escape"&&o();return n.$$set=l=>{"$$scope"in l&&t(1,s=l.$$scope)},[o,s,r,a]}class Oce extends xn{constructor(e){super(),wn(this,e,l1t,a1t,pn,{quit:0})}get quit(){return this.$$.ctx[0]}}function c1t(n){return n<.5?4*n*n*n:.5*Math.pow(2*n-2,3)+1}function KV(n){const e=n-1;return e*e*e+1}function yM(n,{delay:e=0,duration:t=400,easing:r=c1t,amount:s=5,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.filter==="none"?"":o.filter,c=a*(1-i),[u,h]=Dxt(s);return{delay:e,duration:t,easing:r,css:(f,d)=>`opacity: ${a-c*d}; filter: ${l} blur(${d*u}${h});`}}function r9(n,{delay:e=0,duration:t=400,easing:r=KV,axis:s="y"}={}){const i=getComputedStyle(n),o=+i.opacity,a=s==="y"?"height":"width",l=parseFloat(i[a]),c=s==="y"?["top","bottom"]:["left","right"],u=c.map(y=>`${y[0].toUpperCase()}${y.slice(1)}`),h=parseFloat(i[`padding${u[0]}`]),f=parseFloat(i[`padding${u[1]}`]),d=parseFloat(i[`margin${u[0]}`]),p=parseFloat(i[`margin${u[1]}`]),m=parseFloat(i[`border${u[0]}Width`]),g=parseFloat(i[`border${u[1]}Width`]);return{delay:e,duration:t,easing:r,css:y=>`overflow: hidden;opacity: ${Math.min(y*20,1)*o};${a}: ${y*l}px;padding-${c[0]}: ${y*h}px;padding-${c[1]}: ${y*f}px;margin-${c[0]}: ${y*d}px;margin-${c[1]}: ${y*p}px;border-${c[0]}-width: ${y*m}px;border-${c[1]}-width: ${y*g}px;`}}function s9(n,{delay:e=0,duration:t=400,easing:r=KV,start:s=0,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.transform==="none"?"":o.transform,c=1-s,u=a*(1-i);return{delay:e,duration:t,easing:r,css:(h,f)=>`
			transform: ${l} scale(${1-c*f});
			opacity: ${a-u*f}
		`}}function u1t(n,{from:e,to:t},r={}){const s=getComputedStyle(n),i=s.transform==="none"?"":s.transform,[o,a]=s.transformOrigin.split(" ").map(parseFloat),l=e.left+e.width*o/t.width-(t.left+o),c=e.top+e.height*a/t.height-(t.top+a),{delay:u=0,duration:h=d=>Math.sqrt(d)*120,easing:f=KV}=r;return{delay:u,duration:o0(h)?h(Math.sqrt(l*l+c*c)):h,easing:f,css:(d,p)=>{const m=p*l,g=p*c,y=d+p*e.width/t.width,b=d+p*e.height/t.height;return`transform: ${i} translate(${m}px, ${g}px) scale(${y}, ${b});`}}}function i9(n,e,t){const r=n.slice();return r[6]=e[t].title,r[7]=e[t].message,r[8]=e[t].type,r[9]=e[t].id,r}function h1t(n){let e;return{c(){e=Fs("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z`)},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function f1t(n){let e;return{c(){e=Fs("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z`)},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function o9(n,e){let t,r,s,i,o,a,l,c=e[6]+"",u,h,f,d=e[7]+"",p,m,g,y,b,x,w,S,C,k,A=tt,M,E,N;function O(X,G){if(X[8]==="default")return f1t;if(X[8]==="danger")return h1t}let R=O(e),D=R&&R(e);function z(){return e[3](e[9])}function B(...X){return e[4](e[9],...X)}return{key:n,first:null,c(){t=we("div"),r=we("div"),s=we("div"),i=Fs("svg"),D&&D.c(),o=Ye(),a=we("div"),l=we("p"),u=He(c),h=Ye(),f=we("p"),p=He(d),m=Ye(),g=we("div"),y=Fs("svg"),b=Fs("title"),x=He("Close"),w=Fs("path"),S=Ye(),Z(i,"class","notification-svg mr-4 svelte-c58nio"),Z(i,"xmlns","http://www.w3.org/2000/svg"),Z(i,"viewBox","0 0 20 20"),qt(i,"default",e[8]==="default"),qt(i,"danger",e[8]==="danger"),Z(s,"class","py-1"),Z(l,"class","my-1 font-bold"),Z(f,"class","my-1 text-sm"),Z(w,"d",`M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1
              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10
              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0
              1.698z`),Z(y,"class","notification-svg ml-4 cursor-pointer svelte-c58nio"),Z(y,"role","button"),Z(y,"xmlns","http://www.w3.org/2000/svg"),Z(y,"viewBox","0 0 20 20"),qt(y,"default",e[8]==="default"),qt(y,"danger",e[8]==="danger"),Z(r,"class","flex items-start"),Z(t,"class","notification-card svelte-c58nio"),Z(t,"role","alert"),qt(t,"default",e[8]==="default"),qt(t,"danger",e[8]==="danger"),this.first=t},m(X,G){me(X,t,G),se(t,r),se(r,s),se(s,i),D&&D.m(i,null),se(r,o),se(r,a),se(a,l),se(l,u),se(a,h),se(a,f),se(f,p),se(r,m),se(r,g),se(g,y),se(y,b),se(b,x),se(y,w),se(t,S),M=!0,E||(N=[qn(y,"click",z),qn(y,"keypress",ZC(B))],E=!0)},p(X,G){e=X,R!==(R=O(e))&&(D&&D.d(1),D=R&&R(e),D&&(D.c(),D.m(i,null))),(!M||G&1)&&qt(i,"default",e[8]==="default"),(!M||G&1)&&qt(i,"danger",e[8]==="danger"),(!M||G&1)&&c!==(c=e[6]+"")&&cn(u,c),(!M||G&1)&&d!==(d=e[7]+"")&&cn(p,d),(!M||G&1)&&qt(y,"default",e[8]==="default"),(!M||G&1)&&qt(y,"danger",e[8]==="danger"),(!M||G&1)&&qt(t,"default",e[8]==="default"),(!M||G&1)&&qt(t,"danger",e[8]==="danger")},r(){k=t.getBoundingClientRect()},f(){qxt(t),A(),Ace(t,k)},a(){A(),A=jxt(t,k,u1t,{})},i(X){M||(Ru(()=>{M&&(C||(C=Iv(t,yM,{amount:10},!0)),C.run(1))}),M=!0)},o(X){C||(C=Iv(t,yM,{amount:10},!1)),C.run(0),M=!1},d(X){X&&de(t),D&&D.d(),X&&C&&C.end(),E=!1,po(N)}}}function d1t(n){let e,t=[],r=new Map,s,i=n[0].slice(0,10);const o=a=>a[9];for(let a=0;a<i.length;a+=1){let l=i9(n,i,a),c=o(l);r.set(c,t[a]=o9(c,l))}return{c(){e=we("div");for(let a=0;a<t.length;a+=1)t[a].c();Z(e,"class","marcelle notification-container svelte-c58nio")},m(a,l){me(a,e,l);for(let c=0;c<t.length;c+=1)t[c]&&t[c].m(e,null);s=!0},p(a,[l]){if(l&3){i=a[0].slice(0,10),dr();for(let c=0;c<t.length;c+=1)t[c].r();t=Dce(t,l,o,1,a,i,r,e,e1t,o9,null,i9);for(let c=0;c<t.length;c+=1)t[c].a();pr()}},i(a){if(!s){for(let l=0;l<i.length;l+=1)Ie(t[l]);s=!0}},o(a){for(let l=0;l<t.length;l+=1)$e(t[l]);s=!1},d(a){a&&de(e);for(let l=0;l<t.length;l+=1)t[l].d()}}}function p1t(n,e,t){let{notifications:r=[]}=e;function s(c){t(0,r=r.filter(u=>u.id!==c))}let i=1;function o({title:c,message:u,type:h="default",duration:f=3e3}){const d={id:i,title:c,message:u,type:h};i+=1,t(0,r=[...r,d]),f>0&&setTimeout(()=>{s(d.id)},f)}const a=c=>s(c),l=(c,u)=>u.key==="Escape"&&s(c);return n.$$set=c=>{"notifications"in c&&t(0,r=c.notifications)},[r,s,o,a,l]}class m1t extends xn{constructor(e){super(),wn(this,e,p1t,d1t,pn,{notifications:0,add:2})}get add(){return this.$$.ctx[2]}}function g1t(n){let e,t,r,s,i,o,a,l,c,u;return{c(){e=we("div"),t=we("button"),r=He("-"),s=Ye(),i=we("input"),o=Ye(),a=we("button"),l=He("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(i,"type","number"),Z(i,"inputmode","decimal"),i.value=n[0],i.disabled=n[1],cu(i,"width","80px"),Z(i,"class","svelte-1w23q60"),a.disabled=n[1],Z(a,"class","right svelte-1w23q60"),Z(e,"class","flex")},m(h,f){me(h,e,f),se(e,t),se(t,r),se(e,s),se(e,i),se(e,o),se(e,a),se(a,l),c||(u=[qn(t,"click",n[3]),qn(i,"change",n[2]),qn(a,"click",n[4])],c=!0)},p(h,[f]){f&2&&(t.disabled=h[1]),f&1&&i.value!==h[0]&&(i.value=h[0]),f&2&&(i.disabled=h[1]),f&2&&(a.disabled=h[1])},i:tt,o:tt,d(h){h&&de(e),c=!1,po(u)}}}function y1t(n,e,t){let{disabled:r=!1}=e,{value:s}=e;function i(l){const c=l.target,u=parseFloat(c.value);Number.isNaN(u)?c.value=s.toString():t(0,s=u)}const o=()=>{t(0,s-=1)},a=()=>{t(0,s+=1)};return n.$$set=l=>{"disabled"in l&&t(1,r=l.disabled),"value"in l&&t(0,s=l.value)},[s,r,i,o,a]}class b1t extends xn{constructor(e){super(),wn(this,e,y1t,g1t,pn,{disabled:1,value:0})}}function a9(n,e,t){const r=n.slice();return r[12]=e[t],r[14]=t,r}function l9(n){let e,t,r,s,i,o,a,l,c,u=n[0],h=[];for(let f=0;f<u.length;f+=1)h[f]=c9(a9(n,u,f));return{c(){e=we("div");for(let f=0;f<h.length;f+=1)h[f].c();t=Ye(),r=we("button"),s=He("-"),i=Ye(),o=we("button"),a=He("+"),r.disabled=n[1],Z(r,"class","left svelte-1w23q60"),o.disabled=n[1],Z(o,"class","right svelte-1w23q60"),cu(o,"border-left","none"),Z(e,"class","flex items-center")},m(f,d){me(f,e,d);for(let p=0;p<h.length;p+=1)h[p]&&h[p].m(e,null);se(e,t),se(e,r),se(r,s),se(e,i),se(e,o),se(o,a),l||(c=[qn(r,"click",n[10]),qn(o,"click",n[11])],l=!0)},p(f,d){if(d&31){u=f[0];let p;for(p=0;p<u.length;p+=1){const m=a9(f,u,p);h[p]?h[p].p(m,d):(h[p]=c9(m),h[p].c(),h[p].m(e,t))}for(;p<h.length;p+=1)h[p].d(1);h.length=u.length}d&2&&(r.disabled=f[1]),d&2&&(o.disabled=f[1])},d(f){f&&de(e),qs(h,f),l=!1,po(c)}}}function c9(n){let e,t,r,s,i,o,a,l,c,u,h;function f(){return n[7](n[14])}function d(...m){return n[8](n[14],...m)}function p(){return n[9](n[14])}return{c(){e=we("div"),t=we("button"),r=He("-"),s=Ye(),i=we("input"),a=Ye(),l=we("button"),c=He("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(i,"type","number"),Z(i,"inputmode","decimal"),i.value=o=n[12],i.disabled=n[1],cu(i,"width","80px"),Z(i,"class","svelte-1w23q60"),l.disabled=n[1],Z(l,"class","right svelte-1w23q60"),Z(e,"class","flex mr-2")},m(m,g){me(m,e,g),se(e,t),se(t,r),se(e,s),se(e,i),se(e,a),se(e,l),se(l,c),u||(h=[qn(t,"click",f),qn(i,"change",d),qn(l,"click",p)],u=!0)},p(m,g){n=m,g&2&&(t.disabled=n[1]),g&1&&o!==(o=n[12])&&i.value!==o&&(i.value=o),g&2&&(i.disabled=n[1]),g&2&&(l.disabled=n[1])},d(m){m&&de(e),u=!1,po(h)}}}function v1t(n){let e=n[0]&&Array.isArray(n[0]),t,r=e&&l9(n);return{c(){r&&r.c(),t=mo()},m(s,i){r&&r.m(s,i),me(s,t,i)},p(s,[i]){i&1&&(e=s[0]&&Array.isArray(s[0])),e?r?r.p(s,i):(r=l9(s),r.c(),r.m(t.parentNode,t)):r&&(r.d(1),r=null)},i:tt,o:tt,d(s){r&&r.d(s),s&&de(t)}}}function w1t(n,e,t){let{disabled:r=!1}=e,{value:s}=e;function i(m,g){const y=m.target,b=parseFloat(y.value);Number.isNaN(b)?y.value=s[g].toString():t(0,s[g]=b,s)}function o(m){const g=s.slice();g[m]-=1,t(0,s=g)}function a(m){const g=s.slice();g[m]+=1,t(0,s=g)}function l(){const m=s.slice();m.push(m.length?m[m.length-1]:0),t(0,s=m)}function c(){t(0,s=s.slice(0,s.length-1))}const u=m=>o(m),h=(m,g)=>i(g,m),f=m=>a(m),d=()=>c(),p=()=>l();return n.$$set=m=>{"disabled"in m&&t(1,r=m.disabled),"value"in m&&t(0,s=m.value)},[s,r,i,o,a,l,c,u,h,f,d,p]}let x1t=class extends xn{constructor(e){super(),wn(this,e,w1t,v1t,pn,{disabled:1,value:0})}};function u9(n,e,t){const r=n.slice();return r[7]=e[t],r}function _1t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"d","M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"),Z(e,"class","fill-current inline-block h-5 w-5"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"viewBox","0 0 20 20")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function h9(n){let e,t,r,s,i,o=n[0],a=[];for(let l=0;l<o.length;l+=1)a[l]=f9(u9(n,o,l));return{c(){e=we("div"),t=we("div"),r=we("div");for(let l=0;l<a.length;l+=1)a[l].c();Z(r,"class","py-1"),Z(r,"role","menu"),Z(r,"aria-orientation","vertical"),Z(r,"aria-labelledby","options-menu"),Z(t,"class","origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"),Z(e,"class","origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50"),qt(e,"hidden",!1)},m(l,c){me(l,e,c),se(e,t),se(t,r);for(let u=0;u<a.length;u+=1)a[u]&&a[u].m(r,null);i=!0},p(l,c){if(c&9){o=l[0];let u;for(u=0;u<o.length;u+=1){const h=u9(l,o,u);a[u]?a[u].p(h,c):(a[u]=f9(h),a[u].c(),a[u].m(r,null))}for(;u<a.length;u+=1)a[u].d(1);a.length=o.length}},i(l){i||(Ru(()=>{i&&(s||(s=Iv(e,r9,{duration:100},!0)),s.run(1))}),i=!0)},o(l){s||(s=Iv(e,r9,{duration:100},!1)),s.run(0),i=!1},d(l){l&&de(e),qs(a,l),l&&s&&s.end()}}}function f9(n){let e,t=n[7].text+"",r,s,i,o;function a(){return n[5](n[7])}return{c(){e=we("button"),r=He(t),s=Ye(),Z(e,"class","text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer")},m(l,c){me(l,e,c),se(e,r),se(e,s),i||(o=qn(e,"click",a),i=!0)},p(l,c){n=l,c&1&&t!==(t=n[7].text+"")&&cn(r,t)},d(l){l&&de(e),i=!1,o()}}}function S1t(n){let e,t,r,s,i,o,a;r=new zs({props:{size:"small",round:!0,$$slots:{default:[_1t]},$$scope:{ctx:n}}}),r.$on("click",n[2]);let l=n[1]&&h9(n);return{c(){e=Ye(),t=we("div"),It(r.$$.fragment),s=Ye(),l&&l.c(),Z(t,"class","relative")},m(c,u){me(c,e,u),me(c,t,u),kt(r,t,null),se(t,s),l&&l.m(t,null),i=!0,o||(a=qn(document.body,"click",n[4]),o=!0)},p(c,[u]){const h={};u&1024&&(h.$$scope={dirty:u,ctx:c}),r.$set(h),c[1]?l?(l.p(c,u),u&2&&Ie(l,1)):(l=h9(c),l.c(),Ie(l,1),l.m(t,null)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr())},i(c){i||(Ie(r.$$.fragment,c),Ie(l),i=!0)},o(c){$e(r.$$.fragment,c),$e(l),i=!1},d(c){c&&de(e),c&&de(t),Tt(r),l&&l.d(),o=!1,a()}}}function C1t(n,e,t){let{actions:r=[]}=e;const s=Oc();let i=!1;function o(u){u.stopPropagation(),i?t(1,i=!1):t(1,i=!0)}function a(u){s("select",u)}const l=()=>{t(1,i=!1)},c=u=>a(u.code);return n.$$set=u=>{"actions"in u&&t(0,r=u.actions)},[r,i,o,a,l,c]}class k1t extends xn{constructor(e){super(),wn(this,e,C1t,S1t,pn,{actions:0})}}function T1t(n){let e,t;return{c(){e=we("div"),Z(e,"class","progress-line svelte-dee3y"),Z(e,"style",t=n[0]>=0?`--bar-mr: ${100-Math.floor(n[0]*100)}%;`:"--bar-mr: 0px"),qt(e,"thin",n[2]),qt(e,"indeterminate",n[0]===void 0||n[0]===null||n[0]<0),qt(e,"gray",n[1]==="idle"),qt(e,"green",n[1]==="success"),qt(e,"red",n[1]==="danger")},m(r,s){me(r,e,s)},p(r,[s]){s&1&&t!==(t=r[0]>=0?`--bar-mr: ${100-Math.floor(r[0]*100)}%;`:"--bar-mr: 0px")&&Z(e,"style",t),s&4&&qt(e,"thin",r[2]),s&1&&qt(e,"indeterminate",r[0]===void 0||r[0]===null||r[0]<0),s&2&&qt(e,"gray",r[1]==="idle"),s&2&&qt(e,"green",r[1]==="success"),s&2&&qt(e,"red",r[1]==="danger")},i:tt,o:tt,d(r){r&&de(e)}}}function E1t(n,e,t){let{progress:r}=e,{type:s="default"}=e,{thin:i=!1}=e;return n.$$set=o=>{"progress"in o&&t(0,r=o.progress),"type"in o&&t(1,s=o.type),"thin"in o&&t(2,i=o.thin)},[r,s,i]}class Fce extends xn{constructor(e){super(),wn(this,e,E1t,T1t,pn,{progress:0,type:1,thin:2})}}function d9(n,e,t){const r=n.slice();return r[7]=e[t],r}function p9(n){let e,t;return{c(){e=we("option"),t=He(n[2]),e.__value="",e.value=e.__value,e.disabled=!0,Z(e,"class","svelte-g3sqa4")},m(r,s){me(r,e,s),se(e,t)},p(r,s){s&4&&cn(t,r[2])},d(r){r&&de(e)}}}function m9(n){let e,t=n[7]+"",r,s;return{c(){e=we("option"),r=He(t),e.__value=s=n[7],e.value=e.__value,Z(e,"class","svelte-g3sqa4")},m(i,o){me(i,e,o),se(e,r)},p(i,o){o&2&&t!==(t=i[7]+"")&&cn(r,t),o&2&&s!==(s=i[7])&&(e.__value=s,e.value=e.__value)},d(i){i&&de(e)}}}function I1t(n){let e,t,r,s,i,o,a,l=n[2]&&p9(n),c=n[1],u=[];for(let h=0;h<c.length;h+=1)u[h]=m9(d9(n,c,h));return{c(){e=we("div"),t=we("select"),l&&l.c(),r=mo();for(let h=0;h<u.length;h+=1)u[h].c();s=Ye(),i=we("div"),i.innerHTML='<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>',Z(t,"class","svelte-g3sqa4"),n[0]===void 0&&Ru(()=>n[5].call(t)),qt(t,"small",n[3]==="small"),Z(i,"class","pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700"),Z(e,"class","select-container svelte-g3sqa4")},m(h,f){me(h,e,f),se(e,t),l&&l.m(t,null),se(t,r);for(let d=0;d<u.length;d+=1)u[d]&&u[d].m(t,null);t9(t,n[0],!0),se(e,s),se(e,i),o||(a=[qn(t,"change",n[5]),qn(t,"change",n[6])],o=!0)},p(h,[f]){if(h[2]?l?l.p(h,f):(l=p9(h),l.c(),l.m(t,r)):l&&(l.d(1),l=null),f&2){c=h[1];let d;for(d=0;d<c.length;d+=1){const p=d9(h,c,d);u[d]?u[d].p(p,f):(u[d]=m9(p),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}f&3&&t9(t,h[0]),f&8&&qt(t,"small",h[3]==="small")},i:tt,o:tt,d(h){h&&de(e),l&&l.d(),qs(u,h),o=!1,po(a)}}}function A1t(n,e,t){let{options:r}=e,{value:s=""}=e,{placeholder:i="Select an Option"}=e,{size:o="normal"}=e;const a=Oc();function l(){s=Vxt(this),t(0,s),t(1,r)}const c=u=>a("change",u.currentTarget.value);return n.$$set=u=>{"options"in u&&t(1,r=u.options),"value"in u&&t(0,s=u.value),"placeholder"in u&&t(2,i=u.placeholder),"size"in u&&t(3,o=u.size)},[s,r,i,o,a,l,c]}let Lce=class extends xn{constructor(e){super(),wn(this,e,A1t,I1t,pn,{options:1,value:0,placeholder:2,size:3})}};function M1t(n){let e;return{c(){e=we("span"),e.innerHTML='<span class="spinner svelte-zvuq20"><span class="dot1 svelte-zvuq20"></span>  <span class="dot2 svelte-zvuq20"></span></span>',Z(e,"class","spinner-container svelte-zvuq20")},m(t,r){me(t,e,r)},p:tt,i:tt,o:tt,d(t){t&&de(e)}}}class zce extends xn{constructor(e){super(),wn(this,e,null,M1t,pn,{})}}function N1t(n){let e,t,r,s,i,o,a,l,c;return{c(){e=we("label"),t=we("input"),r=Ye(),s=we("span"),s.innerHTML=`<span class="track svelte-smv03c"></span> 
    <span class="thumb svelte-smv03c"></span>`,i=Ye(),o=we("span"),a=He(n[1]),Z(t,"type","checkbox"),t.disabled=n[2],Z(t,"class","svelte-smv03c"),Z(s,"class","switch svelte-smv03c"),Z(o,"class","ml-2 cursor-pointer"),Z(e,"class","marcelle")},m(u,h){me(u,e,h),se(e,t),t.checked=n[0],se(e,r),se(e,s),se(e,i),se(e,o),se(o,a),l||(c=qn(t,"change",n[3]),l=!0)},p(u,[h]){h&4&&(t.disabled=u[2]),h&1&&(t.checked=u[0]),h&2&&cn(a,u[1])},i:tt,o:tt,d(u){u&&de(e),l=!1,c()}}}function $1t(n,e,t){let{text:r=""}=e,{checked:s=!1}=e,{disabled:i=!1}=e;function o(){s=this.checked,t(0,s)}return n.$$set=a=>{"text"in a&&t(1,r=a.text),"checked"in a&&t(0,s=a.checked),"disabled"in a&&t(2,i=a.disabled)},[s,r,i,o]}class R1t extends xn{constructor(e){super(),wn(this,e,$1t,N1t,pn,{text:1,checked:0,disabled:2})}}const fb=[];function m_(n,e=tt){let t;const r=new Set;function s(a){if(pn(n,a)&&(n=a,t)){const l=!fb.length;for(const c of r)c[1](),fb.push(c,n);if(l){for(let c=0;c<fb.length;c+=2)fb[c][0](fb[c+1]);fb.length=0}}}function i(a){s(a(n))}function o(a,l=tt){const c=[a,l];return r.add(c),r.size===1&&(t=e(s)||tt),a(n),()=>{r.delete(c),r.size===0&&t&&(t(),t=null)}}return{set:s,update:i,subscribe:o}}function P1t(n){let e,t;const r=n[1].default,s=Hp(r,n,n[0],null);return{c(){e=we("div"),s&&s.c(),Z(e,"class","tabs")},m(i,o){me(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&qp(s,r,i,i[0],t?jp(r,i[0],o,null):Xp(i[0]),null)},i(i){t||(Ie(s,i),t=!0)},o(i){$e(s,i),t=!1},d(i){i&&de(e),s&&s.d(i)}}}const YV={};function D1t(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=[],o=[],a=m_(null),l=m_(null);return Xxt(YV,{registerTab:c=>{i.push(c),a.update(u=>u||c),Fg(()=>{const u=i.indexOf(c);i.splice(u,1),a.update(h=>h===c?i[u]||i[i.length-1]:h)})},registerPanel:c=>{o.push(c),l.update(u=>u||c),Fg(()=>{const u=o.indexOf(c);o.splice(u,1),l.update(h=>h===c?o[u]||o[o.length-1]:h)})},selectTab:c=>{const u=i.indexOf(c);a.set(c),l.set(o[u])},selectedTab:a,selectedPanel:l}),n.$$set=c=>{"$$scope"in c&&t(0,s=c.$$scope)},[s,r]}class O1t extends xn{constructor(e){super(),wn(this,e,D1t,P1t,pn,{})}}function F1t(n){let e,t,r,s;const i=n[5].default,o=Hp(i,n,n[4],null);return{c(){e=we("div"),o&&o.c(),Z(e,"class","text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-d0yt2a"),Z(e,"role","tab"),qt(e,"selected",n[0]===n[1])},m(a,l){me(a,e,l),o&&o.m(e,null),t=!0,r||(s=qn(e,"click",n[6]),r=!0)},p(a,[l]){o&&o.p&&(!t||l&16)&&qp(o,i,a,a[4],t?jp(i,a[4],l,null):Xp(a[4]),null),(!t||l&3)&&qt(e,"selected",a[0]===a[1])},i(a){t||(Ie(o,a),t=!0)},o(a){$e(o,a),t=!1},d(a){a&&de(e),o&&o.d(a),r=!1,s()}}}function L1t(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerTab:a,selectTab:l,selectedTab:c}=Nce(YV);HV(n,c,h=>t(0,r=h)),a(o);const u=()=>l(o);return n.$$set=h=>{"$$scope"in h&&t(4,i=h.$$scope)},[r,o,l,c,i,s,u]}class $E extends xn{constructor(e){super(),wn(this,e,L1t,F1t,pn,{})}}function g9(n){let e;const t=n[4].default,r=Hp(t,n,n[3],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&8)&&qp(r,t,s,s[3],e?jp(t,s[3],i,null):Xp(s[3]),null)},i(s){e||(Ie(r,s),e=!0)},o(s){$e(r,s),e=!1},d(s){r&&r.d(s)}}}function z1t(n){let e,t,r=n[0]===n[1]&&g9(n);return{c(){r&&r.c(),e=mo()},m(s,i){r&&r.m(s,i),me(s,e,i),t=!0},p(s,[i]){s[0]===s[1]?r?(r.p(s,i),i&1&&Ie(r,1)):(r=g9(s),r.c(),Ie(r,1),r.m(e.parentNode,e)):r&&(dr(),$e(r,1,1,()=>{r=null}),pr())},i(s){t||(Ie(r),t=!0)},o(s){$e(r),t=!1},d(s){r&&r.d(s),s&&de(e)}}}function B1t(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerPanel:a,selectedPanel:l}=Nce(YV);return HV(n,l,c=>t(0,r=c)),a(o),n.$$set=c=>{"$$scope"in c&&t(3,i=c.$$scope)},[r,o,l,i,s]}class RE extends xn{constructor(e){super(),wn(this,e,B1t,z1t,pn,{})}}function V1t(n){let e;return{c(){e=He(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},i:tt,o:tt,d(t){t&&de(e)}}}function U1t(n){let e=n[1].toPrecision(2)+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[1].toPrecision(2)+"")&&cn(t,e)},i:tt,o:tt,d(r){r&&de(t)}}}function W1t(n){let e,t=vL(n[1]).join(", ")+"",r,s;return{c(){e=He("Array("),r=He(t),s=He(")")},m(i,o){me(i,e,o),me(i,r,o),me(i,s,o)},p(i,o){o&2&&t!==(t=vL(i[1]).join(", ")+"")&&cn(r,t)},i:tt,o:tt,d(i){i&&de(e),i&&de(r),i&&de(s)}}}function G1t(n){let e=n[3](n[1])+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[3](r[1])+"")&&cn(t,e)},i:tt,o:tt,d(r){r&&de(t)}}}function H1t(n){let e;const t=n[4].default,r=Hp(t,n,n[7],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&128)&&qp(r,t,s,s[7],e?jp(t,s[7],i,null):Xp(s[7]),null)},i(s){e||(Ie(r,s),e=!0)},o(s){$e(r,s),e=!1},d(s){r&&r.d(s)}}}function j1t(n){let e,t;return e=new zs({props:{size:"small",$$slots:{default:[K1t]},$$scope:{ctx:n}}}),e.$on("click",n[6]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&130&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function q1t(n){let e,t=n[1].text+"",r,s,i;return{c(){e=we("sl-button"),r=He(t),Ib(e,"type","text"),Ib(e,"size","small")},m(o,a){me(o,e,a),se(e,r),s||(i=qn(e,"click",n[5]),s=!0)},p(o,a){a&2&&t!==(t=o[1].text+"")&&cn(r,t)},i:tt,o:tt,d(o){o&&de(e),s=!1,i()}}}function X1t(n){let e,t;return{c(){e=we("img"),Z(e,"alt","thumbnail"),Ev(e.src,t=n[1])||Z(e,"src",t),Z(e,"width","30"),Z(e,"height","30"),Z(e,"class","rounded-md")},m(r,s){me(r,e,s)},p(r,s){s&2&&!Ev(e.src,t=r[1])&&Z(e,"src",t)},i:tt,o:tt,d(r){r&&de(e)}}}function K1t(n){let e;return{c(){e=He(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},d(t){t&&de(e)}}}function Y1t(n){let e,t,r,s;const i=[X1t,q1t,j1t,H1t,G1t,W1t,U1t,V1t],o=[];function a(l,c){return l[0]==="image"?0:l[0]==="link"?1:l[0]==="action"?2:l[0]==="slot"?3:l[0]==="date"?4:l[0]==="array"?5:typeof l[1]=="number"?6:7}return t=a(n),r=o[t]=i[t](n),{c(){e=we("td"),r.c(),Z(e,"class","svelte-fe0rg4")},m(l,c){me(l,e,c),o[t].m(e,null),s=!0},p(l,[c]){let u=t;t=a(l),t===u?o[t].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),r=o[t],r?r.p(l,c):(r=o[t]=i[t](l),r.c()),Ie(r,1),r.m(e,null))},i(l){s||(Ie(r),s=!0)},o(l){$e(r),s=!1},d(l){l&&de(e),o[t].d()}}}function vL(n){return Array.isArray(n)?n.length>0&&Array.isArray(n[0])?[n.length,...vL(n[0])]:[n.length]:[]}function Z1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{type:i="generic"}=e,{value:o=null}=e;const a=Oc();function l(h){try{return r8e(Date.parse(h),{includeSeconds:!0,addSuffix:!0})}catch(f){return console.log("Date Parsing Error",h,f),h}}const c=()=>{console.log("GOTO:",o.href)},u=()=>a("action",o);return n.$$set=h=>{"type"in h&&t(0,i=h.type),"value"in h&&t(1,o=h.value),"$$scope"in h&&t(7,s=h.$$scope)},[i,o,a,l,r,c,u,s]}class Bce extends xn{constructor(e){super(),wn(this,e,Z1t,Y1t,pn,{type:0,value:1})}}function y9(n){let e,t,r,s;const i=[Q1t,J1t],o=[];function a(l,c){return l[2]?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=mo()},m(l,c){o[e].m(l,c),me(l,r,c),s=!0},p(l,c){let u=e;e=a(l),e===u?o[e].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ie(t,1),t.m(r.parentNode,r))},i(l){s||(Ie(t),s=!0)},o(l){$e(t),s=!1},d(l){o[e].d(l),l&&de(r)}}}function J1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[e_t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Q1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[t_t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function e_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M16 17l-4 4m0 0l-4-4m4 4V3"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function t_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M8 7l4-4m0 0l4 4m-4-4v18"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function n_t(n){let e,t,r,s,i,o,a=n[1]&&y9(n);return{c(){e=we("th"),t=we("span"),r=we("span"),s=He(n[0]),i=Ye(),a&&a.c(),cu(r,"margin-top","0.5rem"),cu(r,"margin-bottom","0.5rem"),cu(t,"display","flex"),cu(t,"justify-content","space-between"),cu(t,"align-items","center"),Z(e,"class","svelte-1310j1m")},m(l,c){me(l,e,c),se(e,t),se(t,r),se(r,s),se(t,i),a&&a.m(t,null),o=!0},p(l,[c]){(!o||c&1)&&cn(s,l[0]),l[1]?a?(a.p(l,c),c&2&&Ie(a,1)):(a=y9(l),a.c(),Ie(a,1),a.m(t,null)):a&&(dr(),$e(a,1,1,()=>{a=null}),pr())},i(l){o||(Ie(a),o=!0)},o(l){$e(a),o=!1},d(l){l&&de(e),a&&a.d()}}}function r_t(n,e,t){let{name:r="name"}=e,{sortable:s=!1}=e,{sorting:i={col:"",ascending:!0}}=e;const o=Oc();let a=!0;function l(){t(2,a=!a),o("sort",{col:r,ascending:a})}return n.$$set=c=>{"name"in c&&t(0,r=c.name),"sortable"in c&&t(1,s=c.sortable),"sorting"in c&&t(4,i=c.sorting)},n.$$.update=()=>{n.$$.dirty&17&&i.col===r&&t(2,a=i.ascending)},[r,s,a,l,i]}class s_t extends xn{constructor(e){super(),wn(this,e,r_t,n_t,pn,{name:0,sortable:1,sorting:4})}}function b9(n,e,t){const r=n.slice();return r[10]=e[t].name,r[11]=e[t].multiple,r[12]=e[t].confirm,r}function i_t(n){let e=n[10]+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[10]+"")&&cn(t,e)},d(r){r&&de(t)}}}function v9(n){let e,t;function r(){return n[7](n[10],n[12])}return e=new zs({props:{size:"small",disabled:n[11]===!1&&n[0].length>1,type:n[10]==="delete"?"danger":"default",$$slots:{default:[i_t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i&3&&(o.disabled=n[11]===!1&&n[0].length>1),i&2&&(o.type=n[10]==="delete"?"danger":"default"),i&32770&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function w9(n){let e,t;return e=new Oce({props:{$$slots:{default:[l_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&32780&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function o_t(n){let e;return{c(){e=He("Cancel")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function a_t(n){let e;return{c(){e=He("Confirm")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function l_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d;return l=new zs({props:{type:"danger",$$slots:{default:[o_t]},$$scope:{ctx:n}}}),l.$on("click",n[8]),f=new zs({props:{variant:"filled",$$slots:{default:[a_t]},$$scope:{ctx:n}}}),f.$on("click",n[4]),{c(){e=we("div"),t=we("p"),r=He("Do you want to "),s=He(n[2]),i=He(" the selected items?"),o=Ye(),a=we("div"),It(l.$$.fragment),c=Ye(),u=we("span"),h=Ye(),It(f.$$.fragment),Z(u,"class","w-2"),Z(a,"class","w-full flex justify-end"),Z(e,"class","p-8")},m(p,m){me(p,e,m),se(e,t),se(t,r),se(t,s),se(t,i),se(e,o),se(e,a),kt(l,a,null),se(a,c),se(a,u),se(a,h),kt(f,a,null),d=!0},p(p,m){(!d||m&4)&&cn(s,p[2]);const g={};m&32768&&(g.$$scope={dirty:m,ctx:p}),l.$set(g);const y={};m&32768&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ie(l.$$.fragment,p),Ie(f.$$.fragment,p),d=!0)},o(p){$e(l.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&de(e),Tt(l),Tt(f)}}}function c_t(n){let e,t,r,s,i=n[1],o=[];for(let c=0;c<i.length;c+=1)o[c]=v9(b9(n,i,c));const a=c=>$e(o[c],1,1,()=>{o[c]=null});let l=n[3]&&w9(n);return{c(){e=we("div");for(let c=0;c<o.length;c+=1)o[c].c();t=Ye(),l&&l.c(),r=mo(),Z(e,"class","actions")},m(c,u){me(c,e,u);for(let h=0;h<o.length;h+=1)o[h]&&o[h].m(e,null);me(c,t,u),l&&l.m(c,u),me(c,r,u),s=!0},p(c,[u]){if(u&35){i=c[1];let h;for(h=0;h<i.length;h+=1){const f=b9(c,i,h);o[h]?(o[h].p(f,u),Ie(o[h],1)):(o[h]=v9(f),o[h].c(),Ie(o[h],1),o[h].m(e,null))}for(dr(),h=i.length;h<o.length;h+=1)a(h);pr()}c[3]?l?(l.p(c,u),u&8&&Ie(l,1)):(l=w9(c),l.c(),Ie(l,1),l.m(r.parentNode,r)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr())},i(c){if(!s){for(let u=0;u<i.length;u+=1)Ie(o[u]);Ie(l),s=!0}},o(c){o=o.filter(Boolean);for(let u=0;u<o.length;u+=1)$e(o[u]);$e(l),s=!1},d(c){c&&de(e),qs(o,c),c&&de(t),l&&l.d(c),c&&de(r)}}}function u_t(n,e,t){let{provider:r}=e,{actions:s}=e,{selected:i}=e;const o=Oc();let a="",l=!1;async function c(){if(a==="delete")for(const d of i)await r.delete(d);else o("action",[a,i]);t(3,l=!1),t(0,i=[]),o("selected",i)}function u(d,p){t(2,a=d),!(!a||i.length===0)&&(p?t(3,l=!0):c())}const h=(d,p)=>u(d,p),f=()=>{t(3,l=!1)};return n.$$set=d=>{"provider"in d&&t(6,r=d.provider),"actions"in d&&t(1,s=d.actions),"selected"in d&&t(0,i=d.selected)},[i,s,a,l,c,u,r,h,f]}class h_t extends xn{constructor(e){super(),wn(this,e,u_t,c_t,pn,{provider:6,actions:1,selected:0})}}function x9(n){let e,t,r;function s(o){n[11](o)}let i={provider:n[1],actions:n[2]};return n[0]!==void 0&&(i.selected=n[0]),e=new h_t({props:i}),hi.push(()=>nd(e,"selected",s)),e.$on("selected",n[12]),e.$on("action",n[13]),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.provider=o[1]),a&4&&(l.actions=o[2]),!t&&a&1&&(t=!0,l.selected=o[0],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function f_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M15 19l-7-7 7-7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function d_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M9 5l7 7-7 7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function p_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E=n[2].length>0&&n[0].length>0&&x9(n);return l=new Lce({props:{size:"small",options:["10","20","50","all"],value:n[5].toString()}}),l.$on("change",n[14]),y=new zs({props:{round:!0,disabled:n[3]===1,$$slots:{default:[f_t]},$$scope:{ctx:n}}}),y.$on("click",n[15]),C=new zs({props:{round:!0,disabled:n[3]===n[6],$$slots:{default:[d_t]},$$scope:{ctx:n}}}),C.$on("click",n[17]),{c(){e=we("div"),t=we("div"),E&&E.c(),r=Ye(),s=we("div"),i=we("div"),o=He(`Items per page:
			`),a=we("div"),It(l.$$.fragment),c=Ye(),u=we("div"),h=He(n[7]),f=He("-"),d=He(n[8]),p=He(" of "),m=He(n[4]),g=Ye(),It(y.$$.fragment),b=Ye(),x=we("input"),S=Ye(),It(C.$$.fragment),Z(t,"class","actions"),Z(a,"class","w-12 ml-2"),Z(i,"class","flex items-center mx-4"),Z(u,"class","mx-3"),Z(x,"class","marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50"),x.value=w=n[3].toString(),Z(s,"class","flex items-center"),Z(e,"class","table-footer svelte-13k2ee6")},m(N,O){me(N,e,O),se(e,t),E&&E.m(t,null),se(e,r),se(e,s),se(s,i),se(i,o),se(i,a),kt(l,a,null),se(s,c),se(s,u),se(u,h),se(u,f),se(u,d),se(u,p),se(u,m),se(s,g),kt(y,s,null),se(s,b),se(s,x),se(s,S),kt(C,s,null),k=!0,A||(M=qn(x,"blur",n[16]),A=!0)},p(N,[O]){N[2].length>0&&N[0].length>0?E?(E.p(N,O),O&5&&Ie(E,1)):(E=x9(N),E.c(),Ie(E,1),E.m(t,null)):E&&(dr(),$e(E,1,1,()=>{E=null}),pr());const R={};O&32&&(R.value=N[5].toString()),l.$set(R),(!k||O&128)&&cn(h,N[7]),(!k||O&256)&&cn(d,N[8]),(!k||O&16)&&cn(m,N[4]);const D={};O&8&&(D.disabled=N[3]===1),O&262144&&(D.$$scope={dirty:O,ctx:N}),y.$set(D),(!k||O&8&&w!==(w=N[3].toString())&&x.value!==w)&&(x.value=w);const z={};O&72&&(z.disabled=N[3]===N[6]),O&262144&&(z.$$scope={dirty:O,ctx:N}),C.$set(z)},i(N){k||(Ie(E),Ie(l.$$.fragment,N),Ie(y.$$.fragment,N),Ie(C.$$.fragment,N),k=!0)},o(N){$e(E),$e(l.$$.fragment,N),$e(y.$$.fragment,N),$e(C.$$.fragment,N),k=!1},d(N){N&&de(e),E&&E.d(),Tt(l),Tt(y),Tt(C),A=!1,M()}}}function m_t(n,e,t){let r,{provider:s}=e,{actions:i}=e,{selected:o}=e,a=1,l=1,c=0,u=0,h=0,f=()=>{};function d(S){t(3,a=S),s.page(S)}function p(S){o=S,t(0,o)}function m(S){gM.call(this,n,S)}function g(S){gM.call(this,n,S)}const y=({detail:S})=>{const C=S==="all"?h:parseInt(S);s.paginate(C),t(5,r=C)},b=()=>{d(a-1)},x=S=>{let C=parseInt(S.currentTarget.value);isNaN(C)||d(Math.max(1,Math.min(l,C)))},w=()=>{d(a+1)};return n.$$set=S=>{"provider"in S&&t(1,s=S.provider),"actions"in S&&t(2,i=S.actions),"selected"in S&&t(0,o=S.selected)},n.$$.update=()=>{n.$$.dirty&2&&t(5,r=s.options.itemsPerPage),n.$$.dirty&1082&&(f(),t(10,f=s.total.subscribe(S=>{S===void 0||S===0?(t(6,l=1),t(7,c=0),t(8,u=0),t(4,h=0)):(t(6,l=Math.ceil(h/r)),t(7,c=(a-1)*r+1),t(8,u=Math.min(h||0,a*r)),t(4,h=S))})))},[o,s,i,a,h,r,l,c,u,d,f,p,m,g,y,b,x,w]}class g_t extends xn{constructor(e){super(),wn(this,e,m_t,p_t,pn,{provider:1,actions:2,selected:0})}}function _9(n,e,t){const r=n.slice();return r[22]=e[t],r[24]=t,r}function S9(n,e,t){const r=n.slice();return r[25]=e[t].type,r[26]=e[t].name,r}function C9(n,e,t){const r=n.slice();return r[26]=e[t].name,r[29]=e[t].sortable,r}function k9(n){let e,t,r,s,i,o,a,l;return{c(){e=we("div"),t=we("sl-alert"),r=we("sl-icon"),s=Ye(),i=we("strong"),i.textContent="Table Data Error",o=we("br"),a=Ye(),l=He(n[9]),Ib(r,"slot","icon"),Ib(r,"name","check2-circle"),Ib(t,"type","danger"),Ib(t,"open",""),Z(e,"class","service-error")},m(c,u){me(c,e,u),se(e,t),se(t,r),se(t,s),se(t,i),se(t,o),se(t,a),se(t,l)},p(c,u){u[0]&512&&cn(l,c[9])},d(c){c&&de(e)}}}function T9(n){let e,t=!n[4]&&E9(n);return{c(){e=we("th"),t&&t.c(),Z(e,"class","svelte-12gp9na")},m(r,s){me(r,e,s),t&&t.m(e,null)},p(r,s){r[4]?t&&(t.d(1),t=null):t?t.p(r,s):(t=E9(r),t.c(),t.m(e,null))},d(r){r&&de(e),t&&t.d()}}}function E9(n){let e,t,r,s;return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].length>0&&n[6].length===n[10].length},m(i,o){me(i,e,o),r||(s=qn(e,"click",n[12]),r=!0)},p(i,o){o[0]&1088&&t!==(t=i[6].length>0&&i[6].length===i[10].length)&&(e.checked=t)},d(i){i&&de(e),r=!1,s()}}}function I9(n){let e,t;return e=new s_t({props:{name:n[26],sortable:n[29],sorting:n[7]}}),e.$on("sort",n[11]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s[0]&1&&(i.name=r[26]),s[0]&1&&(i.sortable=r[29]),s[0]&128&&(i.sorting=r[7]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function A9(n){let e,t;return e=new Bce({props:{type:"slot",$$slots:{default:[y_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s[0]&64|s[1]&2&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function y_t(n){let e,t,r,s;function i(...o){return n[16](n[24],...o)}return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].includes(n[24])},m(o,a){me(o,e,a),r||(s=qn(e,"click",i),r=!0)},p(o,a){n=o,a[0]&64&&t!==(t=n[6].includes(n[24]))&&(e.checked=t)},d(o){o&&de(e),r=!1,s()}}}function M9(n){let e,t;function r(...s){return n[17](n[24],...s)}return e=new Bce({props:{type:n[25],value:n[22][n[26]]}}),e.$on("action",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i[0]&1&&(o.type=n[25]),i[0]&1025&&(o.value=n[22][n[26]]),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function N9(n){let e,t,r,s,i=n[3]&&A9(n),o=n[0],a=[];for(let c=0;c<o.length;c+=1)a[c]=M9(S9(n,o,c));const l=c=>$e(a[c],1,1,()=>{a[c]=null});return{c(){e=we("tr"),i&&i.c(),t=Ye();for(let c=0;c<a.length;c+=1)a[c].c();r=Ye(),Z(e,"class","svelte-12gp9na")},m(c,u){me(c,e,u),i&&i.m(e,null),se(e,t);for(let h=0;h<a.length;h+=1)a[h]&&a[h].m(e,null);se(e,r),s=!0},p(c,u){if(c[3]?i?(i.p(c,u),u[0]&8&&Ie(i,1)):(i=A9(c),i.c(),Ie(i,1),i.m(e,t)):i&&(dr(),$e(i,1,1,()=>{i=null}),pr()),u[0]&17409){o=c[0];let h;for(h=0;h<o.length;h+=1){const f=S9(c,o,h);a[h]?(a[h].p(f,u),Ie(a[h],1)):(a[h]=M9(f),a[h].c(),Ie(a[h],1),a[h].m(e,r))}for(dr(),h=o.length;h<a.length;h+=1)l(h);pr()}},i(c){if(!s){Ie(i);for(let u=0;u<o.length;u+=1)Ie(a[u]);s=!0}},o(c){$e(i),a=a.filter(Boolean);for(let u=0;u<a.length;u+=1)$e(a[u]);s=!1},d(c){c&&de(e),i&&i.d(),qs(a,c)}}}function b_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d=n[9]&&k9(n),p=n[3]&&T9(n),m=n[0],g=[];for(let k=0;k<m.length;k+=1)g[k]=I9(C9(n,m,k));const y=k=>$e(g[k],1,1,()=>{g[k]=null});let b=n[10],x=[];for(let k=0;k<b.length;k+=1)x[k]=N9(_9(n,b,k));const w=k=>$e(x[k],1,1,()=>{x[k]=null});function S(k){n[18](k)}let C={provider:n[1],actions:n[2]};return n[6]!==void 0&&(C.selected=n[6]),u=new g_t({props:C}),hi.push(()=>nd(u,"selected",S)),u.$on("action",n[19]),{c(){d&&d.c(),e=Ye(),t=we("div"),r=we("table"),s=we("thead"),i=we("tr"),p&&p.c(),o=Ye();for(let k=0;k<g.length;k+=1)g[k].c();a=Ye(),l=we("tbody");for(let k=0;k<x.length;k+=1)x[k].c();c=Ye(),It(u.$$.fragment),Z(i,"class","svelte-12gp9na"),Z(s,"class","svelte-12gp9na"),Z(l,"class","svelte-12gp9na"),Z(r,"class","svelte-12gp9na"),Z(t,"class","marcelle table-container svelte-12gp9na")},m(k,A){d&&d.m(k,A),me(k,e,A),me(k,t,A),se(t,r),se(r,s),se(s,i),p&&p.m(i,null),se(i,o);for(let M=0;M<g.length;M+=1)g[M]&&g[M].m(i,null);se(r,a),se(r,l);for(let M=0;M<x.length;M+=1)x[M]&&x[M].m(l,null);se(t,c),kt(u,t,null),f=!0},p(k,A){if(k[9]?d?d.p(k,A):(d=k9(k),d.c(),d.m(e.parentNode,e)):d&&(d.d(1),d=null),k[3]?p?p.p(k,A):(p=T9(k),p.c(),p.m(i,o)):p&&(p.d(1),p=null),A[0]&2177){m=k[0];let E;for(E=0;E<m.length;E+=1){const N=C9(k,m,E);g[E]?(g[E].p(N,A),Ie(g[E],1)):(g[E]=I9(N),g[E].c(),Ie(g[E],1),g[E].m(i,null))}for(dr(),E=m.length;E<g.length;E+=1)y(E);pr()}if(A[0]&25673){b=k[10];let E;for(E=0;E<b.length;E+=1){const N=_9(k,b,E);x[E]?(x[E].p(N,A),Ie(x[E],1)):(x[E]=N9(N),x[E].c(),Ie(x[E],1),x[E].m(l,null))}for(dr(),E=b.length;E<x.length;E+=1)w(E);pr()}const M={};A[0]&2&&(M.provider=k[1]),A[0]&4&&(M.actions=k[2]),!h&&A[0]&64&&(h=!0,M.selected=k[6],td(()=>h=!1)),u.$set(M)},i(k){if(!f){for(let A=0;A<m.length;A+=1)Ie(g[A]);for(let A=0;A<b.length;A+=1)Ie(x[A]);Ie(u.$$.fragment,k),f=!0}},o(k){g=g.filter(Boolean);for(let A=0;A<g.length;A+=1)$e(g[A]);x=x.filter(Boolean);for(let A=0;A<x.length;A+=1)$e(x[A]);$e(u.$$.fragment,k),f=!1},d(k){d&&d.d(k),k&&de(e),k&&de(t),p&&p.d(),qs(g,k),qs(x,k),Tt(u)}}}function v_t(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(s,R=>t(9,i=R)),s),l,c=tt,u=()=>(c(),c=os(r,R=>t(10,l=R)),r);n.$$.on_destroy.push(()=>o()),n.$$.on_destroy.push(()=>c());let{columns:h}=e,{provider:f}=e,{actions:d=[]}=e,{selectable:p=!0}=e,{singleSelection:m=!1}=e,{selection:g=[]}=e,y=[];const b=Oc();let x={col:"",ascending:!0};function w({detail:R}){t(7,x=R),f.sort(R)}async function S(){t(15,g=await Promise.all(y.map(f.get.bind(f)))),b("selection",g)}function C(){y.length===p_(r).length?t(6,y=[]):t(6,y=p_(r).map((R,D)=>D)),S()}function k(R,D){m?(t(6,y=D.currentTarget.checked?[R]:[]),S()):D.currentTarget.checked?y.includes(R)||(t(6,y=y.concat([R])),S()):(t(6,y=y.filter(z=>z!==R)),S())}async function A([R,D]){const z=Array.isArray(D)?await Promise.all(D.map(f.get.bind(f))):await f.get(D);b(R,z)}const M=(R,D)=>k(R,D),E=(R,{detail:D})=>{A([D,R])};function N(R){y=R,t(6,y),t(15,g),t(5,r),t(1,f)}const O=({detail:R})=>A(R);return n.$$set=R=>{"columns"in R&&t(0,h=R.columns),"provider"in R&&t(1,f=R.provider),"actions"in R&&t(2,d=R.actions),"selectable"in R&&t(3,p=R.selectable),"singleSelection"in R&&t(4,m=R.singleSelection),"selection"in R&&t(15,g=R.selection)},n.$$.update=()=>{n.$$.dirty[0]&2&&u(t(5,r=f.data)),n.$$.dirty[0]&2&&a(t(8,s=f.error)),n.$$.dirty[0]&32800&&t(6,y=g.map(R=>p_(r).indexOf(R)))},[h,f,d,p,m,r,y,x,s,i,l,w,C,k,A,g,M,E,N,O]}class Vce extends xn{constructor(e){super(),wn(this,e,v_t,b_t,pn,{columns:0,provider:1,actions:2,selectable:3,singleSelection:4,selection:15},null,[-1,-1])}}function w_t(n){let e,t;const r=n[1].default,s=Hp(r,n,n[0],null);return{c(){e=we("div"),s&&s.c(),Z(e,"class","flex border-solid border-0 border-b border-gray-200 mb-2")},m(i,o){me(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&qp(s,r,i,i[0],t?jp(r,i[0],o,null):Xp(i[0]),null)},i(i){t||(Ie(s,i),t=!0)},o(i){$e(s,i),t=!1},d(i){i&&de(e),s&&s.d(i)}}}function x_t(n,e,t){let{$$slots:r={},$$scope:s}=e;return n.$$set=i=>{"$$scope"in i&&t(0,s=i.$$scope)},[s,r]}class __t extends xn{constructor(e){super(),wn(this,e,x_t,w_t,pn,{})}}const $9={itemsPerPage:10};class Uce{constructor(e=$9){Mt(this,"options");Mt(this,"data",m_([]));Mt(this,"total",m_(0));Mt(this,"error",m_(null));this.options={...$9,...e}}paginate(e){this.options.itemsPerPage=e,this.update()}async get(e){const t=p_(this.data);return e>=0&&e<t.length?t[e]:null}}class S_t extends Uce{constructor({data:t,...r}){super(r);Mt(this,"rawData");Mt(this,"currentPage",1);this.rawData=t,this.total.set(t.length),this.data.set(this.rawData.slice(0,this.options.itemsPerPage))}async update(){this.page(this.currentPage)}async page(t){this.data.set(this.rawData.slice((t-1)*this.options.itemsPerPage,Math.min(t*this.options.itemsPerPage,this.rawData.length))),this.currentPage=t}async sort(t){this.rawData.sort((r,s)=>r[t.col]>s[t.col]?t.ascending?1:-1:r[t.col]<s[t.col]?t.ascending?-1:1:0),this.page(this.currentPage)}async delete(t){return this.rawData.splice(t,1),this.page(this.currentPage),null}}class C_t extends Uce{constructor({service:t,columns:r,transform:s,...i}){super(i);Mt(this,"service");Mt(this,"query");Mt(this,"transform");this.service=t,this.transform=s||{},this.query={$sort:{updatedAt:-1},$limit:this.options.itemsPerPage},r&&(this.query.$select=r.map(o=>o.name).concat(["id"])),this.update(),this.service.on("created",this.update.bind(this)),this.service.on("patched",this.update.bind(this)),this.service.on("updated",this.update.bind(this)),this.service.on("removed",this.update.bind(this))}paginate(t){super.paginate(t),this.query.$limit=this.options.itemsPerPage,this.update()}async update(){try{const t=await this.service.find({query:this.query}),r=t.data.map((s,i)=>{const o=Object.entries(this.transform).map(([a,l])=>{try{return{[a]:l(s,i)}}catch{return{[a]:"transform error"}}}).reduce((a,l)=>({...a,...l}),{});return{...s,...o}});this.data.set(r),this.total.set(t.total),this.error.set(null)}catch(t){this.data.set([]),this.total.set(0),this.error.set(t)}}async page(t){this.query.$skip=(t-1)*this.query.$limit,this.update()}async sort(t){const{col:r,ascending:s}=t;r?this.query.$sort={[r]:s?1:-1}:delete this.query.$sort,this.update()}async delete(t){const r=p_(this.data)[t];return await this.service.remove(r.id),this.update(),r}}function R9(n){let e,t,r;return t=new Fce({props:{progress:n[2],thin:!0}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","absolute top-0 left-0 right-0")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&4&&(o.progress=s[2]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function P9(n){let e,t;return e=new zce({}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function k_t(n){let e,t,r,s,i,o,a,l=n[2]!==!1&&R9(n),c=n[1]&&P9();const u=n[4].default,h=Hp(u,n,n[3],null);return{c(){e=we("div"),l&&l.c(),t=Ye(),r=we("span"),s=He(n[0]),i=Ye(),c&&c.c(),o=Ye(),h&&h.c(),Z(r,"class","card-title"),Z(e,"class","card-container svelte-xnhseh")},m(f,d){me(f,e,d),l&&l.m(e,null),se(e,t),se(e,r),se(r,s),se(e,i),c&&c.m(e,null),se(e,o),h&&h.m(e,null),a=!0},p(f,[d]){f[2]!==!1?l?(l.p(f,d),d&4&&Ie(l,1)):(l=R9(f),l.c(),Ie(l,1),l.m(e,t)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr()),(!a||d&1)&&cn(s,f[0]),f[1]?c?d&2&&Ie(c,1):(c=P9(),c.c(),Ie(c,1),c.m(e,o)):c&&(dr(),$e(c,1,1,()=>{c=null}),pr()),h&&h.p&&(!a||d&8)&&qp(h,u,f,f[3],a?jp(u,f[3],d,null):Xp(f[3]),null)},i(f){a||(Ie(l),Ie(c),Ie(h,f),a=!0)},o(f){$e(l),$e(c),$e(h,f),a=!1},d(f){f&&de(e),l&&l.d(),c&&c.d(),h&&h.d(f)}}}function T_t(n,e,t){let{$$slots:r={},$$scope:s}=e,{title:i}=e,{loading:o=!1}=e,{progress:a=!1}=e;return n.$$set=l=>{"title"in l&&t(0,i=l.title),"loading"in l&&t(1,o=l.loading),"progress"in l&&t(2,a=l.progress),"$$scope"in l&&t(3,s=l.$$scope)},[i,o,a,s,r]}class sa extends xn{constructor(e){super(),wn(this,e,T_t,k_t,pn,{title:0,loading:1,progress:2})}}let b1,PE;function bM({title:n,message:e,duration:t=3e3,type:r="default"}){b1||(b1=document.createElement("div"),b1.id="notification-container",document.body.appendChild(b1),PE=new m1t({target:b1})),PE==null||PE.add({title:n,message:e,duration:t,type:r})}function Dn(n,e,t,r){var s=arguments.length,i=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(i=(s<3?o(i):s>3?o(e,t,i):o(e,t))||i);return s>3&&i&&Object.defineProperty(e,t,i),i}function $t(n,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!r:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(n):r?r.value:e.get(n)}function ir(n,e,t,r,s){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?n!==e||!s:!e.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?s.call(n,t):s?s.value=t:e.set(n,t),t}function Wb(){}var Nm,$m,cI;function E_t(n){}const D9=N8e();function I_t(n){return n&&typeof n=="object"&&n.run!==void 0}function ZV(n){return n&&typeof n=="object"&&n.run!==void 0&&n.id!==void 0}class mt{constructor(e,t=void 0){this.id=mt.nextId++,this.subscribers=[],this.value=void 0,this.ready=!1,Nm.set(this,void 0),$m.set(this,!1),cI.set(this,void 0),ir(this,Nm,!!t,"f");const[r,s]=kH(),[i,o]=kH();this.stopStream=r,this.set=l=>{this.value=l,i(l)};let a;ZV(e)?(a=e,t===void 0&&ir(this,Nm,e.holding,"f"),e.holding&&(this.value=e.value)):I_t(e)?a=e:(a=wH(()=>this.value,qD(e)),this.value=e),this.stream=o7e(xH(this.runListeners.bind(this),CH(s,_H(a,o))))}get(){return this.value}get holding(){return $t(this,Nm,"f")}run(e,t){return this.stream.run(e,t)}runListeners(e){this.value=e;for(const t of this.subscribers)t(e)}subscribe(e=E_t,t=Wb){$t(this,Nm,"f")&&$t(this,$m,"f")&&e(this.value);const r=s=>{t(),e(s)};return this.subscribers.push(r),$t(this,$m,"f")||this.start(),()=>{const s=this.subscribers.indexOf(r);s!==-1&&this.subscribers.splice(s,1)}}async start(){return $t(this,$m,"f")||(mt.numActive++,tqe(this.stream,D9).then(()=>{mt.numActive--}),ir(this,$m,!0,"f"),ir(this,cI,new Promise((e,t)=>{WN({run:()=>{this.ready=!0,e()},error(r){t(r)},dispose(){}},D9)}),"f")),$t(this,cI,"f")}stop(){this.stopStream(void 0),ir(this,$m,!1,"f")}hold(e=!0){return ir(this,Nm,e,"f"),this}thru(e){return new mt(e(this))}startWith(e){const t=new mt(f7e(e,this));return this.holding&&(t.value=e),t}continueWith(e){const t=new mt(g7e(e,this));return this.holding&&(t.value=this.value),t}map(e){const t=new mt(wH(e,this));return this.holding&&(t.value=e(this.value)),t}constant(e){const t=new mt(d7e(e,this));return this.holding&&(t.value=e),t}tap(e){const t=new mt(xH(e,this));return this.holding&&(t.value=this.value),t}ap(e){const t=new mt(p7e(e,this));return this.holding&&e.holding&&(t.value=e.get()(this.value)),t}scan(e,t){const r=new mt(h7e(e,t,this));return this.holding&&(r.value=t),r}loop(e,t){return new mt(u7e(e,t,this))}withItems(e){return new mt(S7e(e,this))}zipItems(e,t){return new mt(_7e(e,t,this))}switchLatest(){return new mt(T9e(this))}join(){return new mt(vee(this))}chain(e){return new mt(m7e(e,this))}concatMap(e){return new mt(y7e(e,this))}mergeConcurrently(e){return new mt(b7e(e,this))}mergeMapConcurrently(e,t){return new mt(v7e(e,t,this))}merge(e){const t=new mt(_H(e,this));return this.holding&&(t.value=this.value),t}combine(e,t){const r=new mt(w7e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}zip(e,t){const r=new mt(C7e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}resample(e){return new mt(SH(this,e))}sample(e){return new mt(SH(e,this))}snapshot(e,t){return new mt(x7e(e,t,this))}filter(e){const t=new mt(k7e(e,this));return this.holding&&e(this.value)&&(t.value=this.value),t}skipRepeats(){const e=new mt(N9e(this));return this.holding&&(e.value=this.value),e}skipRepeatsWith(e){return new mt(T7e(e,this))}slice(e,t){return new mt(A7e(e,t,this))}take(e){return new mt(E7e(e,this))}skip(e){return new mt(I7e(e,this))}takeWhile(e){return new mt(M7e(e,this))}skipWhile(e){return new mt(N7e(e,this))}skipAfter(e){return new mt($7e(e,this))}until(e){return new mt(CH(e,this))}since(e){return new mt(R7e(e,this))}during(e){return new mt(P7e(e,this))}delay(e){return new mt(D7e(e,this))}withLocalTime(e){return new mt(c7e(e,this))}throttle(e){return new mt(O7e(e,this))}debounce(e){return new mt(F7e(e,this))}awaitPromises(){return new mt(Z9e(this))}recoverWith(e){return new mt(L7e(e,this))}static empty(){return new mt(Ki())}static never(){return new mt(F_())}static now(e){return new mt(qD(e))}static at(e,t){return new mt(fee(e,t))}static periodic(e){return new mt(Q8e(e))}static throwError(e){return new mt(n7e(e))}}Nm=new WeakMap,$m=new WeakMap,cI=new WeakMap;mt.nextId=0;mt.numActive=0;var vc;(function(n){n[n.Debug=0]="Debug",n[n.Info=1]="Info",n[n.Warning=2]="Warning",n[n.Error=3]="Error"})(vc||(vc={}));const V1=new mt(F_()),ya={log(...n){console.log(...n),V1.set([vc.Info,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},debug(...n){V1.set([vc.Debug,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},info(...n){this.log(...n)},warning(...n){V1.set([vc.Warning,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},error(...n){console.error(...n),V1.set([vc.Error,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])}};function A_t(){return V1}function Ln(n,e,t){const r=t.value;return t.value=function(...i){try{return r.apply(this,i)}catch(o){return ya.error(o),bM({title:o.name,message:o.message,type:"danger"}),o}},t}class Ip extends Error{constructor(e){super(e),this.name="Training Error"}}function Ea(n,{duration:e=3e3}={}){ya.error(`${n.name}: ${n.message}`,n),bM({title:n.name,message:n.message,type:"danger",duration:e})}function Wce(n,e){return async function*(){let t=0;for await(const r of n())e(r,t++)&&(yield await r)}}function eD(n,e){return async function*(){let t=0;for await(const r of n())yield await e(r,t++)}}function M_t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){yield*Wce(n,(t,r)=>r>=e)()}}function N_t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){let t=e;for await(const r of n()){if(t--===0)return;yield await r}}}function tD(n,e){return async function*(){yield*await n(),yield*await e}}async function $_t(n,e){let t=0;for await(const r of n())e(r,t++)}async function R_t(n){const e=[];for await(const t of n())e.push(t);return e}function P_t(n,e){return async function*(){const t=e()[Symbol.asyncIterator]();for await(const r of n()){const s=await t.next();if(s.done)return;yield[r,s.value]}}}async function D_t(n,e,t){let[r,s]=[-1,t];for await(const i of n())s=++r===0&&t===void 0?i:e(s,i,r);if(t===void 0&&r===-1)throw new Error("Sequence contains no elements.");return s}function O_t(n){return typeof n[Symbol.iterator]=="function"}function F_t(n){return typeof n[Symbol.asyncIterator]=="function"}class ml{constructor(e){this.source=e}[Symbol.asyncIterator](){return this.source()[Symbol.asyncIterator]()}entries(){return new ml(eD(this.source,(e,t)=>[t,e]))}keys(){return new ml(eD(this.source,(e,t)=>t))}values(){return new ml(this.source)}forEach(e){return $_t(this.source,e)}concat(e){return O_t(e)?new ml(tD(this.source,async function*(t){yield*t}(e))):F_t(e)?new ml(tD(this.source,e)):new ml(tD(this.source,async function*(t){yield t}(e)))}reduce(e,t){return D_t(this.source,e,t)}filter(e){return new ml(Wce(this.source,e))}take(e){return new ml(N_t(this.source,e))}skip(e){return new ml(M_t(this.source,e))}map(e){return new ml(eD(this.source,e))}zip(e){return new ml(P_t(this.source,e))}toArray(){return R_t(this.source)}}function nD(n){return n&&typeof n=="object"&&!Array.isArray(n)}function vl(n,...e){if(!e.length)return n;const t=e.shift(),r={...n};if(nD(n)&&nD(t))for(const s in t)nD(t[s])?(r[s]||Object.assign(r,{[s]:{}}),r[s]=vl(r[s],t[s])):Object.assign(r,{[s]:t[s]});return vl(r,...e)}window&&(window.onerror=n=>{typeof n=="string"&&bM({title:"An error occurred",message:n,type:"danger"})},window.addEventListener("unhandledrejection",n=>{bM({title:"An error occurred",message:n.reason,type:"danger"})}));let L_t=0;class Aa{constructor(){this.id=`component-${String(L_t++).padStart(3,"0")}`,this.$$={streams:[],app:void 0},G7e(this)}destroy(){var e;(e=this.$$.app)===null||e===void 0||e.$destroy(),this.$$.app=void 0}start(){this.$$.streams=Object.entries(this).filter(([e,t])=>e[0]==="$"&&ZV(t)).map(([,e])=>(e.start(),e))}stop(){for(const e of this.$$.streams)e.stop()}dispose(){this.destroy(),this.stop()}}let rD=~~(Math.random()*16777215);const sD=parseInt((Math.random()*16777215).toString(),10);function z_t(){const n=~~(Date.now()/1e3),e=Math.floor(Math.random()*1e5);rD=(rD+1)%16777215;const t=rD,r=new Uint8Array(12);return r[3]=n&255,r[2]=n>>8&255,r[1]=n>>16&255,r[0]=n>>24&255,r[6]=sD&255,r[5]=sD>>8&255,r[4]=sD>>16&255,r[8]=e&255,r[7]=e>>8&255,r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r.reduce((s,i)=>s+`0${i.toString(16)}`.slice(-2),"")}const Rm=document.createElement("canvas"),db=Rm.getContext("2d"),v1=new Image;function O9(n){return new Promise((e,t)=>{n?(v1.addEventListener("load",()=>{Rm.width=v1.width,Rm.height=v1.height,db==null||db.drawImage(v1,0,0,Rm.width,Rm.height),e(db==null?void 0:db.getImageData(0,0,Rm.width,Rm.height))},!1),v1.src=n):t()})}function B_t(n){const{data:e,service:t}=n;return n.data={[t.id]:z_t(),...e},n}function Cm(n){const{result:e,params:t}=n;if(e){if(e._id)e.id=e._id,delete e._id;else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())s._id&&(e.data[r].id=e.data[r]._id,delete e.data[r]._id)}else t&&t.query&&(t.query.id&&(n.params.query._id=n.params.query.id,delete n.params.query.id),t.query.$select&&t.query.$select.includes("id")&&!t.query.$select.includes("_id")&&n.params.query.$select.push("_id"));return n}function V_t(n){return n.data||(n.data={}),n.data.createdAt=new Date,n.data.updatedAt=n.data.createdAt,n}function F9(n){return!n.data||!n.data.createdAt||(n.data.updatedAt=new Date),n}function U_t(n,e){return t=>{const{data:r}=t;return t.data={[n]:e,...r},t}}function w1(n,e){return t=>(t.params=t.params||{},t.params.query=t.params.query||{},t.params.query[n]=e,t)}const uI=document.createElement("canvas"),W_t=uI.getContext("2d");async function G_t(n){const{data:e}=n;for(const[t,r]of Object.entries(e))if(r instanceof ImageData){const s=r.width,i=r.height;uI.width=s,uI.height=i,W_t.putImageData(r,0,0),n.data[t]=uI.toDataURL("image/jpeg")}return n}async function L9(n){if(!n.result)return n;const{result:e}=n,t=r=>r&&typeof r=="string"&&r.slice(0,22)==="data:image/jpeg;base64";if(e._id)for(const[r,s]of Object.entries(e).filter(([i])=>i!=="thumbnail"))t(s)&&(e[r]=await O9(s));else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())for(const[i,o]of Object.entries(s).filter(([a])=>a!=="thumbnail"))t(o)&&(e.data[r][i]=await O9(o));return n}async function H_t(n){var e,t;if(!(!((t=(e=n.params)===null||e===void 0?void 0:e.query)===null||t===void 0)&&t.$distinct)||n.type!=="before"||n.method!=="find")return n;const{$distinct:r,...s}=n.params.query;s.$select=[r],s.$skip=0;let i=1;const o=new Set;for(;s.$skip<i;){const a=await n.service.find({query:s});for(const l of a.data)o.add(l[r]);s.$skip+=a.limit,i=a.total}return n.result=Array.from(o),n}function j_t(n){let e;return{c(){e=He("Register")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function q_t(n){let e;return{c(){e=He("Log In")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function z9(n){let e,t,r,s,i,o,a,l,c;return{c(){e=we("div"),t=we("span"),t.innerHTML='<i class="fas fa-bell"></i>',r=Ye(),s=we("span"),i=we("b"),i.textContent="Login Error",o=Ye(),a=He(n[1]),l=Ye(),c=we("button"),c.innerHTML="<span>×</span>",Z(t,"class","text-xl inline-block mr-5 align-middle"),Z(i,"class","capitalize"),Z(s,"class","inline-block align-middle mr-8"),Z(c,"class","absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none"),Z(e,"class","text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500")},m(u,h){me(u,e,h),se(e,t),se(e,r),se(e,s),se(s,i),se(s,o),se(s,a),se(e,l),se(e,c)},p(u,h){h&2&&cn(a,u[1])},d(u){u&&de(e)}}}function X_t(n){let e;return{c(){e=He("Register")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function K_t(n){let e;return{c(){e=He("Log In")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Y_t(n){let e,t,r,s;return{c(){e=He(`Already have an account?
        `),t=we("button"),t.textContent="Log In",Z(t,"class","text-blue-500")},m(i,o){me(i,e,o),me(i,t,o),r||(s=qn(t,"click",n[2]),r=!0)},p:tt,d(i){i&&de(e),i&&de(t),r=!1,s()}}}function Z_t(n){let e,t,r,s;return{c(){e=He(`Don't have an account?
        `),t=we("button"),t.textContent="Register Here",Z(t,"class","text-blue-500")},m(i,o){me(i,e,o),me(i,t,o),r||(s=qn(t,"click",n[2]),r=!0)},p:tt,d(i){i&&de(e),i&&de(t),r=!1,s()}}}function J_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b;function x(R,D){return R[0]==="login"?q_t:j_t}let w=x(n),S=w(n),C=n[1]&&z9(n);function k(R,D){return R[0]==="login"?K_t:X_t}let A=k(n),M=A(n);function E(R,D){return R[0]==="login"?Z_t:Y_t}let N=E(n),O=N(n);return{c(){e=we("div"),t=we("div"),r=we("h2"),S.c(),s=Ye(),i=we("p"),i.textContent="This Marcelle application requires authentication.",o=Ye(),C&&C.c(),a=Ye(),l=we("form"),c=we("div"),c.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> 
        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>`,u=Ye(),h=we("div"),h.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> 
        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>`,f=Ye(),d=we("div"),p=we("button"),M.c(),m=Ye(),g=we("p"),O.c(),Z(r,"class","text-xl"),Z(i,"class","text-gray-600"),Z(t,"class","p-4 text-center"),Z(c,"class","relative w-full mb-3"),Z(h,"class","relative w-full mb-3"),Z(p,"class","bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full"),Z(p,"type","submit"),cu(p,"transition","all 0.15s ease 0s"),Z(d,"class","text-center mt-6"),Z(g,"class","my-4"),Z(e,"class","marcelle p-12")},m(R,D){me(R,e,D),se(e,t),se(t,r),S.m(r,null),se(t,s),se(t,i),se(e,o),C&&C.m(e,null),se(e,a),se(e,l),se(l,c),se(l,u),se(l,h),se(l,f),se(l,d),se(d,p),M.m(p,null),se(e,m),se(e,g),O.m(g,null),y||(b=qn(l,"submit",ZC(n[7])),y=!0)},p(R,D){w!==(w=x(R))&&(S.d(1),S=w(R),S&&(S.c(),S.m(r,null))),R[1]?C?C.p(R,D):(C=z9(R),C.c(),C.m(e,a)):C&&(C.d(1),C=null),A!==(A=k(R))&&(M.d(1),M=A(R),M&&(M.c(),M.m(p,null))),N===(N=E(R))&&O?O.p(R,D):(O.d(1),O=N(R),O&&(O.c(),O.m(g,null)))},d(R){R&&de(e),S.d(),C&&C.d(),M.d(),O.d(),y=!1,b()}}}function Q_t(n){let e,t;return e=new Oce({props:{$$slots:{default:[J_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&515&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function eSt(n,e,t){const r=Oc();let{dataStore:s}=e,{mode:i="login"}=e,o;function a(){t(0,i=i==="login"?"register":"login")}function l(f){r("terminate",f)}async function c(f){const d=new FormData(f.target);try{const p=await s.login(d.get("email"),d.get("password"));l(p)}catch(p){t(1,o=p)}}async function u(f){const d=new FormData(f.target);try{const p=await s.signup(d.get("email"),d.get("password"));l(p)}catch{l(null)}}const h=f=>i==="login"?c(f):u(f);return n.$$set=f=>{"dataStore"in f&&t(5,s=f.dataStore),"mode"in f&&t(0,i=f.mode)},[i,o,a,c,u,s,l,h]}class tSt extends xn{constructor(e){super(),wn(this,e,eSt,Q_t,pn,{dataStore:5,mode:0,terminate:6})}get terminate(){return this.$$.ctx[6]}}class Ab extends ml{constructor(e,t={}){super(async function*(){const r={query:{},skip:0,take:-1,...t},s=r.take;let i=0,o=[];const a={...r.query,$skip:r.skip,$limit:10};for(;;)try{if(s>0&&i>=s)return;if(i++,o.length>0)yield o.shift();else{const l=await e.find({query:a});if(a.$skip=l.skip+l.limit,o=l.data,o.length>0)yield o.shift();else return}}catch(l){throw l.message=`Error thrown while iterating through a service: ${l.message}`,l}}),this.service=e,this.params={query:{},skip:0,take:-1,...t}}skip(e){return new Ab(this.service,{...this.params,skip:e})}take(e){return new Ab(this.service,{...this.params,take:e})}select(e){const t=tZe.cloneDeep(this.params);return t.query.$select=e,new Ab(this.service,t)}query(e){return new Ab(this.service,vl(this.params,{query:e}))}}function nSt(n){return new Ab(n)}var hI,U1,W1,_b,G1;function rSt(n){try{new URL(n)}catch{return!1}return!0}var bl;(function(n){n[n.Memory=0]="Memory",n[n.LocalStorage=1]="LocalStorage",n[n.Remote=2]="Remote"})(bl||(bl={}));class Gce{constructor(e="memory"){if(this.requiresAuth=!1,this.apiPrefix="",this.$services=new mt([],!0),hI.set(this,void 0),U1.set(this,void 0),W1.set(this,Promise.resolve()),_b.set(this,!1),G1.set(this,Wb),this.feathers=_Ye(),this.location=e,rSt(e)){this.backend=bl.Remote;const t=new URL(e),r=t.host;this.apiPrefix=t.pathname.replace(/\/$/,"");const s=NKe(r,{transports:["websocket"],reconnectionAttempts:5,path:this.apiPrefix+"/socket.io"});this.feathers.configure(NYe(s,{timeout:15e3})),ir(this,hI,new Promise(i=>{this.feathers.io.on("init",({auth:o})=>{this.requiresAuth=o,o&&this.feathers.configure(YKe({path:`${this.apiPrefix}/authentication`})),i()})}),"f")}else if(e==="localStorage"){this.backend=bl.LocalStorage;const t=r=>eZe({storage:window.localStorage,name:r,id:"_id",multi:!0,paginate:{default:100,max:200}});ir(this,G1,r=>{this.feathers.use(`/${r}`,t(r))},"f")}else if(e==="memory")this.backend=bl.Memory,ir(this,G1,t=>{this.feathers.use(`/${t}`,ZYe({id:"_id",paginate:{default:100,max:200}}))},"f");else throw new Error(`Cannot process backend location '${e}'`);this.setupAppHooks()}async connect(){return this.backend!==bl.Remote?{email:null}:($t(this,U1,"f")||(ya.log(`Connecting to backend ${this.location}...`),ir(this,U1,new Promise((e,t)=>{this.feathers.io.on("connect",()=>{ya.log(`Connected to backend ${this.location}!`),e()}),this.feathers.io.on("reconnect_failed",()=>{const r=new Error(`Cannot reach backend at location ${this.location}. Is the server running?
          If using locally, run 'npm run backend'`);r.name="DataStore connection error",t(),Ea(r,{duration:0})})}),"f")),await $t(this,hI,"f"),await $t(this,U1,"f"),this.authenticate())}async authenticate(){if(!this.requiresAuth)return this.user={email:null},this.user;if(this.user)return this.user;const e=()=>(ir(this,_b,!0,"f"),new Promise((t,r)=>{this.feathers.reAuthenticate().then(({user:s})=>{ir(this,_b,!1,"f"),this.user=s,ya.log(`Authenticated as ${s.email}`),t()}).catch(s=>{ir(this,_b,!1,"f"),r(s)})}));return ir(this,W1,$t(this,W1,"f").then(()=>$t(this,_b,"f")?null:e()),"f"),$t(this,W1,"f").then(()=>this.user)}async login(e,t){const r=await this.feathers.authenticate({strategy:"local",email:e,password:t});return this.user=r.user,this.user}async loginWithUI(){const e=new tSt({target:document.body,props:{dataStore:this}});return new Promise((t,r)=>{e.$on("terminate",s=>{e.$destroy(),s?t(s):r()})})}async signup(e,t){try{return await this.service("users").create({email:e,password:t}),await this.login(e,t),this.user}catch(r){return ya.error("An error occurred during signup",r),{email:null}}}async logout(){await this.feathers.logout(),document.location.reload()}service(e){const t=Object.keys(this.feathers.services).includes(e);t||($t(this,G1,"f").call(this,e),this.$services.set(Object.keys(this.feathers.services)));const r=this.backend===bl.Remote?this.feathers.service(`${this.apiPrefix}/${e}`):this.feathers.service(e);return t||(r.items=()=>nSt(r)),r}setupAppHooks(){const e=this.backend!==bl.Remote?[B_t]:[],t=this.backend!==bl.Remote?[H_t]:[];this.feathers.hooks({before:{find:[...t,Cm],create:[...e,V_t],update:[F9],patch:[F9]},after:{find:[Cm],get:[Cm],create:[Cm],update:[Cm],patch:[Cm],remove:[Cm]}})}}hI=new WeakMap,U1=new WeakMap,W1=new WeakMap,_b=new WeakMap,G1=new WeakMap;function JV(n){return new Gce(n)}async function GS(n,e,t){const r=document.createElement("a");r.style.display="none",document.body.appendChild(r);const s=new Blob([n],{type:t});r.href=URL.createObjectURL(s),r.download=e,r.click()}async function Hce(n){return new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const s=JSON.parse(r.result);e(s)},r.onerror=s=>{t(s)},r.readAsText(n)})}function JC(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[\s_]+/g,"-").toLowerCase()}var H1,j1;class sSt extends Aa{constructor(e,t=JV()){super(),this.title="dataset",this.isDataset=!0,H1.set(this,void 0),this.query={},j1.set(this,new Set),this.$count=new mt(0,!0),this.$changes=new mt([]),this.name=e,this.title=`dataset (${e})`,ir(this,H1,t,"f"),this.start(),this.ready=new Promise((r,s)=>{$t(this,H1,"f").connect().then(()=>this.setup()).then(r).catch(i=>{const o=new Error(i==null?void 0:i.message);o.name=`Dataset Error (${e}): datastore connection failed`,Ea(o,{duration:0}),s(o)})})}async setup(){const e=JC(`instances-${this.name}`);this.instanceService=$t(this,H1,"f").service(e),this.instanceService.__hooks.before.find===void 0&&this.instanceService.hooks({before:{all:[],create:[U_t("datasetName",this.name),G_t],find:[w1("datasetName",this.name)],get:[w1("datasetName",this.name)],update:[w1("datasetName",this.name)],patch:[w1("datasetName",this.name)],remove:[w1("datasetName",this.name)]},after:{find:[L9],get:[L9]}}),this.instanceService.hooks({before:{update:[this.checkUpdates],patch:[this.checkUpdates]}}),await this.reset(),this.watchChanges()}async reset(){const{total:e}=await this.find({query:{$limit:0}});this.$count.set(e),this.$changes.set([{level:"dataset",type:"created"}])}async checkUpdates(e){if(Object.keys(this.query).length===0)return;const t=t6(this.query),r=t(e.data);try{const s=await this.get(e.id);t(s)&&!r&&(this.$count.set(this.$count.get()-1),this.$changes.set([{level:"instance",type:"removed",data:s}]))}catch{$t(this,j1,"f").add(e.id)}}watchChanges(){const e=t6(this.query);this.instanceService.on("created",r=>{if(!e(r))return;const s={...r,id:r.id||r._id};this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}])});const t=r=>{if(!e(r))return;const s={...r,id:r.id||r._id};$t(this,j1,"f").has(s.id)?(this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}]),$t(this,j1,"f").delete(s.id)):this.$changes.set([{level:"instance",type:"updated",data:s}])};this.instanceService.on("updated",t),this.instanceService.on("patched",t),this.instanceService.on("removed",r=>{if(!e(r))return;this.$count.set(this.$count.get()-1);const s={...r,id:r.id||r._id};this.$changes.set([{level:"instance",type:"removed",data:s}])})}async sift(e={}){return this.query=e,this.ready.then(()=>this.reset())}items(){return this.instanceService.items().query(this.query)}async find(e){const t=vl(e||{},{query:this.query});return this.instanceService.find(t)}async get(e,t){const r=vl(t||{},{query:this.query});return this.instanceService.get(e,r)}async create(e,t){const r=vl(t||{},{query:this.query});return this.instanceService.create(e,r)}async update(e,t,r){const s=vl(r||{},{query:this.query});return this.instanceService.update(e,t,s)}async patch(e,t,r){const s=vl(r||{},{query:this.query});return this.instanceService.patch(e,t,s)}async remove(e,t){const r=vl(t||{},{query:this.query});return this.instanceService.remove(e,r)}async clear(){await this.remove(null,{query:{}})}async distinct(e){const t={$distinct:e,...this.query};return this.instanceService.find({query:t})}async download(){const e=await this.find(),t={marcelleMeta:{type:"dataset"},instances:e.data},r=new Date(Date.now()),s=`${this.title}-${r.toISOString()}.json`;await GS(JSON.stringify(t),s,"text/plain")}async upload(e){const t=e.filter(i=>i.type==="application/json").map(i=>Hce(i)),s=(await Promise.all(t)).map(i=>i.instances.map(o=>{const{id:a,...l}=o;return this.create(l).catch(c=>{Ea(c)})}));await Promise.all(s)}mount(){}}H1=new WeakMap,j1=new WeakMap;function jce(n,e){return new sSt(n,e)}function Uf(n){return typeof n=="object"&&n!==null&&n.isDataset}class l0 extends Aa{constructor(){super(),this.ready=!1,this.$training=new mt({status:"idle"},!0),this.$training.start(),this.$training.subscribe(({status:e})=>{(e==="success"||e==="loaded")&&(this.ready=!0)})}sync(e,t){return this.syncData={name:t,store:e},this.syncData.store.connect().then(()=>{this.syncData.service=this.syncData.store.service(this.serviceName),this.setupSync()}).catch(r=>{const s=new Error(r==null?void 0:r.message);s.name=`Model Sync Error (${t}): datastore connection failed`,Ea(s,{duration:0})}),this}async setupSync(){if(!this.syncData.service)return;const{data:e}=await this.syncData.service.find({query:{name:this.syncData.name,$select:["id"],$limit:1,$sort:{updatedAt:-1}}});let t=null;e.length===1&&(t=e[0].id,this.load(this.syncData.store,t));let r=!1;this.$training.subscribe(({status:i,data:o})=>{(i==="success"||i==="loaded"&&(o==null?void 0:o.source)!=="datastore")&&(r=!0,this.save(this.syncData.store,this.syncData.name,{},t).then(a=>{t=a}))});const s=i=>{(i._id===t||!t&&i.name===this.syncData.name)&&(t=i._id,r||this.load(this.syncData.store,t),r=!1)};this.syncData.service.on("created",s),this.syncData.service.on("updated",s),this.syncData.service.on("patched",s)}async saveToDatastore(e,t,r=null){await e.connect();const s=e.service(this.serviceName);if(!s||!t)return null;let i=r;return r?await s.update(r,t):i=(await s.create(t)).id,ya.info(`Model was saved to data store at location ${e.location}`),i}async loadFromDatastore(e,t){await e.connect();const r=e.service(this.serviceName);if(!r||!t)return null;let s;try{s=await r.get(t)}catch{const{data:o}=await r.find({query:{name:t,$limit:1,$sort:{updatedAt:-1}}});o.length===1&&(s=o[0])}if(s){const i=s.name;ya.info(`Model ${i} was loaded from data store at location ${e.location}`)}return s}mount(){}}function qce(n){if(!n.modelTopology.model_config||!n.modelTopology.model_config.config||!n.modelTopology.model_config.config.layers||n.modelTopology.model_config.config.layers.length>0&&!n.modelTopology.model_config.config.layers[0].class_name)return n;try{let e=!1;for(const[t,r]of n.modelTopology.model_config.config.layers.entries())if(r.class_name==="SeparableConv2D"){const s=["kernel_constraint","kernel_initializer","kernel_regularizer"];for(const i of s)Object.keys(n.modelTopology.model_config.config.layers[t].config).includes(i)&&(e=!0),delete n.modelTopology.model_config.config.layers[t].config[i]}e&&ya.warning("TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers")}catch(e){ya.warning("TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers",e)}return n}function wL(...n){const e=cN(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return qce(s)},e}function Xce(...n){const e=MY(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return qce(s)},e}class X$ extends l0{constructor(){super(...arguments),this.serviceName="tfjs-models"}async warmup(){const e=this.model.inputs[0].shape.map(r=>r&&r>0?r:1),t=this.model.predict(Se(()=>ms(e)));await t.data(),t.dispose()}async save(e,t,r,s=null){if(!this.model)return null;let i;if(e.backend===bl.LocalStorage)await this.model.save(`indexeddb://${t}`),i=[["main",`indexeddb://${t}`]];else if(e.backend===bl.Remote){const a={};if(e.requiresAuth){const l=await e.feathers.authentication.getAccessToken(),c=new Headers({Authorization:`Bearer ${l}`});a.requestInit={headers:c}}i=await this.model.save(wL(`${e.location}/tfjs-models/upload`,a)).then(l=>l.responses[0].json())}const o={name:t,files:i,format:"tfjs",metadata:{tfjsModelFormat:this.model instanceof Yd?"layers-model":"graph-model",...this.labels&&{labels:this.labels},...r}};return this.saveToDatastore(e,o,s)}async load(e,t){if(!t)return null;this.$training.set({status:"loading"}),this.ready=!1,await K2();try{const r=await this.loadFromDatastore(e,t);this.loadFn=r.metadata.tfjsModelFormat==="graph-model"?Rl:J_;let s;if(e.backend===bl.LocalStorage)s=await this.loadFn(r.files[0][1]);else if(e.backend===bl.Remote){const i={};if(e.requiresAuth){const o=await e.feathers.authentication.getAccessToken(),a=new Headers({Authorization:`Bearer ${o}`});i.requestInit={headers:a}}s=await this.loadFn(wL(`${e.location}/tfjs-models/${r.id}/model.json`,i))}return s&&(this.model=s,await this.warmup()),r.metadata&&r.metadata.labels?this.labels=r.metadata.labels:this.labels=void 0,this.$training.set({status:"loaded",data:{source:"datastore",url:e.location}}),r}catch(r){throw console.log("[tfjs-model] Loading error",r),this.$training.set({status:"error"}),r}}async download(e){const t=JC(this.title),r={type:"tfjs-model",tfjsModelFormat:this.model instanceof Yd?"layers-model":"graph-model",name:t,...this.labels&&{labels:this.labels},...e},s=new Date(Date.now());await this.model.save(OY(async i=>{const o={modelTopology:i.modelTopology,weightsManifest:[{paths:[`./${t}.weights.bin`],weights:i.weightSpecs}],marcelle:r};return await GS(i.weightData,`${t}.weights.bin`,"application/octet-stream"),await GS(JSON.stringify(o),`${t}.json`,"text/plain"),{modelArtifactsInfo:{dateSaved:s,modelTopologyType:"JSON"}}}))}async upload(...e){this.$training.set({status:"loading"});try{const t=e.filter(o=>o.name.includes(".json")),r=e.filter(o=>o.name.includes(".bin")),{marcelle:s}=await new Promise((o,a)=>{const l=new FileReader;l.onload=()=>{const c=JSON.parse(l.result);o(c)},l.onerror=c=>a(new Error(`The provided files are not a valid marcelle model ${c}`)),l.readAsText(t[0])});if(this.loadFn=s.tfjsModelFormat==="graph-model"?Rl:J_,t.length===1&&e.length){const o=await this.loadFn(Xce([t[0],...r]));return o&&(this.model=o,await this.warmup()),s&&s.labels?this.labels=s.labels:this.labels=null,this.$training.set({status:"loaded",data:{source:"file"}}),{name:s.name,format:"tfjs",files:[],metadata:s}}const i=new Error("The provided files are not compatible with this model");throw i.name="File upload error",i}catch(t){throw this.$training.set({status:"error"}),t}}}Dn([Ln],X$.prototype,"warmup",null);Dn([Ln],X$.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iSt=1e-7,oSt=1e-4;class aSt{refCount(e){return Ba("refCount")}incRef(e){return Ba("incRef")}timerAvailable(){return!0}time(e){return Ba("time")}read(e){return Ba("read")}readSync(e){return Ba("readSync")}readToGPU(e,t){return Ba("readToGPU")}numDataIds(){return Ba("numDataIds")}disposeData(e,t){return Ba("disposeData")}write(e,t,r){return Ba("write")}move(e,t,r,s,i){return Ba("move")}createTensorFromGPUData(e,t,r){return Ba("createTensorFromGPUData")}memory(){return Ba("memory")}floatPrecision(){return Ba("floatPrecision")}epsilon(){return this.floatPrecision()===32?iSt:oSt}dispose(){return Ba("dispose")}}function Ba(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Gb(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Kce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function lSt(n){return n%1===0}function fI(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Yce(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),Bi(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),Bi(n.every(r=>lSt(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function cSt(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:Yce(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function uSt(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function hSt(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function xL(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function fSt(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function QV(n){return typeof n=="string"||n instanceof String}function dSt(n){return typeof n=="boolean"}function pSt(n){return typeof n=="number"}function eU(n){return Array.isArray(n)?eU(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":pSt(n)?"float32":QV(n)?"string":dSt(n)?"bool":"float32"}function B9(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Zce(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Jce(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=Jce(n+l*a,o,t,r)}return s}function V9(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Jce(0,n,e,t)}function mSt(n,e){const t=Qce(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Qce(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function gSt(n){n.forEach(e=>{Bi(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function tU(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9="tfjsflags";class ySt{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bSt,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ja().getBool("IS_TEST")||ja().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];ja().getBool("IS_TEST")||ja().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(tU(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);U9 in e&&e[U9].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=wSt(s,i)})}}function bSt(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(vSt(e,r[0],r[1]),r.join("="))),e}function vSt(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function wSt(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ja(){return eue}let eue=null;function xSt(n){eue=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iD;function tue(){if(iD==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");iD=n}return iD}function _St(){const n=tue();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function nU(n,e){const t=_St();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const SSt="Abs",CSt="Add",kSt="ArgMax",TSt="BatchMatMul",nue="Cast",ESt="ComplexAbs",ISt="ExpandDims",ASt="GatherV2",MSt="Identity",NSt="Max",$St="Min",RSt="Multiply",PSt="Pow",DSt="Reshape",OSt="Sqrt",FSt="Sum";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(...n){ja().getBool("IS_TEST")||ja().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rue=nU("kernelRegistry",()=>new Map),LSt=nU("gradRegistry",()=>new Map);function W9(n,e){const t=zSt(n,e);return rue.get(t)}function G9(n){return LSt.get(n)}function H9(n){const e=rue.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function zSt(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BSt(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VSt(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function sue(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=HS(n)),ja().getBool("DEBUG")&&uSt(n,e),VSt(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function vM(){return ja().platform.now()}function USt(n,e="utf-8"){return e=e||"utf-8",ja().platform.encode(n,e)}function j9(n,e="utf-8"){return e=e||"utf-8",ja().platform.decode(n,e)}function Pu(n){return ja().platform.isTypedArray!=null?ja().platform.isTypedArray(n):BSt(n)}function HS(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||tU(n)||n==null||Pu(n)&&t)e.push(n);else if(Array.isArray(n)||Pu(n))for(let r=0;r<n.length;++r)HS(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)HS(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WSt{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new HSt)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=vM();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:vM()-a})}if(ja().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{GSt(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function GSt(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class HSt{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?fI(`${s}ms`,9):s.error,l=fI(e,25),c=t.rank,u=t.size,h=fI(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jSt(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function qSt(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Kce(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q9=20,_1=3,oD=7;function XSt(n,e,t,r){const s=Zce(e),i=KSt(n,e,t,s),o=e.length,a=dI(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function KSt(n,e,t,r){const s=Gb(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?X1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],q1(l[u+h],0,t).length)}return o}function q1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(oD))} + ${parseFloat(n[1].toFixed(oD))}j`:QV(n)?r=`'${n}'`:t==="bool"?r=iue(n):r=parseFloat(n.toFixed(oD)).toString(),fI(r,e)}function iue(n){return n===0?"false":"true"}function dI(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=X1(n);return[q1(m[0],0,t)]}return t==="bool"?[iue(n[0])]:[n[0].toString()]}if(l===1){if(a>q9){const g=_1*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-_1)*o,a*o));return t==="complex64"&&(y=X1(y),b=X1(b)),["["+y.map((x,w)=>q1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>q1(x,s[a-_1+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?X1(n):Array.from(n)).map((g,y)=>q1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>q9){for(let m=0;m<_1;m++){const g=m*h,y=g+h;f.push(...dI(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-_1;m<a;m++){const g=m*h,y=g+h;f.push(...dI(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...dI(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function X1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uh=null,S1=null;function YSt(n){uh=n}class uc{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Gb(e),this.strides=Zce(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return S1.buffer(this.shape,this.dtype,e)}bufferSync(){return S1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return V9(this.shape,e,this.dtype==="complex64")}arraySync(){return V9(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=uh().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>j9(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),uh().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=uh().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>j9(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await uh().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),uh().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return S1.print(this,e)}clone(){return this.throwIfDisposed(),S1.clone(this)}toString(e=!1){const t=this.dataSync();return XSt(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),S1.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),uh().makeVariable(this,e,t,r)}}Object.defineProperty(uc,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Fc(){return nU("Tensor",()=>uc)}Fc();class _L extends uc{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Kce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);uh().disposeTensor(this),this.dataId=e.dataId,uh().incRef(this,null)}dispose(){uh().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(_L,Symbol.hasInstance,{value:n=>n instanceof uc&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var X9;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(X9||(X9={}));var SL;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(SL||(SL={}));var CL;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(CL||(CL={}));var kL;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(kL||(kL={}));var TL;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(TL||(TL={}));const ZSt={float32:kL,int32:SL,bool:CL,complex64:TL};function JSt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return ZSt[n][e]}function oue(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function aue(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rU(n,e){if(n.dtype===e.dtype)return[n,e];const t=JSt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function QSt(n){const e=[];return lue(n,e,new Set),e}function lue(n,e,t){if(n==null)return;if(n instanceof uc){e.push(n);return}if(!e2t(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),lue(i,e,t))}}function e2t(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aD(n){return n.kernelName!=null}class K9{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Av{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new K9}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(x1(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new WSt(this.backendInstance),!0}setupRegisteredKernels(){H9(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){H9(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof aSt)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,x1(`Initialization of backend ${e} failed`),x1(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return x1(`Initialization of backend ${e} failed`),x1(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Av.nextTensorId++}nextVariableId(){return Av.nextVariableId++}clone(e){const t=ws.runKernel(MSt,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ws.runKernel(nue,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(W9(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=aD(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(aD(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=W9(p,this.backendName);Bi(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=aD(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=G9(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(Bi(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&QV(e[0])&&(i=e.map(l=>USt(l)));const o=s.write(i,t,r),a=new uc(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=fSt(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new uc(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new _L(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*xL(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof _L||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*xL(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=G9(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=Qce(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=QSt(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(Bi(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Bi(i instanceof uc,()=>"The result y returned by f() must be a tensor.");const o=jSt(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??t2t(i.shape),qSt(a,o,c=>this.tidy(c),r2t);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return Bi(B9(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{Bi(t.every(a=>a instanceof uc),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),Bi(r.value instanceof uc,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Bi(B9(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];Bi(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Bi(u.every(f=>f instanceof uc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=vM(),r=await this.backend.time(e);return r.wallMs=vM()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new K9;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Av.nextTensorId=0;Av.nextVariableId=0;function t2t(n){const e=mSt(Gb(n),"float32");return ws.makeTensor(e,n,"float32")}function n2t(){const n=tue();if(n._tfengine==null){const e=new ySt(n);n._tfengine=new Av(e)}return xSt(n._tfengine.ENV),YSt(()=>n._tfengine),n._tfengine}const ws=n2t();function r2t(n,e){const t={a:n,b:e};return ws.runKernel(CSt,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2t(n,e){let t=n;if(Pu(n))return e==="string"?[]:[n.length];if(oue(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(aue(n))return[n.buffer.size/(e==null?4:xL(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Pu(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&ja().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&cue(n,r,[]),r}function cue(n,e,t){if(t=t||[],!Array.isArray(n)&&!Pu(n)){Bi(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}Bi(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),Bi(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)cue(n[s],r,t.concat(s))}function Y9(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function $i(n,e,t,r="numeric"){if(n instanceof uc)return Y9(r,n.dtype,e,t),n;let s=eU(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Y9(r,s,e,t),n==null||!Pu(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=s2t(n,s);!Pu(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?sue(n,s):HS(n,[],!0);return ws.makeTensor(a,i,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2t="__op";function ia(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+i2t;const s=(...i)=>{ws.startScope(t);try{const o=r(...i);return tU(o)&&console.error("Cannot return a Promise inside of tidy."),ws.endScope(o),o}catch(o){throw ws.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2t(n,e,t=0,r=0){const s=$i(n,"x","gather"),i=$i(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return ws.runKernel(ASt,o,a)}const a2t=ia({gather_:o2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.gather=function(n,e,t){return this.throwIfDisposed(),a2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2t(n,e=0){const r={x:$i(n,"x","argMax")},s={axis:e};return ws.runKernel(kSt,r,s)}const c2t=ia({argMax_:l2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.argMax=function(n){return this.throwIfDisposed(),c2t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2t(n,e){const r={x:$i(n,"x","reshape","string_or_numeric")},s={shape:e};return ws.runKernel(DSt,r,s)}const mx=ia({reshape_:u2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2t(n,e){const t=$i(n,"x","squeeze","string_or_numeric");return mx(t,cSt(t.shape,e).newShape)}const f2t=ia({squeeze_:h2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.squeeze=function(n){return this.throwIfDisposed(),f2t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d2t(n,e=0){const t=$i(n,"x","expandDims","string_or_numeric");Bi(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return ws.runKernel(ISt,r,s)}const p2t=ia({expandDims_:d2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.expandDims=function(n){return this.throwIfDisposed(),p2t(this,n)};function Z9(n,e=null,t=!1){const r=e?{$select:e}:{},s=Uf(n)?n.items().query(r):n,i=t?s.toArray():Promise.resolve(s);async function*o(){const a=await i;for await(const l of a)yield l}return qrt(o)}function J9(n){const e={};for(const[t,r]of Object.entries(n)){const s=t.startsWith("val_")?t.replace("val_","")+"Val":t;e[s]=r}return e}class uue extends X${constructor({epochs:e=20,batchSize:t=8,validationSplit:r=.2}={}){super(),this.title="TFJSCustomModel",this.loadFn=J_,this.validationSplit=Math.max(Math.min(r,1),0),this.parameters={epochs:new mt(e,!0),batchSize:new mt(t,!0)}}transformDataset(e){return e.map(t=>({xs:Ei(t.x),ys:Ei(t.y)}))}async train(e,t){this.$training.set({status:"start",epochs:this.parameters.epochs.get()});const s=Uf(e)?e.$count.value:(await e.toArray()).length,i=Math.min(200,s),o=this.transformDataset(Z9(e,["x","y"],s<200)).shuffle(i);let a,l;if(t)a=o,l=this.transformDataset(Z9(t,["x","y"],s<200)).shuffle(i);else{const h=Math.floor(s*(1-this.validationSplit));a=o.take(h),l=this.validationSplit>0&&o.skip(h)}const[{xs:c,ys:u}]=await a.take(1).toArray();this.buildModel(c.shape,u.shape),this.fit(a,l)}_predict(e){return this.model?Se(()=>this.model.predict(Ei(e).expandDims(0)).gather(0)):null}clear(){delete this.model}fit(e,t){this.model.fitDataset(e.batch(this.parameters.batchSize.get()),{...t?{validationData:t.batch(this.parameters.batchSize.get())}:{},epochs:this.parameters.epochs.get(),callbacks:{onEpochEnd:(r,s)=>{this.$training.set({status:"epoch",epoch:r+1,epochs:this.parameters.epochs.get(),data:J9(s)})}}}).then(r=>{this.$training.set({status:"success",data:J9(r.history)})}).catch(r=>{throw this.$training.set({status:"error",data:r}),new Ip(r.message)})}}Dn([Ln],uue.prototype,"train",null);class hue extends uue{constructor(){super(...arguments),this.title="TFJSCustomClassifier"}async train(e,t){const r=Uf(e);if(this.labels=r?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:i})=>i).toArray())),this.labels.length===0){Ea(new Ip("This dataset is empty or is missing labels")),this.$training.set({status:"error"});return}if(this.labels.length===1){Ea(new Ip("At least two classes are needed to train the classifier")),this.$training.set({status:"error"});return}const s=this.labels.length;this.transformDataset=i=>i.map(o=>({xs:Ei(o.x),ys:Jb(this.labels.indexOf(o.y),s)})),super.train(e,t)}async predict(e){return this.model?Se(()=>{const t=this._predict(e),r=this.labels[t.argMax().arraySync()],i=t.arraySync().reduce((o,a,l)=>({...o,[this.labels[l]]:a}),{});return{label:r,confidences:i}}):{label:void 0,confidences:{}}}}Dn([Ln],hue.prototype,"train",null);function m2t(n){var g,y,b,x;let e,t,r,s,i=((g=n[2])==null?void 0:g.message)+"",o,a,l,c,u=Math.floor(((y=n[2])==null?void 0:y.progress)*100)+"",h,f,d,p,m;return p=new Fce({props:{progress:(b=n[2])==null?void 0:b.progress,type:(x=n[2])==null?void 0:x.type}}),{c(){var w,S,C,k,A,M;e=we("div"),t=we("div"),r=we("div"),s=we("span"),o=He(i),a=Ye(),l=we("div"),c=we("span"),h=He(u),f=He("%"),d=Ye(),It(p.$$.fragment),Z(s,"class","text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-cymqgb"),qt(s,"gray",((w=n[2])==null?void 0:w.type)==="idle"),qt(s,"green",((S=n[2])==null?void 0:S.type)==="success"),qt(s,"red",((C=n[2])==null?void 0:C.type)==="danger"),Z(c,"class","text-xs font-semibold inline-block text-blue-600 svelte-cymqgb"),qt(c,"tgray",((k=n[2])==null?void 0:k.type)==="idle"),qt(c,"tgreen",((A=n[2])==null?void 0:A.type)==="success"),qt(c,"tred",((M=n[2])==null?void 0:M.type)==="danger"),Z(l,"class","text-right"),Z(t,"class","flex mb-2 items-center justify-between"),Z(e,"class","relative pt-6 w-full"),cu(e,"min-width","250px")},m(w,S){me(w,e,S),se(e,t),se(t,r),se(r,s),se(s,o),se(t,a),se(t,l),se(l,c),se(c,h),se(c,f),se(e,d),kt(p,e,null),m=!0},p(w,S){var k,A,M,E,N,O,R,D,z,B;(!m||S&4)&&i!==(i=((k=w[2])==null?void 0:k.message)+"")&&cn(o,i),(!m||S&4)&&qt(s,"gray",((A=w[2])==null?void 0:A.type)==="idle"),(!m||S&4)&&qt(s,"green",((M=w[2])==null?void 0:M.type)==="success"),(!m||S&4)&&qt(s,"red",((E=w[2])==null?void 0:E.type)==="danger"),(!m||S&4)&&u!==(u=Math.floor(((N=w[2])==null?void 0:N.progress)*100)+"")&&cn(h,u),(!m||S&4)&&qt(c,"tgray",((O=w[2])==null?void 0:O.type)==="idle"),(!m||S&4)&&qt(c,"tgreen",((R=w[2])==null?void 0:R.type)==="success"),(!m||S&4)&&qt(c,"tred",((D=w[2])==null?void 0:D.type)==="danger");const C={};S&4&&(C.progress=(z=w[2])==null?void 0:z.progress),S&4&&(C.type=(B=w[2])==null?void 0:B.type),p.$set(C)},i(w){m||(Ie(p.$$.fragment,w),m=!0)},o(w){$e(p.$$.fragment,w),m=!1},d(w){w&&de(e),Tt(p)}}}function g2t(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[m2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function y2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{progress:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"progress"in l&&i(t(1,a=l.progress))},[o,a,r]}class b2t extends xn{constructor(e){super(),wn(this,e,y2t,g2t,pn,{title:0,progress:1})}}class v2t extends Aa{constructor(e){super(),this.$progress=e,this.title="progress bar",this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new b2t({target:t,props:{title:this.title,progress:this.$progress}}))}}function w2t(n){if(!n.$training)throw new Error("The argument is not a valid MLP");const e=n.$training.map(({status:r,epoch:s,epochs:i})=>{let o="default",a=i>0?s/i:null;return r==="error"&&(o="danger"),r==="idle"&&(o="idle",a=0),["success","loaded"].includes(r)&&(o="success",a=1),["start","loading"].includes(r)&&(a=null),{message:`Status: ${r}`,progress:a,type:o}}).hold(),t=new v2t(e);return t.title="Training Progress",t}var K1;class x2t extends Aa{constructor(e,t=JV()){super(),this.title="batch prediction",K1.set(this,void 0),this.$status=new mt({status:"loading"},!0),this.name=e,this.title=`batch prediction (${e})`,ir(this,K1,t||new Gce,"f"),this.start(),$t(this,K1,"f").connect().then(()=>{this.setup()}).catch(r=>{const s=new Error(r==null?void 0:r.message);s.name=`Batch Prediction Error (${e}): Datastore connection failed`,Ea(s,{duration:0})})}async setup(){const e=JC(`predictions-${this.name}`);this.predictionService=$t(this,K1,"f").service(e);const{total:t}=await this.predictionService.find({query:{$limit:1,$select:["id"]}});this.$status.set({status:t>0?"loaded":"idle"})}async predict(e,t){try{const r=Uf(t)?t.$count.value:(await t.toArray()).length;this.$status.set({status:"start"});const s=Uf(t)?t.items():t;let i=0;for await(const{id:o,x:a,y:l}of s){const c=await e.predict(a),u=await this.predictionService.create({...c,instanceId:o,yTrue:l});this.$status.set({status:"running",count:++i,total:r,data:u})}this.$status.set({status:"success",count:i,total:r})}catch(r){this.$status.set({status:"error",data:{error:r}})}}async clear(){await this.predictionService.remove(null,{query:{}})}items(){return this.predictionService.items()}mount(){}}K1=new WeakMap;function fue(...n){return new x2t(...n)}function _2t(n){let e;return{c(){e=He(n[10])},m(t,r){me(t,e,r)},p(t,r){r&1024&&cn(e,t[10])},d(t){t&&de(e)}}}function S2t(n){let e,t,r,s;function i(a){n[11](a)}let o={disabled:n[7],type:n[8],$$slots:{default:[_2t]},$$scope:{ctx:n}};return n[9]!==void 0&&(o.pressed=n[9]),t=new zs({props:o}),hi.push(()=>nd(t,"pressed",i)),t.$on("click",n[12]),{c(){e=we("div"),It(t.$$.fragment)},m(a,l){me(a,e,l),kt(t,e,null),s=!0},p(a,l){const c={};l&128&&(c.disabled=a[7]),l&256&&(c.type=a[8]),l&9216&&(c.$$scope={dirty:l,ctx:a}),!r&&l&512&&(r=!0,c.pressed=a[9],td(()=>r=!1)),t.$set(c)},i(a){s||(Ie(t.$$.fragment,a),s=!0)},o(a){$e(t.$$.fragment,a),s=!1},d(a){a&&de(e),Tt(t)}}}function C2t(n){let e,t;return e=new sa({props:{title:n[0],loading:n[6],$$slots:{default:[S2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&64&&(i.loading=r[6]),s&10112&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function k2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(S,E=>t(6,r=E)),S),o,a=tt,l=()=>(a(),a=os(C,E=>t(7,o=E)),C),c,u=tt,h=()=>(u(),u=os(k,E=>t(8,c=E)),k),f,d=tt,p=()=>(d(),d=os(w,E=>t(9,f=E)),w),m,g=tt,y=()=>(g(),g=os(x,E=>t(10,m=E)),x);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u()),n.$$.on_destroy.push(()=>d()),n.$$.on_destroy.push(()=>g());let{title:b}=e,{text:x}=e;y();let{pressed:w}=e;p();let{loading:S}=e;i();let{disabled:C}=e;l();let{type:k}=e;h();function A(E){f=E,w.set(f)}function M(E){gM.call(this,n,E)}return n.$$set=E=>{"title"in E&&t(0,b=E.title),"text"in E&&y(t(1,x=E.text)),"pressed"in E&&p(t(2,w=E.pressed)),"loading"in E&&i(t(3,S=E.loading)),"disabled"in E&&l(t(4,C=E.disabled)),"type"in E&&h(t(5,k=E.type))},[b,x,w,S,C,k,r,o,c,f,m,A,M]}class T2t extends xn{constructor(e){super(),wn(this,e,k2t,C2t,pn,{title:0,text:1,pressed:2,loading:3,disabled:4,type:5})}}class E2t extends Aa{constructor(e="click me"){super(),this.title="button",this.$click=new mt(F_()),this.$pressed=new mt(!1,!0),this.$loading=new mt(!1,!0),this.$disabled=new mt(!1,!0),this.$type=new mt("default",!0),this.$text=new mt(e,!0),this.start(),this.$loading.skip(1).subscribe(t=>{this.$disabled.set(t)})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new T2t({target:t,props:{title:this.title,text:this.$text,pressed:this.$pressed,loading:this.$loading,disabled:this.$disabled,type:this.$type}}),this.$$.app.$on("click",this.$click.set))}}function gx(...n){return new E2t(...n)}function I2t(n){let e,t;return{c(){e=He("COCO-SSD loaded with base "),t=He(n[2])},m(r,s){me(r,e,s),me(r,t,s)},p(r,s){s&4&&cn(t,r[2])},d(r){r&&de(e),r&&de(t)}}}function A2t(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function M2t(n){let e;function t(i,o){return i[3]?A2t:I2t}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function N2t(n){let e,t;return e=new sa({props:{title:n[0],loading:n[3],$$slots:{default:[M2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function $2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{base:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"base"in c&&t(2,l=c.base)},[o,a,l,r]}class R2t extends xn{constructor(e){super(),wn(this,e,$2t,N2t,pn,{title:0,loading:1,base:2})}}var Pm,Ed;class yx extends l0{constructor({base:e="lite_mobilenet_v2"}={}){super(),this.title="COCO-SSD Object Detection",this.parameters={},this.serviceName="undefined",Pm.set(this,void 0),Ed.set(this,void 0),this.$loading=new mt(!0,!0),ir(this,Ed,e,"f"),this.setup()}async setup(){await K2();const e=await HL(),t=Object.keys(e).filter(r=>r.includes("cocossd"));try{ir(this,Pm,await U6.load({base:$t(this,Ed,"f"),modelUrl:`indexeddb://cocossd-${$t(this,Ed,"f")}`}),"f")}catch{t.length>0&&await jL(t[0]),ir(this,Pm,await U6.load({base:$t(this,Ed,"f")}),"f"),await $t(this,Pm,"f").model.save(`indexeddb://cocossd-${$t(this,Ed,"f")}`)}ya.info("COCO-SSD loaded with base `lite_mobilenet_v2`"),this.$loading.set(!1),this.start()}train(){throw new Ip("Model `CocoSsd` cannot be trained")}async predict(e){if(!$t(this,Pm,"f"))throw new Error("Model is not loaded");return{outputs:(await $t(this,Pm,"f").detect(e)).map(s=>({bbox:s.bbox,class:s.class,confidence:s.score}))}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new R2t({target:t,props:{title:this.title,loading:this.$loading,base:$t(this,Ed,"f")}}))}save(){throw new Error("CocoSsd does not support saving")}load(){throw new Error("CocoSsd does not support loading")}download(){throw new Error("CocoSsd does not support downloading")}upload(){throw new Error("CocoSsd does not support uploading")}}Pm=new WeakMap,Ed=new WeakMap;Dn([Ln],yx.prototype,"train",null);Dn([Ln],yx.prototype,"predict",null);Dn([Ln],yx.prototype,"save",null);Dn([Ln],yx.prototype,"load",null);Dn([Ln],yx.prototype,"download",null);Dn([Ln],yx.prototype,"upload",null);function P2t(n){let e,t;return{c(){e=we("div"),t=we("canvas"),Z(e,"class","w-full h-96")},m(r,s){me(r,e,s),se(e,t),n[6](t)},p:tt,d(r){r&&de(e),n[6](null)}}}function D2t(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[P2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&32770&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function O2t(n,e,t){let{title:r}=e,{preset:s}=e,{options:i}=e,{datasets:o}=e;iu.register(JE,GE,HE,vA,kb,Jat,slt,Vd,jE,fF,dF,aF,QE,qE,XE,D1,eI,KE,iS,mF,oie,lie);const a=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"],l={data:{},options:{maintainAspectRatio:!1,animation:{duration:200},borderWidth:4}};function c(b){return{borderColor:a[b%6],backgroundColor:a[b%6],fill:!1,lineTension:.2}}function u(b,x,w){const S={labels:[]};let C=0;return S.datasets=b.map(({dataStream:k,label:A,options:M},E)=>{C=Math.max(C,k.get()?k.get().length:0),E===0&&(S.labels=M.labels||[],!M.labels&&k.get()&&k.get().length>0&&(typeof k.get()[0]=="number"?S.labels=Array.from(Array(k.get().length),(O,R)=>R.toString()):S.labels=k.get().map(O=>O.x.toString())));let N={...c(E),...x,...M,label:A,data:k.get()||[]};return(["bar","bar-fast"].includes(M.type)||["bar","bar-fast"].includes(w.type)&&!M.type)&&b.length===1&&(N.borderColor=a,N.backgroundColor=a),N}),S}let h,f=[],d;function p(){let b=vl(l,s.global);b=vl(b,{data:u(o,s.datasets,b),options:i}),i.xlabel&&(b=vl(b,{options:{scales:{x:{title:{display:!0,text:i.xlabel}}}}})),i.ylabel&&(b=vl(b,{options:{scales:{y:{title:{display:!0,text:i.ylabel}}}}}));const x=o.map(({dataStream:S})=>{var C;return((C=S.get())===null||C===void 0?void 0:C.length)||0});f=o.map(({dataStream:S,options:C},k)=>S.subscribe(A=>{if(A&&h){const M=x.reduce((E,N)=>Math.max(E,N));x[k]=A.length,!C.labels&&A.length>0&&x[k]>M&&(typeof A[0]=="number"?b.data.labels=Array.from(Array(A.length),(E,N)=>N.toString()):b.data.labels=A.map(E=>E.x.toString())),b.data.datasets[k].data=A;try{h.update()}catch(E){console.log(E)}}}));const w=d.getContext("2d");h=new iu(w,b)}function m(){for(const b of f)b();h==null||h.destroy()}$u(async()=>{await ea(),await ea(),p()});let g=o.length;Fg(m);function y(b){hi[b?"unshift":"push"](()=>{d=b,t(1,d)})}return n.$$set=b=>{"title"in b&&t(0,r=b.title),"preset"in b&&t(2,s=b.preset),"options"in b&&t(3,i=b.options),"datasets"in b&&t(4,o=b.datasets)},n.$$.update=()=>{n.$$.dirty&48&&o.length!==g&&(m(),p(),t(5,g=o.length))},[r,d,s,i,o,g,y]}class F2t extends xn{constructor(e){super(),wn(this,e,O2t,D2t,pn,{title:0,preset:2,options:3,datasets:4})}}var pI,mI,pl;const Q9={line:{global:{type:"line",options:{animation:{duration:200},scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:.2}},"line-fast":{global:{type:"line",options:{elements:{point:{radius:0}},animation:!1,tooltips:!1,spanGaps:!0,scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:0}},bar:{global:{type:"bar",options:{animation:{duration:200},scales:{y:{beginAtZero:!0}}}}},"bar-fast":{global:{type:"bar",options:{animation:!1,scales:{y:{beginAtZero:!0}}}}},scatter:{global:{type:"scatter",options:{scales:{x:{type:"linear",position:"bottom"}}}}}};class L2t extends Aa{constructor({preset:e="line",options:t={}}={}){super(),this.title="generic chart",pI.set(this,void 0),mI.set(this,void 0),pl.set(this,[]),Object.keys(Q9).includes(e)||Ea(new Error(`Preset ${e} is not recognized`)),ir(this,pI,e,"f"),ir(this,mI,Q9[e],"f"),this.options=t,this.start()}addSeries(e,t,r={}){if(ZV(e)){if($t(this,pI,"f")==="line-fast"){const s=e.debounce(10);s.value=e.get(),$t(this,pl,"f").push({dataStream:s,label:t,options:r})}else $t(this,pl,"f").push({dataStream:e,label:t,options:r});this.updateView()}else e.toArray().then(s=>{const i=new mt(s,!0);$t(this,pl,"f").push({dataStream:i,label:t,options:r}),this.updateView()})}setColors(e){$t(this,pl,"f")[0].label="clusters",$t(this,pl,"f")[0].options.backgroundColor=e.get(),$t(this,pl,"f")[0].options.color=e.get()}removeSeries(e){const t=$t(this,pl,"f").map(r=>r.dataStream).indexOf(e);t>-1&&$t(this,pl,"f").splice(t,1)}clear(){ir(this,pl,[],"f"),this.updateView()}updateView(){this.$$.app&&this.$$.app.$set({datasets:$t(this,pl,"f")})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new F2t({target:t,props:{title:this.title,preset:$t(this,mI,"f"),options:this.options,datasets:$t(this,pl,"f")}}))}}pI=new WeakMap,mI=new WeakMap,pl=new WeakMap;function due(...n){return new L2t(...n)}function e7(n){let e,t;return{c(){e=new Uxt(!1),t=mo(),e.a=t},m(r,s){e.m(n[2],r,s),me(r,t,s)},p(r,s){s&4&&e.p(r[2])},d(r){r&&de(t),r&&e.d()}}}function z2t(n){let e,t=n[2]&&e7(n);return{c(){e=we("div"),t&&t.c(),Z(e,"class","grow")},m(r,s){me(r,e,s),t&&t.m(e,null)},p(r,s){r[2]?t?t.p(r,s):(t=e7(r),t.c(),t.m(e,null)):t&&(t.d(1),t=null)},d(r){r&&de(e),t&&t.d()}}}function B2t(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[z2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function V2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{text:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"text"in l&&i(t(1,a=l.text))},[o,a,r]}class U2t extends xn{constructor(e){super(),wn(this,e,V2t,B2t,pn,{title:0,text:1})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),Lg()}get text(){return this.$$.ctx[1]}set text(e){this.$$set({text:e}),Lg()}}class W2t extends Aa{constructor(e="click me"){super(),this.title="text",this.$value=new mt(e,!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new U2t({target:t,props:{title:this.title,text:this.$value}}))}}function G2t(...n){return new W2t(...n)}var gf,nh;class H2t extends Aa{constructor(e){super(),this.title="confidence plot",gf.set(this,void 0),nh.set(this,void 0),this.$confidenceStream=e.map(({confidences:t})=>Object.entries(t).map(([r,s])=>({x:r,y:s})).sort((r,s)=>r.x<s.x?-1:r.x>s.x?1:0)),ir(this,gf,due({preset:"bar-fast",options:{xlabel:"Label",ylabel:"Confidence",scales:{y:{suggestedMax:1}}}}),"f"),$t(this,gf,"f").addSeries(this.$confidenceStream,"Confidences"),$t(this,gf,"f").title="",ir(this,nh,G2t("Waiting for predictions..."),"f"),$t(this,nh,"f").title=this.title,$t(this,nh,"f").$value=new mt(e.map(({label:t})=>`<p>Predicted Label: <code style="font-size: 1.5rem;">${t}</code></p>`).startWith("Waiting for predictions..."),!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);if(!t)return;const r=document.createElement("div");r.id=`${t.id}-${$t(this,nh,"f").id}`;const s=document.createElement("div");s.id=`${t.id}-${$t(this,gf,"f").id}`,t.appendChild(r),t.appendChild(s),$t(this,nh,"f").title=this.title,$t(this,nh,"f").mount(r),$t(this,gf,"f").mount(s),this.destroy=()=>{r.parentElement.removeChild(r),s.parentElement.removeChild(s),$t(this,nh,"f").destroy(),$t(this,gf,"f").destroy()}}destroy(){$t(this,nh,"f").destroy(),$t(this,gf,"f").destroy()}}gf=new WeakMap,nh=new WeakMap;function j2t(...n){return new H2t(...n)}function q2t(n){let e;return{c(){e=we("p"),e.textContent="Waiting for predictions...",Z(e,"class","m-2")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function X2t(n){let e,t,r=n[6].toFixed(2)+"",s,i,o,a,l,c;return{c(){e=we("p"),t=He("Global Accuracy: "),s=He(r),i=Ye(),o=we("div"),a=we("canvas"),Z(e,"class","m-2"),Z(o,"class","confusion-container svelte-1d2i0ke")},m(u,h){me(u,e,h),se(e,t),se(e,s),me(u,i,h),me(u,o,h),se(o,a),l||(c=Pxt(n[7].call(null,a)),l=!0)},p(u,h){h&64&&r!==(r=u[6].toFixed(2)+"")&&cn(s,r)},d(u){u&&de(e),u&&de(i),u&&de(o),l=!1,c()}}}function K2t(n){let e;function t(i,o){return i[6]!==void 0?X2t:q2t}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},d(i){s.d(i),i&&de(e)}}}function Y2t(n){let e,t;return e=new sa({props:{title:n[0],loading:n[4],progress:n[5],$$slots:{default:[K2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&16&&(i.loading=r[4]),s&32&&(i.progress=r[5]),s&131136&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Z2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(d,E=>t(4,r=E)),d),o,a=tt,l=()=>(a(),a=os(p,E=>t(5,o=E)),p),c,u=tt,h=()=>(u(),u=os(m,E=>t(6,c=E)),m);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{loading:d}=e;i();let{progress:p}=e;l();let{accuracy:m}=e;h();let{confusion:g}=e,{labels:y}=e,{selected:b}=e;iu.register(vA,oie,lie,_F,L1);let x=1,w=1,S=-1;const C={type:"matrix",data:{datasets:[{label:"Confusion Matrix",data:[],backgroundColor(E){if(E.dataset.data.length>0){if(E.dataIndex===S){const{x:O,y:R}=E.dataset.data[E.dataIndex];return O===R?"green":"red"}return`rgba(54, 162, 235, ${E.dataset.data[E.dataIndex].v/x})`}return"rgba(54, 162, 235, 0)"},width(E){const N=E.chart.chartArea;return N?(N.right-N.left)/w-2:0},height(E){const N=E.chart.chartArea;return N?(N.bottom-N.top)/w-2:0}}]},options:{aspectRatio:1,legend:{display:!1},plugins:{tooltip:{callbacks:{title([E]){return["count: "+E.dataset.data[E.dataIndex].v]},label(E){const N=E.dataset.data[E.dataIndex];return["true label: "+N.y,"predicted label: "+N.x]}}}},scales:{x:{type:"category",labels:[],ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"Predicted Label"}},y:{type:"category",labels:[],offset:!0,reverse:!0,ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"True Label"}}},onClick(E){try{const N=E.chart.tooltip.dataPoints[0].dataIndex;S===N?(b.set(null),S=-1):(b.set(E.chart.tooltip.dataPoints[0].raw),S=N,E.chart.update())}catch(N){console.log("[confusion matrix] selection error:",N)}}}};let k,A=[];function M(E){const N=E.getContext("2d");k=new iu(N,C),A.push(y.subscribe(O=>{w=O.length,C.options.scales.x.labels=O.sort(),C.options.scales.y.labels=O.sort(),k.update()})),A.push(g.subscribe(O=>{x=O.reduce((R,{v:D})=>Math.max(R,D),0),C.data.datasets[0].data=O,k.update()}))}return Fg(()=>{for(const E of A)E()}),n.$$set=E=>{"title"in E&&t(0,f=E.title),"loading"in E&&i(t(1,d=E.loading)),"progress"in E&&l(t(2,p=E.progress)),"accuracy"in E&&h(t(3,m=E.accuracy)),"confusion"in E&&t(8,g=E.confusion),"labels"in E&&t(9,y=E.labels),"selected"in E&&t(10,b=E.selected)},[f,d,p,m,r,o,c,M,g,y,b]}class J2t extends xn{constructor(e){super(),wn(this,e,Z2t,Y2t,pn,{title:0,loading:1,progress:2,accuracy:3,confusion:8,labels:9,selected:10})}}var Sb;class Q2t extends Aa{constructor(e){super(),this.title="confusion matrix",Sb.set(this,void 0),this.$confusion=new mt([],!0),this.$accuracy=new mt(void 0,!0),this.$labels=new mt([],!0),this.$selected=new mt(null,!0),this.$progress=new mt(!1,!0),ir(this,Sb,e,"f"),this.start(),this.setup()}setup(){let e=[];$t(this,Sb,"f").$status.subscribe(async({status:t,count:r,total:s,data:i})=>{t==="start"?(e=[],this.$progress.set(null)):t==="running"?(e.push(i),this.$progress.set(r/s)):t==="loaded"?(e=await $t(this,Sb,"f").predictionService.items().query({$select:["id","label","yTrue"]}).toArray(),this.$progress.set(!1)):t==="loading"?(e=[],this.$progress.set(null)):this.$progress.set(!1),this.updateConfusionMatrix(e),this.updateAccuracy(e)})}updateConfusionMatrix(e){const t=e.map(c=>c.label),r=e.map(c=>c.yTrue),s=Array.from(new Set(t.concat(r)));l_(s,this.$labels.value)||this.$labels.set(s);const i=s.length,o=s.reduce((c,u,h)=>({...c,[u]:h}),{}),a=Array.from(Array(i**2),()=>0);for(let c=0;c<t.length;c+=1)a[o[t[c]]*i+o[r[c]]]+=1;const l=a.map((c,u)=>({x:s[Math.floor(u/i)],y:s[u%i],v:c}));this.$confusion.set(l)}updateAccuracy(e){e.length===0?this.$accuracy.set(void 0):this.$accuracy.set(e.reduce((t,{label:r,yTrue:s})=>t+(r===s?1:0),0)/e.length)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new J2t({target:t,props:{title:this.title,loading:$t(this,Sb,"f").$status.map(({status:r})=>r==="loading"),progress:this.$progress,confusion:this.$confusion,accuracy:this.$accuracy,labels:this.$labels,selected:this.$selected}}))}}Sb=new WeakMap;function pue(...n){return new Q2t(...n)}const{window:t7}=Oxt;function n7(n,e,t){const r=n.slice();return r[27]=e[t][0],r[28]=e[t][1].loaded,r[29]=e[t][1].total,r[30]=e[t][1].instances,r}function r7(n,e,t){const r=n.slice();return r[33]=e[t].id,r[34]=e[t].thumbnail,r}function s7(n){let e,t,r,s,i;function o(f,d){return f[6]>0?tCt:eCt}let a=o(n),l=a(n),c=Object.entries(n[5]),u=[];for(let f=0;f<c.length;f+=1)u[f]=a7(n7(n,c,f));const h=f=>$e(u[f],1,1,()=>{u[f]=null});return{c(){l.c(),e=Ye(),t=we("div");for(let f=0;f<u.length;f+=1)u[f].c();Z(t,"class","flex flex-wrap")},m(f,d){l.m(f,d),me(f,e,d),me(f,t,d);for(let p=0;p<u.length;p+=1)u[p]&&u[p].m(t,null);r=!0,s||(i=[qn(t,"click",n[18]),qn(t,"keypress",ZC(n[19]))],s=!0)},p(f,d){if(a===(a=o(f))&&l?l.p(f,d):(l.d(1),l=a(f),l&&(l.c(),l.m(e.parentNode,e))),d[0]&6560){c=Object.entries(f[5]);let p;for(p=0;p<c.length;p+=1){const m=n7(f,c,p);u[p]?(u[p].p(m,d),Ie(u[p],1)):(u[p]=a7(m),u[p].c(),Ie(u[p],1),u[p].m(t,null))}for(dr(),p=c.length;p<u.length;p+=1)h(p);pr()}},i(f){if(!r){for(let d=0;d<c.length;d+=1)Ie(u[d]);r=!0}},o(f){u=u.filter(Boolean);for(let d=0;d<u.length;d+=1)$e(u[d]);r=!1},d(f){l.d(f),f&&de(e),f&&de(t),qs(u,f),s=!1,po(i)}}}function eCt(n){let e;return{c(){e=we("p"),e.textContent="This dataset is empty.",Z(e,"class","ml-3 mt-2")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function tCt(n){let e,t,r,s,i=n[6]>1?"s":"",o,a;return{c(){e=we("p"),t=He("This dataset contains "),r=He(n[6]),s=He(" instance"),o=He(i),a=He("."),Z(e,"class","ml-3 mt-2")},m(l,c){me(l,e,c),se(e,t),se(e,r),se(e,s),se(e,o),se(e,a)},p(l,c){c[0]&64&&cn(r,l[6]),c[0]&64&&i!==(i=l[6]>1?"s":"")&&cn(o,i)},d(l){l&&de(e)}}}function i7(n,e){let t,r,s,i,o,a,l;function c(){return e[16](e[33])}return{key:n,first:null,c(){t=we("img"),Ev(t.src,r=e[34])||Z(t,"src",r),Z(t,"alt","thumbnail"),Z(t,"class","m-1 svelte-14ms951"),qt(t,"selected",e[7].includes(e[33])),this.first=t},m(u,h){me(u,t,h),o=!0,a||(l=qn(t,"click",zxt(c)),a=!0)},p(u,h){e=u,(!o||h[0]&32&&!Ev(t.src,r=e[34]))&&Z(t,"src",r),(!o||h[0]&160)&&qt(t,"selected",e[7].includes(e[33]))},i(u){o||(Ru(()=>{o&&(i&&i.end(1),s=Zxt(t,s9,{}),s.start())}),o=!0)},o(u){s&&s.invalidate(),i=Jxt(t,s9,{}),o=!1},d(u){u&&de(t),u&&i&&i.end(),a=!1,l()}}}function o7(n){let e,t;function r(){return n[17](n[27])}return e=new zs({props:{size:"small",variant:"light",$$slots:{default:[nCt]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i[1]&64&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function nCt(n){let e;return{c(){e=He("View More")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function a7(n){let e,t,r,s,i=n[27]+"",o,a,l,c,u,h=[],f=new Map,d,p,m,g;function y(...S){return n[15](n[27],...S)}l=new k1t({props:{actions:[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])}}),l.$on("select",y);let b=n[30];const x=S=>S[33];for(let S=0;S<b.length;S+=1){let C=r7(n,b,S),k=x(C);f.set(k,h[S]=i7(k,C))}let w=n[28]<n[29]&&o7(n);return{c(){e=we("div"),t=we("div"),r=we("div"),s=we("span"),o=He(i),a=Ye(),It(l.$$.fragment),c=Ye(),u=we("div");for(let S=0;S<h.length;S+=1)h[S].c();d=Ye(),p=we("div"),w&&w.c(),m=Ye(),Z(s,"class","browser-class-title svelte-14ms951"),Z(r,"class","browser-class-header svelte-14ms951"),Z(u,"class","browser-class-body svelte-14ms951"),Z(t,"class","w-full"),Z(p,"class","pb-1"),Z(e,"class","browser-class svelte-14ms951")},m(S,C){me(S,e,C),se(e,t),se(t,r),se(r,s),se(s,o),se(r,a),kt(l,r,null),se(t,c),se(t,u);for(let k=0;k<h.length;k+=1)h[k]&&h[k].m(u,null);se(e,d),se(e,p),w&&w.m(p,null),se(e,m),g=!0},p(S,C){n=S,(!g||C[0]&32)&&i!==(i=n[27]+"")&&cn(o,i);const k={};C[0]&128&&(k.actions=[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])),l.$set(k),C[0]&2208&&(b=n[30],dr(),h=Dce(h,C,x,1,n,b,f,u,Pce,i7,null,r7),pr()),n[28]<n[29]?w?(w.p(n,C),C[0]&32&&Ie(w,1)):(w=o7(n),w.c(),Ie(w,1),w.m(p,null)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr())},i(S){if(!g){Ie(l.$$.fragment,S);for(let C=0;C<b.length;C+=1)Ie(h[C]);Ie(w),g=!0}},o(S){$e(l.$$.fragment,S);for(let C=0;C<h.length;C+=1)$e(h[C]);$e(w),g=!1},d(S){S&&de(e),Tt(l);for(let C=0;C<h.length;C+=1)h[C].d();w&&w.d()}}}function l7(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> 
      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires
        authentication</div>`,Z(e,"class","flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"),Z(e,"role","alert")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function rCt(n){let e,t,r,s=n[5]&&!n[4]&&s7(n),i=n[4]&&l7();return{c(){s&&s.c(),e=Ye(),i&&i.c(),t=mo()},m(o,a){s&&s.m(o,a),me(o,e,a),i&&i.m(o,a),me(o,t,a),r=!0},p(o,a){o[5]&&!o[4]?s?(s.p(o,a),a[0]&48&&Ie(s,1)):(s=s7(o),s.c(),Ie(s,1),s.m(e.parentNode,e)):s&&(dr(),$e(s,1,1,()=>{s=null}),pr()),o[4]?i||(i=l7(),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ie(s),r=!0)},o(o){$e(s),r=!1},d(o){s&&s.d(o),o&&de(e),i&&i.d(o),o&&de(t)}}}function sCt(n){let e,t,r,s;return e=new sa({props:{title:n[0],loading:n[3],$$slots:{default:[rCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(i,o){kt(e,i,o),t=!0,r||(s=[qn(t7,"keydown",n[9]),qn(t7,"keyup",n[10])],r=!0)},p(i,o){const a={};o[0]&1&&(a.title=i[0]),o[0]&8&&(a.loading=i[3]),o[0]&240|o[1]&64&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){t||(Ie(e.$$.fragment,i),t=!0)},o(i){$e(e.$$.fragment,i),t=!1},d(i){Tt(e,i),r=!1,po(s)}}}function iCt(n,e,t){let r,s=tt,i=()=>(s(),s=os(h,G=>t(6,r=G)),h),o,a=tt,l=()=>(a(),a=os(d,G=>t(7,o=G)),d);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{batchSize:u}=e,{count:h}=e;i();let{dataset:f}=e,{selected:d}=e;l();let p=!1,m=!1,g={};async function y(G){await f.ready;for await(const te of f.items().query({y:G,$sort:{updatedAt:-1}}).skip(g[G].loaded).take(u).select(["id","y","thumbnail"]))t(5,g[G].instances=[...g[G].instances,te],g),t(5,g[G].loaded+=1,g)}async function b(){if(p)return;t(3,p=!0);try{t(4,m=!1),await f.ready}catch{t(3,p=!1),t(4,m=!0);return}const G=await f.distinct("y");t(5,g=G.reduce((te,ge)=>({...te,[ge]:{total:0,loaded:0,instances:[]}}),{}));for(const te of G){const{total:ge}=await f.find({query:{$limit:0,y:te}});if(t(5,g[te].total=ge,g),u>0)await y(te);else for(;g[te].loaded<g[te].total;)await y(te)}t(3,p=!1)}function x(G){for(const[te,{instances:ge}]of Object.entries(g))if(ge.map(ae=>ae.id).includes(G))return te;return null}async function w(){let G=Promise.resolve();for(const te of d.get())G=G.then(()=>f.remove(te));await G,d.set([])}async function S(G){let te=Promise.resolve();for(const ge of d.get())te=te.then(()=>f.patch(ge,{y:G}));await te,d.set([])}let C=!1,k=!1;function A(G){["Meta","Control"].includes(G.key)?C=!0:G.key==="Shift"?k=!0:(G.key==="Delete"||G.key==="Backspace"&&C)&&w()}function M(G){["Meta","Control"].includes(G.key)?C=!1:G.key==="Shift"&&(k=!1)}let E=null;function N(G){if(C){if(!G)return;d.get().includes(G)?d.set(d.get().filter(te=>te!==G)):d.set(d.get().concat([G]))}else if(k){if(!E||!G)return;const te=x(E),ge=x(G);if(te!==ge)return;const ae=g[te].instances.map(De=>De.id),Ne=ae.indexOf(E),ke=ae.indexOf(G);d.set(Ne<ke?ae.slice(Ne,ke+1):ae.slice(ke,Ne+1))}else d.set(G?[G]:[]),E=G}function O(G,te){let ge;switch(te){case"edit":ge=window.prompt("Enter the new label",G),ge&&f.patch(null,{y:ge},{query:{y:G}});break;case"delete":f.remove(null,{query:{y:G}});break;case"deleteInstances":w();break;case"relabelInstances":ge=window.prompt("Enter the new label",G),ge&&S(ge);break;default:alert(`Class ${G}: ${te}`);break}}$u(()=>{b(),f.$changes.subscribe(async G=>{for(const{level:te,type:ge,data:ae}of G)if(te==="dataset")ge==="created"&&(N(),b());else if(te==="instance")if(ge==="created")g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].total+=1,g),t(5,g[ae.y].loaded+=1,g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g);else if(ge==="updated"){const Ne=x(ae.id);t(5,g[Ne].total-=1,g),t(5,g[Ne].loaded-=1,g),t(5,g[Ne].instances=g[Ne].instances.filter(({id:ke})=>ke!==ae.id),g),g[Ne].total===0&&(delete g[Ne],t(5,g)),g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g)}else ge==="removed"&&(t(5,g[ae.y].total-=1,g),t(5,g[ae.y].loaded-=1,g),t(5,g[ae.y].instances=g[ae.y].instances.filter(({id:Ne})=>Ne!==ae.id),g),g[ae.y].total===0&&(delete g[ae.y],t(5,g)))})});const R=(G,te)=>O(G,te.detail),D=G=>N(G),z=G=>y(G),B=()=>N(),X=G=>G.key==="Escape"&&N();return n.$$set=G=>{"title"in G&&t(0,c=G.title),"batchSize"in G&&t(13,u=G.batchSize),"count"in G&&i(t(1,h=G.count)),"dataset"in G&&t(14,f=G.dataset),"selected"in G&&l(t(2,d=G.selected))},[c,h,d,p,m,g,r,o,y,A,M,N,O,u,f,R,D,z,B,X]}class oCt extends xn{constructor(e){super(),wn(this,e,iCt,sCt,pn,{title:0,batchSize:13,count:1,dataset:14,selected:2},null,[-1,-1])}}var Y1;class aCt extends Aa{constructor(e,{batchSize:t=6}={}){super(),this.title="dataset browser",Y1.set(this,void 0),this.$selected=new mt([],!0),ir(this,Y1,e,"f"),this.batchSize=t,this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new oCt({target:t,props:{title:this.title,batchSize:this.batchSize,count:$t(this,Y1,"f").$count,dataset:$t(this,Y1,"f"),selected:this.$selected}}))}}Y1=new WeakMap;function mue(...n){return new aCt(...n)}function lCt(n){let e;return{c(){e=we("canvas"),Z(e,"class","w-full max-w-full")},m(t,r){me(t,e,r),n[3](e)},p:tt,d(t){t&&de(e),n[3](null)}}}function cCt(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[lCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&34&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function uCt(n,e,t){let{title:r}=e,{imageStream:s}=e,i,o=Wb;$u(async()=>{await ea(),await ea();const l=i.getContext("2d");o=s.subscribe(c=>{if(!(Array.isArray(c)&&c.length===0)){if(c instanceof ImageData)t(1,i.width=c.width,i),t(1,i.height=c.height,i),l.putImageData(c,0,0);else if(Array.isArray(c))throw new Error("This component does not yet support multiple images")}})}),Fg(()=>{o()});function a(l){hi[l?"unshift":"push"](()=>{i=l,t(1,i)})}return n.$$set=l=>{"title"in l&&t(0,r=l.title),"imageStream"in l&&t(2,s=l.imageStream)},[r,i,s,a]}class hCt extends xn{constructor(e){super(),wn(this,e,uCt,cCt,pn,{title:0,imageStream:2})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),Lg()}get imageStream(){return this.$$.ctx[2]}set imageStream(e){this.$$set({imageStream:e}),Lg()}}var gI;class fCt extends Aa{constructor(e){super(),this.title="image display",gI.set(this,void 0),ir(this,gI,e,"f")}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new hCt({target:t,props:{title:this.title,imageStream:$t(this,gI,"f")}}))}}gI=new WeakMap;function gue(...n){return new fCt(...n)}function c7(n,e,t){const r=n.slice();return r[18]=e[t],r}function u7(n){let e;return{c(){e=we("div"),e.innerHTML=`<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> 
      <p class="text-lg text-blue-700">Drop files to upload</p>`,Z(e,"class","overlay svelte-u8vb5e")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function dCt(n){let e;return{c(){e=He("Upload a file")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function h7(n){let e,t;return{c(){e=we("img"),Z(e,"class","mx-auto my-2 w-32"),Ev(e.src,t=n[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")||Z(e,"src",t),Z(e,"alt","no data")},m(r,s){me(r,e,s)},p(r,s){s&8&&!Ev(e.src,t=r[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")&&Z(e,"src",t)},d(r){r&&de(e)}}}function pCt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p=n[2]&&u7();l=new zs({props:{$$slots:{default:[dCt]},$$scope:{ctx:n}}}),l.$on("click",n[8]);let m=n[3],g=[];for(let y=0;y<m.length;y+=1)g[y]=h7(c7(n,m,y));return{c(){p&&p.c(),e=Ye(),t=we("div"),r=we("div"),s=we("p"),s.innerHTML="<span>Drag and drop an image or</span>",i=Ye(),o=we("input"),a=Ye(),It(l.$$.fragment),c=Ye(),u=we("div");for(let y=0;y<g.length;y+=1)g[y].c();Z(s,"class","mb-3 font-semibold text-gray-900 flex flex-wrap justify-center"),Z(o,"type","file"),o.multiple=!0,Z(o,"class","hidden"),Z(r,"class","border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center"),Z(u,"class","flex flex-wrap"),Z(t,"class","image-upload svelte-u8vb5e")},m(y,b){p&&p.m(y,b),me(y,e,b),me(y,t,b),se(t,r),se(r,s),se(r,i),se(r,o),n[13](o),se(r,a),kt(l,r,null),se(t,c),se(t,u);for(let x=0;x<g.length;x+=1)g[x]&&g[x].m(u,null);h=!0,f||(d=[qn(t,"dragenter",n[4]),qn(t,"dragleave",n[5]),qn(t,"dragover",n[6]),qn(t,"drop",n[7])],f=!0)},p(y,b){y[2]?p||(p=u7(),p.c(),p.m(e.parentNode,e)):p&&(p.d(1),p=null);const x={};if(b&2097152&&(x.$$scope={dirty:b,ctx:y}),l.$set(x),b&8){m=y[3];let w;for(w=0;w<m.length;w+=1){const S=c7(y,m,w);g[w]?g[w].p(S,b):(g[w]=h7(S),g[w].c(),g[w].m(u,null))}for(;w<g.length;w+=1)g[w].d(1);g.length=m.length}},i(y){h||(Ie(l.$$.fragment,y),h=!0)},o(y){$e(l.$$.fragment,y),h=!1},d(y){p&&p.d(y),y&&de(e),y&&de(t),n[13](null),Tt(l),qs(g,y),f=!1,po(d)}}}function mCt(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[pCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&2097166&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function gCt(n,e,t){let{title:r}=e,{images:s}=e,{thumbnails:i}=e,{width:o}=e,{height:a}=e,l,c=0,u=!1,h=[];const f=({dataTransfer:{types:S=[]}})=>S.indexOf("Files")>-1;function d(S){S.preventDefault(),f(S)&&(c+=1,t(2,u=!0))}function p(){c-=1,c<1&&t(2,u=!1)}function m(S){f(S)&&S.preventDefault()}async function g(S){const{image:C}=await Pj(S,{...o>0&&{maxWidth:o},...a>0&&{maxHeight:a},cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),{image:k}=await Pj(S,{maxWidth:60,maxHeight:60,cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),A=C,M=A.getContext("2d").getImageData(0,0,o||A.width,a||A.height),N=k.toDataURL("image/jpeg");i.set(N),s.set(M)}async function y(S){t(3,h=[]);let C=Promise.resolve();for(let k=0;k<S.length;k++){const A=S[k];A.type.match("image.*")&&(C=C.then(()=>g(A))),t(2,u=!1),c=0}await C}function b(S){S.preventDefault(),y(S.dataTransfer.files)}$u(async()=>{await ea(),await ea(),l.addEventListener("change",S=>{y(S.target.files)})});function x(){l&&l.click()}function w(S){hi[S?"unshift":"push"](()=>{l=S,t(1,l)})}return n.$$set=S=>{"title"in S&&t(0,r=S.title),"images"in S&&t(9,s=S.images),"thumbnails"in S&&t(10,i=S.thumbnails),"width"in S&&t(11,o=S.width),"height"in S&&t(12,a=S.height)},[r,l,u,h,d,p,m,b,x,s,i,o,a,w]}class yCt extends xn{constructor(e){super(),wn(this,e,gCt,mCt,pn,{title:0,images:9,thumbnails:10,width:11,height:12})}}var yI,bI;class bCt extends Aa{constructor({width:e=0,height:t=0}={}){super(),this.title="image upload",this.$images=new mt(F_()),this.$thumbnails=new mt(F_()),yI.set(this,void 0),bI.set(this,void 0),ir(this,yI,e,"f"),ir(this,bI,t,"f"),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new yCt({target:t,props:{title:this.title,images:this.$images,thumbnails:this.$thumbnails,width:$t(this,yI,"f"),height:$t(this,bI,"f")}}))}}yI=new WeakMap,bI=new WeakMap;function vCt(...n){return new bCt(...n)}function wCt(n,e){return n.map((t,r)=>Math.abs(t-e[r])**2).reduce((t,r)=>t+r)**(1/2)}class sU extends l0{constructor({k:e=3}={}){super(),this.title="k-means clustering",this.serviceName="kmeans-models",this.parameters={k:new mt(e,!0)},this.$centers=new mt([],!1),this.$clusters=new mt([],!1),this.dataset=[],this.start()}async train(e){this.$training.set({status:"start",epochs:1});const t=Uf(e)?e.items():e;for await(const{x:s}of t)this.dataset.push(s);const r=lft(this.dataset,this.parameters.k.get());this.$centers.set(r.centroids.map(s=>s.centroid)),this.$clusters.set(r.clusters),this.$training.set({status:"success"})}async predict(e){let t=0,r=1e3;const s={};let i=0;for(let o=0;o<this.$centers.get().length;o++){const a=wCt(this.$centers.get()[o],e);a<r&&(r=a,t=o),s[`${o}`]=Math.exp(a),i+=Math.exp(a)}if(Object.entries(s).forEach(([o])=>{s[o]/=i}),this.$centers.get().length===0){const o=new Error("KMeans is not trained");o.name="[KMeans] Prediction Error",Ea(o)}return{cluster:t,confidences:s}}async batchPredict(e){const t=[],r=Uf(e)?e.items():e;for await(const{x:i}of r)t.push(i);const s=[];for(let i=0;i<t.length;i++)this.predict(t[i]).then(o=>s.push(o));if(this.$centers.get().length===0){const i=new Error("KMeans is not trained");i.name="[KMeans] Prediction Error",Ea(i)}return s}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);GS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){return{name:JC(this.title),files:[],format:"ml-kmeans",metadata:{clusters:this.$clusters.get(),centers:this.$centers.get(),...e}}}async read(e){const t=e.metadata.data;t&&(Object.entries(t).forEach(([r,s])=>{}),this.$clusters.set(e.metadata.labels),this.$training.set({status:"loaded"}))}}Dn([Ln],sU.prototype,"train",null);Dn([Ln],sU.prototype,"predict",null);Dn([Ln],sU.prototype,"batchPredict",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.flatten=function(){return this.throwIfDisposed(),mx(this,[this.size])};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xCt(n){const e=$i(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ws.runKernel(ESt,t)}else{const t={x:e};return ws.runKernel(SSt,t)}}const Td=ia({abs_:xCt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ct(n,e){const t=$i(n,"x","cast");if(!hSt(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return ws.runKernel(nue,r,s)}const yue=ia({cast_:_Ct});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SCt(n,e,t=!1,r=!1){let s=$i(n,"a","matMul"),i=$i(e,"b","matMul");[s,i]=rU(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return ws.runKernel(TSt,o,a)}const CCt=ia({matMul_:SCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kCt(n,e){let t=$i(n,"a","mul"),r=$i(e,"b","mul");[t,r]=rU(t,r);const s={a:t,b:r};return ws.runKernel(RSt,s)}const TCt=ia({mul_:kCt});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECt(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function ICt(n,e){const t=e.map(r=>1);return ECt(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACt(n,e=null,t=!1){const s={x:$i(n,"x","max")},i={reductionIndices:e,keepDims:t};return ws.runKernel(NSt,s,i)}const lD=ia({max_:ACt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MCt(n,e=null,t=!1){const s={x:$i(n,"x","min")},i={axis:e,keepDims:t};return ws.runKernel($St,s,i)}const f7=ia({min_:MCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NCt(n,e){let t=$i(n,"base","pow"),r=$i(e,"exp","pow");[t,r]=rU(t,r);const s={a:t,b:r};return ws.runKernel(PSt,s)}const $Ct=ia({pow_:NCt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCt(n,e,t,r){if(r==null)r=eU(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(aue(n)||oue(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ws.backend.createTensorFromGPUData(n,e||t,r)}if(!Pu(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){gSt(e);const s=Gb(e),i=Gb(t);Bi(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Gb(e.slice(o)):!0;Bi(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Pu(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?sue(n,r):HS(n,[],!0),ws.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PCt(n,e){if((Pu(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Pu(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return RCt(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCt(n){const t={x:$i(n,"x","sqrt","float32")};return ws.runKernel(OSt,t)}const d7=ia({sqrt_:DCt});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OCt(n){const e=$i(n,"x","square"),t={};return ws.runKernel("Square",{x:e},t)}const FCt=ia({square_:OCt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LCt(n,e=null,t=!1){let r=$i(n,"x","sum");r.dtype==="bool"&&(r=yue(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ws.runKernel(FSt,s,i)}const pb=ia({sum_:LCt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zCt(n,e="euclidean",t=null,r=!1){n=$i(n,"x","norm");const s=bue(n,e,t);let i=s.shape;if(r){const o=Yce(t,n.shape);i=ICt(s.shape,o)}return mx(s,i)}function bue(n,e,t=null){if(n.rank===0)return Td(n);if(n.rank!==1&&t===null)return bue(mx(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return pb(Td(n),t);if(e===1/0)return lD(Td(n),t);if(e===-1/0)return f7(Td(n),t);if(e==="euclidean"||e===2)return d7(pb($Ct(Td(n),PCt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return lD(pb(Td(n),t[0]),t[1]-1);if(e===1/0)return lD(pb(Td(n),t[1]),t[0]);if(e===-1/0)return f7(pb(Td(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return d7(pb(FCt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const BCt=ia({norm_:zCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.norm=function(n,e,t){return this.throwIfDisposed(),BCt(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),CCt(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.as1D=function(){return this.throwIfDisposed(),mx(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.as2D=function(n,e){return this.throwIfDisposed(),mx(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.asType=function(n){return this.throwIfDisposed(),yue(this,n)};class vue extends l0{constructor({k:e=3}={}){super(),this.title="KNN classifier",this.serviceName="knn-classifier-models",this.classifier=new dft,this.parameters={k:new mt(e,!0)}}async train(e){this.labels=Uf(e)?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:r})=>r).toArray()));const t=Uf(e)?e.items():e;if(this.labels.length<1)throw this.$training.set({status:"error"}),new Error("Cannot train a kNN with no classes");this.$training.set({status:"start",epochs:1}),this.classifier.clearAllClasses();for await(const{x:r,y:s}of t)this.classifier.addExample(Ei(r),s);this.$training.set({status:"success"})}async predict(e){if(!this.classifier||!this.labels||this.labels.length<1)return{label:void 0,confidences:{}};const{label:t,confidences:r}=await this.classifier.predictClass(Ei(e),this.parameters.k.get());return{label:t,confidences:r}}clear(){delete this.classifier}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);GS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){if(!this.classifier)return null;const t=this.classifier.getClassifierDataset(),r={};for(const i of Object.keys(t)){const o=t[i].arraySync();r[i]=o}return{name:JC(this.title),files:[],format:"knn-classifier",metadata:{labels:this.labels,data:r,...e}}}async read(e){const t=e.metadata.data;if(!t)return;const r={};for(const[s,i]of Object.entries(t))r[s]=Xa(i);this.labels=e.metadata.labels,this.classifier.setClassifierDataset(r),this.$training.set({status:"loaded"})}}Dn([Ln],vue.prototype,"train",null);Dn([Ln],vue.prototype,"predict",null);class VCt extends hue{constructor({layers:e=[64,32],...t}={}){super(t),this.title="MLPClassifier",this.parameters={layers:new mt(e,!0),...this.parameters}}buildModel(e,t){this.model=art();for(const[s,i]of this.parameters.layers.get().entries()){const o={units:i,activation:"relu"};s===0&&(o.inputDim=e[0]),this.model.add(z6(o))}this.model.add(z6({units:t[0],activation:"softmax"}));const r=Id.adam();this.model.compile({optimizer:r,loss:"categoricalCrossentropy",metrics:["accuracy"]})}}function UCt(...n){return new VCt(...n)}function WCt(n){let e,t,r,s,i;return{c(){e=He("Using Mobilenet v"),t=He(n[2]),r=He(" with alpha = "),s=He(n[3]),i=He(".")},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,s,a),me(o,i,a)},p(o,a){a&4&&cn(t,o[2]),a&8&&cn(s,o[3])},d(o){o&&de(e),o&&de(t),o&&de(r),o&&de(s),o&&de(i)}}}function GCt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function HCt(n){let e;function t(i,o){return i[4]?GCt:WCt}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function jCt(n){let e,t;return e=new sa({props:{title:n[0],loading:n[4],$$slots:{default:[HCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&16&&(i.loading=r[4]),s&60&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function qCt(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,u=>t(4,r=u)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{version:l}=e,{alpha:c}=e;return n.$$set=u=>{"title"in u&&t(0,o=u.title),"loading"in u&&i(t(1,a=u.loading)),"version"in u&&t(2,l=u.version),"alpha"in u&&t(3,c=u.alpha)},[o,a,l,c,r]}class XCt extends xn{constructor(e){super(),wn(this,e,qCt,jCt,pn,{title:0,loading:1,version:2,alpha:3})}}var yf;class bx extends l0{constructor({version:e=1,alpha:t=1}={}){if(super(),this.title="mobileNet",this.parameters={},this.serviceName="undefined",yf.set(this,void 0),this.$loading=new mt(!0,!0),![1,2].includes(e))throw new Error("Mobilenet version must be 1 or 2");if(![.25,.5,.75,1].includes(t))throw new Error("Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0");this.version=e,this.alpha=t,this.setup()}async setup(){await K2();const e=await HL(),t=Object.keys(e).filter(r=>r.includes("mobileNet"));try{ir(this,yf,await Vj({modelUrl:`indexeddb://mobilenet-v${this.version}-${this.alpha}`,version:this.version,alpha:this.alpha}),"f")}catch{t.length>0&&await jL(t[0]),ir(this,yf,await Vj({version:this.version,alpha:this.alpha}),"f"),await $t(this,yf,"f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`)}return ya.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`),this.$loading.set(!1),this.start(),this}async process(e){return $t(this,yf,"f")?Se(()=>$t(this,yf,"f").infer(e,!0).arraySync()[0]):[]}async predict(e){if(!$t(this,yf,"f"))throw new Error("Mobilenet is not loaded");const t=await $t(this,yf,"f").classify(e,5);return{label:t[0].className,confidences:t.reduce((r,s)=>({...r,[s.className]:s.probability}),{})}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new XCt({target:t,props:{title:this.title,loading:this.$loading,version:this.version,alpha:this.alpha}}))}train(){throw new Ip("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}yf=new WeakMap;Dn([Ln],bx.prototype,"train",null);Dn([Ln],bx.prototype,"save",null);Dn([Ln],bx.prototype,"load",null);Dn([Ln],bx.prototype,"download",null);Dn([Ln],bx.prototype,"upload",null);function KCt(...n){return new bx(...n)}function YCt(n){let e,t,r;function s(o){n[7](o)}let i={type:"text"};return n[2]!==void 0&&(i.value=n[2]),e=new o1t({props:i}),hi.push(()=>nd(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function ZCt(n){let e,t,r;function s(o){n[6](o)}let i={};return n[2]!==void 0&&(i.value=n[2]),e=new x1t({props:i}),hi.push(()=>nd(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function JCt(n){let e,t,r;function s(o){n[5](o)}let i={};return n[2]!==void 0&&(i.value=n[2]),e=new b1t({props:i}),hi.push(()=>nd(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function QCt(n){let e,t,r;function s(o){n[4](o)}let i={};return n[2]!==void 0&&(i.checked=n[2]),e=new R1t({props:i}),hi.push(()=>nd(e,"checked",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.checked=o[2],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function ekt(n){let e,t,r;function s(o){n[3](o)}let i={options:n[1].options};return n[2]!==void 0&&(i.value=n[2]),e=new Lce({props:i}),hi.push(()=>nd(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.options=o[1].options),!t&&a&4&&(t=!0,l.value=o[2],td(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function tkt(n){let e,t,r,s,i,o,a,l;const c=[ekt,QCt,JCt,ZCt,YCt],u=[];function h(f,d){return d&2&&(t=null),d&3&&(r=null),d&3&&(s=null),d&3&&(i=null),t==null&&(t=!!(f[1].type==="menu"&&Array.isArray(f[1].options)&&f[1].options.length>0)),t?0:(r==null&&(r=f[1].type==="boolean"||f[1].type==="auto"&&typeof f[0].get()=="boolean"),r?1:(s==null&&(s=f[1].type==="number"||f[1].type==="auto"&&typeof f[0].get()=="number"),s?2:(i==null&&(i=!!(f[1].type==="number array"||f[1].type==="auto"&&Array.isArray(f[0].get())&&f[0].get().length&&typeof f[0].get()[0]=="number")),i?3:4)))}return o=h(n,-1),a=u[o]=c[o](n),{c(){e=we("div"),a.c(),cu(e,"flex-grow","1")},m(f,d){me(f,e,d),u[o].m(e,null),l=!0},p(f,[d]){let p=o;o=h(f,d),o===p?u[o].p(f,d):(dr(),$e(u[p],1,1,()=>{u[p]=null}),pr(),a=u[o],a?a.p(f,d):(a=u[o]=c[o](f),a.c()),Ie(a,1),a.m(e,null))},i(f){l||(Ie(a),l=!0)},o(f){$e(a),l=!1},d(f){f&&de(e),u[o].d()}}}function nkt(n,e,t){let r,s=tt,i=()=>(s(),s=os(o,d=>t(2,r=d)),o);n.$$.on_destroy.push(()=>s());let{stream:o}=e;i();let{spec:a}=e;function l(d){r=d,o.set(r)}function c(d){r=d,o.set(r)}function u(d){r=d,o.set(r)}function h(d){r=d,o.set(r)}function f(d){r=d,o.set(r)}return n.$$set=d=>{"stream"in d&&i(t(0,o=d.stream)),"spec"in d&&t(1,a=d.spec)},[o,a,r,l,c,u,h,f]}class wue extends xn{constructor(e){super(),wn(this,e,nkt,tkt,pn,{stream:0,spec:1})}}function p7(n,e,t){const r=n.slice();return r[4]=e[t][0],r[5]=e[t][1],r}function rkt(n){let e,t;return e=new wue({props:{stream:n[5],spec:{type:"auto"}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&2&&(i.stream=r[5]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function skt(n){let e,t;return e=new wue({props:{stream:n[5],spec:n[2][n[4]]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&2&&(i.stream=r[5]),s&6&&(i.spec=r[2][r[4]]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function m7(n){let e,t,r=n[4]+"",s,i,o,a,l,c;const u=[skt,rkt],h=[];function f(d,p){return d[4]in d[2]?0:1}return o=f(n),a=h[o]=u[o](n),{c(){e=we("div"),t=we("p"),s=He(r),i=Ye(),a.c(),l=Ye(),Z(t,"class","w-32 my-2"),Z(e,"class","flex my-1 items-center")},m(d,p){me(d,e,p),se(e,t),se(t,s),se(e,i),h[o].m(e,null),se(e,l),c=!0},p(d,p){(!c||p&2)&&r!==(r=d[4]+"")&&cn(s,r);let m=o;o=f(d),o===m?h[o].p(d,p):(dr(),$e(h[m],1,1,()=>{h[m]=null}),pr(),a=h[o],a?a.p(d,p):(a=h[o]=u[o](d),a.c()),Ie(a,1),a.m(e,l))},i(d){c||(Ie(a),c=!0)},o(d){$e(a),c=!1},d(d){d&&de(e),h[o].d()}}}function ikt(n){let e,t,r=Object.entries(n[1]),s=[];for(let o=0;o<r.length;o+=1)s[o]=m7(p7(n,r,o));const i=o=>$e(s[o],1,1,()=>{s[o]=null});return{c(){e=we("div");for(let o=0;o<s.length;o+=1)s[o].c();Z(e,"class","m-2")},m(o,a){me(o,e,a);for(let l=0;l<s.length;l+=1)s[l]&&s[l].m(e,null);t=!0},p(o,a){if(a&6){r=Object.entries(o[1]);let l;for(l=0;l<r.length;l+=1){const c=p7(o,r,l);s[l]?(s[l].p(c,a),Ie(s[l],1)):(s[l]=m7(c),s[l].c(),Ie(s[l],1),s[l].m(e,null))}for(dr(),l=r.length;l<s.length;l+=1)i(l);pr()}},i(o){if(!t){for(let a=0;a<r.length;a+=1)Ie(s[a]);t=!0}},o(o){s=s.filter(Boolean);for(let a=0;a<s.length;a+=1)$e(s[a]);t=!1},d(o){o&&de(e),qs(s,o)}}}function okt(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[ikt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&262&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function akt(n,e,t){let{title:r}=e,{parameters:s}=e,{config:i={}}=e,o=[];return n.$$set=a=>{"title"in a&&t(0,r=a.title),"parameters"in a&&t(1,s=a.parameters),"config"in a&&t(2,i=a.config)},n.$$.update=()=>{if(n.$$.dirty&10){for(const a of o)a();t(3,o=Object.values(s).map(a=>a.subscribe()))}},[r,s,i,o]}class lkt extends xn{constructor(e){super(),wn(this,e,akt,okt,pn,{title:0,parameters:1,config:2})}}var vI;class ckt extends Aa{constructor(e,t={}){super(),this.title="modelParameters",vI.set(this,void 0),ir(this,vI,e,"f"),this.config=t}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new lkt({target:t,props:{title:this.title,parameters:$t(this,vI,"f").parameters,config:this.config}}))}}vI=new WeakMap;function ukt(n,e={}){if(!n.parameters)throw new Error("The argument is not a valid component with parameters");return new ckt(n,e)}function hkt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function fkt(n){let e,t,r,s;return{c(){e=we("p"),t=He("Model Loaded from "),r=He(n[2]),s=He(".")},m(i,o){me(i,e,o),se(e,t),se(e,r),se(e,s)},p(i,o){o&4&&cn(r,i[2])},d(i){i&&de(e)}}}function dkt(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function pkt(n){let e;function t(i,o){return i[3]==="loading"?dkt:i[3]==="loaded"?fkt:hkt}let r=t(n),s=r(n);return{c(){e=we("div"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function mkt(n){let e,t;return e=new sa({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[pkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function gkt(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class ykt extends xn{constructor(e){super(),wn(this,e,gkt,mkt,pn,{title:0,training:1})}}var bf;function g7(n,e){return n===e}function y7(n,e){return n===e}class ju extends l0{constructor({inputType:e,taskType:t,inputShape:r}){super(),this.title="onnx model",this.parameters={},this.serviceName="onnx-models",this.$loading=new mt(!1,!0),this.$ready=new mt(!1,!0),this.modelName="",this.lockLoading=Promise.resolve(),bf.set(this,void 0),this.inputType=e,this.taskType=t,this.inputShape=r,this.start()}train(){throw new Ip("Model `OnnxModel` cannot be trained")}async predict(e){if(!$t(this,bf,"f")||!this.$ready.get())throw new Error("Model is not loaded");const t=this.preprocess(e),r=await $t(this,bf,"f").run({[$t(this,bf,"f").inputNames[0]]:t});return await this.postprocess(r)}async loadFromUrl(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{await this.loadModel(e,e),this.$training.set({status:"loaded",data:{source:"url",url:e}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}async loadFromFile(e){if(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{const t=await new Promise((r,s)=>{const i=new FileReader;i.onload=function(){const a=this.result;r(a)},i.onerror=function(){s()},i.readAsArrayBuffer(e)});await this.loadModel(t,e.name),this.$training.set({status:"loaded",data:{source:"file"}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}}async loadModel(e,t){this.ready=!1,this.lockLoading=this.lockLoading.then(()=>ort.InferenceSession.create(e)).then(r=>{ir(this,bf,r,"f")}),await this.lockLoading,this.modelName=t;try{await this.warmup()}catch(r){console.log("ONNX Model warmup failed",r)}this.ready=!0}preprocess(e){if(g7(this.inputType,"image"))return this.preprocessImage(e);if(g7(this.inputType,"generic")){const t=e.flat().flat().flat().flat().flat();return new ort.Tensor("float32",Float32Array.from(t),this.inputShape)}throw new Error("Invalid input data type")}preprocessImage(e){throw new Error("ONNX for Images: Not yet implemented")}async postprocess(e){if(y7(this.taskType,"classification")){const t=this.labels?s=>this.labels[s]:s=>s.toString(),r=Array.from(e.probabilities.data).reduce((s,i,o)=>({...s,[t(o)]:i}),{});return{label:t(e.label.data[0]),confidences:r}}if(y7(this.taskType,"generic")){const t={};for(const r of $t(this,bf,"f").outputNames)t[r]=Array.from(e[r].data);return t}throw new Error("Invalid output data type")}async warmup(){const e=Float32Array.from(Array(this.inputShape.reduce((r,s)=>r*s,1)),()=>Math.random()),t=new ort.Tensor("float32",e,this.inputShape);await $t(this,bf,"f").run({[$t(this,bf,"f").inputNames[0]]:t})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new ykt({target:t,props:{title:this.title,training:this.$training}}))}save(){throw new Error("OnnxModel does not support saving")}load(){throw new Error("OnnxModel does not support loading")}download(){throw new Error("OnnxModel does not support downloading")}upload(){throw new Error("OnnxModel does not support uploading")}}bf=new WeakMap;Dn([Ln],ju.prototype,"train",null);Dn([Ln],ju.prototype,"predict",null);Dn([Ln],ju.prototype,"loadFromUrl",null);Dn([Ln],ju.prototype,"loadFromFile",null);Dn([Ln],ju.prototype,"loadModel",null);Dn([Ln],ju.prototype,"preprocess",null);Dn([Ln],ju.prototype,"postprocess",null);Dn([Ln],ju.prototype,"save",null);Dn([Ln],ju.prototype,"load",null);Dn([Ln],ju.prototype,"download",null);Dn([Ln],ju.prototype,"upload",null);const bkt={MoveNet:.35,PoseNet:.5,BlazePose:.65},vkt=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class b7{constructor(e,t){this.model=e,this.width=t,this.params={lineWidth:2,radius:4,scoreThreshold:bkt[e]},this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.width,this.ctx=this.canvas.getContext("2d")}drawKeypoint(e){if((e.score!=null?e.score:1)>=this.params.scoreThreshold){const r=new Path2D;r.arc(e.x,e.y,this.params.radius,0,2*Math.PI),this.ctx.fill(r),this.ctx.stroke(r)}}drawKeypoints(e){const t=Zj.getKeypointIndexBySide(this.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=this.params.lineWidth;for(const r of t.middle)this.drawKeypoint(e[r]);this.ctx.fillStyle="Green";for(const r of t.left)this.drawKeypoint(e[r]);this.ctx.fillStyle="Orange";for(const r of t.right)this.drawKeypoint(e[r])}drawSkeleton(e,t){const r=t!=null?vkt[t%20]:"White";this.ctx.fillStyle=r,this.ctx.strokeStyle=r,this.ctx.lineWidth=this.params.lineWidth,Zj.getAdjacentPairs(this.model).forEach(([s,i])=>{const o=e[s],a=e[i],l=o.score!=null?o.score:1,c=a.score!=null?a.score:1,u=this.params.scoreThreshold||0;l>=u&&c>=u&&(this.ctx.beginPath(),this.ctx.moveTo(o.x,o.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke())})}drawResult(e){if(e.keypoints!=null&&(this.drawKeypoints(e.keypoints),this.drawSkeleton(e.keypoints,e.id)),e.keypoints3D!=null)throw new Error("Keypoints 3D is not Implemented...")}drawResults(e){for(const t of e)this.drawResult(t)}drawImage(e){this.ctx.clearRect(0,0,e.width,e.width),this.canvas.height=e.height,this.canvas.width=e.width,this.ctx.putImageData(e,0,0)}render(e,t,r="ImageData"){return this.drawImage(e),this.drawResults(t),r==="ImageData"?this.ctx.getImageData(0,0,this.width,this.width):this.canvas.toDataURL("image/jpeg")}}function wkt(n){let e,t,r;return{c(){e=He("Using "),t=He(n[2]),r=He(" pose detector.")},m(s,i){me(s,e,i),me(s,t,i),me(s,r,i)},p(s,i){i&4&&cn(t,s[2])},d(s){s&&de(e),s&&de(t),s&&de(r)}}}function xkt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function _kt(n){let e;function t(i,o){return i[3]?xkt:wkt}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function Skt(n){let e,t;return e=new sa({props:{title:n[0],loading:n[3],$$slots:{default:[_kt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Ckt(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{model:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"model"in c&&t(2,l=c.model)},[o,a,l,r]}class kkt extends xn{constructor(e){super(),wn(this,e,Ckt,Skt,pn,{title:0,loading:1,model:2})}}var Z1,wI,xI;class QC extends l0{constructor(e="MoveNet",t){super(),this.model=e,this.modelConfig=t,this.title="Pose Detection",this.parameters={},this.serviceName="undefined",Z1.set(this,void 0),this.$loading=new mt(!0,!0),this.$bodyParts=new mt("Full body",!1),wI.set(this,void 0),xI.set(this,void 0),ir(this,wI,new b7(io[e],224),"f"),ir(this,xI,new b7(io[e],60),"f"),this.start(),this.setup(e,t)}async setup(e,t){await K2(),ir(this,Z1,await Tdt(io[e],t),"f"),ya.info(`${e} loaded`),this.$loading.set(!1),this.start()}async predict(e){return $t(this,Z1,"f")?await $t(this,Z1,"f").estimatePoses(e):(ya.error("Movenet is not loaded"),[])}postprocess(e,t){const r=t&&Array.isArray(t)&&t.length>0?(s,i)=>t.includes(i):()=>!0;return e.map(s=>{const i=s.keypoints[0];return s.keypoints.filter(r).reduce((o,a)=>[...o,(a.x-i.x)/100,(a.y-i.y)/100],[])}).reduce((s,i)=>[...s,...i],[])}thumbnail(e,t){return $t(this,xI,"f").render(e,t,"dataURL")}render(e,t){return $t(this,wI,"f").render(e,t)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new kkt({target:t,props:{title:this.title,loading:this.$loading,model:this.model}}))}train(){throw new Ip("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}Z1=new WeakMap,wI=new WeakMap,xI=new WeakMap;Dn([Ln],QC.prototype,"train",null);Dn([Ln],QC.prototype,"save",null);Dn([Ln],QC.prototype,"load",null);Dn([Ln],QC.prototype,"download",null);Dn([Ln],QC.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fc().prototype.mul=function(n){return this.throwIfDisposed(),TCt(this,n)};function Tkt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Ekt(n){let e,t,r,s;return{c(){e=we("p"),t=He("Model Loaded from "),r=He(n[2]),s=He(".")},m(i,o){me(i,e,o),se(e,t),se(e,r),se(e,s)},p(i,o){o&4&&cn(r,i[2])},d(i){i&&de(e)}}}function Ikt(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Akt(n){let e;function t(i,o){return i[3]==="loading"?Ikt:i[3]==="loaded"?Ekt:Tkt}let r=t(n),s=r(n);return{c(){e=we("div"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function Mkt(n){let e,t;return e=new sa({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[Akt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Nkt(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class $kt extends xn{constructor(e){super(),wn(this,e,Nkt,Mkt,pn,{title:0,training:1})}}function v7(n,e){return n===e}function cD(n,e){return n===e}class c0 extends X${constructor({inputType:e,taskType:t,segmentationOptions:r={applyArgmax:!1,output:"image"}}){super(),this.title="tfjs model",this.parameters={},this.segmentationOptions={applyArgmax:!1,output:"image",...r},this.inputType=e,this.taskType=t,this.$training.subscribe(({status:s})=>{s==="loaded"&&(this.inputShape=this.model.inputs[0].shape.map(i=>i&&i>0?i:1))})}train(){throw new Ip("Model `TfModel` cannot be trained")}async predict(e){if(!this.model||this.$training.get().status!=="loaded")throw new Error("Model is not loaded");const t=Se(()=>{const s=this.preprocess(e);return this.model.predict(s.expandDims(0)).gather(0)}),r=await this.postprocess(t);return t.dispose(),r}preprocess(e){if(v7(this.inputType,"image"))return this.preprocessImage(e);if(v7(this.inputType,"generic"))return Ei(e);throw new Error("Invalid input data type")}preprocessImage(e){return Ci.resizeBilinear(cC(e),[this.inputShape[1],this.inputShape[2]])}async postprocess(e){if(cD(this.taskType,"classification")){const t=this.labels?i=>this.labels[i]:i=>i.toString(),r=Se(()=>e.argMax().dataSync()[0]),s=e.arraySync().reduce((i,o,a)=>({...i,[t(a)]:o}),{});return{label:t(r),confidences:s}}if(cD(this.taskType,"segmentation")){const[t,r]=e.shape,s=this.segmentationOptions.applyArgmax?Se(()=>e.argMax(-1).mul(.5)):e,i=this.segmentationOptions.output==="image"?new ImageData(await lC(s),t,r):await s.array();return this.segmentationOptions.applyArgmax&&s.dispose(),i}if(cD(this.taskType,"generic"))return e.array();throw new Error("Invalid output data type")}async loadFromFiles(e){this.$training.set({status:"loading"});try{const t=e.filter(s=>s.name.includes(".json")),r=e.filter(s=>s.name.includes(".bin"));if(t.length!==1){const s=new Error("The provided files are not compatible with this model");throw s.name="File upload error",s}if(this.$training.set({status:"loading"}),e.length){const s=await Hce(t[0]);this.loadFn=s.format==="graph-model"?Rl:J_,this.model=await this.loadFn(Xce([t[0],...r])),await this.warmup(),this.$training.set({status:"loaded",data:{source:"file"}})}}catch(t){throw this.$training.set({status:"error"}),t}}async loadFromUrl(e){this.$training.set({status:"loading"});try{const t=await fetch(e).then(r=>r.json());this.loadFn=t.format==="graph-model"?Rl:J_,this.model=await this.loadFn(wL(e)),await this.warmup(),this.$training.set({status:"loaded",data:{source:"url",url:e}})}catch(t){throw console.log("[tf-model] Loading error",t),this.$training.set({status:"error"}),t}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new $kt({target:t,props:{title:this.title,training:this.$training}}))}}Dn([Ln],c0.prototype,"train",null);Dn([Ln],c0.prototype,"predict",null);Dn([Ln],c0.prototype,"preprocess",null);Dn([Ln],c0.prototype,"preprocessImage",null);Dn([Ln],c0.prototype,"postprocess",null);Dn([Ln],c0.prototype,"loadFromFiles",null);Dn([Ln],c0.prototype,"loadFromUrl",null);const Rkt=n=>function(t,r,s){const i=s.value;return s.value=function(...a){const l=this[n].then(()=>i.apply(this,a));return this[n]=l,l},s};function Pkt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:tt,i:tt,o:tt,d(t){t&&de(e)}}}function Dkt(n){let e,t;return e=new Vce({props:{columns:[{name:"field"},...n[2]],provider:n[1],selectable:!1}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&4&&(i.columns=[{name:"field"},...r[2]]),s&2&&(i.provider=r[1]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Okt(n){let e,t,r,s;const i=[Dkt,Pkt],o=[];function a(l,c){return l[0].length>0?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=mo()},m(l,c){o[e].m(l,c),me(l,r,c),s=!0},p(l,[c]){let u=e;e=a(l),e===u?o[e].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ie(t,1),t.m(r.parentNode,r))},i(l){s||(Ie(t),s=!0)},o(l){$e(t),s=!1},d(l){o[e].d(l),l&&de(r)}}}function Fkt(n,e,t){let r,s,i,o,{runs:a}=e;return n.$$set=l=>{"runs"in l&&t(0,a=l.runs)},n.$$.update=()=>{n.$$.dirty&1&&t(2,r=a.map((l,c)=>({name:`Run ${c+1}`}))),n.$$.dirty&1&&t(4,s=a.length>0?Object.keys(a[0]).filter(l=>l!=="logs"):[]),n.$$.dirty&17&&t(3,i=s.map(l=>a.map((c,u)=>({[`Run ${u+1}`]:c[l]})).reduce((c,u)=>({...c,...u}),{field:l}))),n.$$.dirty&8&&t(1,o=new S_t({data:i}))},[a,o,r,i,s]}class xue extends xn{constructor(e){super(),wn(this,e,Fkt,Okt,pn,{runs:0})}}function w7(n,e,t){const r=n.slice();return r[5]=e[t],r[6]=e,r[7]=t,r}function x7(n){let e,t=n[7];const r=()=>n[3](e,t),s=()=>n[3](null,t);return{c(){e=we("div"),Z(e,"class","card inner-card xl:flex-1 svelte-1o4ebpu")},m(i,o){me(i,e,o),r()},p(i,o){n=i,t!==n[7]&&(s(),t=n[7],r())},d(i){i&&de(e),s()}}}function Lkt(n){let e,t=Object.values(n[0]),r=[];for(let s=0;s<t.length;s+=1)r[s]=x7(w7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","grid grid-cols-1 gap-1")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null);n[4](e)},p(s,[i]){if(i&5){t=Object.values(s[0]);let o;for(o=0;o<t.length;o+=1){const a=w7(s,t,o);r[o]?r[o].p(a,i):(r[o]=x7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},i:tt,o:tt,d(s){s&&de(e),qs(r,s),n[4](null)}}}function zkt(n,e,t){let{charts:r}=e,s,i=[];$u(async()=>{await ea(),await ea(),Object.keys(r).length>1&&s.clientWidth>700&&t(1,s.style.gridTemplateColumns="repeat(2, minmax(0, 1fr))",s);for(const[l,c]of Object.values(r).entries())c.mount(i[l])}),Fg(()=>{for(const l of Object.values(r))l.destroy()});function o(l,c){hi[l?"unshift":"push"](()=>{i[c]=l,t(2,i)})}function a(l){hi[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"charts"in l&&t(0,r=l.charts)},[r,s,i,o,a]}class Bkt extends xn{constructor(e){super(),wn(this,e,zkt,Lkt,pn,{charts:0})}}class Vkt extends Aa{constructor(e,t={loss:["loss","lossVal"],accuracy:["acc","accVal"]}){if(super(),this.model=e,this.title="training plot",this.charts={},!e){const o=new Error("[training plot] No model was provided");o.name="Component Compatibility Error",Ea(o)}if(!e.$training){const o=new Error("[training plot] The provided model is incompatible with the training plot component, missing `$training` stream");o.name="Component Compatibility Error",Ea(o)}let r=t;typeof t=="string"&&(r=[t]),Array.isArray(r)&&(r=r.reduce((o,a)=>({...o,[a]:a}),{}));const s={};for(const[o,a]of Object.entries(r)){const l=Array.isArray(a)?a:[a];this.charts[o]=due({preset:"line-fast",options:{xlabel:"Epoch",ylabel:o}});for(const c of l)Object.keys(s).includes(c)||(s[c]=new mt([],!0)),this.charts[o].addSeries(s[c],c);this.charts[o].title=o}function i(){for(const o of Object.values(s))o.set([])}e.$training.subscribe(o=>{if(o.status==="start")i();else if(o.data)for(const[a,l]of Object.entries(o.data)){if(!Object.keys(s).includes(a))return;Array.isArray(l)?s[a].set(l.map((c,u)=>({x:u+1,y:c}))):s[a].set(s[a].get().concat([{x:s[a].get().length+1,y:l}]))}}),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new Bkt({target:t,props:{charts:this.charts}}))}}function _ue(...n){return new Vkt(...n)}function Ukt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Wkt(n){let e;return{c(){e=we("div")},m(t,r){me(t,e,r),n[7](e)},p:tt,d(t){t&&de(e),n[7](null)}}}function Gkt(n){let e;function t(i,o){return i[0].length>0?Wkt:Ukt}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,[o]){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},i:tt,o:tt,d(i){s.d(i),i&&de(e)}}}function Hkt(n,e,t){let r,s,{names:i}=e,{logs:o}=e,a,l,c;Fg(()=>{c&&c.destroy()});function u(h){hi[h?"unshift":"push"](()=>{a=h,t(1,a)})}return n.$$set=h=>{"names"in h&&t(2,i=h.names),"logs"in h&&t(0,o=h.logs)},n.$$.update=()=>{n.$$.dirty&9&&(t(3,l=Array.from(new Set(o.map(Object.keys).flat()))),l.sort()),n.$$.dirty&5&&t(6,r=o.map((h,f)=>Object.entries(h).reduce((d,[p,m])=>({...d,[`${p} (${i[f]})`]:m}),{})).reduce((h,f)=>({...h,...f}),{})),n.$$.dirty&72&&t(5,s=l.reduce((h,f)=>({...h,[f]:Object.keys(r).filter(d=>d.startsWith(`${f} (`))}),{})),n.$$.dirty&114&&(c&&c.destroy(),t(4,c=_ue({$training:new mt({status:"success",data:r},!0)},s)),c.mount(a))},[o,a,i,l,c,s,r,u]}class jkt extends xn{constructor(e){super(),wn(this,e,Hkt,Gkt,pn,{names:2,logs:0})}}function _7(n,e,t){const r=n.slice();return r[13]=e[t],r[15]=t,r}function qkt(n){let e;return{c(){e=He("Graphs")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Xkt(n){let e;return{c(){e=He("Metadata")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Kkt(n){let e;return{c(){e=He("Parameters")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Ykt(n){let e;return{c(){e=He("Model Summary")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Zkt(n){let e,t,r,s,i,o,a,l;return e=new $E({props:{$$slots:{default:[qkt]},$$scope:{ctx:n}}}),r=new $E({props:{$$slots:{default:[Xkt]},$$scope:{ctx:n}}}),i=new $E({props:{$$slots:{default:[Kkt]},$$scope:{ctx:n}}}),a=new $E({props:{$$slots:{default:[Ykt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),t=Ye(),It(r.$$.fragment),s=Ye(),It(i.$$.fragment),o=Ye(),It(a.$$.fragment)},m(c,u){kt(e,c,u),me(c,t,u),kt(r,c,u),me(c,s,u),kt(i,c,u),me(c,o,u),kt(a,c,u),l=!0},p(c,u){const h={};u&65536&&(h.$$scope={dirty:u,ctx:c}),e.$set(h);const f={};u&65536&&(f.$$scope={dirty:u,ctx:c}),r.$set(f);const d={};u&65536&&(d.$$scope={dirty:u,ctx:c}),i.$set(d);const p={};u&65536&&(p.$$scope={dirty:u,ctx:c}),a.$set(p)},i(c){l||(Ie(e.$$.fragment,c),Ie(r.$$.fragment,c),Ie(i.$$.fragment,c),Ie(a.$$.fragment,c),l=!0)},o(c){$e(e.$$.fragment,c),$e(r.$$.fragment,c),$e(i.$$.fragment,c),$e(a.$$.fragment,c),l=!1},d(c){Tt(e,c),c&&de(t),Tt(r,c),c&&de(s),Tt(i,c),c&&de(o),Tt(a,c)}}}function Jkt(n){let e,t;return e=new jkt({props:{logs:n[4].map(k7),names:n[4].map(T7)}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.logs=r[4].map(k7)),s&16&&(i.names=r[4].map(T7)),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Qkt(n){let e,t;return e=new xue({props:{runs:n[4]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function eTt(n){let e,t;return e=new xue({props:{runs:n[4].map(E7)}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4].map(E7)),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function S7(n){let e,t,r,s=n[15]+1+"",i,o,a,l,c=n[13]+"",u,h,f;return{c(){e=we("div"),t=we("h2"),r=He("Model "),i=He(s),o=Ye(),a=we("div"),l=we("pre"),u=He(c),h=we("br"),f=Ye(),Z(a,"class","summary svelte-y4izzs")},m(d,p){me(d,e,p),se(e,t),se(t,r),se(t,i),se(e,o),se(e,a),se(a,l),se(l,u),se(l,h),se(e,f)},p(d,p){p&16&&c!==(c=d[13]+"")&&cn(u,c)},d(d){d&&de(e)}}}function tTt(n){let e,t=n[4].map(I7),r=[];for(let s=0;s<t.length;s+=1)r[s]=S7(_7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","summaries svelte-y4izzs")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&16){t=s[4].map(I7);let o;for(o=0;o<t.length;o+=1){const a=_7(s,t,o);r[o]?r[o].p(a,i):(r[o]=S7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&de(e),qs(r,s)}}}function nTt(n){let e,t,r,s,i,o,a,l,c,u;return e=new __t({props:{$$slots:{default:[Zkt]},$$scope:{ctx:n}}}),r=new RE({props:{$$slots:{default:[Jkt]},$$scope:{ctx:n}}}),i=new RE({props:{$$slots:{default:[Qkt]},$$scope:{ctx:n}}}),a=new RE({props:{$$slots:{default:[eTt]},$$scope:{ctx:n}}}),c=new RE({props:{$$slots:{default:[tTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),t=Ye(),It(r.$$.fragment),s=Ye(),It(i.$$.fragment),o=Ye(),It(a.$$.fragment),l=Ye(),It(c.$$.fragment)},m(h,f){kt(e,h,f),me(h,t,f),kt(r,h,f),me(h,s,f),kt(i,h,f),me(h,o,f),kt(a,h,f),me(h,l,f),kt(c,h,f),u=!0},p(h,f){const d={};f&65536&&(d.$$scope={dirty:f,ctx:h}),e.$set(d);const p={};f&65552&&(p.$$scope={dirty:f,ctx:h}),r.$set(p);const m={};f&65552&&(m.$$scope={dirty:f,ctx:h}),i.$set(m);const g={};f&65552&&(g.$$scope={dirty:f,ctx:h}),a.$set(g);const y={};f&65552&&(y.$$scope={dirty:f,ctx:h}),c.$set(y)},i(h){u||(Ie(e.$$.fragment,h),Ie(r.$$.fragment,h),Ie(i.$$.fragment,h),Ie(a.$$.fragment,h),Ie(c.$$.fragment,h),u=!0)},o(h){$e(e.$$.fragment,h),$e(r.$$.fragment,h),$e(i.$$.fragment,h),$e(a.$$.fragment,h),$e(c.$$.fragment,h),u=!1},d(h){Tt(e,h),h&&de(t),Tt(r,h),h&&de(s),Tt(i,h),h&&de(o),Tt(a,h),h&&de(l),Tt(c,h)}}}function rTt(n){let e,t,r,s,i,o,a;function l(u){n[10](u)}let c={columns:n[7],provider:n[6],actions:[...n[1].map(C7),{name:"delete",confirm:!0}]};return n[4]!==void 0&&(c.selection=n[4]),e=new Vce({props:c}),hi.push(()=>nd(e,"selection",l)),n[11](e),e.$on("select",n[12]),o=new O1t({props:{$$slots:{default:[nTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),r=Ye(),s=we("br"),i=Ye(),It(o.$$.fragment)},m(u,h){kt(e,u,h),me(u,r,h),me(u,s,h),me(u,i,h),kt(o,u,h),a=!0},p(u,h){const f={};h&2&&(f.actions=[...u[1].map(C7),{name:"delete",confirm:!0}]),!t&&h&16&&(t=!0,f.selection=u[4],td(()=>t=!1)),e.$set(f);const d={};h&65552&&(d.$$scope={dirty:h,ctx:u}),o.$set(d)},i(u){a||(Ie(e.$$.fragment,u),Ie(o.$$.fragment,u),a=!0)},o(u){$e(e.$$.fragment,u),$e(o.$$.fragment,u),a=!1},d(u){n[11](null),Tt(e,u),u&&de(r),u&&de(s),u&&de(i),Tt(o,u)}}}function sTt(n){let e,t;return e=new sa({props:{title:n[0],$$slots:{default:[rTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&65562&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}const C7=n=>typeof n=="string"?{name:n}:n,k7=n=>n.logs,T7=n=>n.name,E7=n=>n.params,I7=n=>{var e;return((e=n.model)==null?void 0:e.summary)||"No summary available"};function iTt(n,e,t){let r,s=tt,i=()=>(s(),s=os(u,b=>t(4,r=b)),u);n.$$.on_destroy.push(()=>s());let{title:o}=e,{service:a}=e,{metrics:l}=e,{actions:c}=e,{selection:u}=e;i();const h=Oc(),f=new C_t({service:a,transform:{...l.reduce((b,x)=>({...b,[x]:w=>x in w.logs?w.logs[x][w.logs[x].length-1]:"metrics not found"}),{}),...c.reduce((b,x)=>({...b,[typeof x=="string"?x:x.name]:()=>typeof x=="string"?x:x.name}),{})}});f.data.subscribe(()=>{u.set([])});const d=[{name:"name",sortable:!0},{name:"start",sortable:!0,type:"date"},...l.map(b=>({name:b})),{name:"epochs"},{name:"status"},...c.map(b=>({name:typeof b=="string"?b:b.name,type:"action"}))];let p;$u(async()=>{await ea(),await ea();for(const b of c){const x=typeof b=="string"?b:b.name;p.$on(x,({detail:w})=>{h(x,w)})}});function m(b){r=b,u.set(r)}function g(b){hi[b?"unshift":"push"](()=>{p=b,t(3,p)})}const y=({detail:b})=>h("load",b);return n.$$set=b=>{"title"in b&&t(0,o=b.title),"service"in b&&t(8,a=b.service),"metrics"in b&&t(9,l=b.metrics),"actions"in b&&t(1,c=b.actions),"selection"in b&&i(t(2,u=b.selection))},[o,c,u,p,r,h,f,d,a,l,m,g,y]}class oTt extends xn{constructor(e){super(),wn(this,e,iTt,sTt,pn,{title:0,service:8,metrics:9,actions:1,selection:2})}}function aTt(n,e){const t={...n};for(const[r,s]of Object.entries(e))t[r]=(t[r]||[]).concat([s]);return t}const lTt={metrics:["accuracy","accuracyVal","loss","lossVal"],actions:[]};class cTt extends Aa{constructor(e,t={}){super(),this.dataStore=e,this.title="Training History",this.$selection=new mt([],!0),this.$actions=new mt(null).skip(1),this.ready=Promise.resolve(),this.stopTracking=Wb,this.lock=Promise.resolve(),this.options={...lTt,...t},this.lock=this.lock.then(Wb),this.start(),this.ready=this.ready.then(()=>this.dataStore.connect()).then(()=>{this.runService=this.dataStore.service("runs")}).catch(()=>{ya.log("[dataset] dataStore connection failed")})}track(e,t="anonymous"){return this.ready.then(()=>(this.stopTracking(),this.model=e,this.modelName=t,this.runService.find({query:{basename:t,$sort:{createdAt:-1},$select:["name"],$limit:1}}))).then(({data:r})=>r.length>0?parseInt(r[0].name.split(`${t}-`)[1])+1:1).then(r=>{this.nextIndex=r,this.crtRun=null,this.stopTracking=this.model?this.model.$training.subscribe(this.trackTrainingStream):Wb}),this}async trackTrainingStream(e){if(e.status==="start")this.crtRun=await this.runService.create({name:`${this.modelName}-${this.nextIndex++}`,basename:this.modelName,start:new Date(Date.now()).toISOString(),source:"js",status:e.status,epochs:e.epochs,params:Object.entries(this.model.parameters).map(([t,r])=>({[t]:r.get()})).reduce((t,r)=>({...t,...r}),{}),logs:{}});else if(e.status==="epoch")this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:aTt(this.crtRun.logs,e.data)});else if(e.status==="success"){const t=await this.model.save(this.dataStore,this.modelName,{});this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:e.data,checkpoints:(this.crtRun.checkpoints||[]).concat([{id:t,name:`${this.crtRun.name}@final`,service:this.model.serviceName}])})}else e.status==="error"&&this.runService.patch(this.crtRun.id,{status:e.status})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.ready.then(()=>{this.$$.app=new oTt({target:t,props:{title:this.title,service:this.runService,metrics:this.options.metrics,actions:this.options.actions,selection:this.$selection}});for(const r of this.options.actions){const s=typeof r=="string"?r:r.name;this.$$.app.$on(s,({detail:i})=>{this.$actions.set({name:s,data:i})})}}))}}Dn([Rkt("lock")],cTt.prototype,"trackTrainingStream",null);function A7(n){return typeof n=="string"}function M7(n){return Array.isArray(n)}let uTt=class{constructor(e,t=!0){this.name=e,this.showSidebar=t,this.components=[],this.componentsLeft=[]}use(...e){return this.components=this.components.concat(e),this}sidebar(...e){return this.componentsLeft=this.componentsLeft.concat(e),this}mount(){for(const e of this.components)if(M7(e))for(const t of e)t.mount();else A7(e)||e.mount();for(const e of this.componentsLeft)e.mount()}destroy(){for(const e of this.components)if(M7(e))for(const t of e)t.destroy();else A7(e)||e.destroy();for(const e of this.componentsLeft)e.destroy()}};function hTt(n,e,t,r){return n instanceof RegExp?n:(n instanceof Array&&(n=`(${n.join("|")})`),n=n.concat(r?"":"/?").replace(/\/\(/g,"(?:/").replace(/\+/g,"__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g,(s,i,o,a,l,c)=>(e.push({name:a,optional:!!c}),i=i||"",`${c?"":i}(?:${c?i:""}${o||""}${l||o&&"([^/.]+?)"||"([^/]+?)"})${c||""}`)).replace(/([/.])/g,"\\$1").replace(/__plus__/g,"(.+)").replace(/\*/g,"(.*)"),new RegExp(`^${n}$`,t?"":"i"))}class fTt{constructor(e,t){this.path=e,this.name=t,this.keys=[],this.fns=[],this.params={},this.regex=hTt(this.path,this.keys,!1,!1)}addHandler(e){this.fns.push(e)}removeHandler(e){this.fns=this.fns.filter(t=>e===t)}run(e){for(const t of this.fns)t.apply(this,e)}match(e,t){const r=this.regex.exec(e);if(!r)return!1;for(let s=1,i=r.length;s<i;s++){const o=this.keys[s-1],a=typeof r[s]=="string"?decodeURIComponent(r[s]):r[s];o&&(this.params[o.name]=a),t.push(a)}return!0}}function dTt(n,e){const t=[];return e.match(n,t)?(e.run(t),!0):!1}class pTt{constructor(){this.map={},this.routes=[],this.addListener()}route(e,t){const r=e.split(" "),s=r.length===2?r[0]:null;e=r.length===2?r[1]:r[0],Object.keys(this.map).includes(e)||(this.map[e]=new fTt(e,s),this.routes.push(this.map[e])),this.map[e].addHandler(t),this.reload()}addListener(){window.addEventListener("hashchange",this.reload.bind(this),!1)}removeListener(){window.removeEventListener("hashchange",this.reload.bind(this))}reload(){const e=window.location.hash.substring(1);for(let t=0;t<this.routes.length;t++){const r=this.routes[t];if(dTt(e,r))return}}navigate(e,{silent:t=!1}={}){t&&this.removeListener(),setTimeout(()=>{window.location.hash=e,t&&setTimeout(()=>{this.addListener()},1)},1)}}function N7(n,e,t){const r=n.slice();return r[1]=e[t],r}function $7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function R7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function P7(n){let e,t,r=n[0].showSidebar&&D7(n),s=n[0].components,i=[];for(let o=0;o<s.length;o+=1)i[o]=L7(N7(n,s,o));return{c(){r&&r.c(),e=Ye(),t=we("div");for(let o=0;o<i.length;o+=1)i[o].c();Z(t,"class","right svelte-15dyumc"),qt(t,"fullw",!n[0].showSidebar)},m(o,a){r&&r.m(o,a),me(o,e,a),me(o,t,a);for(let l=0;l<i.length;l+=1)i[l]&&i[l].m(t,null)},p(o,a){if(o[0].showSidebar?r?r.p(o,a):(r=D7(o),r.c(),r.m(e.parentNode,e)):r&&(r.d(1),r=null),a&1){s=o[0].components;let l;for(l=0;l<s.length;l+=1){const c=N7(o,s,l);i[l]?i[l].p(c,a):(i[l]=L7(c),i[l].c(),i[l].m(t,null))}for(;l<i.length;l+=1)i[l].d(1);i.length=s.length}a&1&&qt(t,"fullw",!o[0].showSidebar)},d(o){r&&r.d(o),o&&de(e),o&&de(t),qs(i,o)}}}function D7(n){let e,t=n[0].componentsLeft,r=[];for(let s=0;s<t.length;s+=1)r[s]=O7(R7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","left svelte-15dyumc")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&1){t=s[0].componentsLeft;let o;for(o=0;o<t.length;o+=1){const a=R7(s,t,o);r[o]?r[o].p(a,i):(r[o]=O7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&de(e),qs(r,s)}}}function O7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function mTt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&de(e)}}}function gTt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=He(t),Z(e,"class","svelte-15dyumc")},m(s,i){me(s,e,i),se(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&cn(r,t)},d(s){s&&de(e)}}}function yTt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=F7($7(n,r,i));return{c(){e=we("div");for(let i=0;i<s.length;i+=1)s[i].c();t=Ye(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){me(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);se(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=$7(i,r,a);s[a]?s[a].p(l,o):(s[a]=F7(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&de(e),qs(s,i)}}}function F7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function L7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?yTt:typeof o[1]=="string"?gTt:mTt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=mo()},m(o,a){i.m(o,a),me(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&de(t)}}}function bTt(n){let e,t=n[0]&&P7(n);return{c(){t&&t.c(),e=mo()},m(r,s){t&&t.m(r,s),me(r,e,s)},p(r,[s]){r[0]?t?t.p(r,s):(t=P7(r),t.c(),t.m(e.parentNode,e)):t&&(t.d(1),t=null)},i:tt,o:tt,d(r){t&&t.d(r),r&&de(e)}}}function vTt(n,e,t){let{dashboard:r}=e;return Mce(()=>{r.mount()}),n.$$set=s=>{"dashboard"in s&&t(0,r=s.dashboard)},[r]}class wTt extends xn{constructor(e){super(),wn(this,e,vTt,bTt,pn,{dashboard:0})}}function xTt(n){let e;return{c(){e=He("This dataset is empty")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function _Tt(n){let e,t,r,s=n[3]?"s":"",i,o;return{c(){e=He("This dataset contains "),t=He(n[3]),r=He(" instance"),i=He(s),o=He(".")},m(a,l){me(a,e,l),me(a,t,l),me(a,r,l),me(a,i,l),me(a,o,l)},p(a,l){l&8&&cn(t,a[3]),l&8&&s!==(s=a[3]?"s":"")&&cn(i,s)},d(a){a&&de(e),a&&de(t),a&&de(r),a&&de(i),a&&de(o)}}}function z7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[STt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function STt(n){let e;return{c(){e=He("Download Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function CTt(n){let e;return{c(){e=He("Upload Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function kTt(n){let e;return{c(){e=He("Clear Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function TTt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?_Tt:xTt}let b=y(n),x=b(n),w=n[3]&&z7(n);return c=new zs({props:{$$slots:{default:[CTt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[kTt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("p"),x.c(),o=Ye(),a=we("div"),w&&w.c(),l=Ye(),It(c.$$.fragment),u=Ye(),h=we("span"),f=Ye(),d=we("input"),p=Ye(),It(m.$$.fragment),Z(e,"class","card-title"),Z(i,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),se(e,r),me(S,s,C),me(S,i,C),x.m(i,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),se(a,l),kt(c,a,null),se(a,u),se(a,h),se(a,f),se(a,d),n[7](d),se(a,p),kt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&x?x.p(S,C):(x.d(1),x=b(S),x&&(x.c(),x.m(i,null))),S[3]?w?(w.p(S,C),C&8&&Ie(w,1)):(w=z7(S),w.c(),Ie(w,1),w.m(a,l)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(Ie(w),Ie(c.$$.fragment,S),Ie(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&de(e),S&&de(s),S&&de(i),x.d(),S&&de(o),S&&de(a),w&&w.d(),Tt(c),n[7](null),Tt(m)}}}function ETt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{dataset:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$u(async()=>{await ea(),await ea(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){hi[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"dataset"in d&&t(0,a=d.dataset)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class ITt extends xn{constructor(e){super(),wn(this,e,ETt,TTt,pn,{dataset:0})}}function B7(n){let e,t,r,s={ctx:n,current:null,token:null,hasCatch:!1,pending:$Tt,then:MTt,catch:ATt,value:4,blocks:[,,,]};return n9(t=n[0].connect(),s),{c(){e=mo(),s.block.c()},m(i,o){me(i,e,o),s.block.m(i,s.anchor=o),s.mount=()=>e.parentNode,s.anchor=e,r=!0},p(i,o){n=i,s.ctx=n,o&1&&t!==(t=n[0].connect())&&n9(t,s)||Qxt(s,n,o)},i(i){r||(Ie(s.block),r=!0)},o(i){for(let o=0;o<3;o+=1){const a=s.blocks[o];$e(a)}r=!1},d(i){i&&de(e),s.block.d(i),s.token=null,s=null}}}function ATt(n){return{c:tt,m:tt,p:tt,i:tt,o:tt,d:tt}}function MTt(n){let e,t,r=n[4].email+"",s,i,o,a,l;return a=new zs({props:{$$slots:{default:[NTt]},$$scope:{ctx:n}}}),a.$on("click",n[3]),{c(){e=we("p"),t=He("Hello, "),s=He(r),i=Ye(),o=we("div"),It(a.$$.fragment),Z(e,"class","pb-2"),Z(o,"class","flex")},m(c,u){me(c,e,u),se(e,t),se(e,s),me(c,i,u),me(c,o,u),kt(a,o,null),l=!0},p(c,u){(!l||u&1)&&r!==(r=c[4].email+"")&&cn(s,r);const h={};u&32&&(h.$$scope={dirty:u,ctx:c}),a.$set(h)},i(c){l||(Ie(a.$$.fragment,c),l=!0)},o(c){$e(a.$$.fragment,c),l=!1},d(c){c&&de(e),c&&de(i),c&&de(o),Tt(a)}}}function NTt(n){let e;return{c(){e=He("Log out")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function $Tt(n){let e,t;return e=new zce({}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p:tt,i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function V7(n){let e,t,r=n[2].join(", ")+"",s;return{c(){e=we("div"),t=He("This data store contains the following services: "),s=He(r)},m(i,o){me(i,e,o),se(e,t),se(e,s)},p(i,o){o&4&&r!==(r=i[2].join(", ")+"")&&cn(s,r)},d(i){i&&de(e)}}}function RTt(n){let e,t,r,s=n[0].requiresAuth&&B7(n),i=n[2]&&V7(n);return{c(){s&&s.c(),e=Ye(),i&&i.c(),t=mo()},m(o,a){s&&s.m(o,a),me(o,e,a),i&&i.m(o,a),me(o,t,a),r=!0},p(o,a){o[0].requiresAuth?s?(s.p(o,a),a&1&&Ie(s,1)):(s=B7(o),s.c(),Ie(s,1),s.m(e.parentNode,e)):s&&(dr(),$e(s,1,1,()=>{s=null}),pr()),o[2]?i?i.p(o,a):(i=V7(o),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ie(s),r=!0)},o(o){$e(s),r=!1},d(o){s&&s.d(o),o&&de(e),i&&i.d(o),o&&de(t)}}}function PTt(n){let e,t;return e=new sa({props:{title:"data store ("+n[0].location+")",$$slots:{default:[RTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title="data store ("+r[0].location+")"),s&37&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function DTt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,c=>t(2,s=c)),r);n.$$.on_destroy.push(()=>i());let{dataStore:a}=e;function l(){a.logout()}return n.$$set=c=>{"dataStore"in c&&t(0,a=c.dataStore)},n.$$.update=()=>{n.$$.dirty&1&&o(t(1,r=a.$services))},[a,r,s,l]}class OTt extends xn{constructor(e){super(),wn(this,e,DTt,PTt,pn,{dataStore:0})}}function FTt(n){let e;return{c(){e=He("Download Model")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function LTt(n){let e;return{c(){e=He("Upload Model")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function zTt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d;return o=new zs({props:{$$slots:{default:[FTt]},$$scope:{ctx:n}}}),o.$on("click",n[2]),f=new zs({props:{$$slots:{default:[LTt]},$$scope:{ctx:n}}}),f.$on("click",n[3]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("div"),It(o.$$.fragment),a=Ye(),l=we("span"),c=Ye(),u=we("input"),h=Ye(),It(f.$$.fragment),Z(e,"class","card-title"),Z(l,"class","w-1"),Z(u,"type","file"),u.multiple=!0,Z(u,"class","hidden"),Z(i,"class","flex")},m(p,m){me(p,e,m),se(e,r),me(p,s,m),me(p,i,m),kt(o,i,null),se(i,a),se(i,l),se(i,c),se(i,u),n[4](u),se(i,h),kt(f,i,null),d=!0},p(p,[m]){(!d||m&1)&&t!==(t=p[0].title+"")&&cn(r,t);const g={};m&32&&(g.$$scope={dirty:m,ctx:p}),o.$set(g);const y={};m&32&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ie(o.$$.fragment,p),Ie(f.$$.fragment,p),d=!0)},o(p){$e(o.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&de(e),p&&de(s),p&&de(i),Tt(o),n[4](null),Tt(f)}}}function uD(n){return"download"in n}function BTt(n,e,t){let{model:r}=e,s;function i(){uD(r)?r.download():Ea(new Error("This model cannot be saved"))}function o(){uD(r)?s==null||s.click():Ea(new Error("This model cannot be uploaded"))}$u(async()=>{await ea(),await ea(),s.addEventListener("change",l=>{const c=l.target.files,u=[];for(let h=0;h<c.length;h++)u.push(c[h]);uD(r)&&r.upload(...u)})});function a(l){hi[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"model"in l&&t(0,r=l.model)},[r,s,i,o,a]}class VTt extends xn{constructor(e){super(),wn(this,e,BTt,zTt,pn,{model:0})}}function UTt(n){let e;return{c(){e=He("This batch prediction component is empty")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function WTt(n){let e,t,r,s=n[3]?"s":"",i;return{c(){e=He(`This batch prediction component contains
    `),t=He(n[3]),r=He(`
    prediction`),i=He(s)},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,i,a)},p(o,a){a&8&&cn(t,o[3]),a&8&&s!==(s=o[3]?"s":"")&&cn(i,s)},d(o){o&&de(e),o&&de(t),o&&de(r),o&&de(i)}}}function U7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[GTt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function GTt(n){let e;return{c(){e=He("Download Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function HTt(n){let e;return{c(){e=He("Upload Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function jTt(n){let e;return{c(){e=He("Clear Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function qTt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?WTt:UTt}let b=y(n),x=b(n),w=n[3]&&U7(n);return c=new zs({props:{$$slots:{default:[HTt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[jTt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("p"),x.c(),o=Ye(),a=we("div"),w&&w.c(),l=Ye(),It(c.$$.fragment),u=Ye(),h=we("span"),f=Ye(),d=we("input"),p=Ye(),It(m.$$.fragment),Z(e,"class","card-title"),Z(i,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),se(e,r),me(S,s,C),me(S,i,C),x.m(i,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),se(a,l),kt(c,a,null),se(a,u),se(a,h),se(a,f),se(a,d),n[7](d),se(a,p),kt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&x?x.p(S,C):(x.d(1),x=b(S),x&&(x.c(),x.m(i,null))),S[3]?w?(w.p(S,C),C&8&&Ie(w,1)):(w=U7(S),w.c(),Ie(w,1),w.m(a,l)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(Ie(w),Ie(c.$$.fragment,S),Ie(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&de(e),S&&de(s),S&&de(i),x.d(),S&&de(o),S&&de(a),w&&w.d(),Tt(c),n[7](null),Tt(m)}}}function XTt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{prediction:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$u(async()=>{await ea(),await ea(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){hi[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"prediction"in d&&t(0,a=d.prediction)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class KTt extends xn{constructor(e){super(),wn(this,e,XTt,qTt,pn,{prediction:0})}}function W7(n,e,t){const r=n.slice();return r[1]=e[t],r}function G7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function H7(n,e,t){const r=n.slice();return r[7]=e[t],r}function j7(n,e,t){const r=n.slice();return r[10]=e[t],r}function q7(n,e,t){const r=n.slice();return r[13]=e[t],r}function X7(n,e,t){const r=n.slice();return r[16]=e[t],r}function K7(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g=n[0].xDataStores,y=[];for(let D=0;D<g.length;D+=1)y[D]=Y7(X7(n,g,D));const b=D=>$e(y[D],1,1,()=>{y[D]=null});let x=n[0].xModels,w=[];for(let D=0;D<x.length;D+=1)w[D]=Z7(q7(n,x,D));const S=D=>$e(w[D],1,1,()=>{w[D]=null});let C=n[0].xDatasets,k=[];for(let D=0;D<C.length;D+=1)k[D]=J7(j7(n,C,D));const A=D=>$e(k[D],1,1,()=>{k[D]=null});let M=n[0].xPredictions,E=[];for(let D=0;D<M.length;D+=1)E[D]=Q7(H7(n,M,D));const N=D=>$e(E[D],1,1,()=>{E[D]=null});let O=n[0].components,R=[];for(let D=0;D<O.length;D+=1)R[D]=tX(W7(n,O,D));return{c(){e=we("div"),t=we("h2"),t.textContent="Data Stores",r=Ye();for(let D=0;D<y.length;D+=1)y[D].c();s=Ye(),i=we("h2"),i.textContent="Models",o=Ye();for(let D=0;D<w.length;D+=1)w[D].c();a=Ye(),l=we("h2"),l.textContent="Datasets",c=Ye();for(let D=0;D<k.length;D+=1)k[D].c();u=Ye(),h=we("h2"),h.textContent="Predictions",f=Ye();for(let D=0;D<E.length;D+=1)E[D].c();d=Ye(),p=we("div");for(let D=0;D<R.length;D+=1)R[D].c();Z(e,"class","left svelte-inuorr"),Z(p,"class","right svelte-inuorr")},m(D,z){me(D,e,z),se(e,t),se(e,r);for(let B=0;B<y.length;B+=1)y[B]&&y[B].m(e,null);se(e,s),se(e,i),se(e,o);for(let B=0;B<w.length;B+=1)w[B]&&w[B].m(e,null);se(e,a),se(e,l),se(e,c);for(let B=0;B<k.length;B+=1)k[B]&&k[B].m(e,null);se(e,u),se(e,h),se(e,f);for(let B=0;B<E.length;B+=1)E[B]&&E[B].m(e,null);me(D,d,z),me(D,p,z);for(let B=0;B<R.length;B+=1)R[B]&&R[B].m(p,null);m=!0},p(D,z){if(z&1){g=D[0].xDataStores;let B;for(B=0;B<g.length;B+=1){const X=X7(D,g,B);y[B]?(y[B].p(X,z),Ie(y[B],1)):(y[B]=Y7(X),y[B].c(),Ie(y[B],1),y[B].m(e,s))}for(dr(),B=g.length;B<y.length;B+=1)b(B);pr()}if(z&1){x=D[0].xModels;let B;for(B=0;B<x.length;B+=1){const X=q7(D,x,B);w[B]?(w[B].p(X,z),Ie(w[B],1)):(w[B]=Z7(X),w[B].c(),Ie(w[B],1),w[B].m(e,a))}for(dr(),B=x.length;B<w.length;B+=1)S(B);pr()}if(z&1){C=D[0].xDatasets;let B;for(B=0;B<C.length;B+=1){const X=j7(D,C,B);k[B]?(k[B].p(X,z),Ie(k[B],1)):(k[B]=J7(X),k[B].c(),Ie(k[B],1),k[B].m(e,u))}for(dr(),B=C.length;B<k.length;B+=1)A(B);pr()}if(z&1){M=D[0].xPredictions;let B;for(B=0;B<M.length;B+=1){const X=H7(D,M,B);E[B]?(E[B].p(X,z),Ie(E[B],1)):(E[B]=Q7(X),E[B].c(),Ie(E[B],1),E[B].m(e,null))}for(dr(),B=M.length;B<E.length;B+=1)N(B);pr()}if(z&1){O=D[0].components;let B;for(B=0;B<O.length;B+=1){const X=W7(D,O,B);R[B]?R[B].p(X,z):(R[B]=tX(X),R[B].c(),R[B].m(p,null))}for(;B<R.length;B+=1)R[B].d(1);R.length=O.length}},i(D){if(!m){for(let z=0;z<g.length;z+=1)Ie(y[z]);for(let z=0;z<x.length;z+=1)Ie(w[z]);for(let z=0;z<C.length;z+=1)Ie(k[z]);for(let z=0;z<M.length;z+=1)Ie(E[z]);m=!0}},o(D){y=y.filter(Boolean);for(let z=0;z<y.length;z+=1)$e(y[z]);w=w.filter(Boolean);for(let z=0;z<w.length;z+=1)$e(w[z]);k=k.filter(Boolean);for(let z=0;z<k.length;z+=1)$e(k[z]);E=E.filter(Boolean);for(let z=0;z<E.length;z+=1)$e(E[z]);m=!1},d(D){D&&de(e),qs(y,D),qs(w,D),qs(k,D),qs(E,D),D&&de(d),D&&de(p),qs(R,D)}}}function Y7(n){let e,t,r;return t=new OTt({props:{dataStore:n[16]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataStore=s[16]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function Z7(n){let e,t,r;return t=new VTt({props:{model:n[13]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.model=s[13]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function J7(n){let e,t,r;return t=new ITt({props:{dataset:n[10]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataset=s[10]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function Q7(n){let e,t,r,s;return t=new KTt({props:{prediction:n[7]}}),{c(){e=we("div"),It(t.$$.fragment),r=Ye(),Z(e,"class","card")},m(i,o){me(i,e,o),kt(t,e,null),se(e,r),s=!0},p(i,o){const a={};o&1&&(a.prediction=i[7]),t.$set(a)},i(i){s||(Ie(t.$$.fragment,i),s=!0)},o(i){$e(t.$$.fragment,i),s=!1},d(i){i&&de(e),Tt(t)}}}function YTt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&de(e)}}}function ZTt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=He(t)},m(s,i){me(s,e,i),se(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&cn(r,t)},d(s){s&&de(e)}}}function JTt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=eX(G7(n,r,i));return{c(){e=we("div");for(let i=0;i<s.length;i+=1)s[i].c();t=Ye(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){me(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);se(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=G7(i,r,a);s[a]?s[a].p(l,o):(s[a]=eX(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&de(e),qs(s,i)}}}function eX(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function tX(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?JTt:typeof o[1]=="string"?ZTt:YTt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=mo()},m(o,a){i.m(o,a),me(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&de(t)}}}function QTt(n){let e,t,r=n[0]&&K7(n);return{c(){r&&r.c(),e=mo()},m(s,i){r&&r.m(s,i),me(s,e,i),t=!0},p(s,[i]){s[0]?r?(r.p(s,i),i&1&&Ie(r,1)):(r=K7(s),r.c(),Ie(r,1),r.m(e.parentNode,e)):r&&(dr(),$e(r,1,1,()=>{r=null}),pr())},i(s){t||(Ie(r),t=!0)},o(s){$e(r),t=!1},d(s){r&&r.d(s),s&&de(e)}}}function eEt(n,e,t){let{settings:r}=e;return Mce(()=>{r.mount()}),n.$$set=s=>{"settings"in s&&t(0,r=s.settings)},[r]}let tEt=class extends xn{constructor(e){super(),wn(this,e,eEt,QTt,pn,{settings:0})}};function nX(n,e,t){const r=n.slice();return r[8]=e[t][0],r[9]=e[t][1],r[11]=t,r}function rX(n){let e,t=n[9]+"",r,s,i;return{c(){e=we("a"),r=He(t),s=Ye(),Z(e,"href",i=`#${n[8]}`),Z(e,"class","ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v"),qt(e,"active",!n[4]&&n[2]===n[9])},m(o,a){me(o,e,a),se(e,r),se(e,s)},p(o,a){a&2&&t!==(t=o[9]+"")&&cn(r,t),a&2&&i!==(i=`#${o[8]}`)&&Z(e,"href",i),a&22&&qt(e,"active",!o[4]&&o[2]===o[9])},d(o){o&&de(e)}}}function nEt(n){let e,t,r;return{c(){e=Fs("svg"),t=Fs("circle"),r=Fs("path"),Z(t,"cx","12"),Z(t,"cy","12"),Z(t,"r","3"),Z(r,"d","M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-settings")},m(s,i){me(s,e,i),se(e,t),se(e,r)},p:tt,d(s){s&&de(e)}}}function sX(n){let e,t,r,s;return e=new zs({props:{round:!0,type:"danger",$$slots:{default:[rEt]},$$scope:{ctx:n}}}),e.$on("click",n[5]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&4096&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function rEt(n){let e,t,r;return{c(){e=Fs("svg"),t=Fs("path"),r=Fs("line"),Z(t,"d","M18.36 6.64a9 9 0 1 1-12.73 0"),Z(r,"x1","12"),Z(r,"y1","2"),Z(r,"x2","12"),Z(r,"y2","12"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-power")},m(s,i){me(s,e,i),se(e,t),se(e,r)},p:tt,d(s){s&&de(e)}}}function sEt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m=Object.entries(n[1]),g=[];for(let b=0;b<m.length;b+=1)g[b]=rX(nX(n,m,b));u=new zs({props:{round:!0,$$slots:{default:[nEt]},$$scope:{ctx:n}}}),u.$on("click",n[6]);let y=n[3]&&sX(n);return{c(){e=we("header"),t=we("div"),r=we("a"),s=we("span"),i=He(n[0]),o=Ye(),a=we("nav");for(let b=0;b<g.length;b+=1)g[b].c();l=Ye(),c=we("div"),It(u.$$.fragment),h=Ye(),f=we("span"),d=Ye(),y&&y.c(),Z(s,"class","mx-3 text-lg"),Z(r,"href","#/"),Z(r,"class","flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v"),Z(a,"class","flex items-stretch justify-start flex-wrap text-base grow mx-4"),Z(f,"class","w-1"),Z(c,"class","flex items-center"),Z(t,"class","mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full"),Z(e,"class","bg-white text-gray-700 body-font")},m(b,x){me(b,e,x),se(e,t),se(t,r),se(r,s),se(s,i),se(t,o),se(t,a);for(let w=0;w<g.length;w+=1)g[w]&&g[w].m(a,null);se(t,l),se(t,c),kt(u,c,null),se(c,h),se(c,f),se(c,d),y&&y.m(c,null),p=!0},p(b,[x]){if((!p||x&1)&&cn(i,b[0]),x&22){m=Object.entries(b[1]);let S;for(S=0;S<m.length;S+=1){const C=nX(b,m,S);g[S]?g[S].p(C,x):(g[S]=rX(C),g[S].c(),g[S].m(a,null))}for(;S<g.length;S+=1)g[S].d(1);g.length=m.length}const w={};x&4096&&(w.$$scope={dirty:x,ctx:b}),u.$set(w),b[3]?y?(y.p(b,x),x&8&&Ie(y,1)):(y=sX(b),y.c(),Ie(y,1),y.m(c,null)):y&&(dr(),$e(y,1,1,()=>{y=null}),pr())},i(b){p||(Ie(u.$$.fragment,b),Ie(y),p=!0)},o(b){$e(u.$$.fragment,b),$e(y),p=!1},d(b){b&&de(e),qs(g,b),Tt(u),y&&y.d()}}}function iEt(n,e,t){let{title:r}=e,{items:s}=e,{current:i}=e,{closable:o}=e,{showSettings:a=!1}=e;const l=Oc();function c(){a?window.location.href=window.location.href.split("#")[0]+"#"+Object.keys(s)[Object.values(s).indexOf(i)]:window.location.href=window.location.href.split("#")[0]+"#settings"}function u(){setTimeout(()=>{l("quit")},400)}return n.$$set=h=>{"title"in h&&t(0,r=h.title),"items"in h&&t(1,s=h.items),"current"in h&&t(2,i=h.current),"closable"in h&&t(3,o=h.closable),"showSettings"in h&&t(4,a=h.showSettings)},[r,s,i,o,a,u,c]}class oEt extends xn{constructor(e){super(),wn(this,e,iEt,sEt,pn,{title:0,items:1,current:2,closable:3,showSettings:4,quit:5})}get quit(){return this.$$.ctx[5]}}function aEt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function lEt(n){let e;function t(i,o){return i[1][0]===vc.Warning?hEt:i[1][0]===vc.Error?uEt:cEt}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},d(i){s.d(i),i&&de(e)}}}function cEt(n){let e=(n[1][1]||"")+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=(r[1][1]||"")+"")&&cn(t,e)},d(r){r&&de(t)}}}function uEt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=He(`Err:
        `),r=He(t)},m(s,i){me(s,e,i),me(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&cn(r,t)},d(s){s&&de(e),s&&de(r)}}}function hEt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=He(`Warn:
        `),r=He(t)},m(s,i){me(s,e,i),me(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&cn(r,t)},d(s){s&&de(e),s&&de(r)}}}function fEt(n){let e,t,r,s,i,o;function a(u,h){return u[1]?lEt:aEt}let l=a(n),c=l(n);return{c(){e=we("footer"),t=we("p"),c.c(),r=Ye(),s=we("p"),i=He("© 2021 "),o=He(n[0]),Z(t,"class","console svelte-i04gf3"),qt(t,"error",n[1]&&n[1][0]===vc.Error),qt(t,"warning",n[1]&&n[1][0]===vc.Warning),Z(s,"class","text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200"),Z(e,"class","bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row")},m(u,h){me(u,e,h),se(e,t),c.m(t,null),se(e,r),se(e,s),se(s,i),se(s,o)},p(u,[h]){l===(l=a(u))&&c?c.p(u,h):(c.d(1),c=l(u),c&&(c.c(),c.m(t,null))),h&2&&qt(t,"error",u[1]&&u[1][0]===vc.Error),h&2&&qt(t,"warning",u[1]&&u[1][0]===vc.Warning),h&1&&cn(o,u[0])},i:tt,o:tt,d(u){u&&de(e),c.d()}}}function dEt(n,e,t){let r,{author:s}=e;const i=A_t();return HV(n,i,o=>t(1,r=o)),n.$$set=o=>{"author"in o&&t(0,s=o.author)},[s,r,i]}class pEt extends xn{constructor(e){super(),wn(this,e,dEt,fEt,pn,{author:0})}}function iX(n){let e,t,r,s,i,o,a,l,c,u,h;r=new oEt({props:{title:n[0],items:n[10].reduce(n[12],{}),current:n[9],showSettings:n[8],closable:n[4]}}),r.$on("quit",n[5]);const f=[gEt,mEt],d=[];function p(m,g){return m[8]?0:m[9]?1:-1}return~(o=p(n))&&(a=d[o]=f[o](n)),c=new pEt({props:{author:n[1]}}),{c(){e=we("div"),t=we("div"),It(r.$$.fragment),s=Ye(),i=we("main"),a&&a.c(),l=Ye(),It(c.$$.fragment),Z(i,"class","main-container svelte-1da5cws"),Z(t,"class","app-container svelte-1da5cws"),Z(e,"class","marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50")},m(m,g){me(m,e,g),se(e,t),kt(r,t,null),se(t,s),se(t,i),~o&&d[o].m(i,null),se(t,l),kt(c,t,null),h=!0},p(m,g){n=m;const y={};g&1&&(y.title=n[0]),g&1088&&(y.items=n[10].reduce(n[12],{})),g&512&&(y.current=n[9]),g&256&&(y.showSettings=n[8]),g&16&&(y.closable=n[4]),r.$set(y);let b=o;o=p(n),o===b?~o&&d[o].p(n,g):(a&&(dr(),$e(d[b],1,1,()=>{d[b]=null}),pr()),~o?(a=d[o],a?a.p(n,g):(a=d[o]=f[o](n),a.c()),Ie(a,1),a.m(i,null)):a=null);const x={};g&2&&(x.author=n[1]),c.$set(x)},i(m){h||(Ie(r.$$.fragment,m),Ie(a),Ie(c.$$.fragment,m),Ru(()=>{h&&(u||(u=Iv(t,yM,{amount:10,duration:n[4]?400:0},!0)),u.run(1))}),h=!0)},o(m){$e(r.$$.fragment,m),$e(a),$e(c.$$.fragment,m),u||(u=Iv(t,yM,{amount:10,duration:n[4]?400:0},!1)),u.run(0),h=!1},d(m){m&&de(e),Tt(r),~o&&d[o].d(),Tt(c),m&&u&&u.end()}}}function mEt(n){let e,t;return e=new wTt({props:{dashboard:n[2][n[9]]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&516&&(i.dashboard=r[2][r[9]]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function gEt(n){let e,t;return e=new tEt({props:{settings:n[3]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&8&&(i.settings=r[3]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function yEt(n){let e,t,r,s;document.title=e=n[0];let i=n[7]&&iX(n);return{c(){t=Ye(),i&&i.c(),r=mo()},m(o,a){me(o,t,a),i&&i.m(o,a),me(o,r,a),s=!0},p(o,[a]){(!s||a&1)&&e!==(e=o[0])&&(document.title=e),o[7]?i?(i.p(o,a),a&128&&Ie(i,1)):(i=iX(o),i.c(),Ie(i,1),i.m(r.parentNode,r)):i&&(dr(),$e(i,1,1,()=>{i=null}),pr())},i(o){s||(Ie(i),s=!0)},o(o){$e(i),s=!1},d(o){o&&de(t),i&&i.d(o),o&&de(r)}}}function oX(n){let e=n.replace(/^\s+|\s+$/g,"");e=e.toLowerCase();const t="àáäâèéëêìíïîòóöôùúüûñç·/_,:;",r="aaaaeeeeiiiioooouuuunc------";for(let s=0,i=t.length;s<i;s++)e=e.replace(new RegExp(t.charAt(s),"g"),r.charAt(s));return e=e.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),e}function bEt(n,e,t){let r,s;const i=Oc();let{title:o}=e,{author:a}=e,{dashboards:l={}}=e,{settings:c}=e,{page:u}=e,{closable:h}=e,f=!1;$u(()=>{t(7,f=!0)});function d(){t(7,f=!1),setTimeout(()=>{i("quit")},400)}let p=!1,m=Object.keys(l)[0]||void 0;$u(()=>{try{const y=new pTt;y.route("settings",()=>{t(8,p=!0),m&&l[m].destroy(),u.set("settings")}),s.forEach((b,x)=>{y.route(b,()=>{t(8,p=!1),m!==r[x]&&(m&&l[m].destroy(),t(9,m=r[x]),u.set(b===""?oX(r[0]):b))})})}catch(y){console.log("Could not enable router",y)}});const g=(y,b,x)=>({...y,[b]:r[x]});return n.$$set=y=>{"title"in y&&t(0,o=y.title),"author"in y&&t(1,a=y.author),"dashboards"in y&&t(2,l=y.dashboards),"settings"in y&&t(3,c=y.settings),"page"in y&&t(11,u=y.page),"closable"in y&&t(4,h=y.closable)},n.$$.update=()=>{n.$$.dirty&4&&t(6,r=Object.keys(l)),n.$$.dirty&64&&t(10,s=[""].concat(r.slice(1).map(oX)))},[o,a,l,c,h,d,r,f,p,m,s,u,g]}let vEt=class extends xn{constructor(e){super(),wn(this,e,bEt,yEt,pn,{title:0,author:1,dashboards:2,settings:3,page:11,closable:4,quit:5})}get quit(){return this.$$.ctx[5]}};function aX(n){return typeof n=="string"}function lX(n){return Array.isArray(n)}class wEt{constructor(){this.name="settings",this.components=[],this.xModels=[],this.xDatasets=[],this.xPredictions=[],this.xDataStores=[]}use(...e){return this.components=this.components.concat(e),this}dataStores(...e){return this.xDataStores=e,this}models(...e){return this.xModels=e,this}datasets(...e){return this.xDatasets=e,this}predictions(...e){return this.xPredictions=e,this}mount(){for(const e of this.components)if(lX(e))for(const t of e)t.mount();else aX(e)||e.mount()}destroy(){for(const e of this.components)if(lX(e))for(const t of e)t.destroy();else aX(e)||e.destroy()}}class xEt{constructor({title:e="Hello, Marcelle!",author:t="author",closable:r=!1}){this.panels={},this.settings=new wEt,this.$active=new mt(!1,!0),this.$page=new mt("",!0),this.title=e,this.author=t,this.closable=r}page(e,t){return Object.keys(this.panels).includes(e)||(this.panels[e]=new uTt(e,t)),this.panels[e]}show(){this.app=new vEt({target:document.body,props:{title:this.title,author:this.author,dashboards:this.panels,settings:this.settings,page:this.$page,closable:this.closable}}),this.$active.set(!0),this.app.$on("quit",()=>{var e;this.$active.set(!1),(e=this.app)===null||e===void 0||e.$destroy();for(const t of Object.values(this.panels))t.destroy();this.app=void 0})}hide(){var e;(e=this.app)===null||e===void 0||e.quit()}}function _Et(n){return new xEt(n)}const vx=JV("localStorage"),wx=_Et({title:"Train your vision model",author:"Téo Sanchez"});async function $h(n,e,t=""){const r=`https://api.github.com/repos/${n}/${e}/contents/${t}`;return(await(await fetch(r)).json()).filter(a=>a.type==="file"&&/\.(jpg|jpeg|png|gif)$/i.test(a.name)).map(a=>a.download_url)}async function SEt(n,...e){return n(...e)}function CEt(n,e={}){const t=n.split("/"),i=t[t.length-1].split("_").slice(0,1).join("-");return e[i]||i}function kEt(n){return new Promise((e,t)=>{const r=new Image;r.onload=()=>{const s=document.createElement("canvas"),i=s.getContext("2d");s.width=r.width,s.height=r.height,i.drawImage(r,0,0);const o=i.getImageData(0,0,r.width,r.height);e(o)},r.onerror=t,r.src=n})}async function Rh(n,e,t,r,s={}){const i=await SEt(t,...r);for(const o of i)try{const a=await fetch(o).then(f=>f.blob()),l=URL.createObjectURL(a),c=await kEt(l),u=CEt(o,s),h={x:await e.process(c),thumbnail:c,y:u};n.create(h)}catch(a){console.error(a)}}async function TEt(n){return new Promise((e,t)=>{const r=new Image;r.onload=()=>{const s=document.createElement("canvas");s.width=r.width,s.height=r.height;const i=s.getContext("2d");i.drawImage(r,0,0);const o=i.getImageData(0,0,s.width,s.height);e(o)},r.onerror=s=>t(s),r.src=n,n.startsWith("data:")?r.src=n:r.src=`data:image/jpeg;base64,${n}`})}const Ph="teo-sanchez",Dh="teo-sanchez.github.io",ta=jce("trainingSet",vx),K$=mue(ta);K$.title="Training set";const Du=KCt(),Qa=jce("testSet",vx),Y$=mue(Qa);Y$.title="Test set";const iU=gx("miniMASK");iU.title="Mask classification";iU.$click.subscribe(()=>{const n={"masque-bien-mis":"good","masque-mal-mis":"bad","pas-de-masque":"none"};ta.clear();let e="/assets/demos_data/miniMASK/train";Rh(ta,Du,$h,[Ph,Dh,e],n).catch(console.error),Qa.clear(),e="/assets/demos_data/miniMASK/test",Rh(Qa,Du,$h,[Ph,Dh,e],n).catch(console.error)});const oU=gx("miniROAD");oU.title="Traffic light classification";oU.$click.subscribe(()=>{const n={"feu-orange":"orange","feu-rouge":"red","feu-vert":"green"};ta.clear();let e="/assets/demos_data/miniROAD/train";Rh(ta,Du,$h,[Ph,Dh,e],n).catch(console.error),Qa.clear(),e="/assets/demos_data/miniROAD/test",Rh(Qa,Du,$h,[Ph,Dh,e],n).catch(console.error)});const aU=gx("miniTRASH");aU.title="Trash classification";aU.$click.subscribe(()=>{const n={emballage:"packaging","verre-blanc":"transparent glass","verre-colore":"colored glass"};ta.clear();let e="/assets/demos_data/miniTRASH/train";Rh(ta,Du,$h,[Ph,Dh,e],n).catch(console.error),Qa.clear(),e="/assets/demos_data/miniTRASH/test",Rh(Qa,Du,$h,[Ph,Dh,e],n).catch(console.error)});const lU=gx("miniRETINA");lU.title="Retina disease classification";lU.$click.subscribe(()=>{const n={dmla:"macular degeneration",rd:"diabetic retinopathy",sain:"healthy"};ta.clear();let e="/assets/demos_data/miniRETINA/train";Rh(ta,Du,$h,[Ph,Dh,e],n).catch(console.error),Qa.clear(),e="/assets/demos_data/miniRETINA/test",Rh(Qa,Du,$h,[Ph,Dh,e],n).catch(console.error)});const cU=gx("miniSKIN");cU.title="Skin cancer classification";cU.$click.subscribe(()=>{ta.clear();let n="/assets/demos_data/miniSKIN/train";Rh(ta,Du,$h,[Ph,Dh,n]).catch(console.error),Qa.clear(),n="/assets/demos_data/miniSKIN/test",Rh(Qa,Du,$h,[Ph,Dh,n]).catch(console.error)});const uU=K$.$selected.map(n=>({source:"training",id:n.length>0?n[n.length-1]:void 0})).map(({_:n,id:e})=>e).filter(n=>n!==void 0).map(n=>ta.get(n)).awaitPromises().map(n=>n.thumbnail).merge(Y$.$selected.map(n=>({source:"test",id:n.length>0?n[n.length-1]:void 0})).map(({_:n,id:e})=>e).filter(n=>n!==void 0).map(n=>Qa.get(n)).awaitPromises().map(n=>n.thumbnail)).map(n=>TEt(n)).awaitPromises(),Sue=gue(uU);Sue.title="Image selected";function EEt(n){n.page("Data collection").sidebar(Sue).use([iU,oU,aU,lU,cU],[K$,Y$])}const hU=gx("Train");hU.title="Train the neural network";const mu=UCt({layers:[64,32],epochs:15,batch:8}).sync(vx,"mlp"),Cue=ukt(mu);Cue.title="Neural network parameters";hU.$click.subscribe(()=>{mu.train(ta)});const kue=w2t(mu);kue.title="Training progress";const Tue=_ue(mu);Tue.title="Learning curve";function IEt(n){n.page("Training").sidebar(hU,kue).use(Cue,Tue)}const EL=fue("mlp",vx),IL=fue("mlp",vx),Eue=pue(EL,ta);Eue.title="Confusion on training set";const Iue=pue(IL,Qa);Iue.title="Confusion on test set";mu.$training.subscribe(async()=>{mu.ready||Ea(new Error("No classifier has been trained")),await EL.clear(),await IL.clear(),await EL.predict(mu,ta),await IL.predict(mu,Qa)});function AEt(n){n.page("Testing").use([Eue,Iue])}const Z$=vCt();Z$.title="Upload new image to be classified";const MEt=uU.merge(Z$.$images).filter(()=>mu.ready).map(async n=>mu.predict(await Du.process(n))).awaitPromises(),NEt=gue(uU.merge(Z$.$images)),Aue=j2t(MEt);Aue.title="Prediction confidence";function $Et(n){n.page("Deployment").sidebar(NEt,Aue).use([K$,Y$,Z$])}EEt(wx);IEt(wx);AEt(wx);$Et(wx);wx.settings.dataStores(vx).datasets(ta).models(mu);wx.show();
